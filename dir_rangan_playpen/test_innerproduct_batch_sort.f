      subroutine test_innerproduct_batch_sort(n_S,n_M,delta_x_max_
     $    ,delta_y_max_,gamma_z_max_,C_Z_max_,delta_x_sort_
     $    ,delta_y_sort_,gamma_z_sort_,C_Z_sort_,I_permute_
     $    ,I_inverse_)
c$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c$$$      This subroutine is used to sort the output generated by
c$$$      test_innerproduct_svdread_batch. After sorting, the user
c$$$      can easily determine which subsets of templates are best
c$$$      matched to each of the different images.
c$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c$$$
c$$$      INPUTS:
c$$$
c$$$      integer *4 n_S        Number of templates.
c$$$
c$$$      integer *4 n_M        Number of images.
c$$$
c$$$      real *8 delta_x_max_  Array of size n_S*n_M.
c$$$                          - Assuming this array is indexed from 0
c$$$                            to n_S*n_M-1, delta_x_max_(ns + nm*n_S) 
c$$$                            holds the delta_x value associated with the 
c$$$                            best alignment between template ns and image 
c$$$                            nm. 
c$$$                            (output of test_innerproduct_svdread_batch.f)
c$$$
c$$$      real *8 delta_y_max_  Array of size n_S*n_M.
c$$$                          - Assuming this array is indexed from 0
c$$$                            to n_S*n_M-1, delta_y_max_(ns + nm*n_S) 
c$$$                            holds the delta_y value associated with the 
c$$$                            best alignment between template ns and image 
c$$$                            nm.
c$$$                            (output of test_innerproduct_svdread_batch.f)
c$$$
c$$$      real *8 gamma_z_max_  Array of size n_S*n_M.
c$$$                          - Assuming this array is indexed from 0
c$$$                            to n_S*n_M-1, gamma_z_max_(ns + nm*n_S) 
c$$$                            holds the gamma_z value associated with the 
c$$$                            best alignment between template ns and image 
c$$$                            nm.
c$$$                            (output of test_innerproduct_svdread_batch.f)
c$$$
c$$$      complex *16 C_Z_max_  Array of size n_S*n_M.
c$$$                          - Assuming this array is indexed from 0
c$$$                            to n_S*n_M-1, C_Z_max_(ns + nm*n_S) 
c$$$                            holds the (complex) normalized innerproduct
c$$$                            associated with the best alignment between 
c$$$                            template ns and image nm.
c$$$                          - Note that this is complex. While the 
c$$$                            imaginary part should be 0.0d0, the 
c$$$                            approximations used will incur a small 
c$$$                            error; consequently, the imaginary part will
c$$$                            in general be nonzero.
c$$$                            (output of test_innerproduct_svdread_batch.f)
c$$$
c$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
c$$$
c$$$      OUTPUTS:
c$$$
c$$$      complex *16 C_Z_sort_ Array of size n_S*n_M.
c$$$                            Each segment of length n_S holds the 
c$$$                            corresponding values of C_Z_max_ sorted in 
c$$$                            ascending order in terms of their real part.
c$$$                          - For example, assuming that C_Z_sort_ is
c$$$                            indexed from 0 to n_S*n_M-1, 
c$$$                            the higest value of C_Z_max_ for the 
c$$$                            image-template pair corresponding to 
c$$$                            image nm and template ns is stored in:
c$$$                            C_Z_sort_( n_S-1 + nm*n_S ).
c$$$                          - Similarly, the lowest value of C_Z_max_
c$$$                            for that image-template pair is stored in:
c$$$                            C_Z_sort_( 0 + nm*n_S ).
c$$$
c$$$      integer *4 I_permute_ Array of size n_S*n_M.
c$$$                            Each segment of length n_S holds the 
c$$$                            template-indices associated with the 
c$$$                            permutation linking C_Z_max_ to C_Z_sort_.
c$$$                          - For example, assuming that I_permute_ is
c$$$                            indexed from 0 to n_S*n_M-1,
c$$$                            the template-index (again ranging from 0
c$$$                            to n_S-1) which best matches image nm
c$$$                            is stored in:
c$$$                            I_permute_( n_S-1 + nm*n_S ).
c$$$                          - Similarly, the template-index that has the
c$$$                            poorest match to image nm is stored in:
c$$$                            I_permute_( 0 + nm*n_S ).
c$$$
c$$$      integer *4 I_inverse_ Array of size n_S*n_M.
c$$$                            Each segment of length n_S holds the inverse
c$$$                            permutation associated with I_permute_.
c$$$                          - For example, assuming I_inverse_ is indexed
c$$$                            from 0 to n_S*n_M-1, the index stored in
c$$$                            I_inverse_( ns + nm*n_S ) indicates the rank
c$$$                            of template ns when evaluated with respect
c$$$                            to image nm (again, assuming all images are
c$$$                            indexed from 0 to n_M-1 and all templates
c$$$                            are indexed from 0 to n_S-1).
c$$$
c$$$      real *8 delta_x_sort_ Array of size n_S*n_M.
c$$$                            Each segment of length n_S holds the values
c$$$                            of delta_x_max_ associated with the tempate
c$$$                            indices that match C_Z_sort_.
c$$$                            In other words, the x-displacement that
c$$$                            corresponds to the best alignment associated
c$$$                            with image nm is given by
c$$$                            delta_x_sort_( n_S-1 + nm*n_S )
c$$$                            (assuming, as above, that all indices start
c$$$                            at 0).
c$$$
c$$$      real *8 delta_y_sort_ Array of size n_S*n_M.
c$$$                            Each segment of length n_S holds the values
c$$$                            of delta_y_max_ associated with the tempate
c$$$                            indices that match C_Z_sort_.
c$$$
c$$$      real *8 gamma_z_sort_ Array of size n_S*n_M.
c$$$                            Each segment of length n_S holds the values
c$$$                            of gamma_z_max_ associated with the tempate
c$$$                            indices that match C_Z_sort_.
c$$$
c$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
      implicit none
      integer n_S,n_M
      real *8 delta_x_max_(0:n_S*n_M-1)
      real *8 delta_y_max_(0:n_S*n_M-1)
      real *8 gamma_z_max_(0:n_S*n_M-1)
      complex *16 C_Z_max_(0:n_S*n_M-1)
      real *8 delta_x_sort_(0:n_S*n_M-1)
      real *8 delta_y_sort_(0:n_S*n_M-1)
      real *8 gamma_z_sort_(0:n_S*n_M-1)
      complex *16 C_Z_sort_(0:n_S*n_M-1)
      integer *4 I_permute_(0:n_S*n_M-1)
      integer *4 I_inverse_(0:n_S*n_M-1)
      external quicksort_c16
      external quicksort_i4
      integer nm,ns,I_tmp_(0:n_S-1)
      call cp1_c16(n_S*n_M,C_Z_max_,C_Z_sort_)
      do nm=0,n_M-1
         do ns=0,n_S-1
            I_permute_(ns+nm*n_S) = ns
         enddo
         call quicksort_c16(0,n_S-1,C_Z_sort_(nm*n_S),1,I_permute_(nm
     $        *n_S),1,quicksort_c16)
         do ns=0,n_S-1
            I_tmp_(ns) = I_permute_(ns+nm*n_S)
            I_inverse_(ns+nm*n_S) = ns
         enddo
         call quicksort_i4(0,n_S-1,I_tmp_,1,I_inverse_(nm*n_S),1
     $        ,quicksort_i4)
         do ns=0,n_S-1
            delta_x_sort_(ns+nm*n_S) = delta_x_max_(I_permute_(ns+nm
     $           *n_S)+nm*n_S)
            delta_y_sort_(ns+nm*n_S) = delta_y_max_(I_permute_(ns+nm
     $           *n_S)+nm*n_S)
            gamma_z_sort_(ns+nm*n_S) = gamma_z_max_(I_permute_(ns+nm
     $           *n_S)+nm*n_S)
         enddo
      enddo
      end
      
