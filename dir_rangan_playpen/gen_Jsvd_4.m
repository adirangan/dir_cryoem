function [n_svd_r,svd_r_,svd_r_m,svd_r_c,svd_r_w_,svd_r_Lv_,n_svd_d,svd_d_,svd_d_m,svd_d_c,svd_d_w_,svd_d_Lv_,n_svd_l,svd_l_,svd_U_d_,svd_s_,svd_V_r_] = gen_Jsvd_4(K_max,N_pixel,eps_target,l_max,a_K,b_K,a_polycoef_,b_polycoef_);
% Generating functional svd-expansion of various bessel-functions. ;
%
% Inputs: ;
% K_max: maximum K-value; R_target will be set to K_max-0.5. ;
% N_pixel: maximum pixel width (in wavelengths) allowed for square grid of displacements. ;
% eps_target: tolerance of svd-expansion. ;
% l_max: maximum order of bessel-functions in svd-expansion. ;
% a_K: degree of orthonormal-polynomials used to represent r = |k|. ;
% b_K: degree of orthonormal-polynomials used to represent d = |delta|. ;
% a_polycoef_: vector of polynomial coefficients for polynomial weighting for r = k. ;
% b_polycoef_: vector of polynomial coefficients for polynomial weighting for d = delta. ;
% ;
% Outputs: ;
% n_svd_r: number of coefficients used to represent polynomials of r = k. ;
% svd_r_: vector of quadrature nodes associated with polynomials of r = k. ;
% svd_r_m: midpoint of interval for r = k. ;
% svd_r_c: half-width of interval for r = k. ;
% svd_r_w_: vector of quadrature weights for r = k. ;
% svd_r_Lv_: array of polynomial coefficients for r = k. ; 
%      Note: svd_r_Lv_(1+j,:) are the polynomial coefficients for L_{j}(r) in matlab order, ;
%            where L_{j} is the orthonormal polynomial of degree j ;
%            defined with respect to weighting function given by a_polycoef_. ;
% n_svd_d: number of coefficients used to represent polynomials of d = delta. ;
% svd_d_: vector of quadrature nodes associated with polynomials of d = delta. ;
% svd_d_m: midpoint of interval for d = delta. ;
% svd_d_c: half-width of interval for d = delta. ;
% svd_d_w_: vector of quadrature weights for d = delta. ;
% svd_d_Lv_: array of polynomial coefficients for d = delta. ; 
%      Note: svd_d_Lv_(1+j,:) are the polynomial coefficients for L_{j}(d) in matlab order, ;
%      where L_{j} is the orthonormal polynomial of degree j ;
%      defined with respect to weighting function given by b_polycoef_. ;
% n_svd_l: number of terms in svd-expansion. ;
% svd_l_: vector of bessel-orders for the terms in the svd-expansion. ;
% svd_U_d_: array of size b_K-x-n_svd_l storing the delta-side of the svd-expansion. ;
% svd_s_: vector of length n_svd_l storing the singular-values of the svd-expansion. ;
% svd_V_r_: array of size a_K-x-n_svd_l storing the r-side of the svd-expansion. ;
%     Note: if we define ij_tmp_ to be the list of indices for which svd_l_ = l_tmp,: ;
%           then we can use the svd-expansion to reconstruct the bessel-function of order l_tmp. ;
%           For example, try: ;
%           gen_Jsvd_4();

if (nargin<3);
K_max = 128; N_pixel = 3.0; eps_target = 0.1; l_max = 16; n_r_degree = 18; n_d_degree = 19; k_polycoef_ = [1,1]; d_polycoef_ = [1,1];
disp(sprintf(' %% testing gen_Jsvd_4 with K_max %d N_pixel %0.2f eps_target %0.2f and radial weight function',K_max,N_pixel,eps_target));
[n_svd_r,svd_r_,svd_r_m,svd_r_c,svd_r_w_,svd_r_Lv_,n_svd_d,svd_d_,svd_d_m,svd_d_c,svd_d_w_,svd_d_Lv_,n_svd_l,svd_l_,svd_U_d_,svd_s_,svd_V_r_] = gen_Jsvd_4(K_max,N_pixel,eps_target,l_max,n_r_degree,n_d_degree,k_polycoef_,d_polycoef_);
a_K = n_r_degree; b_K = n_d_degree;
for l_tmp = 0:5;
ij_tmp_ = find(svd_l_==l_tmp);
n_delta = 129; delta_value_ = max(svd_d_)*linspace(0,1,n_delta);
n_r = 128; r_value_ = max(svd_r_)*linspace(0,1,n_r);
J_ = besselj(l_tmp,transpose(delta_value_)*r_value_);
H_ = zeros(size(J_));
for ij=ij_tmp_;
U_d_ = zeros(1,length(delta_value_));
for nkB=0:b_K-1;
b_tmp = polyval(svd_d_Lv_(1+nkB,:),(delta_value_ - svd_d_m)/svd_d_c);
U_d_ = U_d_ + svd_U_d_(1+nkB,ij)*b_tmp;
end;% for nkB=0:b_K-1;
V_r_ = zeros(1,length(r_value_));
a_K = size(svd_V_r_,1);
for nkA=0:a_K-1;
a_tmp = polyval(svd_r_Lv_(1+nkA,:),(r_value_ - svd_r_m)/svd_r_c);
V_r_ = V_r_ + svd_V_r_(1+nkA,ij)*a_tmp;
end;%for nkA=0:a_K-1;
H_ = H_ + transpose(U_d_)*svd_s_(ij)*V_r_;
end;%for ij=ij_tmp_;
%plot(r_value_,J_,'k.-',r_value_,H_,'ro-'); xlabel('r'); ylabel('J,H'); legend('J','H');
subplot(6,3,1 + 3*l_tmp); colormap(colormap_beach(64)); imagesc(J_); set(gca,'Xtick',[],'Ytick',[]); axis square; title(sprintf('J%d',l_tmp));
subplot(6,3,2 + 3*l_tmp); colormap(colormap_beach(64)); imagesc(H_); set(gca,'Xtick',[],'Ytick',[]); axis square; title(sprintf('H%d',l_tmp));
subplot(6,3,3 + 3*l_tmp); colormap(colormap_beach(64)); imagesc(J_-H_,eps_target*[-1,1]); set(gca,'Xtick',[],'Ytick',[]); axis square;  title('J-H'); colorbar();  
suptitle(sprintf('max delta %0.3f, eps %0.3f',max(delta_value_),eps_target));
set(gcf,'Position',1+[0,0,768,1024]);
end;%for l_tmp = 0:5;
disp('returning'); return;
end;%if (nargin<3);

verbose=2;
ni = 4;
if (nargin<ni); l_max = 16; end; ni = ni+1;
if (nargin<ni); a_K = 18; end; ni = ni+1;
if (nargin<ni); b_K = 19; end; ni = ni+1;
if (nargin<ni); a_polycoef_ = [1 1]; end; ni = ni+1;
if (nargin<ni); b_polycoef_ = [1 1]; end; ni = ni+1;
if (verbose>1); 
disp(sprintf(' %% [entering gen_Jsvd_4] l_max %d',l_max)); 
disp(sprintf(' %% a_polycoef_: ')); disp(num2str(a_polycoef_));
disp(sprintf(' %% b_polycoef_: ')); disp(num2str(b_polycoef_));
end;%if (verbose>1);

R_target = K_max-0.5;
z_target = N_pixel*pi*sqrt(2);
D_target = z_target/(2*pi*R_target);

r_max = 2*pi*R_target;
d_max = D_target;
a_m = r_max/2; a_r = a_m;
b_m = d_max/2; b_r = b_m;
%%%%%%%%%%%%%%%%;
% radial weighting. ;
%%%%%%%%%%%%%%%%;
%a_polycoef = @(a) 1+a; a_polycoef_ = [1 1]; % k ;
%b_polycoef = @(b) 1+b; b_polycoef_ = [1 1]; % delta ;
%%%%%%%%%%%%%%%%;
% uniform weighting. ;
%%%%%%%%%%%%%%%%;
%a_polycoef = @(a) 1; a_polycoef_ = [1]; % k ;
%b_polycoef = @(b) 1; b_polycoef_ = [1]; % delta ;
%a_K = 18; b_K = 19;
[a_lx,a_lw,a_Lx,a_Lv] = orthopoly_node_weight_matrix_0(a_K,a_polycoef_);
a_lt = a_lx*a_r + a_m;
[b_lx,b_lw,b_Lx,b_Lv] = orthopoly_node_weight_matrix_0(b_K,b_polycoef_);
b_lt = b_lx*b_r + b_m;
[A_lt_,B_lt_] = meshgrid(a_lt,b_lt);

clear S_l_ S_u_ S_s_ S_v_ ;
l=0; n_S=0; continue_flag=1;
while (continue_flag);
if (l==0); l_ = [0]; else l_ = [-l,+l]; end;
for l_tmp = l_;
F = @(a,b) besselj(l_tmp,a.*b);
F_lt_ = F(A_lt_,B_lt_);
F_ = zeros(b_K,a_K);
lw = b_lw*transpose(a_lw);
for nkA=0:a_K-1;for nkB=0:b_K-1;
L_tmp = transpose(b_Lx(1+nkB,:))*a_Lx(1+nkA,:);
S_tmp = F_lt_.*L_tmp.*lw;
F_(1+nkB,1+nkA) = sum(S_tmp(:));
end;end;%for nkA=0:a_K-1;for nkB=0:b_K-1;
n_svds = min([b_K,a_K]);
[U_,S_,V_] = svds(F_,n_svds); S_ = diag(S_); [ij_ret_] = find(S_>eps_target) ;
if ~isempty(ij_ret_);
if (verbose>1); disp(sprintf(' %% l %+.2d, found %d terms [%0.2f,..,%0.2f];',l_tmp,length(ij_ret_),S_(ij_ret_(1)),S_(ij_ret_(end)))); end;%if
for ij = 1:length(ij_ret_);
S_l_(1+n_S) = l_tmp;
S_u_(:,1+n_S) = U_(:,ij_ret_(ij));
S_s_(1,1+n_S) = S_(ij_ret_(ij),1);
S_v_(:,1+n_S) = V_(:,ij_ret_(ij));
n_S = n_S + 1;
end;%for ij = 1:length(ij_ret_);
end;%if ~isempty(ij_ret_);
end;%for l_tmp = l_;
l=l+1;
if (l>l_max); continue_flag=0; else continue_flag=1; end;
end;%while (continue_flag);
if (verbose>1); disp(sprintf(' %% total of n_S %d terms found;',n_S)); end%if;

n_svd_r = length(a_lt); svd_r_ = a_lt;
svd_r_m = a_m; svd_r_c = a_r; svd_r_w_ = a_lw; svd_r_Lv_ = a_Lv;
n_svd_d = length(b_lt); svd_d_ = b_lt;
svd_d_m = b_m; svd_d_c = b_r; svd_d_w_ = b_lw; svd_d_Lv_ = b_Lv;
n_svd_l = n_S;
svd_l_ = S_l_;
svd_U_d_ = S_u_;
svd_s_ = S_s_;
svd_V_r_ = S_v_;
