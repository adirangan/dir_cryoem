import numpy as np ; pi = np.pi ; i = 1j ; import torch ; import timeit ;
from matlab_index_2d_0 import matlab_index_2d_0 ;
from matlab_index_3d_0 import matlab_index_3d_0 ;
from matlab_index_4d_0 import matlab_index_4d_0 ;
from wignerd_b import wignerd_b ;
from wignerd_lsq_b import wignerd_lsq_b ;
from wignerd_c import wignerd_c ;
fnorm = lambda a : torch.linalg.norm(a).item() ;
mtr = lambda a : tuple(reversed(a)) ; #<-- matlab-arranged size (i.e., tuple(reversed(...))). ;
msr = lambda str : str[::-1] ; #<-- for einsum (i.e., string reversed (...)). ;
mts = lambda a : tuple(len(a) - x - 1 for x in a) ; #<-- for permute (i.e., tuple subtract (...)). ;
tic = lambda : timeit.default_timer() ;
toc = lambda a : tic() - a ;

flag_verbose=1;
if (flag_verbose>0): print(f' %% testing wignerd_b, wignerd_lsq_b and wignerd_c');
#%%%%%%%%;
#% Note that the discrepancy is larger than 1e-6 at nl==88. ;
#%%%%%%%%;
n_l=32;
#%n_l=196;
beta=pi/6;
#%%%%;
tmp_t = tic();
W1_ = wignerd_b(n_l,beta);
tmp_t = toc(tmp_t);
print(f' %% wignerd_b  : {tmp_t:2f} seconds');
#%%%%;
tmp_t = tic();
W2_ = wignerd_lsq_b(n_l,beta);
tmp_t = toc(tmp_t);
print(f' %% wignerd_lsq_b  : {tmp_t:2f} seconds');
#%%%%;
tmp_t = tic();
_,d0W_,d1W_,d2W_,V_lmm___,L_lm__ = wignerd_c([],n_l,beta)[0:6];
W3_ = d0W_;
tmp_t = toc(tmp_t);
print(f' %% wignerd_c  : {tmp_t:2f} seconds');
#%%%%;
dir_base = '/data/rangan' ;
dir_ascii = dir_base + '/dir_cryoem/dir_rangan_python/dir_ascii' ;
for nl in range(n_l+1):
    fname_ascii = dir_ascii + '/d0W_' + str(nl) + '__.ascii' ;
    print(f" %% writing {fname_ascii}");
    np.savetxt(fname_ascii,d0W_[nl].numpy().ravel());
    fname_ascii = dir_ascii + '/d1W_' + str(nl) + '__.ascii' ;
    print(f" %% writing {fname_ascii}");
    np.savetxt(fname_ascii,d1W_[nl].numpy().ravel());
    fname_ascii = dir_ascii + '/d2W_' + str(nl) + '__.ascii' ;
    print(f" %% writing {fname_ascii}");
    np.savetxt(fname_ascii,d2W_[nl].numpy().ravel());
    #%%%%; 
    #% Note that, while the eigenstructure computed by torch.linalg.eig matches that of matlab eig, the ordering of the eigenvalues and the phasing of the eigenvectors (i.e., the entries of L_m_ and columns of V_mm__) will not necessarily match. ;
    #%%%%; 
    #%fname_ascii = dir_ascii + '/V_lmm_' + str(nl) + '__.ascii' ;
    #%print(f" %% writing {fname_ascii}");
    #%np.savetxt(fname_ascii,V_lmm___[nl].numpy().ravel());
    #%fname_ascii = dir_ascii + '/L_lm_' + str(nl) + '_.ascii' ;
    #%print(f" %% writing {fname_ascii}");
    #%np.savetxt(fname_ascii,L_lm__[nl].numpy().ravel());
#end;%for nl=0:n_l;
#%%%%;
for nl in range(n_l+1):
  print(f' %% nl {nl}/{n_l}: W1_ vs W2_: error {fnorm(W1_[nl]-W2_[nl]):.16f}');
  print(f' %% nl {nl}/{n_l}: W3_ vs W2_: error {fnorm(W3_[nl]-W2_[nl]):.16f}');
#end;%for nl=0:n_l;
