function C_q_ = innerproduct_q__k_svdd_1(flag_S_vs_M,n_svd_d,svd_d_,n_svd_l,svd_l_,svd_U_d_,n_delta_x,delta_x_,n_delta_y,delta_y_,l_max);
% Creates a matrix for translations.  ;
% Uses svd-expansion defined via n_svd_d, .. , svd_U_d_.;
% Term-l of Translation-d is stored in ;
% C_q_(1+l + ndx*n_svd_l + ndy*n_svd_l*n_delta_x).;
% l_max must equal or exceed order of bessel-function expansion;
if (nargin<11); l_max = 15; end;
warning_flag = 1;
verbose=1;
if (verbose>1); disp(sprintf(' [entering innerproduct_q__k_svdd_1] l_max %d',l_max)); end;

C_q_ = zeros(n_svd_l,n_delta_x*n_delta_y);
nC = 0;
for ndy=0:n_delta_y-1;
delta_y = delta_y_(1+ndy);
for ndx=0:n_delta_x-1;
delta_x = delta_x_(1+ndx);
if (verbose>1);
disp(sprintf(' %% ndx %d ndy %d dx %f dy %f',ndx,ndy,delta_x,delta_y));
end;%if;
delta = sqrt(delta_x.^2 + delta_y.^2);
svd_d_max = svd_d_(1+n_svd_d-1);
if (delta>svd_d_max*1.0625 & warning_flag);
disp(sprintf(' %% Warning, delta %f > svd_d_max %f; ratio %f in innerproduct_q__k_svdd_1',delta,svd_d_max,delta/svd_d_max));
end;%if;
omega = atan2(delta_y,delta_x);
if (verbose>1);
disp(sprintf('delta %f omega %f',delta,omega));
end;%if;
% here we initialize C_q_pre using omega and l_max;
% The goal is for ;
% C_q_pre(1+l_max+nl_pre) ;
% to equal:;
% S-type --> cmplx( +cos(theta) , +sin(theta) );
% M-type --> cmplx( +cos(theta) , -sin(theta) );
% with;
% theta = nl_pre*(pi/2 - omega).;
C_q_pre(1+l_max+0) = 1.0 + i*0.0;
if (flag_S_vs_M==1) theta = (pi/2 - omega); end%if;
if (flag_S_vs_M==0) theta = (pi/2 - omega + pi); end%if;
if (flag_S_vs_M==1) C_q = exp(+i*theta); end%if;
if (flag_S_vs_M==0) C_q = exp(-i*theta); end%if;
for nl_pre=1:l_max;
C_q_pre(1+l_max+nl_pre) = C_q_pre(1+l_max+nl_pre-1)*C_q;
end;%for;
if (flag_S_vs_M==1) C_q = exp(-i*theta); end%if;
if (flag_S_vs_M==0) C_q = exp(+i*theta); end%if;
for nl_pre=1:l_max;
C_q_pre(1+l_max-nl_pre) = C_q_pre(1+l_max-nl_pre+1)*C_q;
end;%for;
n_svd_d_v = (n_svd_d-1)*delta/svd_d_max;
n_svd_d_pre = max(0,min(n_svd_d-1,floor(n_svd_d_v)));
n_svd_d_pos = max(0,min(n_svd_d-1,ceil(n_svd_d_v)));
d_svd_d_pre = abs(n_svd_d_v - n_svd_d_pre);
d_svd_d_pos = abs(n_svd_d_pos - n_svd_d_v);
if (d_svd_d_pre+d_svd_d_pos<=0.0d0);
alpha_d = 0.0d0;
beta_d = 1.0d0;
 else;
alpha_d = d_svd_d_pre / (d_svd_d_pre + d_svd_d_pos);
beta_d = d_svd_d_pos / (d_svd_d_pre + d_svd_d_pos);
end;%if;
if (verbose>1);
disp(sprintf(' %% n_svd_d_pre n_svd_d_pos: %d %d',n_svd_d_pre,n_svd_d_pos));
disp(sprintf(' %% d_svd_d_pre d_svd_d_pos: %f %f',d_svd_d_pre,d_svd_d_pos));
disp(sprintf(' %% alpha_d beta_d : %f %f ',alpha_d,beta_d));
end;%if;
for nl=0:n_svd_l-1;
I_l = svd_l_(1+nl);
if (abs(I_l)>l_max);
disp(sprintf(' %% Warning, I_l %d > l_max in innerproduct_q__k_svdd_1',I_l));
end;%if;
if (verbose>2);
disp(sprintf(' %% nl %d I_l %d',nl,I_l));
end;%if;
%    theta = I_l*(pi/2 - omega);
%    If transformation were applied to S we would use:;
%    C_q = cmplx( +cos(theta) , +sin(theta) );
%    If transformation were applied to M we would use:;
%    C_q = cmplx( +cos(theta) , -sin(theta) );
C_q = C_q_pre(1+l_max+I_l);
D_U_d = beta_d*svd_U_d_(1+n_svd_d_pre + nl*n_svd_d) + alpha_d*svd_U_d_(1+n_svd_d_pos + nl*n_svd_d);
%    nC = nl + ndx*n_svd_l + ndy*n_delta_x*n_svd_l;
C_q_(1+nC) = D_U_d*C_q;
nC = nC+1;
end;%for;
end;%for;
end;%for;
if (verbose>1); disp(sprintf(' [finished innerproduct_q__k_svdd_1]')); end;
