function [C_q_,U_d__] = innerproduct_q_k_svdd_3(flag_S_vs_M,svd_d_max,n_svd_d,svd_d_,n_svd_l,svd_l_,svd_U_d_,n_delta_v,delta_x_,delta_y_);
% Creates a matrix for translations.  ;
% Uses svd-expansion defined via n_svd_d, .. , svd_U_d_. ;
% Term-l of Translation-d is stored in ;
% C_q_(l + ndv*n_svd_l). ;
% The logical flag_S_vs_M determines the sign of the complex exponential. ;
% flag_S_vs_M .eqv. .true. --> transformation applied to S, use +. ;
% flag_S_vs_M .eqv. .false. --> transformation applied to M, use -. ;

C_q_ = zeros(n_svd_l*n_delta_v,1);
U_d__ = zeros(n_svd_l*n_delta_v,1);
verbose = 0;
warning_flag = 1;
% l_max must equal or exceed order of bessel-function expansion
if (verbose>0);
disp(sprintf(' %% [entering innerproduct_q_k_svdd_3] %d %d %d',n_svd_d,n_svd_l,n_delta_v));
end;%if (verbose>0);
l_max = max(svd_l_);
C_q_pre_ = zeros(1+2*l_max,1);
U_d_ = zeros(n_svd_l,1);
nC = 0;
svd_d_m = svd_d_max / 2.0 ;
svd_d_c = svd_d_m ;
for ndv=0:n_delta_v-1;
delta_x = delta_x_(1+ndv);
delta_y = delta_y_(1+ndv);
if (verbose>1);
disp(sprintf(' %% ndv %d dx %0.4f dy %0.4f',ndv,delta_x,delta_y));
end;%if (verbose>1);
delta = sqrt(delta_x^2 + delta_y^2);
if (delta>svd_d_max & warning_flag) then;
disp(sprintf(' %% Warning, delta %0.6f > svd_d_max %0.6f in innerproduct_q_k_svdd_3',delta,svd_d_max));
end;%if (delta>svd_d_max & warning_flag) then;
omega = atan2(delta_y,delta_x);
if (verbose>1);
disp(sprintf(' %% delta %0.6f omega %0.6f',delta,omega));
end;%if (verbose>1);
%       here we initialize C_q_pre using omega and l_max ;
%       The goal is for ;
%       C_q_pre_(1+l_max+nl_pre) ;
%       to equal: ;
%       S-type --> cmplx( +cos(theta) , +sin(theta) ) ;
%       M-type --> cmplx( +cos(theta) , -sin(theta) ) ;
%       with ;
%       theta = nl_pre*(pi/2 - omega). ;
C_q_pre_(1+l_max+0) = 1;
if (flag_S_vs_M==1) theta = (pi/2 - omega); end;
if (flag_S_vs_M==0) theta = (pi/2 - omega + pi); end;
%%%%%%%%;
if (flag_S_vs_M==1) C_q = exp(+i*theta); end;
if (flag_S_vs_M==0) C_q = exp(-i*theta); end;
for nl_pre=1:l_max;
C_q_pre_(1+l_max+nl_pre) = C_q_pre_(1+l_max+nl_pre-1)*C_q;
end;%for nl_pre=1:l_max;
%%%%%%%%;
if (flag_S_vs_M==1) C_q = exp(-i*theta); end;
if (flag_S_vs_M==0) C_q = exp(+i*theta); end;
for nl_pre=1:l_max;
C_q_pre_(1+l_max-nl_pre) = C_q_pre_(1+l_max-nl_pre+1)*C_q;
end;%for nl_pre=1:l_max;
svd_d = (delta - svd_d_m)/svd_d_c;
for nl=0:n_svd_l-1;
U_d_(1+nl) = polyval_r8_reverse_0(n_svd_d,svd_U_d_(1+(nl*n_svd_d) + (0:n_svd_d-1)),1,svd_d);
U_d__(1+nl+ndv*n_svd_l) = U_d_(1+nl);
if (verbose>1);
disp(sprintf(' %% delta %0.6f svd_d %0.6f U_d_(1+%d) %0.6f',detla,svd_d,nl,U_d_(1+nl)));
end;%if (verbose>1);
end;%for nl=0:n_svd_l-1;
for nl=0:n_svd_l-1;
I_l = svd_l_(1+nl);
if (abs(I_l)>l_max);
disp(sprintf(' %% Warning, I_l %d > l_max in innerproduct_q_k_svdd_3',I_l));
end;%if (abs(I_l)>l_max);
if (verbose>2);
disp(sprintf(' %% nl %d I_l %d',nl,I_l));
end;%if (verbose>2);
%          theta = I_l*(pi/2 - omega) ;
%          If transformation were applied to S we would use: ;
%          C_q = cmplx( +cos(theta) , +sin(theta) ) ;
%          If transformation were applied to M we would use: ;
%          C_q = cmplx( +cos(theta) , -sin(theta) ) ;
C_q = C_q_pre_(1+l_max+I_l);
%          nC = nl + ndv*n_svd_l ;
C_q_(1+nC) = U_d_(1+nl)*C_q;
nC = nC+1;
end;%for nl=0:n_svd_l-1;
end;%for ndv=0:n_delta_v-1;
if (verbose>0);
disp(sprintf(' %% [finished innerproduct_q_k_svdd_3]'));
end;%if (verbose>0);

