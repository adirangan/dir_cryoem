function S_k_p_ = interp_x_c_to_k_p_nufft(n_x1,diameter_x1_c,n_x2,diameter_x2_c,S_x_c_,n_r,grid_k_p_,n_w_) ;
%%%%%%%%;
% Assuming that S_x_c_ is the original image ordered as: ;
% S_x_c_(nx1 + nx2*n_x1) = pixel nx1,nx2 ;
% we use nufft2d2 to calculate ;
% S_k_p_(na) = S_k_p_(nw + n_w_csum_(nr)) ;
% given by: ;
% S_k_p_(na) = 1/Z * \sum_{nx1=0,nx2=0}^{nx1=n_x1-1,nx2=n_x2-1}  ;
%              S_x_c_(nx1 + nx2*n_x1)  ;
%              * exp(-i * (x1_(nx1)*k1+x2_(nx2)*k2)) ;
% where:  ;
% Z = sqrt(n_x1*n_x2) ;
% and: ;
% k1 = 2*pi*grid_k_p_(nr)*cos(2*pi*nw/n_w_(nr)) ;
% k2 = 2*pi*grid_k_p_(nr)*sin(2*pi*nw/n_w_(nr)) ;
% and ;
% x1_(nx1) = half_diameter_x1_c*(-1 + 2*nx1/n_x1) ;
% x2_(nx2) = half_diameter_x2_c*(-1 + 2*nx2/n_x2) ;
% or equivalently: ;
% x1_(nx1) = diameter_x1_c/n_x1*(nx1-n_x1/2) ;
% x2_(nx2) = diameter_x2_c/n_x2*(nx2-n_x2/2) ;
% where: ;
% nx1-n_x1/2 runs from -n_x1/2 up to +n_x1/2-1 ;
% nx2-n_x2/2 runs from -n_x2/2 up to +n_x2/2-1 ;
% %%%%%%%% ;
% Note that grid_k_p_ is assumed to provide the k-magnitude ;
% in terms of ordinary frequency (not angular frequency). ;
% Hence the 2*pi in the definitions of k1 and k2. ; ;
% %%%%%%%% ;
% We use use the type-2 nufft: ;
% int nufft2d2(BIGINT nj,FLT* xj,FLT *yj,CPX* cj,int iflag,FLT eps, ;
%                BIGINT ms, BIGINT mt, CPX* fk) ;
% cj[j] =  SUM   fk[k1,k2] exp(+/-i (k1 xj[j] + k2 yj[j]))      for j = 0,...,nj-1 ;
%         k1,k2 ;
% where sum is over -ms/2 <= k1 <= (ms-1)/2, -mt/2 <= k2 <= (mt-1)/2, ;
% Inputs: ;
% nj     number of targets (int64, aka BIGINT) ;
% xj,yj     x,y locations of targets (each a size-nj FLT array) in [-3pi,3pi] ;
% fk     FLT complex array of Fourier transform values (size ms*mt, ;
%        increasing fast in ms then slow in mt, ie Fortran ordering). ;
% iflag  if >=0, uses + sign in exponential, otherwise - sign (int) ;
% eps    precision requested (>1e-16) ;
% ms,mt  numbers of Fourier modes given in x and y (int64) ;
%        each may be even or odd; ;
%        in either case the mode range is integers lying in [-m/2, (m-1)/2]. ;
% Outputs: ;
% cj     size-nj complex FLT array of target values ;
%        (ie, stored as 2*nj FLTs interleaving Re, Im). ;
% returned value - 0 if success, else see ../docs/usage.rst ;
% %%%%%%%% ;
% Because of the conventions we make regarding the image and frequencies, ;
% we call the type-2 nufft using: ;
% nj = n_w_sum = n_A ;
% xj = k1_*diameter_x1_c/n_x1 = 2*pi*grid_k_p_(nr)*cos(2*pi*nw/n_w_(nr))*diameter_x1_c/n_x1 ;
% yj = k2_*diameter_x2_c/n_x2 = 2*pi*grid_k_p_(nr)*sin(2*pi*nw/n_w_(nr))*diameter_x2_c/n_x2 ;
% cj = S_k_p_ ;
% iflag = -1 ;
% eps = 1e-6 ;
% ms = n_x1 ;
% mt = n_x2 ;
% fk = S_x_c_ ;
%%%%%%%%;

verbose=0;
iflag = -1;
eps = 1.0d-6;
flag_2_versus_3 = 0; %<-- logical: compare type-2 and type-3 results. ;
dx1 = diameter_x1_c/n_x1 ;
dx2 = diameter_x2_c/n_x2 ;
n_A = sum(n_w_) ;
k1_ = zeros(n_A,1);
k2_ = zeros(n_A,1);

if (flag_2_versus_3);
tmp_S_k_p_ = zeros(n_A,1);
x1_ = zeros(n_x1*n_x2,1);
x2_ = zeros(n_x1*n_x2,1);
end; %if (flag_2_versus_3);

S_k_p_ = zeros(n_A,1);
na=0;
for nr=0:n_r-1;
r = 2*pi*grid_k_p_(1+nr);
for nw=0:n_w_(1+nr)-1;
omega = (2*pi*nw)/n_w_(1+nr);
k1_(1+na) = r*cos(omega)*dx1;
k2_(1+na) = r*sin(omega)*dx2;
na = na+1;
end;%for nw=0:n_w_(1+nr)-1;
end;%for nr=0:n_r-1;
if (na~=n_A);
disp(sprintf(' %% Warning, na~=n_A in interp_x_c_to_k_p_nufft.m'));
end;%if (na~=n_A);
[S_k_p_,ier] = nufft2d2(n_A,k1_,k2_,iflag,eps,n_x1,n_x2,S_x_c_);
if (ier~=0); disp(sprintf(' %% Warning! precision out of range in nufft2d2 in interp_x_c_to_k_p_nufft.m')); end;
if (flag_2_versus_3);
for nx1=0:n_x1-1;
for nx2=0:n_x2-1;
x1_(1+nx1+nx2*n_x1) = nx1-(1.0d0*n_x1)/2.0d0;
x2_(1+nx1+nx2*n_x1) = nx2-(1.0d0*n_x2)/2.0d0;
end%for nx2=0:n_x2-1;
end%for nx1=0:n_x1-1;
[tmp_S_k_p_,ier] = nufft2d3(n_x1*n_x2,x1_,x2_,S_x_c_,iflag,eps,n_A,k1_,k2_);
if (ier~=0); disp(sprintf(' %% Warning! precision out of range in nufft2d3 in interp_x_c_to_k_p_nufft.m')); end;
print_sub(n_x1*n_x2,x1_,' x1_: ');
print_sub(n_x1*n_x2,x2_,' x2_: ');
print_sub(n_A,    S_k_p_,' 2: S_k_p_: ');
print_sub(n_A,tmp_S_k_p_,' 3: S_k_p_: ');
disp(sprintf(' %% type_2_versus_3: %0.16f',norm(S_k_p_-tmp_S_k_p_,'fro')/max(norm(S_k_p_,'fro'),norm(tmp_S_k_p_,'fro'))));
end;%if (flag_2_versus_3);
S_k_p_ = S_k_p_/sqrt(n_x1*n_x2);

