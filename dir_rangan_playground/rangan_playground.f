!> Doxygen comment: ;\n
!> affine addition: i.e., B = B + A*alpha + beta ;\n
      subroutine ac1_c16(n_x,alpha,beta,A_,B_)
      implicit none
      integer n_x
      complex *16 alpha,beta
      complex *16 A_(0:0),B_(0:0)
      integer nx,na,nb
      na = 0
      nb = 0
      do nx=0,n_x-1
         B_(nb) = B_(nb) + A_(na)*alpha + beta
         na = na + 1
         nb = nb + 1
      enddo
      end
!> Doxygen comment: ;\n
!> adds an amount of additive noise (proportional to sigma) to the image M_k_p_;\n
!> (which is assumed to be in k_p coordinates: i.e., polar coordinates in fourier-space);\n
      subroutine additive_noise_k_p(rseed,n_r,grid_k_p_,n_w_,ld_M,M_k_p_
     $     ,sigma)
      implicit none
      integer *4 rseed
      real *8 adi_rand_f
      include 'adi_rand_f_define.f'
      integer n_r,ld_M
      real *8 grid_k_p_(0:0)
      integer n_w_(0:0)
      complex *16 M_k_p_(0:0)
      real *8 sigma
      integer nr,nw,na,nx,n_w_csum
      real *8 r_pre,r_pos,dA
      real *8 pi
      real *8 v1,v2,v3,v4
      complex *16 vE
      real *8 sigma_use
      pi = 4.0d0*atan(1.0d0)
      na=0
      do nr=0,n_r-1
         if (mod(n_w_(nr),2).ne.0) then
            write(6,'(A,I0,A,I0)') 'Warning, odd n_w_(' , nr , '): ' ,
     $           n_w_(nr)
         end if !if (mod(n_w_(nr),2).ne.0) then
         if (nr.eq.0) r_pre = 0.0d0
         if (nr.gt.0) r_pre = grid_k_p_(nr-1)
         r_pos = grid_k_p_(nr)
         dA = pi*(r_pos*r_pos - r_pre*r_pre)/n_w_(nr)
         sigma_use = sigma/dsqrt(dA)
         nx = n_w_(nr)/2
         do nw=0,nx-1
            v1 = adi_rand_f(rseed)
            v2 = adi_rand_f(rseed)
            v3 = sigma_use*dsqrt(-2.0d0*log(v1))*cos(2.0d0*pi*v2)
            v4 = sigma_use*dsqrt(-2.0d0*log(v1))*sin(2.0d0*pi*v2)
            vE = cmplx(v3,v4)
            M_k_p_(na) = M_k_p_(na) + vE
            M_k_p_(na+nx) = M_k_p_(na+nx) + conjg(ve)
            na = na+1
         enddo !do nw=0,nx-1
         na = na+nx
      enddo !do nr=0,n_r-1
      n_w_csum = 0
      do nr=0,n_r-1
         n_w_csum = n_w_csum + n_w_(nr)
      enddo !do nr=0,n_r-1
      if (na.ne.n_w_csum) then
         write(6,'(A,I0,A,I0)') 'Warning, na ' , na , ' n_w_csum ' ,
     $        n_w_csum
      end if !if (na.ne.n_w_csum) then
      if (na.gt.ld_M) then
         write(6,'(A,I0,A,I0)') 'Warning, na ' , na , ' ld_M ' ,
     $        ld_M
      end if !if (na.gt.ld_M) then
      end
!> Doxygen comment: ;\n
!> l1-norm of x_: ;\n
      real *8 function al1_c16_f(n_x,x_)
      integer n_x,nx
      complex *16 x_(0:n_x-1)
      real *8 m
      if (n_x.le.0) then
         m=0.0d0
      else
         m = dsqrt(dreal(dconjg(x_(0))*x_(0)))
         do nx=1,n_x-1
            m = m + dsqrt(dreal(dconjg(x_(nx))*x_(nx)))
         enddo
      end if
      al1_c16_f = m
      return
      end
!> Doxygen comment: ;\n
!>      this subroutine solves a  complex linear system with a self-adjoint;\n
!>      matrix by means of a conjugate gradient algorithm.;\n
!>      the algorithm has been put togethner without proper;\n
!>      analysis and with several cludges - user beware.;\n
!>      ;\n
!>                    input parameters:;\n
!>      ;\n
!>  n - the dimensionality of the system;\n
!>  a - the matrix of the system (or whatever parameter the user-supplied;\n
!>      matrix-vector multiplication routine mult (see below) requires.;\n
!>  mult - the user-supplied matrix-vector multiplication routine.;\n
!>      ;\n
!>ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;\n
!>     description of the calling system of subroutine mult;\n
!>     ;\n
!>      the calling sequence of mult is as follows:;\n
!>      ;\n
!>         mult(a,x,y,n,i1,i2,i3,i4,i5,i6,p1,p2,p3,z1,z2,z3);\n
!>      ;\n
!>            with the following parameters:;\n
!>     a - the matrix of the system (or whatever other parameter) (input);\n
!>     x - the vectot to whichj a is to be applied (input);\n
!>     y -=a(x) (output);\n
!>     n - the dimensionality of a,x,y (input);\n
!>      ;\n
!>     end of description of the calling system of subroutine mult;\n
!>cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;\n
!>      ;\n
!>  y - the right-hand side of the system to be solved;\n
!>  eps - thed accuracy to which the system is to be solved;\n
!>  numit - the maximum number of iterations permitted;\n
!>     ;\n
!>                      output parameters:;\n
!>      ;\n
!>  ier - error return code;\n
!>    ier=0 means successful conclusion;\n
!>    ier=4 means that the maximum pertmitted number of iterations;\n
!>          (numit) has been performed without the desired precision;\n
!>          being achieved;\n
!>    ier=8 means that the quadrati!>form failed to decrease before;\n
!>          numit iterations have been performed or the accuracy;\n
!>          eps has been achieved;\n
!>  x - the solution of the system;\n
!>  niter - the number of iterations actually performed;\n
!>  err - the array of errors produced by the algorithm on various steps,;\n
!>          that is err(i) = ||a(x_i)-y||, where x_i is the approximation;\n
!>          to the solution obtained on the i-th step of the conjugate;\n
!>          gradient process, and || * || is the l^2 norm;\n
!>      ;\n
!>                        work array :;\n
!>      ;\n
!>  w - must be at least 5*n+10 complex *16 elements long.;\n
!>      ;\n
!>       . . . allocate memory for the conjugate gradient scheme;\n
!>      ;\n
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c          this is the end of the debugging code and the beginning 
c          of the actual conjugate residual routine 
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
c
c
        subroutine ccongr2(ier,n,a,mult,i1,i2,i3,i4,i5,i6,p1,p2,p3,
     1             z1,z2,z3,y,eps,numit,x,niter,err,w)
        implicit real *8 (a-h,o-z)
        integer i1,i2,i3,i4,i5,i6
        real *8 p1,p2,p3
        real *8 err(1)
        complex *16 z1,z2,z3
        complex *16 a(1),y(1),x(1),w(1)
c
        external mult
c
c
c        this subroutine solves a  complex linear system with a self-adjoint
c        matrix by means of a conjugate gradient algorithm.
c        the algorithm has been put togethner without proper
c        analysis and with several cludges - user beware.
c
c                      input parameters:
c
c   n - the dimensionality of the system
c   a - the matrix of the system (or whatever parameter the user-supplied
c       matrix-vector multiplication routine mult (see below) requires.
c   mult - the user-supplied matrix-vector multiplication routine.
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c      description of the calling system of subroutine mult
c
c       the calling sequence of mult is as follows:
c
c          mult(a,x,y,n,i1,i2,i3,i4,i5,i6,p1,p2,p3,z1,z2,z3)
c
c             with the following parameters:
c      a - the matrix of the system (or whatever other parameter) (input)
c      x - the vectot to whichj a is to be applied (input)
c      y -=a(x) (output)
c      n - the dimensionality of a,x,y (input)
c
c      end of description of the calling system of subroutine mult
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c   y - the right-hand side of the system to be solved
c   eps - thed accuracy to which the system is to be solved
c   numit - the maximum number of iterations permitted
c
c                       output parameters:
c
c   ier - error return code
c     ier=0 means successful conclusion
c     ier=4 means that the maximum pertmitted number of iterations
c           (numit) has been performed without the desired precision
c           being achieved
c     ier=8 means that the quadratic form failed to decrease before
c           numit iterations have been performed or the accuracy
c           eps has been achieved
c   x - the solution of the system
c   niter - the number of iterations actually performed
c   err - the array of errors produced by the algorithm on various steps,
c           that is err(i) = ||a(x_i)-y||, where x_i is the approximation
c           to the solution obtained on the i-th step of the conjugate
c           gradient process, and || * || is the l^2 norm
c
c                         work array :
c
c   w - must be at least 5*n+10 complex *16 elements long.
c
c        . . . allocate memory for the conjugate gradient scheme
c
        iaxk=1
        iek=iaxk+n
        iaek=iek+n
        iekm1=iaek+n
        iaekm1=iekm1+n
c
c       conduct the conjugate gradient iterations
c
        nrec=1
cccc        nrec=100
c
c        call prinf(' calling ccongr2a *',n,1)
        call ccongr2a(ier,n,a,y,numit,x,w(iaxk),
     1    w(iek),w(iaek),w(iekm1),w(iaekm1),err,nrec,
     2    mult,i1,i2,i3,i4,i5,i6,p1,p2,p3,z1,z2,z3,eps,niter)
        return
        end
c
c
c
c
c
        subroutine ccongr2a(ier,n,a,y,numit,xk,axk,ek,aek,
     1             ekm1,aekm1,err,nrec,mult,i1,i2,i3,i4,i5,i6,
     2             p1,p2,p3,z1,z2,z3,eps,niter)
        implicit real *8 (a-h,o-z)
        integer i1,i2,i3,i4,i5,i6
        real *8 p1,p2,p3
        real *8 err(1)
        complex *16 a(1),y(1),xk(1),axk(1),ek(1),aek(1),
     1     ekm1(1),aekm1(1),z1,z2,z3
c
        external mult
c
c       initialize the conjugate gradient iterations
c
        done=1
        ifrec=0
        ier=0
        dold=1.0d60
cccc        call prin2('y=*',y,n*2)
c
        do 1400 i=1,n
        xk(i)=0
        axk(i)=0
cccc        xk(i)=y(i)
cccc        xk(i)=i
 1400 continue
c
ccc        call prinf(' calling mult inside ccongr *',n,1)
        call mult(a,xk,axk,n,i1,i2,i3,i4,i5,i6,p1,p2,p3,z1,z2,z3)
ccc        call prin2(' axk *',axk,2*n)
ccc        call prin2(' y *',y,2*n)
c
c       ... find the first direction
c
        er=0
        do 1600 i=1,n
        ek(i)=y(i)-axk(i)
        ekm1(i)=ek(i)
        er=er+dconjg(ek(i))*ek(i)
 1600 continue
c
        er=dsqrt(er)
c
cccc        er=dznrm2(n,ek,1)
c
        err(1)=er
c
        if( er .lt. eps ) return
c
c
c      conduct conjugate gradient iterations
c
        do 4000 k=2,numit
        niter=k
cccc        call prinf('k=*',k,1)
c
        call mult(a,ekm1,aekm1,n,i1,i2,i3,i4,i5,i6,p1,p2,p3,z1,z2,z3)
c
        cd1=0
        cd2=0
        do 2200 i=1,n
        cd1=cd1+dconjg(ek(i))*ek(i)
        cd2=cd2+dconjg(ekm1(i))*aekm1(i)
 2200 continue
c
cccc        cd1=dznrm2(n,ek,1)**2
c
        gamma=cd1/cd2
c
c       ... update the solution
c
        do 2400 i=1,n
        xk(i)=xk(i)+gamma*ekm1(i)
 2400 continue
c
c       ... update the residual
c
        er=0
        do 2600 i=1,n
        ek(i)=ek(i)-gamma*aekm1(i)
        er=er+dconjg(ek(i))*ek(i)
 2600 continue
c
        if( 1 .eq. 2 ) then 
c
        call mult(a,xk,axk,n,i1,i2,i3,i4,i5,i6,p1,p2,p3,z1,z2,z3)
        er=0
        do 2800 i=1,n
        ek(i)=y(i)-axk(i)
        er=er+dconjg(ek(i))*ek(i)
 2800 continue
c
        endif
c
        er=dsqrt(er)
c
cccc        er=dznrm2(n,ek,1)
c
        err(niter)=er
c
c
c       evaluate the quadratic form being minimized
c
        d1=0
        d2=0
        do 3000 i=1,n
cccc        d1=d1+axk(i)*dconjg(xk(i))
        d1=d1+(y(i)-ek(i))*dconjg(xk(i))
        d2=d2+xk(i)*dconjg(y(i))
 3000 continue
cccc        call prin2('d1 as evaluated is*',d1,1)
cccc        call prin2('cd as evaluated is*',cd,2)
        d=d1/2-d2
cccc        call prin2('and quadratic form is*',d,1)
cccc        call prin2('and difference is*',d-dold,1)
c
c       ... if quadratic form failed to decrease, stop
c       
c        if( dold .lt. d ) then
c        ier=8
c        return
c        endif
c
        dold=d
c
c
        if( er .lt. eps ) return
c
c       ... update the search direction
c
        beta=err(niter)/err(niter-1)
        beta=beta**2
c
        do 3200 i=1,n
        ekm1(i)=ek(i)+beta*ekm1(i)
 3200 continue
c
 4000 continue
c
c        the maximum permitted number of iterations has been
c        performed without the desired accuracy being accuracy
c        achieved. inform the user and exit
c
        ier=4
        return
        end
c
c
c
c
c
!> Doxygen comment: ;\n
!> dfftpack library: ;\n
!>     This FFT library is freely available from NETLIB, ;\n
!>     in the BIHAR repository (due to P. Bjorstad). ;\n
!>     These codes are (with minor changes) drawn from FFTPACK ;\n
!>     (due to P. Swarztrauber).;\n
!>     ;\n
!>     Please see NETLIB (http://www.netlib.org) for further details.;\n
!>     ;\n
c    This FFT library is freely available from NETLIB, 
c    in the BIHAR repository (due to P. Bjorstad). 
c    These codes are (with minor changes) drawn from FFTPACK 
c    (due to P. Swarztrauber).
c
c    Please see NETLIB (http://www.netlib.org) for further details.
c
c-------------------------------------------------------------------
      subroutine dcfftb (n,c,wsave)
      double precision c(1), wsave(1)
c
      if (n .eq. 1) return
c
      iw1 = n+n+1
      iw2 = iw1+n+n
      call dcftb1 (n,c,wsave,wsave(iw1),wsave(iw2))
c
      return
      end
      subroutine dcfftf (n,c,wsave)
      double precision c(1), wsave(1)
c
      if (n .eq. 1) return
c
      iw1 = n+n+1
      iw2 = iw1+n+n
      call dcftf1 (n,c,wsave,wsave(iw1),wsave(iw2))
c
      return
      end
      subroutine dcffti (n,wsave)
      double precision wsave(1)
c
      if (n .eq. 1) return
c
      iw1 = n+n+1
      iw2 = iw1+n+n
      call dcfti1 (n,wsave(iw1),wsave(iw2))
c
      return
      end
      subroutine dcftb1 (n,c,ch,wa,ifac)
      double precision c(1), ch(1), wa(1)
      integer ifac(1)
c
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do 116 k1=1,nf
         ip = ifac(k1+2)
         l2 = ip*l1
         ido = n/l2
         idot = ido+ido
         idl1 = idot*l1
         if (ip .ne. 4) go to 103
         ix2 = iw+idot
         ix3 = ix2+idot
         if (na .ne. 0) go to 101
         call dpssb4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
         go to 102
  101    call dpssb4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
  102    na = 1-na
         go to 115
c
  103    if (ip .ne. 2) go to 106
         if (na .ne. 0) go to 104
         call dpssb2 (idot,l1,c,ch,wa(iw))
         go to 105
  104    call dpssb2 (idot,l1,ch,c,wa(iw))
  105    na = 1-na
         go to 115
c
  106    if (ip .ne. 3) go to 109
         ix2 = iw+idot
         if (na .ne. 0) go to 107
         call dpssb3 (idot,l1,c,ch,wa(iw),wa(ix2))
         go to 108
  107    call dpssb3 (idot,l1,ch,c,wa(iw),wa(ix2))
  108    na = 1-na
         go to 115
c
  109    if (ip .ne. 5) go to 112
         ix2 = iw+idot
         ix3 = ix2+idot
         ix4 = ix3+idot
         if (na .ne. 0) go to 110
         call dpssb5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
         go to 111
  110    call dpssb5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
  111    na = 1-na
         go to 115
c
  112    if (na .ne. 0) go to 113
         call dpssb (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
         go to 114
  113    call dpssb (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
  114    if (nac .ne. 0) na = 1-na
c
  115    l1 = l2
         iw = iw+(ip-1)*idot
  116 continue
      if (na .eq. 0) return
c
      n2 = n+n
      do 117 i=1,n2
         c(i) = ch(i)
  117 continue
c
      return
      end
      subroutine dcftf1 (n,c,ch,wa,ifac)
      double precision c(1), ch(1), wa(1)
      integer ifac(1)
c
      nf = ifac(2)
      na = 0
      l1 = 1
      iw = 1
      do 116 k1=1,nf
         ip = ifac(k1+2)
         l2 = ip*l1
         ido = n/l2
         idot = ido+ido
         idl1 = idot*l1
         if (ip .ne. 4) go to 103
         ix2 = iw+idot
         ix3 = ix2+idot
         if (na .ne. 0) go to 101
         call dpssf4 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3))
         go to 102
  101    call dpssf4 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3))
  102    na = 1-na
         go to 115
c
  103    if (ip .ne. 2) go to 106
         if (na .ne. 0) go to 104
         call dpssf2 (idot,l1,c,ch,wa(iw))
         go to 105
  104    call dpssf2 (idot,l1,ch,c,wa(iw))
  105    na = 1-na
         go to 115
c
  106    if (ip .ne. 3) go to 109
         ix2 = iw+idot
         if (na .ne. 0) go to 107
         call dpssf3 (idot,l1,c,ch,wa(iw),wa(ix2))
         go to 108
  107    call dpssf3 (idot,l1,ch,c,wa(iw),wa(ix2))
  108    na = 1-na
         go to 115
c
  109    if (ip .ne. 5) go to 112
         ix2 = iw+idot
         ix3 = ix2+idot
         ix4 = ix3+idot
         if (na .ne. 0) go to 110
         call dpssf5 (idot,l1,c,ch,wa(iw),wa(ix2),wa(ix3),wa(ix4))
         go to 111
  110    call dpssf5 (idot,l1,ch,c,wa(iw),wa(ix2),wa(ix3),wa(ix4))
  111    na = 1-na
         go to 115
c
  112    if (na .ne. 0) go to 113
         call dpssf (nac,idot,ip,l1,idl1,c,c,c,ch,ch,wa(iw))
         go to 114
  113    call dpssf (nac,idot,ip,l1,idl1,ch,ch,ch,c,c,wa(iw))
  114    if (nac .ne. 0) na = 1-na
c
  115    l1 = l2
         iw = iw+(ip-1)*idot
  116 continue
      if (na .eq. 0) return
c
      n2 = n+n
      do 117 i=1,n2
         c(i) = ch(i)
  117 continue
c
      return
      end
      subroutine dcfti1 (n,wa,ifac)
      double precision wa(1), arg, argh, argld, fi, tpi
      integer ifac(1), ntryh(4)
      data ntryh(1), ntryh(2), ntryh(3), ntryh(4) /3, 4, 2, 5/
      data tpi   /  6.2831853071 7958647692 5286766559 00577d0/
c
      nl = n
      nf = 0
      j = 0
c
  101 j = j+1
      if (j.le.4) ntry = ntryh(j)
      if (j.gt.4) ntry = ntry + 2
  104 nq = nl/ntry
      nr = nl-ntry*nq
      if (nr.ne.0) go to 101
c
  105 nf = nf+1
      ifac(nf+2) = ntry
      nl = nq
      if (ntry .ne. 2) go to 107
      if (nf .eq. 1) go to 107
      do 106 i=2,nf
         ib = nf-i+2
         ifac(ib+2) = ifac(ib+1)
  106 continue
      ifac(3) = 2
c
  107 if (nl .ne. 1) go to 104
c
      ifac(1) = n
      ifac(2) = nf
c
      argh = tpi/dfloat(n)
      i = 2
      l1 = 1
      do 110 k1=1,nf
         ip = ifac(k1+2)
         ld = 0
         l2 = l1*ip
         ido = n/l2
         idot = ido+ido+2
         ipm = ip-1
c
         do 109 j=1,ipm
            i1 = i
            wa(i-1) = 1.d0
            wa(i) = 0.d0
            ld = ld+l1
            fi = 0.d0
            argld = dfloat(ld)*argh
            do 108 ii=4,idot,2
               i = i+2
               fi = fi+1.d0
               arg = fi*argld
               wa(i-1) = dcos(arg)
               wa(i) = dsin(arg)
  108       continue
            if (ip .le. 5) go to 109
            wa(i1-1) = wa(i-1)
            wa(i1) = wa(i)
  109    continue
c
         l1 = l2
  110 continue
c
      return
      end
      subroutine dpssb (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
      double precision cc(ido,ip,l1), c1(ido,l1,ip), c2(idl1,ip),
     1  ch(ido,l1,ip), ch2(idl1,ip), wa(1), wai, war
c
      idot = ido/2
      nt = ip*idl1
      ipp2 = ip+2
      ipph = (ip+1)/2
      idp = ip*ido
c
      if (ido .lt. l1) go to 106
      do 103 j=2,ipph
         jc = ipp2-j
         do 102 k=1,l1
            do 101 i=1,ido
               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
  101       continue
  102    continue
  103 continue
c
      do 105 k=1,l1
         do 104 i=1,ido
            ch(i,k,1) = cc(i,1,k)
  104    continue
  105 continue
      go to 112
c
  106 do 109 j=2,ipph
         jc = ipp2-j
         do 108 i=1,ido
            do 107 k=1,l1
               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
  107       continue
  108    continue
  109 continue
c
      do 111 i=1,ido
         do 110 k=1,l1
            ch(i,k,1) = cc(i,1,k)
  110    continue
  111 continue
c
  112 idl = 2-ido
      inc = 0
      do 116 l=2,ipph
         lc = ipp2-l
         idl = idl+ido
         do 113 ik=1,idl1
            c2(ik,l) = ch2(ik,1)+wa(idl-1)*ch2(ik,2)
            c2(ik,lc) = wa(idl)*ch2(ik,ip)
  113    continue
         idlj = idl
         inc = inc+ido
         do 115 j=3,ipph
            jc = ipp2-j
            idlj = idlj+inc
            if (idlj .gt. idp) idlj = idlj-idp
            war = wa(idlj-1)
            wai = wa(idlj)
            do 114 ik=1,idl1
               c2(ik,l) = c2(ik,l)+war*ch2(ik,j)
               c2(ik,lc) = c2(ik,lc)+wai*ch2(ik,jc)
  114       continue
  115    continue
  116 continue
c
      do 118 j=2,ipph
         do 117 ik=1,idl1
            ch2(ik,1) = ch2(ik,1)+ch2(ik,j)
  117    continue
  118 continue
c
      do 120 j=2,ipph
         jc = ipp2-j
         do 119 ik=2,idl1,2
            ch2(ik-1,j) = c2(ik-1,j)-c2(ik,jc)
            ch2(ik-1,jc) = c2(ik-1,j)+c2(ik,jc)
            ch2(ik,j) = c2(ik,j)+c2(ik-1,jc)
            ch2(ik,jc) = c2(ik,j)-c2(ik-1,jc)
  119    continue
  120 continue
c
      nac = 1
      if (ido .eq. 2) return
      nac = 0
c
      do 121 ik=1,idl1
         c2(ik,1) = ch2(ik,1)
  121 continue
c
      do 123 j=2,ip
         do 122 k=1,l1
            c1(1,k,j) = ch(1,k,j)
            c1(2,k,j) = ch(2,k,j)
  122    continue
  123 continue
c
      if (idot .gt. l1) go to 127
      idij = 0
      do 126 j=2,ip
         idij = idij+2
         do 125 i=4,ido,2
            idij = idij+2
            do 124 k=1,l1
               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
               c1(i,k,j) = wa(idij-1)*ch(i,k,j)+wa(idij)*ch(i-1,k,j)
  124       continue
  125    continue
  126 continue
      return
c
  127 idj = 2-ido
      do 130 j=2,ip
         idj = idj+ido
         do 129 k=1,l1
            idij = idj
            do 128 i=4,ido,2
               idij = idij+2
               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)-wa(idij)*ch(i,k,j)
               c1(i,k,j) = wa(idij-1)*ch(i,k,j)+wa(idij)*ch(i-1,k,j)
  128       continue
  129    continue
  130 continue
c
      return
      end
      subroutine dpssb2 (ido,l1,cc,ch,wa1)
      double precision cc(ido,2,l1), ch(ido,l1,2), wa1(1), ti2, tr2
c
      if (ido .gt. 2) go to 102
      do 101 k=1,l1
         ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
         ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
         ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
         ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
  101 continue
      return
c
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ch(i-1,k,1) = cc(i-1,1,k)+cc(i-1,2,k)
            tr2 = cc(i-1,1,k)-cc(i-1,2,k)
            ch(i,k,1) = cc(i,1,k)+cc(i,2,k)
            ti2 = cc(i,1,k)-cc(i,2,k)
            ch(i,k,2) = wa1(i-1)*ti2+wa1(i)*tr2
            ch(i-1,k,2) = wa1(i-1)*tr2-wa1(i)*ti2
  103    continue
  104 continue
c
      return
      end
      subroutine dpssb3 (ido,l1,cc,ch,wa1,wa2)
      double precision cc(ido,3,l1), ch(ido,l1,3), wa1(1), wa2(1),
     1 ci2, ci3, cr2, cr3, di2, di3, dr2, dr3, taui, taur, ti2, tr2
      data taur / -0.5 d0 /
      data taui  /  0.8660254037 8443864676 3723170752 93618d0/
c
c     one half sqrt(3) = .866025.....  .
c
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         tr2 = cc(1,2,k)+cc(1,3,k)
         cr2 = cc(1,1,k)+taur*tr2
         ch(1,k,1) = cc(1,1,k)+tr2
         ti2 = cc(2,2,k)+cc(2,3,k)
         ci2 = cc(2,1,k)+taur*ti2
         ch(2,k,1) = cc(2,1,k)+ti2
         cr3 = taui*(cc(1,2,k)-cc(1,3,k))
         ci3 = taui*(cc(2,2,k)-cc(2,3,k))
         ch(1,k,2) = cr2-ci3
         ch(1,k,3) = cr2+ci3
         ch(2,k,2) = ci2+cr3
         ch(2,k,3) = ci2-cr3
  101 continue
      return
c
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            tr2 = cc(i-1,2,k)+cc(i-1,3,k)
            cr2 = cc(i-1,1,k)+taur*tr2
            ch(i-1,k,1) = cc(i-1,1,k)+tr2
            ti2 = cc(i,2,k)+cc(i,3,k)
            ci2 = cc(i,1,k)+taur*ti2
            ch(i,k,1) = cc(i,1,k)+ti2
            cr3 = taui*(cc(i-1,2,k)-cc(i-1,3,k))
            ci3 = taui*(cc(i,2,k)-cc(i,3,k))
            dr2 = cr2-ci3
            dr3 = cr2+ci3
            di2 = ci2+cr3
            di3 = ci2-cr3
            ch(i,k,2) = wa1(i-1)*di2+wa1(i)*dr2
            ch(i-1,k,2) = wa1(i-1)*dr2-wa1(i)*di2
            ch(i,k,3) = wa2(i-1)*di3+wa2(i)*dr3
            ch(i-1,k,3) = wa2(i-1)*dr3-wa2(i)*di3
  103    continue
  104 continue
c
      return
      end
      subroutine dpssb4 (ido,l1,cc,ch,wa1,wa2,wa3)
      double precision cc(ido,4,l1), ch(ido,l1,4), wa1(1), wa2(1),
     1  wa3(1), ci2, ci3, ci4, cr2, cr3, cr4, ti1, ti2, ti3, ti4, tr1,
     2  tr2, tr3, tr4
c
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         ti1 = cc(2,1,k)-cc(2,3,k)
         ti2 = cc(2,1,k)+cc(2,3,k)
         tr4 = cc(2,4,k)-cc(2,2,k)
         ti3 = cc(2,2,k)+cc(2,4,k)
         tr1 = cc(1,1,k)-cc(1,3,k)
         tr2 = cc(1,1,k)+cc(1,3,k)
         ti4 = cc(1,2,k)-cc(1,4,k)
         tr3 = cc(1,2,k)+cc(1,4,k)
         ch(1,k,1) = tr2+tr3
         ch(1,k,3) = tr2-tr3
         ch(2,k,1) = ti2+ti3
         ch(2,k,3) = ti2-ti3
         ch(1,k,2) = tr1+tr4
         ch(1,k,4) = tr1-tr4
         ch(2,k,2) = ti1+ti4
         ch(2,k,4) = ti1-ti4
  101 continue
      return
c
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ti1 = cc(i,1,k)-cc(i,3,k)
            ti2 = cc(i,1,k)+cc(i,3,k)
            ti3 = cc(i,2,k)+cc(i,4,k)
            tr4 = cc(i,4,k)-cc(i,2,k)
            tr1 = cc(i-1,1,k)-cc(i-1,3,k)
            tr2 = cc(i-1,1,k)+cc(i-1,3,k)
            ti4 = cc(i-1,2,k)-cc(i-1,4,k)
            tr3 = cc(i-1,2,k)+cc(i-1,4,k)
            ch(i-1,k,1) = tr2+tr3
            cr3 = tr2-tr3
            ch(i,k,1) = ti2+ti3
            ci3 = ti2-ti3
            cr2 = tr1+tr4
            cr4 = tr1-tr4
            ci2 = ti1+ti4
            ci4 = ti1-ti4
            ch(i-1,k,2) = wa1(i-1)*cr2-wa1(i)*ci2
            ch(i,k,2) = wa1(i-1)*ci2+wa1(i)*cr2
            ch(i-1,k,3) = wa2(i-1)*cr3-wa2(i)*ci3
            ch(i,k,3) = wa2(i-1)*ci3+wa2(i)*cr3
            ch(i-1,k,4) = wa3(i-1)*cr4-wa3(i)*ci4
            ch(i,k,4) = wa3(i-1)*ci4+wa3(i)*cr4
  103    continue
  104 continue
c
      return
      end
      subroutine dpssb5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
      double precision cc(ido,5,l1), ch(ido,l1,5), wa1(1), wa2(1),
     1  wa3(1), wa4(1), ci2, ci3, ci4, ci5, cr2, cr3, cr4, cr5,
     2  di2, di3, di4, di5, dr2, dr3, dr4, dr5, ti11, ti12, ti2, ti3,
     3  ti4, ti5, tr11, tr12, tr2, tr3, tr4, tr5
      data tr11  /  0.3090169943 7494742410 2293417182 81906d0/
      data ti11  /  0.9510565162 9515357211 6439333379 38214d0/
      data tr12  / -0.8090169943 7494742410 2293417182 81906d0/
      data ti12  /  0.5877852522 9247312916 8705954639 07277d0/
c
c     sin(pi/10) = .30901699....    .
c     cos(pi/10) = .95105651....    .
c     sin(pi/5 ) = .58778525....    .
c     cos(pi/5 ) = .80901699....    .
c
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         ti5 = cc(2,2,k)-cc(2,5,k)
         ti2 = cc(2,2,k)+cc(2,5,k)
         ti4 = cc(2,3,k)-cc(2,4,k)
         ti3 = cc(2,3,k)+cc(2,4,k)
         tr5 = cc(1,2,k)-cc(1,5,k)
         tr2 = cc(1,2,k)+cc(1,5,k)
         tr4 = cc(1,3,k)-cc(1,4,k)
         tr3 = cc(1,3,k)+cc(1,4,k)
         ch(1,k,1) = cc(1,1,k)+tr2+tr3
         ch(2,k,1) = cc(2,1,k)+ti2+ti3
         cr2 = cc(1,1,k)+tr11*tr2+tr12*tr3
         ci2 = cc(2,1,k)+tr11*ti2+tr12*ti3
         cr3 = cc(1,1,k)+tr12*tr2+tr11*tr3
         ci3 = cc(2,1,k)+tr12*ti2+tr11*ti3
         cr5 = ti11*tr5+ti12*tr4
         ci5 = ti11*ti5+ti12*ti4
         cr4 = ti12*tr5-ti11*tr4
         ci4 = ti12*ti5-ti11*ti4
         ch(1,k,2) = cr2-ci5
         ch(1,k,5) = cr2+ci5
         ch(2,k,2) = ci2+cr5
         ch(2,k,3) = ci3+cr4
         ch(1,k,3) = cr3-ci4
         ch(1,k,4) = cr3+ci4
         ch(2,k,4) = ci3-cr4
         ch(2,k,5) = ci2-cr5
  101 continue
      return
c
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ti5 = cc(i,2,k)-cc(i,5,k)
            ti2 = cc(i,2,k)+cc(i,5,k)
            ti4 = cc(i,3,k)-cc(i,4,k)
            ti3 = cc(i,3,k)+cc(i,4,k)
            tr5 = cc(i-1,2,k)-cc(i-1,5,k)
            tr2 = cc(i-1,2,k)+cc(i-1,5,k)
            tr4 = cc(i-1,3,k)-cc(i-1,4,k)
            tr3 = cc(i-1,3,k)+cc(i-1,4,k)
            ch(i-1,k,1) = cc(i-1,1,k)+tr2+tr3
            ch(i,k,1) = cc(i,1,k)+ti2+ti3
            cr2 = cc(i-1,1,k)+tr11*tr2+tr12*tr3
            ci2 = cc(i,1,k)+tr11*ti2+tr12*ti3
            cr3 = cc(i-1,1,k)+tr12*tr2+tr11*tr3
            ci3 = cc(i,1,k)+tr12*ti2+tr11*ti3
            cr5 = ti11*tr5+ti12*tr4
            ci5 = ti11*ti5+ti12*ti4
            cr4 = ti12*tr5-ti11*tr4
            ci4 = ti12*ti5-ti11*ti4
            dr3 = cr3-ci4
            dr4 = cr3+ci4
            di3 = ci3+cr4
            di4 = ci3-cr4
            dr5 = cr2+ci5
            dr2 = cr2-ci5
            di5 = ci2-cr5
            di2 = ci2+cr5
            ch(i-1,k,2) = wa1(i-1)*dr2-wa1(i)*di2
            ch(i,k,2) = wa1(i-1)*di2+wa1(i)*dr2
            ch(i-1,k,3) = wa2(i-1)*dr3-wa2(i)*di3
            ch(i,k,3) = wa2(i-1)*di3+wa2(i)*dr3
            ch(i-1,k,4) = wa3(i-1)*dr4-wa3(i)*di4
            ch(i,k,4) = wa3(i-1)*di4+wa3(i)*dr4
            ch(i-1,k,5) = wa4(i-1)*dr5-wa4(i)*di5
            ch(i,k,5) = wa4(i-1)*di5+wa4(i)*dr5
  103    continue
  104 continue
c
      return
      end
      subroutine dpssf (nac,ido,ip,l1,idl1,cc,c1,c2,ch,ch2,wa)
      double precision cc(ido,ip,l1), c1(ido,l1,ip), c2(idl1,ip),
     1  ch(ido,l1,ip), ch2(idl1,ip), wa(1), wai, war
c
      idot = ido/2
      nt = ip*idl1
      ipp2 = ip+2
      ipph = (ip+1)/2
      idp = ip*ido
c
      if (ido .lt. l1) go to 106
      do 103 j=2,ipph
         jc = ipp2-j
         do 102 k=1,l1
            do 101 i=1,ido
               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
  101       continue
  102    continue
  103 continue
c
      do 105 k=1,l1
         do 104 i=1,ido
            ch(i,k,1) = cc(i,1,k)
  104    continue
  105 continue
      go to 112
c
  106 do 109 j=2,ipph
         jc = ipp2-j
         do 108 i=1,ido
            do 107 k=1,l1
               ch(i,k,j) = cc(i,j,k)+cc(i,jc,k)
               ch(i,k,jc) = cc(i,j,k)-cc(i,jc,k)
  107       continue
  108    continue
  109 continue
c
      do 111 i=1,ido
         do 110 k=1,l1
            ch(i,k,1) = cc(i,1,k)
  110    continue
  111 continue
c
  112 idl = 2-ido
      inc = 0
      do 116 l=2,ipph
         lc = ipp2-l
         idl = idl+ido
         do 113 ik=1,idl1
            c2(ik,l) = ch2(ik,1)+wa(idl-1)*ch2(ik,2)
            c2(ik,lc) = -wa(idl)*ch2(ik,ip)
  113    continue
         idlj = idl
         inc = inc+ido
         do 115 j=3,ipph
            jc = ipp2-j
            idlj = idlj+inc
            if (idlj .gt. idp) idlj = idlj-idp
            war = wa(idlj-1)
            wai = wa(idlj)
            do 114 ik=1,idl1
               c2(ik,l) = c2(ik,l)+war*ch2(ik,j)
               c2(ik,lc) = c2(ik,lc)-wai*ch2(ik,jc)
  114       continue
  115    continue
  116 continue
c
      do 118 j=2,ipph
         do 117 ik=1,idl1
            ch2(ik,1) = ch2(ik,1)+ch2(ik,j)
  117    continue
  118 continue
c
      do 120 j=2,ipph
         jc = ipp2-j
         do 119 ik=2,idl1,2
            ch2(ik-1,j) = c2(ik-1,j)-c2(ik,jc)
            ch2(ik-1,jc) = c2(ik-1,j)+c2(ik,jc)
            ch2(ik,j) = c2(ik,j)+c2(ik-1,jc)
            ch2(ik,jc) = c2(ik,j)-c2(ik-1,jc)
  119    continue
  120 continue
c
      nac = 1
      if (ido .eq. 2) return
      nac = 0
c
      do 121 ik=1,idl1
         c2(ik,1) = ch2(ik,1)
  121 continue
c
      do 123 j=2,ip
         do 122 k=1,l1
            c1(1,k,j) = ch(1,k,j)
            c1(2,k,j) = ch(2,k,j)
  122    continue
  123 continue
c
      if (idot .gt. l1) go to 127
      idij = 0
      do 126 j=2,ip
         idij = idij+2
         do 125 i=4,ido,2
            idij = idij+2
            do 124 k=1,l1
               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
               c1(i,k,j) = wa(idij-1)*ch(i,k,j)-wa(idij)*ch(i-1,k,j)
  124       continue
  125    continue
  126 continue
      return
c
  127 idj = 2-ido
      do 130 j=2,ip
         idj = idj+ido
         do 129 k=1,l1
            idij = idj
            do 128 i=4,ido,2
               idij = idij+2
               c1(i-1,k,j) = wa(idij-1)*ch(i-1,k,j)+wa(idij)*ch(i,k,j)
               c1(i,k,j) = wa(idij-1)*ch(i,k,j)-wa(idij)*ch(i-1,k,j)
  128       continue
  129    continue
  130 continue
c
      return
      end
      subroutine dpssf2 (ido,l1,cc,ch,wa1)
      double precision cc(ido,2,l1), ch(ido,l1,2), wa1(1), ti2, tr2
c
      if (ido .gt. 2) go to 102
      do 101 k=1,l1
         ch(1,k,1) = cc(1,1,k)+cc(1,2,k)
         ch(1,k,2) = cc(1,1,k)-cc(1,2,k)
         ch(2,k,1) = cc(2,1,k)+cc(2,2,k)
         ch(2,k,2) = cc(2,1,k)-cc(2,2,k)
  101 continue
      return
c
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ch(i-1,k,1) = cc(i-1,1,k)+cc(i-1,2,k)
            tr2 = cc(i-1,1,k)-cc(i-1,2,k)
            ch(i,k,1) = cc(i,1,k)+cc(i,2,k)
            ti2 = cc(i,1,k)-cc(i,2,k)
            ch(i,k,2) = wa1(i-1)*ti2-wa1(i)*tr2
            ch(i-1,k,2) = wa1(i-1)*tr2+wa1(i)*ti2
  103    continue
  104 continue
c
      return
      end
      subroutine dpssf3 (ido,l1,cc,ch,wa1,wa2)
      double precision cc(ido,3,l1), ch(ido,l1,3), wa1(1), wa2(1),
     1  ci2, ci3, cr2, cr3, di2, di3, dr2, dr3, taui, taur, ti2, tr2
      data taur / -0.5 d0 /
      data taui  / -0.8660254037 8443864676 3723170752 93618d0/
c
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         tr2 = cc(1,2,k)+cc(1,3,k)
         cr2 = cc(1,1,k)+taur*tr2
         ch(1,k,1) = cc(1,1,k)+tr2
         ti2 = cc(2,2,k)+cc(2,3,k)
         ci2 = cc(2,1,k)+taur*ti2
         ch(2,k,1) = cc(2,1,k)+ti2
         cr3 = taui*(cc(1,2,k)-cc(1,3,k))
         ci3 = taui*(cc(2,2,k)-cc(2,3,k))
         ch(1,k,2) = cr2-ci3
         ch(1,k,3) = cr2+ci3
         ch(2,k,2) = ci2+cr3
         ch(2,k,3) = ci2-cr3
  101 continue
      return
c
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            tr2 = cc(i-1,2,k)+cc(i-1,3,k)
            cr2 = cc(i-1,1,k)+taur*tr2
            ch(i-1,k,1) = cc(i-1,1,k)+tr2
            ti2 = cc(i,2,k)+cc(i,3,k)
            ci2 = cc(i,1,k)+taur*ti2
            ch(i,k,1) = cc(i,1,k)+ti2
            cr3 = taui*(cc(i-1,2,k)-cc(i-1,3,k))
            ci3 = taui*(cc(i,2,k)-cc(i,3,k))
            dr2 = cr2-ci3
            dr3 = cr2+ci3
            di2 = ci2+cr3
            di3 = ci2-cr3
            ch(i,k,2) = wa1(i-1)*di2-wa1(i)*dr2
            ch(i-1,k,2) = wa1(i-1)*dr2+wa1(i)*di2
            ch(i,k,3) = wa2(i-1)*di3-wa2(i)*dr3
            ch(i-1,k,3) = wa2(i-1)*dr3+wa2(i)*di3
  103    continue
  104 continue
c
      return
      end
      subroutine dpssf4 (ido,l1,cc,ch,wa1,wa2,wa3)
      double precision cc(ido,4,l1), ch(ido,l1,4), wa1(1), wa2(1),
     1  wa3(1), ci2, ci3, ci4, cr2, cr3, cr4, ti1, ti2, ti3, ti4,
     2  tr1, tr2, tr3, tr4
c
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         ti1 = cc(2,1,k)-cc(2,3,k)
         ti2 = cc(2,1,k)+cc(2,3,k)
         tr4 = cc(2,2,k)-cc(2,4,k)
         ti3 = cc(2,2,k)+cc(2,4,k)
         tr1 = cc(1,1,k)-cc(1,3,k)
         tr2 = cc(1,1,k)+cc(1,3,k)
         ti4 = cc(1,4,k)-cc(1,2,k)
         tr3 = cc(1,2,k)+cc(1,4,k)
         ch(1,k,1) = tr2+tr3
         ch(1,k,3) = tr2-tr3
         ch(2,k,1) = ti2+ti3
         ch(2,k,3) = ti2-ti3
         ch(1,k,2) = tr1+tr4
         ch(1,k,4) = tr1-tr4
         ch(2,k,2) = ti1+ti4
         ch(2,k,4) = ti1-ti4
  101 continue
      return
c
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ti1 = cc(i,1,k)-cc(i,3,k)
            ti2 = cc(i,1,k)+cc(i,3,k)
            ti3 = cc(i,2,k)+cc(i,4,k)
            tr4 = cc(i,2,k)-cc(i,4,k)
            tr1 = cc(i-1,1,k)-cc(i-1,3,k)
            tr2 = cc(i-1,1,k)+cc(i-1,3,k)
            ti4 = cc(i-1,4,k)-cc(i-1,2,k)
            tr3 = cc(i-1,2,k)+cc(i-1,4,k)
            ch(i-1,k,1) = tr2+tr3
            cr3 = tr2-tr3
            ch(i,k,1) = ti2+ti3
            ci3 = ti2-ti3
            cr2 = tr1+tr4
            cr4 = tr1-tr4
            ci2 = ti1+ti4
            ci4 = ti1-ti4
            ch(i-1,k,2) = wa1(i-1)*cr2+wa1(i)*ci2
            ch(i,k,2) = wa1(i-1)*ci2-wa1(i)*cr2
            ch(i-1,k,3) = wa2(i-1)*cr3+wa2(i)*ci3
            ch(i,k,3) = wa2(i-1)*ci3-wa2(i)*cr3
            ch(i-1,k,4) = wa3(i-1)*cr4+wa3(i)*ci4
            ch(i,k,4) = wa3(i-1)*ci4-wa3(i)*cr4
  103    continue
  104 continue
c
      return
      end
      subroutine dpssf5 (ido,l1,cc,ch,wa1,wa2,wa3,wa4)
      double precision cc(ido,5,l1), ch(ido,l1,5), wa1(1), wa2(1),
     1  wa3(1), wa4(1), ci2, ci3, ci4, ci5, cr2, cr3, cr4, cr5, di2,
     2  di3, di4, di5, dr2, dr3, dr4, dr5, ti11, ti12, ti2, ti3, ti4,
     3  ti5, tr11, tr12, tr2, tr3, tr4, tr5
      data tr11  /  0.3090169943 7494742410 2293417182 81906d0/
      data ti11  / -0.9510565162 9515357211 6439333379 38214d0/
      data tr12  / -0.8090169943 7494742410 2293417182 81906d0/
      data ti12  / -0.5877852522 9247312916 8705954639 07277d0/
c
      if (ido .ne. 2) go to 102
      do 101 k=1,l1
         ti5 = cc(2,2,k)-cc(2,5,k)
         ti2 = cc(2,2,k)+cc(2,5,k)
         ti4 = cc(2,3,k)-cc(2,4,k)
         ti3 = cc(2,3,k)+cc(2,4,k)
         tr5 = cc(1,2,k)-cc(1,5,k)
         tr2 = cc(1,2,k)+cc(1,5,k)
         tr4 = cc(1,3,k)-cc(1,4,k)
         tr3 = cc(1,3,k)+cc(1,4,k)
         ch(1,k,1) = cc(1,1,k)+tr2+tr3
         ch(2,k,1) = cc(2,1,k)+ti2+ti3
         cr2 = cc(1,1,k)+tr11*tr2+tr12*tr3
         ci2 = cc(2,1,k)+tr11*ti2+tr12*ti3
         cr3 = cc(1,1,k)+tr12*tr2+tr11*tr3
         ci3 = cc(2,1,k)+tr12*ti2+tr11*ti3
         cr5 = ti11*tr5+ti12*tr4
         ci5 = ti11*ti5+ti12*ti4
         cr4 = ti12*tr5-ti11*tr4
         ci4 = ti12*ti5-ti11*ti4
         ch(1,k,2) = cr2-ci5
         ch(1,k,5) = cr2+ci5
         ch(2,k,2) = ci2+cr5
         ch(2,k,3) = ci3+cr4
         ch(1,k,3) = cr3-ci4
         ch(1,k,4) = cr3+ci4
         ch(2,k,4) = ci3-cr4
         ch(2,k,5) = ci2-cr5
  101 continue
      return
c
  102 do 104 k=1,l1
         do 103 i=2,ido,2
            ti5 = cc(i,2,k)-cc(i,5,k)
            ti2 = cc(i,2,k)+cc(i,5,k)
            ti4 = cc(i,3,k)-cc(i,4,k)
            ti3 = cc(i,3,k)+cc(i,4,k)
            tr5 = cc(i-1,2,k)-cc(i-1,5,k)
            tr2 = cc(i-1,2,k)+cc(i-1,5,k)
            tr4 = cc(i-1,3,k)-cc(i-1,4,k)
            tr3 = cc(i-1,3,k)+cc(i-1,4,k)
            ch(i-1,k,1) = cc(i-1,1,k)+tr2+tr3
            ch(i,k,1) = cc(i,1,k)+ti2+ti3
            cr2 = cc(i-1,1,k)+tr11*tr2+tr12*tr3
            ci2 = cc(i,1,k)+tr11*ti2+tr12*ti3
            cr3 = cc(i-1,1,k)+tr12*tr2+tr11*tr3
            ci3 = cc(i,1,k)+tr12*ti2+tr11*ti3
            cr5 = ti11*tr5+ti12*tr4
            ci5 = ti11*ti5+ti12*ti4
            cr4 = ti12*tr5-ti11*tr4
            ci4 = ti12*ti5-ti11*ti4
            dr3 = cr3-ci4
            dr4 = cr3+ci4
            di3 = ci3+cr4
            di4 = ci3-cr4
            dr5 = cr2+ci5
            dr2 = cr2-ci5
            di5 = ci2-cr5
            di2 = ci2+cr5
            ch(i-1,k,2) = wa1(i-1)*dr2+wa1(i)*di2
            ch(i,k,2) = wa1(i-1)*di2-wa1(i)*dr2
            ch(i-1,k,3) = wa2(i-1)*dr3+wa2(i)*di3
            ch(i,k,3) = wa2(i-1)*di3-wa2(i)*dr3
            ch(i-1,k,4) = wa3(i-1)*dr4+wa3(i)*di4
            ch(i,k,4) = wa3(i-1)*di4-wa3(i)*dr4
            ch(i-1,k,5) = wa4(i-1)*dr5+wa4(i)*di5
            ch(i,k,5) = wa4(i-1)*di5-wa4(i)*dr5
  103    continue
  104 continue
c
      return
      end
!> Doxygen comment: ;\n
!> calculates dot(v1,v2) ;\n
      complex *16 function dot_c16_f(n_v,v1_,v2_)
      implicit none
      integer n_v
      complex *16 v1_(0:n_v-1)
      complex *16 v2_(0:n_v-1)
      complex *16 aa
      integer nv
      aa = cmplx(0.0d0,0.0d0)
      do nv=0,n_v-1
         aa = aa + dconjg(v1_(nv))*v2_(nv)
      enddo !do nv=0,n_v-1
      dot_c16_f = aa
      return
      end
!> Doxygen comment: ;\n
!> generates figure on cartesian grid (no recentering): ;\n
      subroutine Fig_c16_carte_no_recenter(unitnumber,n_x,grid_x_c_,n_y
     $     ,grid_y_c_,real_or_imag,F_,Fmin,Fmax,x_offset,y_offset,x_side
     $     ,y_side)
c$$$      does not recenter
      implicit none
      integer *4 unitnumber
      integer *4 n_x,n_y
      real *8 grid_x_c_(0:n_x-1),grid_y_c_(0:n_y-1)
      logical real_or_imag
      complex *16 F_(0:n_x*n_y-1)
      real *8 Fmin,Fmax
      real *8 x_offset,y_offset,x_side,y_side
      real *8 F_avg,F_std,Fmin_use,Fmax_use
      real *8 x_pos,y_pos,x_pre,y_pre
      integer *4 diameter,nx,ny,nd
      integer *4 xyval_(0:9)
      integer *4 color_index
      character(len=20) format_string
      write(format_string,'(A,I0,A)') '(A,1X,',10,'(I0,1X))'
      Fmin_use = Fmin
      Fmax_use = Fmax
      if (Fmin_use.ge.Fmax_use) then
         call stdlim_c16(n_x*n_y,real_or_imag,F_,F_avg,F_std)
         Fmin_use = F_avg - 2.0*F_std
         Fmax_use = F_avg + 2.0*F_std
      end if
      diameter = 1000
      do ny=0,n_y-1
         if (ny.gt.0) then
            y_pre = 0.5*(grid_y_c_(ny-1) + grid_y_c_(ny))
         else
            y_pre = grid_y_c_(0)
         end if
         if (ny.lt.n_y-1) then
            y_pos = 0.5*(grid_y_c_(ny) + grid_y_c_(ny+1))
         else
            y_pos = grid_y_c_(n_y-1)
         end if
         do nx=0,n_x-1
            if (nx.gt.0) then
               x_pre = 0.5*(grid_x_c_(nx-1) + grid_x_c_(nx))
            else
               x_pre = grid_x_c_(0)
            end if
            if (nx.lt.n_x-1) then
               x_pos = 0.5*(grid_x_c_(nx) + grid_x_c_(nx+1))
            else
               x_pos = grid_x_c_(n_x-1)
            end if
            xyval_(0 + 2*0) = +int(diameter*(x_pre*x_side + x_offset))
            xyval_(1 + 2*0) = -int(diameter*(y_pre*y_side + y_offset))
            xyval_(0 + 2*1) = +int(diameter*(x_pos*x_side + x_offset))
            xyval_(1 + 2*1) = -int(diameter*(y_pre*y_side + y_offset))
            xyval_(0 + 2*2) = +int(diameter*(x_pos*x_side + x_offset))
            xyval_(1 + 2*2) = -int(diameter*(y_pos*y_side + y_offset))
            xyval_(0 + 2*3) = +int(diameter*(x_pre*x_side + x_offset))
            xyval_(1 + 2*3) = -int(diameter*(y_pos*y_side + y_offset))
            xyval_(0 + 2*4) = +int(diameter*(x_pre*x_side + x_offset))
            xyval_(1 + 2*4) = -int(diameter*(y_pre*y_side + y_offset))
            if (real_or_imag.eqv..true.) then
               color_index = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(real(F_(nx+ny*n_x))-Fmin_use)/(Fmax_use
     $              -Fmin_use))))
            else
               color_index = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(aimag(F_(nx+ny*n_x))-Fmin_use)/(Fmax_use
     $              -Fmin_use))))
            end if
            write(unitnumber,'(A,I0,A,I0)') '2 3 0 0 0 ',color_index
     $           ,' 50 -1 20 0.000 0 0 -1 0 0 ',5
            write(unitnumber,format_string) char(9),(xyval_(nd),nd=0,9)
         enddo
      enddo
      end
!> Doxygen comment: ;\n
!>      Reads in a few images and plots them after ;\n
!>      convolution with their ctf-function ;\n
      subroutine Fig_gen_ctf_ver3(ncur,nlats_,grid_k_p_,n_M,I_M_sample_
     $     ,ld_M,M_k_p_,ld_CTF,CTF_k_p_,alpha_est_
     $     ,n_M_sample,prefix)
c$$$      Reads in a few images and plots them after
c$$$      convolution with their ctf-function
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      data verbose / 2 /
      logical plot_flag
      integer *4 ncur,nlats_(0:ncur-1),n_M,I_M_sample_(0:n_M-1),ld_M
     $     ,ld_CTF,n_M_sample
      real *8 grid_k_p_(0:0)
      real *8 alpha_est_(0:0)
      include 'nalpha_define.f'
      complex *16 M_k_p_(0:0),CTF_k_p_(0:0)
      character(len=1024) prefix
      integer *4 I_M_sample_tmp_(0:n_M_sample)
      integer *4 ntemplatesize
      integer *4, allocatable :: ngridc_(:)
      integer *4, allocatable :: icstart_(:)
c$$$      indices
      integer *4 n_r,nr,n_w_max,n_A,na,nctf,nm,nM_sample
      integer *4, allocatable :: n_w_(:)
c$$$      temporary storage for ctf
      complex *16, allocatable :: T_k_p_(:)
      real *8 pi
      real *8 max_r8_f
      real *8 max_k_c
      character(len=64) format_string
c$$$      parameters for figure generation
      character(len=1024) fig_title,fname_pre,fname_fig,fname_jpg
      integer unitnumber,text_length,color_index,font_type,font_size
      real *8 F_avg,F_std,F_max,F_min
      real *8 x_loc,y_loc,x_side,y_side,x_offset,y_offset
      character(len=1024) fig2dev_system_call
      integer system,system_error

      if (verbose.gt.0) then
          write(6,'(A)')
     $        '[entering Fig_gen_ctf_ver3]: '
       end if
       if (verbose.gt.1) then
         write(6,'(A,I0)') 'verbose: ',verbose
         write(6,'(A,I0)') 'ncur: ',ncur
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'nlats_: ',(nlats_(nr),nr=0,ncur-1)
         write(format_string,'(A,I0,A)') '(A,',ncur,'(F8.3,1X))'
         write(6,format_string) 'grid_k_p_: ',(grid_k_p_(nr),nr=0,ncur
     $        -1)
         write(6,'(A,I0)') 'n_M: ',n_M
         write(6,'(A,I0)') 'ld_M: ',ld_M
         write(6,'(A,I0)') 'ld_CTF: ',ld_CTF
         write(6,'(A,I0)') 'n_alpha: ',n_alpha
         write(6,'(A,I0)') 'n_M_sample: ',n_M_sample
         write(6,'(A)') trim(prefix)
      end if

      do nM_sample=0,n_M_sample-1
         if (n_M_sample.lt.n_M) then
            I_M_sample_tmp_(nM_sample) = min(n_M-1,floor(n_M
     $           *1.0d0*nM_sample/(n_M_sample-1)))
         else
            I_M_sample_tmp_(nM_sample) = nM_sample
         end if
      enddo
      if (verbose.gt.1) then
         write(format_string,'(A,I0,A)') '(',n_M_sample,'(I0,1X))'
         write(6,format_string) (I_M_sample_tmp_(nM_sample),nM_sample=0
     $        ,n_M_sample-1)
      end if

      pi = 4*atan(1.0)

c$$$      Calculating template size using 'get_template_size'
      allocate(ngridc_(ncur))
      allocate(icstart_(ncur))
      if (verbose.gt.1) then
         write(6,'(A,I0,A,A)') 'ncur = ',ncur
     $        ,'; calling get_template_size to'
     $        ,' determine ngridc_ and ntemplatesize'
      end if
      call get_template_size(nlats_,ncur,ntemplatesize,ngridc_,icstart_)
      if (verbose.gt.1) then
         write(6,'(A,I0)') 'ntemplatesize = ',ntemplatesize
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'ngridc_: ',(ngridc_(nr),nr=1,ncur)
      end if
      
c$$$      indices
      n_r = ncur
      if (n_r.lt.2) then
         write(6,'(A,I0,A)') 'Error n_r',n_r,'<2'
      end if
      allocate(n_w_(0:n_r-1))
      n_A = 0
      do nr=0,n_r-1
         n_w_(nr) = ngridc_(1+nr)
         n_A = n_A + n_w_(nr)
      enddo
      n_w_max = n_w_(nr-1)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0)') 'n_w_max ',n_w_max,'; n_A ',n_A
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'n_w_: ',(n_w_(nr),nr=0,ncur-1)
      end if
      
c$$$      generating grids for templates and images 
      max_k_c = 2*grid_k_p_(n_r-1)

c$$$      allocating temporary storage for images and templates 
      allocate(T_k_p_(0:n_A-1))

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We initialize the first figure file.' 
      end if

      unitnumber = 7
      write(fname_pre,'(A)') trim(prefix)
      write(fname_fig,'(A,A)') trim(fname_pre),'.fig'
      write(fname_jpg,'(A,A)') trim(fname_pre),'.jpg'
      open(unitnumber,file=fname_fig,status='replace' ,form='formatted')
      call Fig_header(unitnumber);

      if (verbose.gt.1) then
         write(6,'(A)') ''
         write(6,'(A)')
     $        'We display the images on a k-space polar grid'
     $        ,' along with their values after ctf-convolution.'
      end if
c$$$      printing images
      do nM_sample=0,n_M_sample-1
         nm = I_M_sample_tmp_(nM_sample)
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'sample ',nM_sample,' is image ',nm
         end if
         call stdlim_c16(n_A,.true.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(M_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(M_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$         Print ctf-function associated with image
         nctf = alpha_est_(nalpha_ctf_ind + nm*n_alpha)
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'ctf for image ',nm,' is ',nctf
         end if
c$$$         Display ctf-function
         call cp1_c16(n_A,CTF_k_p_(nctf*ld_CTF),T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(C_k_p(',nctf,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(C_k_p(',nctf,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
      enddo !do nM_sample=0,n_M_sample-1

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We write the figure file to disk.'
         write(6,'(A,A)') 'try: '
     $        ,'"gthumb ?.jpg"'
      end if
c$$$      Printing figure file for image
      close(unitnumber,status='keep')
      write(fig2dev_system_call,'(A,A,1X,A)') 'fig2dev -Ljpeg -q 10 '
     $     ,trim(fname_fig),trim(fname_jpg)
      system_error = system(fig2dev_system_call)

      deallocate(T_k_p_)
      deallocate(n_w_)
      deallocate(ngridc_)
      deallocate(icstart_)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished Fig_gen_ctf_ver3]'
      end if

      end
!> Doxygen comment: ;\n
!>      Reads in a few templates and images and plots a comparison ;\n
      subroutine Fig_gen_ver5(ncur,nlats_,grid_k_p_,n_S,I_S_sample_,ld_S
     $     ,S_k_p_,n_M,I_M_sample_,ld_M,M_k_p_,ld_CTF,CTF_k_p_
     $     ,alpha_est_ ,n_M_sample,prefix)
c$$$      Reads in a few templates and images and plots a comparison
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      data verbose / 0 /
      logical plot_flag
      integer *4 ncur,nlats_(0:ncur-1)
      integer *4 n_S,I_S_sample_(0:n_S-1),ld_S,n_M,I_M_sample_(0:n_M-1)
     $     ,ld_M,ld_CTF,n_M_sample
      real *8 grid_k_p_(0:0)
      real *8 alpha_est_(0:0)
      include 'nalpha_define.f'
      complex *16 S_k_p_(0:0),M_k_p_(0:0),CTF_k_p_(0:0)
      character(len=1024) prefix
      integer *4 ntemplatesize
      integer *4, allocatable :: ngridc_(:)
      integer *4, allocatable :: icstart_(:)
c$$$      indices
      integer *4 n_r,nr,n_w_max,n_A,na,ns,nm,nctf,nM_sample
      integer *4, allocatable :: n_w_(:)
c$$$      temporary storage for templates and images
      complex *16, allocatable :: T_k_p_(:)
      real *8 pi
      real *8 max_r8_f
      real *8 max_k_c
      real *8 delta_x_est,delta_y_est,gamma_z_est
      real *8 delta_x_tmp,delta_y_tmp
      real *8 delta_x,delta_y,gamma_z
      character(len=64) format_string
c$$$      parameters for figure generation
      character(len=1024) fig_title,fname_pre,fname_fig,fname_jpg
      integer unitnumber,text_length,color_index,font_type,font_size
      real *8 F_avg,F_std,F_max,F_min
      real *8 x_loc,y_loc,x_side,y_side,x_offset,y_offset
      character(len=1024) fig2dev_system_call
      integer system,system_error

      if (verbose.gt.0) then
          write(6,'(A)')
     $        '[entering Fig_gen_ver5]: '
       end if
       if (verbose.gt.1) then
         write(6,'(A,I0)') 'verbose: ',verbose
         write(6,'(A,I0)') 'ncur: ',ncur
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'nlats_: ',(nlats_(nr),nr=0,ncur-1)
         write(format_string,'(A,I0,A)') '(A,',ncur,'(F8.3,1X))'
         write(6,format_string) 'grid_k_p_: ',(grid_k_p_(nr),nr=0,ncur
     $        -1)
         write(6,'(A,I0)') 'n_S: ',n_S
         write(6,'(A,I0)') 'ld_S: ',ld_S
         write(6,'(A,I0)') 'n_M: ',n_M
         write(6,'(A,I0)') 'ld_M: ',ld_M
         write(6,'(A,I0)') 'ld_CTF: ',ld_CTF
         write(6,'(A,I0)') 'n_M_sample: ',n_M_sample
         write(6,'(A)') trim(prefix)
      end if

      pi = 4*atan(1.0)

c$$$      Calculating template size using 'get_template_size'
      allocate(ngridc_(ncur))
      allocate(icstart_(ncur))
      if (verbose.gt.1) then
         write(6,'(A,I0,A,A)') 'ncur = ',ncur
     $        ,'; calling get_template_size to'
     $        ,' determine ngridc_ and ntemplatesize'
      end if
      call get_template_size(nlats_,ncur,ntemplatesize,ngridc_,icstart_)
      if (verbose.gt.1) then
         write(6,'(A,I0)') 'ntemplatesize = ',ntemplatesize
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'ngridc_: ',(ngridc_(nr),nr=1,ncur)
      end if
      
c$$$      indices
      n_r = ncur
      if (n_r.lt.2) then
         write(6,'(A,I0,A)') 'Error n_r',n_r,'<2'
      end if
      allocate(n_w_(0:n_r-1))
      n_A = 0
      do nr=0,n_r-1
         n_w_(nr) = ngridc_(1+nr)
         n_A = n_A + n_w_(nr)
      enddo
      n_w_max = n_w_(nr-1)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0)') 'n_w_max ',n_w_max,'; n_A ',n_A
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'n_w_: ',(n_w_(nr),nr=0,ncur-1)
      end if
      
c$$$      generating grids for templates and images 
      max_k_c = 2*grid_k_p_(n_r-1)

c$$$      allocating temporary storage for images and templates 
      allocate(T_k_p_(0:n_A-1))

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We initialize the first figure file.' 
      end if

      unitnumber = 7
      write(fname_pre,'(A)') trim(prefix)
      write(fname_fig,'(A,A)') trim(fname_pre),'.fig'
      write(fname_jpg,'(A,A)') trim(fname_pre),'.jpg'
      open(unitnumber,file=fname_fig,status='replace' ,form='formatted')
      call Fig_header(unitnumber);

      if (verbose.gt.1) then
         write(6,'(A)') ''
         write(6,'(A)')
     $        'We display the images on a k-space polar grid'
     $        ,' along with their best matching (transformed) templates'
     $        ,' also on a k-space polar grid.'
      end if
c$$$      printing templates and images
      do nM_sample=0,n_M_sample-1
         nm = floor((n_M*nM_sample*1.0d0)/(n_M_sample*1.0d0))
         nctf = nint(alpha_est_(nalpha_ctf_ind + nm*n_alpha))
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'sample ',nM_sample,' is image ',nm
            write(6,'(A,I0,A,I0)') 'sample ',nM_sample,' has ctf ',nctf
         end if
c$$$         Display image with ctf
         call stdlim_c16(n_A,.true.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(M_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(M_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$         Pick best matching template
         ns = nint(alpha_est_(nalpha_S_index + nm*n_alpha))
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'Best match to image ',nm,' is ',ns
         end if
c$$$         Display template without perturbation
         ns = nint(alpha_est_(nalpha_S_index + nm*n_alpha))
         call cp1_c16(n_A,S_k_p_(I_S_sample_(ns)*ld_S),T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 67.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(S_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 67.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(S_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$         Display template with perturbation but no ctf
         ns = nint(alpha_est_(nalpha_S_index + nm*n_alpha))
         delta_x_est = alpha_est_(nalpha_delta_x + nm*n_alpha)
         delta_y_est = alpha_est_(nalpha_delta_y + nm*n_alpha)
         gamma_z_est = alpha_est_(nalpha_gamma_z + nm*n_alpha)
         call cp1_c16(n_A,S_k_p_(I_S_sample_(ns)*ld_S),T_k_p_)
         call transf_p_to_p(n_r,grid_k_p_,n_w_,n_A,T_k_p_,+delta_x_est,
     $        +delta_y_est,T_k_p_)
         call rotate_p2p_fz(n_r,n_w_,n_A,T_k_p_,+gamma_z_est
     $        ,T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 45.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(T_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 45.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(T_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$         Display template with perturbation and ctf
         ns = nint(alpha_est_(nalpha_S_index + nm*n_alpha))
         delta_x_est = alpha_est_(nalpha_delta_x + nm*n_alpha)
         delta_y_est = alpha_est_(nalpha_delta_y + nm*n_alpha)
         gamma_z_est = alpha_est_(nalpha_gamma_z + nm*n_alpha)
         call cp1_c16(n_A,S_k_p_(I_S_sample_(ns)*ld_S),T_k_p_)
         call transf_p_to_p(n_r,grid_k_p_,n_w_,n_A,T_k_p_,+delta_x_est,
     $        +delta_y_est,T_k_p_)
         call rotate_p2p_fz(n_r,n_w_,n_A,T_k_p_,+gamma_z_est
     $        ,T_k_p_)
         call xx1_c16(n_A,T_k_p_,CTF_k_p_(nctf*ld_CTF),T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(CT_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 19
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(CT_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 19
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
      enddo

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We write the figure file to disk.'
         write(6,'(A,A)') 'try: '
     $        ,'"gthumb ?.jpg"'
      end if
c$$$      Printing figure file for image
      close(unitnumber,status='keep')
      write(fig2dev_system_call,'(A,A,1X,A)') 'fig2dev -Ljpeg -q 10 '
     $     ,trim(fname_fig),trim(fname_jpg)
      system_error = system(fig2dev_system_call)

      deallocate(T_k_p_)
      deallocate(n_w_)
      deallocate(ngridc_)
      deallocate(icstart_)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished Fig_gen_ver5]'
      end if

      end
!> Doxygen comment: ;\n
!>      Reads in a few images and ctransf and plots a comparison ;\n
      subroutine Fig_R_ver1(ncur,n_polar_a_,grid_k_p_,n_M ,I_M_sample_
     $     ,ld_M,M_k_p_,R_k_p_,alpha_est_ ,n_M_sample,prefix)
c$$$      Reads in a few images and ctransf and plots a comparison
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      data verbose / 0 /
      logical plot_flag
      integer *4 ncur,n_polar_a_(0:ncur-1)
      integer *4 n_M,I_M_sample_(0:n_M-1),ld_M,n_M_sample
      real *8 grid_k_p_(0:0)
      real *8 alpha_est_(0:0)
      include 'nalpha_define.f'
      complex *16 R_k_p_(0:0),M_k_p_(0:0)
      character(len=1024) prefix
      integer *4 I_M_sample_tmp_(0:n_M_sample)
      integer *4 ntemplatesize
      integer *4, allocatable :: ngridc_(:)
      integer *4, allocatable :: icstart_(:)
c$$$      indices
      integer *4 n_r,nr,n_w_max,n_A,na,ns,nm,nM_sample
      integer *4, allocatable :: n_w_(:)
c$$$      temporary storage for templates and images
      complex *16, allocatable :: T_k_p_(:)
      real *8 pi
      real *8 max_r8_f
      real *8 max_k_c
      real *8 delta_x,delta_y,gamma_z
      character(len=64) format_string
c$$$      parameters for figure generation
      character(len=1024) fig_title,fname_pre,fname_fig,fname_jpg
      integer unitnumber,text_length,color_index,font_type,font_size
      real *8 F_avg,F_std,F_max,F_min
      real *8 x_loc,y_loc,x_side,y_side,x_offset,y_offset
      character(len=1024) fig2dev_system_call
      integer system,system_error

      if (verbose.gt.0) then
          write(6,'(A)')
     $        '[entering Fig_R_ver1]: '
       end if
       if (verbose.gt.1) then
         write(6,'(A,I0)') 'verbose: ',verbose
         write(6,'(A,I0)') 'ncur: ',ncur
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'n_polar_a_: ',(n_polar_a_(nr),nr=0,ncur
     $        -1)
         write(format_string,'(A,I0,A)') '(A,',ncur,'(F8.3,1X))'
         write(6,format_string) 'grid_k_p_: ',(grid_k_p_(nr),nr=0,ncur
     $        -1)
         write(6,'(A,I0)') 'n_M: ',n_M
         write(6,'(A,I0)') 'ld_M: ',ld_M
         write(6,'(A,I0)') 'n_M_sample: ',n_M_sample
         write(6,'(A)') trim(prefix)
      end if

      do nM_sample=0,n_M_sample-1
         if (n_M_sample.lt.n_M) then
            I_M_sample_tmp_(nM_sample) = min(n_M-1,floor(n_M
     $           *1.0d0*nM_sample/(n_M_sample-1)))
         else
            I_M_sample_tmp_(nM_sample) = nM_sample
         end if
      enddo
      if (verbose.gt.1) then
         write(format_string,'(A,I0,A)') '(',n_M_sample,'(I0,1X))'
         write(6,format_string) (I_M_sample_tmp_(nM_sample),nM_sample=0
     $        ,n_M_sample-1)
      end if

      pi = 4*atan(1.0)

c$$$      Calculating template size using 'get_template_size'
      allocate(ngridc_(ncur))
      allocate(icstart_(ncur))
      if (verbose.gt.1) then
         write(6,'(A,I0,A,A)') 'ncur = ',ncur
     $        ,'; calling get_template_size to'
     $        ,' determine ngridc_ and ntemplatesize'
      end if
      call get_template_size(n_polar_a_,ncur,ntemplatesize,ngridc_
     $     ,icstart_)
      if (verbose.gt.1) then
         write(6,'(A,I0)') 'ntemplatesize = ',ntemplatesize
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'ngridc_: ',(ngridc_(nr),nr=1,ncur)
      end if
      
c$$$      indices
      n_r = ncur
      if (n_r.lt.2) then
         write(6,'(A,I0,A)') 'Error n_r',n_r,'<2'
      end if
      allocate(n_w_(0:n_r-1))
      n_A = 0
      do nr=0,n_r-1
         n_w_(nr) = ngridc_(1+nr)
         n_A = n_A + n_w_(nr)
      enddo
      n_w_max = n_w_(nr-1)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0)') 'n_w_max ',n_w_max,'; n_A ',n_A
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'n_w_: ',(n_w_(nr),nr=0,ncur-1)
      end if
      
c$$$      generating grids for templates and images 
      max_k_c = 2*grid_k_p_(n_r-1)

c$$$      allocating temporary storage for images and templates 
      allocate(T_k_p_(0:n_A-1))

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We initialize the first figure file.' 
      end if

      unitnumber = 7
      write(fname_pre,'(A)') trim(prefix)
      write(fname_fig,'(A,A)') trim(fname_pre),'.fig'
      write(fname_jpg,'(A,A)') trim(fname_pre),'.jpg'
      open(unitnumber,file=fname_fig,status='replace' ,form='formatted')
      call Fig_header(unitnumber);

      if (verbose.gt.1) then
         write(6,'(A)') ''
         write(6,'(A)')
     $        'We display the images on a k-space polar grid'
     $        ,' along with their ctransf, '
     $        ,' also on a k-space polar grid.'
      end if
c$$$      printing templates and images
      do nM_sample=0,n_M_sample-1
         nm = I_M_sample_tmp_(nM_sample)
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'sample ',nM_sample,' is image ',nm
         end if
c$$$         Display original image with ctf
         call stdlim_c16(n_A,.true.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 - 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(N_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 - 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(N_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)

c$$$         Display original image with ctf, transformed
         delta_x = - alpha_est_(nalpha_delta_x + nm*n_alpha)
         delta_y = - alpha_est_(nalpha_delta_y + nm*n_alpha)
         gamma_z = - alpha_est_(nalpha_gamma_z + nm*n_alpha)
         call cp1_c16(n_A,M_k_p_(I_M_sample_(nm)*ld_M),T_k_p_)
         call rotate_p2p_fz(n_r,n_w_,n_A,T_k_p_,+gamma_z,T_k_p_)
         call transf_p_to_p(n_r,grid_k_p_,n_w_,n_A,T_k_p_,+delta_x,
     $        +delta_y,T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 - 0.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(T_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 - 0.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(T_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)

c$$$         Display corresponding residua
         call stdlim_c16(n_A,.true.,R_k_p_(nm*ld_M),F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,R_k_p_(nm*ld_M),F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(R_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,R_k_p_(nm*ld_M),F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,R_k_p_(nm*ld_M),F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(R_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)

      enddo !do nM_sample=0,n_M_sample-1

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We write the figure file to disk.'
         write(6,'(A,A)') 'try: '
     $        ,'"gthumb ?.jpg"'
      end if
c$$$      Printing figure file for image
      close(unitnumber,status='keep')
      write(fig2dev_system_call,'(A,A,1X,A)') 'fig2dev -Ljpeg -q 10 '
     $     ,trim(fname_fig),trim(fname_jpg)
      system_error = system(fig2dev_system_call)

      deallocate(T_k_p_)
      deallocate(n_w_)
      deallocate(ngridc_)
      deallocate(icstart_)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished Fig_R_ver1]'
      end if

      end
!> Doxygen comment: ;\n
!>          THIS SET OF ROUTINES COMPUTES THE NODES T(J) AND WEIGHTS ;\n
!>       W(J) FOR GAUSSIAN-TYPE QUADRATURE RULES WITH PRE-ASSIGNED ;\n
!>       NODES.  THESE ARE USED WHEN ONE WISHES TO APPROXIMATE ;\n
!>        ;\n
!>                INTEGRAL (FROM A TO B)  F(X) W(X) DX ;\n
!>        ;\n
!>                             N ;\n
!>       BY                   SUM W  F(T ) ;\n
!>                            J=1  J    J ;\n
!>        ;\n
!>       (NOTE W(X) AND W(J) HAVE NO CONNECTION WITH EACH OTHER.) ;\n
!>       HERE W(X) IS ONE OF SIX POSSIBLE NON-NEGATIVE WEIGHT ;\n
!>       FUNCTIONS (LISTED BELOW), AND F(X) IS THE ;\n
!>       FUNCTION TO BE INTEGRATED.  GAUSSIAN QUADRATURE IS PARTICULARLY ;\n
!>       USEFUL ON INFINITE INTERVALS (WITH APPROPRIATE WEIGHT ;\n
!>       FUNCTIONS), SINCE THEN OTHER TECHNIQUES OFTEN FAIL. ;\n
!>        ;\n
!>          ASSOCIATED WITH EACH WEIGHT FUNCTION W(X) IS A SET OF ;\n
!>       ORTHOGONAL POLYNOMIALS.  THE NODES T(J) ARE JUST THE ZEROES ;\n
!>       OF THE PROPER N-TH DEGREE POLYNOMIAL. ;\n
!>        ;\n
!>    INPUT PARAMETERS (ALL REAL NUMBERS ARE IN DOUBLE PRECISION) ;\n
!>        ;\n
!>       KIND     AN INTEGER BETWEEN 1 AND 6 GIVING THE TYPE OF ;\n
!>                QUADRATURE RULE: ;\n
!>        ;\n
!>       KIND = 1:  LEGENDRE QUADRATURE, W(X) = 1 ON (-1, 1) ;\n
!>       KIND = 2:  CHEBYSHEV QUADRATURE OF THE FIRST KIND ;\n
!>                  W(X) = 1/SQRT(1 - X*X) ON (-1, +1) ;\n
!>       KIND = 3:  CHEBYSHEV QUADRATURE OF THE SECOND KIND ;\n
!>                  W(X) = SQRT(1 - X*X) ON (-1, 1) ;\n
!>       KIND = 4:  HERMITE QUADRATURE, W(X) = EXP(-X*X) ON ;\n
!>                  (-INFINITY, +INFINITY) ;\n
!>       KIND = 5:  JACOBI QUADRATURE, W(X) = (1-X)**ALPHA * (1+X)** ;\n
!>                  BETA ON (-1, 1), ALPHA, BETA .GT. -1. ;\n
!>                  NOTE: KIND=2 AND 3 ARE A SPECIAL CASE OF THIS. ;\n
!>       KIND = 6:  GENERALIZED LAGUERRE QUADRATURE, W(X) = EXP(-X)* ;\n
!>                  X**ALPHA ON (0, +INFINITY), ALPHA .GT. -1 ;\n
!>        ;\n
!>       N        THE NUMBER OF POINTS USED FOR THE QUADRATURE RULE ;\n
!>       ALPHA    REAL PARAMETER USED ONLY FOR GAUSS-JACOBI AND GAUSS- ;\n
!>                LAGUERRE QUADRATURE (OTHERWISE USE 0.D0). ;\n
!>       BETA     REAL PARAMETER USED ONLY FOR GAUSS-JACOBI QUADRATURE-- ;\n
!>                (OTHERWISE USE 0.D0) ;\n
!>       KPTS     (INTEGER) NORMALLY 0, UNLESS THE LEFT OR RIGHT END- ;\n
!>                POINT (OR BOTH) OF THE INTERVAL IS REQUIRED TO BE A ;\n
!>                NODE (THIS IS CALLED GAUSS-RADAU OR GAUSS-LOBATTO ;\n
!>                QUADRATURE).  THEN KPTS IS THE NUMBER OF FIXED ;\n
!>                ENDPOINTS (1 OR 2). ;\n
!>       ENDPTS   REAL ARRAY OF LENGTH 2.  CONTAINS THE VALUES OF ;\n
!>                ANY FIXED ENDPOINTS, IF KPTS = 1 OR 2. ;\n
!>       B        REAL SCRATCH ARRAY OF LENGTH N ;\n
!>        ;\n
!>    OUTPUT PARAMETERS (BOTH DOUBLE PRECISION ARRAYS OF LENGTH N) ;\n
!>        ;\n
!>       T        WILL CONTAIN THE DESIRED NODES. ;\n
!>       W        WILL CONTAIN THE DESIRED WEIGHTS W(J). ;\n
!>        ;\n
!>    SUBROUTINES REQUIRED ;\n
!>        ;\n
!>       SOLVE, CLASS, AND IMTQL2 ARE PROVIDED.  UNDERFLOW MAY SOMETIMES ;\n
!>       OCCUR, BUT IT IS HARMLESS IF THE UNDERFLOW INTERRUPTS ARE ;\n
!>       TURNED OFF.  TO DO THIS, THE FIRST CALL OF THE MAIN PROGRAM ;\n
!>       SHOULD BE ;\n
!>                 CALL TRAPS (0, 0, 10000, 0, 0)    IN WATFIV ;\n
!>       OR ;\n
!>                 CALL INIT                         IN FORTRAN G OR H. ;\n
!>        ;\n
!>    ACCURACY ;\n
!>        ;\n
!>       THE ROUTINE WAS TESTED UP TO N = 512 FOR LEGENDRE QUADRATURE, ;\n
!>       UP TO N = 136 FOR HERMITE, UP TO N = 68 FOR LAGUERRE, AND UP ;\n
!>       TO N = 10 OR 20 IN OTHER CASES.  IN ALL BUT TWO INSTANCES, ;\n
!>       COMPARISON WITH TABLES IN REF. 3 SHOWED 12 OR MORE SIGNIFICANT ;\n
!>       DIGITS OF ACCURACY.  THE TWO EXCEPTIONS WERE THE WEIGHTS FOR ;\n
!>       HERMITE AND LAGUERRE QUADRATURE, WHERE UNDERFLOW CAUSED SOME ;\n
!>       VERY SMALL WEIGHTS TO BE SET TO ZERO.  THIS IS, OF COURSE, ;\n
!>       COMPLETELY HARMLESS. ;\n
!>        ;\n
!>    METHOD ;\n
!>        ;\n
!>          THE COEFFICIENTS OF THE THREE-TERM RECURRENCE RELATION ;\n
!>       FOR THE CORRESPONDING SET OF ORTHOGONAL POLYNOMIALS ARE ;\n
!>       USED TO FORM A SYMMETRIC TRIDIAGONAL MATRIX, WHOSE ;\n
!>       EIGENVALUES (DETERMINED BY THE IMPLICIT QL-METHOD WITH ;\n
!>       SHIFTS) ARE JUST THE DESIRED NODES.  THE FIRST COMPONENTS OF ;\n
!>       THE ORTHONORMALIZED EIGENVECTORS, WHEN PROPERLY SCALED, ;\n
!>       YIELD THE WEIGHTS.  THIS TECHNIQUE IS MUCH FASTER THAN USING A ;\n
!>       ROOT-FINDER TO LOCATE THE ZEROES OF THE ORTHOGONAL POLYNOMIAL. ;\n
!>       FOR FURTHER DETAILS, SEE REF. 1.  REF. 2 CONTAINS DETAILS OF ;\n
!>       GAUSS-RADAU AND GAUSS-LOBATTO QUADRATURE ONLY. ;\n
!>        ;\n
!>    REFERENCES ;\n
!>        ;\n
!>       1.  GOLUB, G. H., AND WELSCH, J. H., "CALCULATION OF GAUSSIAN ;\n
!>           QUADRATURE RULES," MATHEMATICS OF COMPUTATION 23 (APRIL, ;\n
!>           1969), PP. 221-230. ;\n
!>       2.  GOLUB, G. H., "SOME MODIFIED MATRIX EIGENVALUE PROBLEMS," ;\n
!>           SIAM REVIEW 15 (APRIL, 1973), PP. 318-334 (SECTION 7). ;\n
!>       3.  STROUD AND SECREST, GAUSSIAN QUADRATURE FORMULAS, PRENTICE- ;\n
!>           HALL, ENGLEWOOD CLIFFS, N.J., 1966. ;\n
!>        ;\n
!>    .................................................................. ;\n
!>        ;\n
!> Doxygen comment: ;\n
C          DATA SET GAUSSQ     AT LEVEL 001 AS OF 07/23/82
C                                1/20/75
      SUBROUTINE GAUSSQ(KIND, N, ALPHA, BETA, KPTS, ENDPTS, B, T, W)
C
C           THIS SET OF ROUTINES COMPUTES THE NODES T(J) AND WEIGHTS
C        W(J) FOR GAUSSIAN-TYPE QUADRATURE RULES WITH PRE-ASSIGNED
C        NODES.  THESE ARE USED WHEN ONE WISHES TO APPROXIMATE
C
C                 INTEGRAL (FROM A TO B)  F(X) W(X) DX
C
C                              N
C        BY                   SUM W  F(T )
C                             J=1  J    J
C
C        (NOTE W(X) AND W(J) HAVE NO CONNECTION WITH EACH OTHER.)
C        HERE W(X) IS ONE OF SIX POSSIBLE NON-NEGATIVE WEIGHT
C        FUNCTIONS (LISTED BELOW), AND F(X) IS THE
C        FUNCTION TO BE INTEGRATED.  GAUSSIAN QUADRATURE IS PARTICULARLY
C        USEFUL ON INFINITE INTERVALS (WITH APPROPRIATE WEIGHT
C        FUNCTIONS), SINCE THEN OTHER TECHNIQUES OFTEN FAIL.
C
C           ASSOCIATED WITH EACH WEIGHT FUNCTION W(X) IS A SET OF
C        ORTHOGONAL POLYNOMIALS.  THE NODES T(J) ARE JUST THE ZEROES
C        OF THE PROPER N-TH DEGREE POLYNOMIAL.
C
C     INPUT PARAMETERS (ALL REAL NUMBERS ARE IN DOUBLE PRECISION)
C
C        KIND     AN INTEGER BETWEEN 1 AND 6 GIVING THE TYPE OF
C                 QUADRATURE RULE:
C
C        KIND = 1:  LEGENDRE QUADRATURE, W(X) = 1 ON (-1, 1)
C        KIND = 2:  CHEBYSHEV QUADRATURE OF THE FIRST KIND
C                   W(X) = 1/SQRT(1 - X*X) ON (-1, +1)
C        KIND = 3:  CHEBYSHEV QUADRATURE OF THE SECOND KIND
C                   W(X) = SQRT(1 - X*X) ON (-1, 1)
C        KIND = 4:  HERMITE QUADRATURE, W(X) = EXP(-X*X) ON
C                   (-INFINITY, +INFINITY)
C        KIND = 5:  JACOBI QUADRATURE, W(X) = (1-X)**ALPHA * (1+X)**
C                   BETA ON (-1, 1), ALPHA, BETA .GT. -1.
C                   NOTE: KIND=2 AND 3 ARE A SPECIAL CASE OF THIS.
C        KIND = 6:  GENERALIZED LAGUERRE QUADRATURE, W(X) = EXP(-X)*
C                   X**ALPHA ON (0, +INFINITY), ALPHA .GT. -1
C
C        N        THE NUMBER OF POINTS USED FOR THE QUADRATURE RULE
C        ALPHA    REAL PARAMETER USED ONLY FOR GAUSS-JACOBI AND GAUSS-
C                 LAGUERRE QUADRATURE (OTHERWISE USE 0.D0).
C        BETA     REAL PARAMETER USED ONLY FOR GAUSS-JACOBI QUADRATURE--
C                 (OTHERWISE USE 0.D0)
C        KPTS     (INTEGER) NORMALLY 0, UNLESS THE LEFT OR RIGHT END-
C                 POINT (OR BOTH) OF THE INTERVAL IS REQUIRED TO BE A
C                 NODE (THIS IS CALLED GAUSS-RADAU OR GAUSS-LOBATTO
C                 QUADRATURE).  THEN KPTS IS THE NUMBER OF FIXED
C                 ENDPOINTS (1 OR 2).
C        ENDPTS   REAL ARRAY OF LENGTH 2.  CONTAINS THE VALUES OF
C                 ANY FIXED ENDPOINTS, IF KPTS = 1 OR 2.
C        B        REAL SCRATCH ARRAY OF LENGTH N
C
C     OUTPUT PARAMETERS (BOTH DOUBLE PRECISION ARRAYS OF LENGTH N)
C
C        T        WILL CONTAIN THE DESIRED NODES.
C        W        WILL CONTAIN THE DESIRED WEIGHTS W(J).
C
C     SUBROUTINES REQUIRED
C
C        SOLVE, CLASS, AND IMTQL2 ARE PROVIDED.  UNDERFLOW MAY SOMETIMES
C        OCCUR, BUT IT IS HARMLESS IF THE UNDERFLOW INTERRUPTS ARE
C        TURNED OFF.  TO DO THIS, THE FIRST CALL OF THE MAIN PROGRAM
C        SHOULD BE
C                  CALL TRAPS (0, 0, 10000, 0, 0)    IN WATFIV
C        OR
C                  CALL INIT                         IN FORTRAN G OR H.
C
C     ACCURACY
C
C        THE ROUTINE WAS TESTED UP TO N = 512 FOR LEGENDRE QUADRATURE,
C        UP TO N = 136 FOR HERMITE, UP TO N = 68 FOR LAGUERRE, AND UP
C        TO N = 10 OR 20 IN OTHER CASES.  IN ALL BUT TWO INSTANCES,
C        COMPARISON WITH TABLES IN REF. 3 SHOWED 12 OR MORE SIGNIFICANT
C        DIGITS OF ACCURACY.  THE TWO EXCEPTIONS WERE THE WEIGHTS FOR
C        HERMITE AND LAGUERRE QUADRATURE, WHERE UNDERFLOW CAUSED SOME
C        VERY SMALL WEIGHTS TO BE SET TO ZERO.  THIS IS, OF COURSE,
C        COMPLETELY HARMLESS.
C
C     METHOD
C
C           THE COEFFICIENTS OF THE THREE-TERM RECURRENCE RELATION
C        FOR THE CORRESPONDING SET OF ORTHOGONAL POLYNOMIALS ARE
C        USED TO FORM A SYMMETRIC TRIDIAGONAL MATRIX, WHOSE
C        EIGENVALUES (DETERMINED BY THE IMPLICIT QL-METHOD WITH
C        SHIFTS) ARE JUST THE DESIRED NODES.  THE FIRST COMPONENTS OF
C        THE ORTHONORMALIZED EIGENVECTORS, WHEN PROPERLY SCALED,
C        YIELD THE WEIGHTS.  THIS TECHNIQUE IS MUCH FASTER THAN USING A
C        ROOT-FINDER TO LOCATE THE ZEROES OF THE ORTHOGONAL POLYNOMIAL.
C        FOR FURTHER DETAILS, SEE REF. 1.  REF. 2 CONTAINS DETAILS OF
C        GAUSS-RADAU AND GAUSS-LOBATTO QUADRATURE ONLY.
C
C     REFERENCES
C
C        1.  GOLUB, G. H., AND WELSCH, J. H., "CALCULATION OF GAUSSIAN
C            QUADRATURE RULES," MATHEMATICS OF COMPUTATION 23 (APRIL,
C            1969), PP. 221-230.
C        2.  GOLUB, G. H., "SOME MODIFIED MATRIX EIGENVALUE PROBLEMS,"
C            SIAM REVIEW 15 (APRIL, 1973), PP. 318-334 (SECTION 7).
C        3.  STROUD AND SECREST, GAUSSIAN QUADRATURE FORMULAS, PRENTICE-
C            HALL, ENGLEWOOD CLIFFS, N.J., 1966.
C
C     ..................................................................
C
      DOUBLE PRECISION B(N), T(N), W(N), ENDPTS(2), MUZERO, T1,
     X GAM, SOLVE, DSQRT, ALPHA, BETA
C
      CALL CLASS (KIND, N, ALPHA, BETA, B, T, MUZERO)
C
C           THE MATRIX OF COEFFICIENTS IS ASSUMED TO BE SYMMETRIC.
C           THE ARRAY T CONTAINS THE DIAGONAL ELEMENTS, THE ARRAY
C           B THE OFF-DIAGONAL ELEMENTS.
C           MAKE APPROPRIATE CHANGES IN THE LOWER RIGHT 2 BY 2
C           SUBMATRIX.
C
      IF (KPTS.EQ.0)  GO TO 100
      IF (KPTS.EQ.2)  GO TO  50
C
C           IF KPTS=1, ONLY T(N) MUST BE CHANGED
C
      T(N) = SOLVE(ENDPTS(1), N, T, B)*B(N-1)**2 + ENDPTS(1)
      GO TO 100
C
C           IF KPTS=2, T(N) AND B(N-1) MUST BE RECOMPUTED
C
   50 GAM = SOLVE(ENDPTS(1), N, T, B)
      T1 = ((ENDPTS(1) - ENDPTS(2))/(SOLVE(ENDPTS(2), N, T, B) - GAM))
      B(N-1) = DSQRT(T1)
      T(N) = ENDPTS(1) + GAM*T1
C
C           NOTE THAT THE INDICES OF THE ELEMENTS OF B RUN FROM 1 TO N-1
C           AND THUS THE VALUE OF B(N) IS ARBITRARY.
C           NOW COMPUTE THE EIGENVALUES OF THE SYMMETRIC TRIDIAGONAL
C           MATRIX, WHICH HAS BEEN MODIFIED AS NECESSARY.
C           THE METHOD USED IS A QL-TYPE METHOD WITH ORIGIN SHIFTING
C
  100 W(1) = 1.0D0
      DO 105 I = 2, N
  105    W(I) = 0.0D0
C
      CALL IMTQL2 (N, T, B, W, IERR)
      DO 110 I = 1, N
  110    W(I) = MUZERO * W(I) * W(I)
C
      RETURN
      END
C
C
C
      DOUBLE PRECISION FUNCTION SOLVE(SHIFT, N, A, B)
C
C       THIS PROCEDURE PERFORMS ELIMINATION TO SOLVE FOR THE
C       N-TH COMPONENT OF THE SOLUTION DELTA TO THE EQUATION
C
C             (JN - SHIFT*IDENTITY) * DELTA  = EN,
C
C       WHERE EN IS THE VECTOR OF ALL ZEROES EXCEPT FOR 1 IN
C       THE N-TH POSITION.
C
C       THE MATRIX JN IS SYMMETRIC TRIDIAGONAL, WITH DIAGONAL
C       ELEMENTS A(I), OFF-DIAGONAL ELEMENTS B(I).  THIS EQUATION
C       MUST BE SOLVED TO OBTAIN THE APPROPRIATE CHANGES IN THE LOWER
C       2 BY 2 SUBMATRIX OF COEFFICIENTS FOR ORTHOGONAL POLYNOMIALS.
C
C
      DOUBLE PRECISION SHIFT, A(N), B(N), ALPHA
C
      ALPHA = A(1) - SHIFT
      NM1 = N - 1
      DO 10 I = 2, NM1
   10    ALPHA = A(I) - SHIFT - B(I-1)**2/ALPHA
      SOLVE = 1.0D0/ALPHA
      RETURN
      END
C
C
C
      SUBROUTINE CLASS(KIND, N, ALPHA, BETA, B, A, MUZERO)
C
C           THIS PROCEDURE SUPPLIES THE COEFFICIENTS A(J), B(J) OF THE
C        RECURRENCE RELATION
C
C             B P (X) = (X - A ) P   (X) - B   P   (X)
C              J J            J   J-1       J-1 J-2
C
C        FOR THE VARIOUS CLASSICAL (NORMALIZED) ORTHOGONAL POLYNOMIALS,
C        AND THE ZERO-TH MOMENT
C
C             MUZERO = INTEGRAL W(X) DX
C
C        OF THE GIVEN POLYNOMIAL'S WEIGHT FUNCTION W(X).  SINCE THE
C        POLYNOMIALS ARE ORTHONORMALIZED, THE TRIDIAGONAL MATRIX IS
C        GUARANTEED TO BE SYMMETRIC.
C
C           THE INPUT PARAMETER ALPHA IS USED ONLY FOR LAGUERRE AND
C        JACOBI POLYNOMIALS, AND THE PARAMETER BETA IS USED ONLY FOR
C        JACOBI POLYNOMIALS.  THE LAGUERRE AND JACOBI POLYNOMIALS
C        REQUIRE THE GAMMA FUNCTION.
C
C     ..................................................................
C
      DOUBLE PRECISION A(N), B(N), MUZERO, ALPHA, BETA
      DOUBLE PRECISION ABI, A2B2, DGAMMA, PI, DSQRT, AB
      DATA PI / 3.141592653589793D0/
C
      NM1 = N - 1
      GO TO (10, 20, 30, 40, 50, 60), KIND
C
C              KIND = 1:  LEGENDRE POLYNOMIALS P(X)
C              ON (-1, +1), W(X) = 1.
C
   10 MUZERO = 2.0D0
      DO 11 I = 1, NM1
         A(I) = 0.0D0
         ABI = I
   11    B(I) = ABI/DSQRT(4*ABI*ABI - 1.0D0)
      A(N) = 0.0D0
      RETURN
C
C              KIND = 2:  CHEBYSHEV POLYNOMIALS OF THE FIRST KIND T(X)
C              ON (-1, +1), W(X) = 1 / SQRT(1 - X*X)
C
   20 MUZERO = PI
      DO 21 I = 1, NM1
         A(I) = 0.0D0
   21    B(I) = 0.5D0
      B(1) = DSQRT(0.5D0)
      A(N) = 0.0D0
      RETURN
C
C              KIND = 3:  CHEBYSHEV POLYNOMIALS OF THE SECOND KIND U(X)
C              ON (-1, +1), W(X) = SQRT(1 - X*X)
C
   30 MUZERO = PI/2.0D0
      DO 31 I = 1, NM1
         A(I) = 0.0D0
   31    B(I) = 0.5D0
      A(N) = 0.0D0
      RETURN
C
C              KIND = 4:  HERMITE POLYNOMIALS H(X) ON (-INFINITY,
C              +INFINITY), W(X) = EXP(-X**2)
C
   40 MUZERO = DSQRT(PI)
      DO 41 I = 1, NM1
         A(I) = 0.0D0
   41    B(I) = DSQRT(I/2.0D0)
      A(N) = 0.0D0
      RETURN
C
C              KIND = 5:  JACOBI POLYNOMIALS P(ALPHA, BETA)(X) ON
C              (-1, +1), W(X) = (1-X)**ALPHA + (1+X)**BETA, ALPHA AND
C              BETA GREATER THAN -1
C
   50 AB = ALPHA + BETA
      ABI = 2.0D0 + AB
      MUZERO = 2.0D0 ** (AB + 1.0D0) * DGAMMA(ALPHA + 1.0D0) * DGAMMA(
     X BETA + 1.0D0) / DGAMMA(ABI)
      A(1) = (BETA - ALPHA)/ABI
      B(1) = DSQRT(4.0D0*(1.0D0 + ALPHA)*(1.0D0 + BETA)/((ABI + 1.0D0)*
     1  ABI*ABI))
      A2B2 = BETA*BETA - ALPHA*ALPHA
      DO 51 I = 2, NM1
         ABI = 2.0D0*I + AB
         A(I) = A2B2/((ABI - 2.0D0)*ABI)
   51    B(I) = DSQRT (4.0D0*I*(I + ALPHA)*(I + BETA)*(I + AB)/
     1   ((ABI*ABI - 1)*ABI*ABI))
      ABI = 2.0D0*N + AB
      A(N) = A2B2/((ABI - 2.0D0)*ABI)
      RETURN
C
C              KIND = 6:  LAGUERRE POLYNOMIALS L(ALPHA)(X) ON
C              (0, +INFINITY), W(X) = EXP(-X) * X**ALPHA, ALPHA GREATER
C              THAN -1.
C
   60 MUZERO = DGAMMA(ALPHA + 1.0D0)
      DO 61 I = 1, NM1
         A(I) = 2.0D0*I - 1.0D0 + ALPHA
   61    B(I) = DSQRT(I*(I + ALPHA))
      A(N) = 2.0D0*N - 1 + ALPHA
      RETURN
      END
C
C
C
C
C
        FUNCTION DGAMMA(X)
        IMPLICIT REAL *8 (A-H,O-Z)
        DGAMMA=1
        RETURN
        END
C
C
      SUBROUTINE IMTQL2(N, D, E, Z, IERR)
C
C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE IMTQL2,
C     NUM. MATH. 12, 377-383(1968) BY MARTIN AND WILKINSON,
C     AS MODIFIED IN NUM. MATH. 15, 450(1970) BY DUBRULLE.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 241-248(1971).
C     THIS IS A MODIFIED VERSION OF THE 'EISPACK' ROUTINE IMTQL2.
C
C     THIS SUBROUTINE FINDS THE EIGENVALUES AND FIRST COMPONENTS OF THE
C     EIGENVECTORS OF A SYMMETRIC TRIDIAGONAL MATRIX BY THE IMPLICIT QL
C     METHOD.
C
C     ON INPUT:
C
C        N IS THE ORDER OF THE MATRIX;
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX;
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
C          IN ITS FIRST N-1 POSITIONS.  E(N) IS ARBITRARY;
C
C        Z CONTAINS THE FIRST ROW OF THE IDENTITY MATRIX.
C
C      ON OUTPUT:
C
C        D CONTAINS THE EIGENVALUES IN ASCENDING ORDER.  IF AN
C          ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT BUT
C          UNORDERED FOR INDICES 1, 2, ..., IERR-1;
C
C        E HAS BEEN DESTROYED;
C
C        Z CONTAINS THE FIRST COMPONENTS OF THE ORTHONORMAL EIGENVECTORS
C          OF THE SYMMETRIC TRIDIAGONAL MATRIX.  IF AN ERROR EXIT IS
C          MADE, Z CONTAINS THE EIGENVECTORS ASSOCIATED WITH THE STORED
C          EIGENVALUES;
C
C        IERR IS SET TO
C          ZERO       FOR NORMAL RETURN,
C          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
C                     DETERMINED AFTER 30 ITERATIONS.
C
C     ------------------------------------------------------------------
C
      INTEGER I, J, K, L, M, N, II, MML, IERR
      REAL*8 D(N), E(N), Z(N), B, C, F, G, P, R, S, MACHEP
      REAL*8 DSQRT, DABS, DSIGN
C
C     :::::::::: MACHEP IS A MACHINE DEPENDENT PARAMETER SPECIFYING
C                THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC.
C                MACHEP = 16.0D0**(-13) FOR LONG FORM ARITHMETIC
C                ON S360 ::::::::::
CCCC  DATA MACHEP/Z3410000000000000/
      DATA MACHEP/1.0D-14/
C
      IERR = 0
      IF (N .EQ. 1) GO TO 1001
C
      E(N) = 0.0D0
      DO 240 L = 1, N
         J = 0
C     :::::::::: LOOK FOR SMALL SUB-DIAGONAL ELEMENT ::::::::::
  105    DO 110 M = L, N
            IF (M .EQ. N) GO TO 120
            IF (DABS(E(M)) .LE. MACHEP * (DABS(D(M)) + DABS(D(M+1))))
     X         GO TO 120
  110    CONTINUE
C
  120    P = D(L)
         IF (M .EQ. L) GO TO 240
         IF (J .EQ. 30) GO TO 1000
         J = J + 1
C     :::::::::: FORM SHIFT ::::::::::
         G = (D(L+1) - P) / (2.0D0 * E(L))
         R = DSQRT(G*G+1.0D0)
         G = D(M) - P + E(L) / (G + DSIGN(R, G))
         S = 1.0D0
         C = 1.0D0
         P = 0.0D0
         MML = M - L
C
C     :::::::::: FOR I=M-1 STEP -1 UNTIL L DO -- ::::::::::
         DO 200 II = 1, MML
            I = M - II
            F = S * E(I)
            B = C * E(I)
            IF (DABS(F) .LT. DABS(G)) GO TO 150
            C = G / F
            R = DSQRT(C*C+1.0D0)
            E(I+1) = F * R
            S = 1.0D0 / R
            C = C * S
            GO TO 160
  150       S = F / G
            R = DSQRT(S*S+1.0D0)
            E(I+1) = G * R
            C = 1.0D0 / R
            S = S * C
  160       G = D(I+1) - P
            R = (D(I) - G) * S + 2.0D0 * C * B
            P = S * R
            D(I+1) = G + P
            G = C * R - B
C     :::::::::: FORM FIRST COMPONENT OF VECTOR ::::::::::
            F = Z(I+1)
            Z(I+1) = S * Z(I) + C * F
  200       Z(I) = C * Z(I) - S * F
C
         D(L) = D(L) - P
         E(L) = G
         E(M) = 0.0D0
         GO TO 105
  240 CONTINUE
C
C     :::::::::: ORDER EIGENVALUES AND EIGENVECTORS ::::::::::
      DO 300 II = 2, N
         I = II - 1
         K = I
         P = D(I)
C
         DO 260 J = II, N
            IF (D(J) .GE. P) GO TO 260
            K = J
            P = D(J)
  260    CONTINUE
C
         IF (K .EQ. I) GO TO 300
         D(K) = D(I)
         D(I) = P
         P = Z(I)
         Z(I) = Z(K)
         Z(K) = P
  300 CONTINUE
C
      GO TO 1001
C     :::::::::: SET ERROR -- NO CONVERGENCE TO AN
C                EIGENVALUE AFTER 30 ITERATIONS ::::::::::
 1000 IERR = L
 1001 RETURN
      END
C     :::::::::: LAST CARD OF IMTQL2 ::::::::::
!> Doxygen comment: ;\n
!> set up ctf in terms of k_p coordinates (i.e., fourier tranform polar grid). ;\n
      subroutine get_ctf_k_p_(ngridr,CTF_k_p_,param_0,param_1,param_2
     $     ,param_3,param_4)
      implicit none
      integer verbose
      data verbose / 0 /
      integer ngridr
      complex *16 CTF_k_p_(0:0)
      real *8 param_0,param_1,param_2,param_3,param_4
c$$$      cryoem parameters
      integer ityper
      real *8 rmax
      real *8, allocatable :: xnodesr(:)
      real *8, allocatable :: wtsr(:)
      integer *4 ntemplatesize,ncur
      integer *4, allocatable :: nlats_(:)
      integer *4, allocatable :: ngridc_(:)
      integer *4, allocatable :: icstart_(:)
c$$$      indices
      integer *4 n_r,nr,n_w_max,n_A,na
      integer *4, allocatable :: n_w_(:)
c$$$      grids 
      integer *4 n_gridpoints,ng
      real *8 pi
      real *8 max_x_c,max_k_c,dtmp
      real *8, allocatable :: grid_x_c_(:)
      real *8, allocatable :: grid_k_c_(:)
      real *8, allocatable :: grid_k_p_(:)
c$$$      Template S
      complex *16, allocatable :: S_x_c_(:)
      complex *16, allocatable :: S_k_c_(:)
      complex *16, allocatable :: S_k_p_(:)
c$$$      innerproducts
      complex *16 C_S_x_c,C_S_k_c,C_S_k_p
      external get_ctf_x_c

      if (verbose.gt.0) then
         write(6,'(A,I0)') '[entering get_ctf_k_p_], ngridr: ',ngridr
      end if

c$$$         We define xnodesr via 'getgridr'
      rmax = 1.0d0*ngridr
      ityper = 0
      allocate(xnodesr(ngridr))
      allocate(wtsr(ngridr))
      call getgridr(rmax,ngridr,ityper,xnodesr,wtsr)

c$$$      Calculating template size using 'get_template_size'
      pi = 4*atan(1.0)
      ncur = ngridr
      allocate(nlats_(0:ncur-1));
      do ng=0,ncur-1
         nlats_(ng) = nint(pi*xnodesr(1+ng))
         if (mod(nlats_(ng),2).ne.0) nlats_(ng) = nlats_(ng)+1
         if (nlats_(ng).lt.6) nlats_(ng) = 6
      enddo
      allocate(ngridc_(ncur))
      allocate(icstart_(ncur))
      call get_template_size(nlats_,ncur,ntemplatesize,ngridc_,icstart_)
      if (verbose.gt.0) then
         write(6,'(A,I0)') 'ntemplatesize = ',ntemplatesize
      end if
      n_gridpoints = ncur
      if (n_gridpoints.lt.2) then
         write(6,'(A,I0,A)') 'Error n_gridpoints',n_gridpoints,'<2'
      end if

c$$$      indices
      n_r = ncur
      if (n_r.lt.2) then
         write(6,'(A,I0,A)') 'Error n_r',n_r,'<2'
      end if
      allocate(n_w_(0:n_r-1))
      n_A = 0
      do nr=0,n_r-1
         n_w_(nr) = ngridc_(1+nr)
         n_A = n_A + n_w_(nr)
      enddo
      n_w_max = n_w_(nr-1)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0)') 'n_w_max ',n_w_max,'; n_A ',n_A
      end if

c$$$      Calculating x-space template on regular cartesian-grid
      max_x_c = 1.0d0
      allocate(grid_x_c_(0:n_gridpoints-1))
      call linspace(0.0d0,max_x_c,n_gridpoints,grid_x_c_)
      allocate(S_x_c_(0:n_gridpoints*n_gridpoints-1))
      call get_ctf_x_c_(n_gridpoints,grid_x_c_,max_x_c,n_gridpoints
     $     ,grid_x_c_,max_x_c,S_x_c_,get_ctf_x_c,param_0,param_1,param_2
     $     ,param_3,param_4)
      call innerproduct_c(n_gridpoints,grid_x_c_,n_gridpoints ,grid_x_c_
     $     ,S_x_c_,S_x_c_,C_S_x_c)
      C_S_x_c = zsqrt(C_S_x_c)
      if (verbose.gt.0) write(6,'(A,2F16.3)') ' C_S_x_c: ',C_S_x_c
      
c$$$      Calculating k-space template on regular cartesian-grid      
      max_k_c = (1.0d0*n_gridpoints)/max_x_c
      allocate(grid_k_c_(0:n_gridpoints-1))
      call linspace(0.0d0,max_k_c,n_gridpoints,grid_k_c_)
      allocate(S_k_c_(0:n_gridpoints*n_gridpoints-1))
      call adi_fft2(-1,n_gridpoints,n_gridpoints,S_x_c_,S_k_c_)
      call innerproduct_c(n_gridpoints,grid_k_c_,n_gridpoints ,grid_k_c_
     $     ,S_k_c_,S_k_c_,C_S_k_c)
      C_S_k_c = zsqrt(C_S_k_c)/(n_gridpoints*n_gridpoints)
      if (verbose.gt.0) write(6,'(A,2F16.3)') ' C_S_k_c: ',C_S_k_c

c$$$      Calculating k-space template on quasi-uniform polar-grid
      allocate(S_k_p_(0:ntemplatesize-1))
      allocate(grid_k_p_(0:n_gridpoints-1))
c$$$      instead of:
c$$$      call linspace(0.0d0,max_k_c/2.0,n_gridpoints,grid_k_p_)
c$$$      we use:
      dtmp = max_k_c/2.0/n_gridpoints
      call linspace(dtmp,max_k_c/2.0+dtmp,n_gridpoints,grid_k_p_)
      call interp_c_to_p(n_gridpoints,max_k_c,n_gridpoints,max_k_c
     $     ,S_k_c_,n_gridpoints,grid_k_p_,ngridc_,ntemplatesize,S_k_p_)
      call innerproduct_p(n_gridpoints,grid_k_p_,ngridc_ ,ntemplatesize
     $     ,S_k_p_,S_k_p_,C_S_k_p)
      C_S_k_p = zsqrt(C_S_k_p)/(n_gridpoints*n_gridpoints)      
      if (verbose.gt.0) write(6,'(A,2F16.3)') ' C_S_k_p: ',C_S_k_p

      if (verbose.gt.0) write(6,'(A)') 'copying'
      call cp1_c16(ntemplatesize,S_k_p_,CTF_k_p_)

      if (verbose.gt.0) write(6,'(A)') 'deallocating'
      deallocate(xnodesr)
      deallocate(wtsr)
      deallocate(nlats_)
      deallocate(ngridc_)
      deallocate(icstart_)
      deallocate(n_w_)
      deallocate(grid_x_c_)
      deallocate(S_x_c_)
      deallocate(grid_k_c_)
      deallocate(S_k_c_)
      deallocate(S_k_p_)
      deallocate(grid_k_p_)

      if (verbose.gt.0) then
         write(6,'(A,I0)') '[finished get_ctf_k_p_], ngridr: ',ngridr
      end if

      end
!> Doxygen comment: ;\n
!> set up ctf in terms of x_c coordinates (i.e., real-space cartesian grid). ;\n
      subroutine get_ctf_x_c_(n_x,grid_x_c_,max_x_c,n_y,grid_y_c_
     $     ,max_y_c,S_x_c_,get_ctf_x_c,param_0,param_1,param_2,param_3
     $     ,param_4)
      implicit none
      integer n_x,n_y
      real *8 grid_x_c_(0:n_x-1),grid_y_c_(0:n_y-1)
      real *8 max_x_c,max_y_c
      real *8 param_0,param_1,param_2,param_3,param_4
      complex *16 S_x_c_(0:n_x*n_y-1)
      integer ny,nx
      real *8 X_x_c,Y_x_c
      complex *16 C_x_c
      external get_ctf_x_c
      do ny=0,n_y-1
         if (ny.lt.n_y/2) then
            Y_x_c = grid_y_c_(ny)
         else
            Y_x_c = grid_y_c_(ny) - max_y_c
         end if
c$$$         Y_x_c = grid_y_c_(ny)
         do nx=0,n_x-1
            if (nx.lt.n_x/2) then
               X_x_c = grid_x_c_(nx)
            else
               X_x_c = grid_x_c_(nx) - max_x_c
            end if
c$$$            X_x_c = grid_x_c_(nx)
            call get_ctf_x_c(max_x_c,X_x_c,Y_x_c,C_x_c,param_0,param_1
     $           ,param_2,param_3,param_4)
            S_x_c_(nx+ny*n_x) = C_x_c
         enddo
      enddo
      end
!> Doxygen comment: ;\n
!> sets up a particular class of (very anisotropic) ctf functions. ;\n
      subroutine get_ctf_x_c(max_x_c,X_x_c,Y_x_c,C_x_c,param_0,param_1
     $     ,param_2,param_3,param_4)
c$$$      Inputs:
c$$$      real *8 max_x_c not used
c$$$      real *8 X_x_c x-value (x-space cartesian-grid)
c$$$      real *8 Y_x_c y-value (x-space cartesian-grid)
c$$$      real *8 param_0 sigma_E, e.g., 0.25
c$$$      real *8 param_1 omega_E, e.g., pi/4
c$$$      real *8 param_2 eccentricity, e.g., 10
c$$$      real *8 param_3 tau_G, e.g., 10
c$$$      real *8 param_4 omega_G, e.g., 5
c$$$      Outputs:
c$$$      complex *16 C_x_c value of ctf on x-space cartesian-grid
c$$$
c$$$      See following matlab code for ctf-function:
c$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$N = 128;
c$$$[X,Y] = meshgrid(linspace(-1,1,N));
c$$$R = sqrt(X.^2+Y.^2);W = atan2(Y,X);
c$$$sigma_E = 1/4; eccentricity = 10;
c$$$omega_E = pi/4; cw = cos(omega_E); sw = sin(omega_E); 
c$$$rw = [cw +sw ; -sw cw] ; rm = [cw -sw ; +sw cw]; 
c$$$dw = (1/sigma_E).*[ 1 0 ; 0 sqrt(eccentricity/1) ]; 
c$$$dm = (sigma_E/1).*[ 1 0 ; 0 sqrt(1/eccentricity) ]; 
c$$$C = dw * rm ;
c$$$Xt = C(1).*X + C(3).*Y; Yt = C(2).*X + C(4).*Y; 
c$$$E1 = Xt.*Xt + Yt.*Yt;
c$$$C = rw * dw * dw * rm;
c$$$E2 = X.*C(1).*X + X.*C(3).*Y + Y.*C(2).*X + Y.*C(4).*Y; 
c$$$disp(sprintf(' %% norm E1-E2 %f',norm(E1-E2)));
c$$$tau_G = 10;
c$$$Rt = sqrt(Xt.^2 + Yt.^2)/tau_G;
c$$$omega_G = 5;
c$$$G1 = exp(-Rt).*sin(min(pi,2*pi*omega_G*Rt.^2));
c$$$F = exp(-E1).*G1;
c$$$%F = exp(-E1);
c$$$K = recenter2(fft2(recenter2(F)));
c$$$subplot(2,2,1); imagesc(F); axis square; colorbar; 
c$$$subplot(2,2,2); imagesc(real(K)); axis square; colorbar;
c$$$subplot(2,2,3); imagesc(imag(K)); axis square; colorbar;
c$$$subplot(2,2,4); imagesc(abs(K)); axis square; colorbar;
c$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$      real *8 param_0 sigma_E
c$$$      real *8 param_1 omega_E
c$$$      real *8 param_2 eccentricity
c$$$      real *8 param_3 tau_G
c$$$      real *8 param_4 omega_G
      implicit none
      integer verbose
      data verbose / 0 /
      real *8 max_x_c,X_x_c,Y_x_c
      real *8 param_0,param_1,param_2,param_3,param_4
      complex *16 C_x_c
      real *8 pi,R_x_c,W_x_c
      real *8 omega_E,sigma_E,cw,sw,omega_G,tau_G,eccentricity
      real *8 rw00,rw10,rw01,rw11
      real *8 rm00,rm10,rm01,rm11
      real *8 dw00,dw10,dw01,dw11
      real *8 dm00,dm10,dm01,dm11
      real *8 cc00,cc10,cc01,cc11
      real *8 xt,yt,et,rt,gt
      if (verbose.gt.0) then
         write(6,'(A,F8.5)') 'param_0: ',param_0
         write(6,'(A,F8.5)') 'param_1: ',param_1
         write(6,'(A,F8.5)') 'param_2: ',param_2
         write(6,'(A,F8.5)') 'param_3: ',param_3
         write(6,'(A,F8.5)') 'param_4: ',param_4
      end if
      pi = 4*atan(1.0)
      R_x_c = dsqrt(X_x_c**2 + Y_x_c**2)
      W_x_c = atan2(Y_x_c,X_x_c)
      omega_E = param_0
      sigma_E = param_1
      eccentricity = param_2
      tau_G = param_3
      omega_G = param_4
      cw = cos(omega_E)
      sw = sin(omega_E)
      rw00 = cw
      rw01 = +sw
      rw10 = -sw
      rw11 = cw
      rm00 = cw
      rm01 = -sw
      rm10 = +sw
      rm11 = cw
      dw00 = 1 / (sigma_E)
      dw01 = 0 / (sigma_E)
      dw10 = 0 / (sigma_E)
      dw11 = dsqrt(eccentricity) / (sigma_E)
      dm00 = 1 * (sigma_E)
      dm01 = 0 * (sigma_E)
      dm10 = 0 * (sigma_E)
      dm11 = (sigma_E) / dsqrt(eccentricity)
      cc00 = dw00*rm00 + dw01*rm10
      cc01 = dw00*rm01 + dw01*rm11
      cc10 = dw10*rm00 + dw11*rm10
      cc11 = dw10*rm01 + dw11*rm11
      xt = cc00*X_x_c + cc01*Y_x_c
      yt = cc10*X_x_c + cc11*Y_x_c
      et = xt*xt + yt*yt
      rt = sqrt(xt**2 + yt**2)/tau_G
      gt = exp(-rt)*sin(min(pi,2*pi*omega_G*rt**2))
      C_x_c = cmplx(exp(-et)*gt,0.0)
      if (verbose.gt.0) then
         write(6,*) 'dm ',dm00,dm01,dm10,dm11
         write(6,*) 'dw ',dw00,dw01,dw10,dw11
         write(6,*) 'rm ',rm00,rm01,rm10,rm11
         write(6,*) 'rw ',rw00,rw01,rw10,rw11
         write(6,*) 'cc ',cc00,cc01,cc10,cc11
         write(6,*) 'X_x_c: ',X_x_c,'Y_x_c: ',Y_x_c
         write(6,*) 'xt: ',xt, 'yt: ',yt
         write(6,*) 'C_x_c: ',C_x_c
      end if
      end
!> Doxygen comment: ;\n
!> set up right-hand-side for least-squares problem ;\n
      subroutine get_lsqdata_2(n_M,I_M_sample_,ld_M,M_k_p__,n_CTF
     $     ,ld_CTF,CTF_k_p_,k_p,fftw_plan_frwd,fftw_plan_back,n_w_csum
     $     ,n_w,fftw_in1_ ,fftw_out_,alpha2d__ ,M_k_c_
     $     ,polar_a_,azimu_b_ ,weight_CTF_k_c_,n_w_M)
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_M,I_M_sample_(0:n_M-1),ld_M,n_CTF,ld_CTF,n_w_csum,n_w
     $     ,n_w_M
      integer *8 fftw_plan_frwd
      integer *8 fftw_plan_back
      complex *16 fftw_in1_(0:n_w-1),fftw_out_(0:n_w-1)
      include 'nalpha_define.f'
      complex *16 M_k_p__(0:0)
      complex *16 CTF_k_p_(0:ld_CTF*n_CTF-1)
      real *8 k_p
      real *8 alpha2d__(0:n_alpha-1,0:n_M-1)
      complex *16 M_k_c_(0:n_w*n_M-1)
      real *8 polar_a_(0:n_w*n_M-1)
      real *8 azimu_b_(0:n_w*n_M-1)
      complex *16 weight_CTF_k_c_(0:n_w*n_M-1)
      real *8 pi,cos_polar_a,azimu_b
      real *8 k1_c,k2_c,k3_c,k_p_1
      real *8 delta_x,delta_y,gamma_z,l2_norm
      real *8, allocatable :: k1_c_(:)
      real *8, allocatable :: k2_c_(:)
      real *8, allocatable :: k3_c_(:)
      complex *16, allocatable ::  M_k_p_1_(:)
      complex *16, allocatable ::  CTF_k_p_1_(:)
      integer nM,nw,nctf
      if (verbose.gt.0) write(6,*)
     $     '[entering get_lsqdata_2]'
c
      allocate(k1_c_(0:n_w-1))
      allocate(k2_c_(0:n_w-1))
      allocate(k3_c_(0:n_w-1))
      allocate(M_k_p_1_(0:n_w-1))
      allocate(CTF_k_p_1_(0:n_w-1))
c
      pi=4.0d0*datan(1.0d0)
      n_w_M = 0
      do nM = 0,n_M-1
         nctf = nint(alpha2d__(nalpha_ctf_ind,nM))
         nctf = max(0,min(n_CTF-1,nctf))
         cos_polar_a = dcos(alpha2d__(nalpha_polar_a,nM))
         azimu_b = alpha2d__(nalpha_azimu_b,nM)
         gamma_z = 0.0d0
         k_p_1 = 1.0d0
         call mkonegreatcircle(k_p_1,cos_polar_a,azimu_b,gamma_z,
     1        n_w,k1_c_,k2_c_,k3_c_)
c
         if (n_alpha.ge.1+nalpha_l2_norm) then
            l2_norm = alpha2d__(nalpha_l2_norm,nM)
         else
            l2_norm = 1.0d0
         end if
            
         if (dabs(l2_norm).lt.1.0d-15) then
            l2_norm=1.0d0
         end if
         do nw = 0,n_w-1
            M_k_p_1_(nw) = M_k_p__(n_w_csum-1+nw + I_M_sample_(nM)*ld_M)
     $           /l2_norm
            CTF_k_p_1_(nw) = CTF_k_p_(n_w_csum-1+nw + nctf*ld_CTF)
         enddo !do nw = 0,n_w-1
c
         gamma_z = -alpha2d__(nalpha_gamma_z,nM)
c$$$         call rotate_p_to_p_single(n_w,M_k_p_1_,+gamma_z,M_k_p_1_)
         call rotate_p2p_fx_single(fftw_plan_frwd,fftw_plan_back,n_w
     $        ,fftw_in1_,fftw_out_,M_k_p_1_,+gamma_z
     $        ,M_k_p_1_)
c$$$         call rotate_p_to_p_single(n_w,CTF_k_p_1_,+gamma_z,CTF_k_p_1_)
         call rotate_p2p_fx_single(fftw_plan_frwd,fftw_plan_back,n_w
     $        ,fftw_in1_,fftw_out_,CTF_k_p_1_,+gamma_z
     $        ,CTF_k_p_1_)
         delta_x = -alpha2d__(nalpha_delta_x,nM)
         delta_y = -alpha2d__(nalpha_delta_y,nM)
         call transf_p_to_p_single(k_p,n_w,M_k_p_1_,+delta_x,+delta_y
     $        ,M_k_p_1_)
c
         do nw = 0,n_w-1
            k1_c = k1_c_(nw)
            k2_c = k2_c_(nw)
            k3_c = k3_c_(nw)
            cos_polar_a = k3_c
            azimu_b = datan2(k2_c,k1_c)
            if (azimu_b.lt.0.0d0) azimu_b = azimu_b + 2*pi
            azimu_b_(n_w_M) = azimu_b
            polar_a_(n_w_M) = datan2(dsqrt(k1_c**2+ k2_c**2)
     $           ,cos_polar_a)
            M_k_c_(n_w_M) = M_k_p_1_(nw)
            weight_CTF_k_c_(n_w_M) = CTF_k_p_1_(nw)
            n_w_M = n_w_M+1;
         enddo !do nw = 0,n_w-1
      enddo !do nM = 0,n_M-1
      
      if (n_w_M.ne.(n_w*n_M)) then
         write(6,'(A,I0,A,I0)') 'Warning: n_w_M ',n_w_M,' n_w*n_M ', n_w
     $        *n_M
      end if !if (n_w_M.ne.(n_w*n_M)) then
      
      if (verbose.gt.0) write(6,*)
     $     '[finished get_lsqdata_2]'
      return
      end
!> Doxygen comment: ;\n
!>      ;\n
!>     Compute norm of model in k-space in L2 using spherical  ;\n
!>     harmonic basis on successive spheres. ;\n
!>      ;\n
!>     INPUT:  ;\n
!>      ;\n
!>     model_sph()  the model in Fourier space, discretized as a  ;\n
!>                  spherical harmonic expansion on successive spheres ;\n
!>                  There are ngridr spheres, of which 1,...,ncur ;\n
!>                  will be used. This is stored in packed (1D) format ;\n
!>     lmod         length of modhat_sph ;\n
!>     sph_start()  array of length ngridr indicating where in the modhat_sph ;\n
!>                  vector the coefficients for the corresponding  ;\n
!>                  sphere begin ;\n
!>     nterms_sph() array of length ngridr defining the orders of the  ;\n
!>                  spherical harmonic expansions on successive spheres.      ;\n
!>     ncur         number of points in radial direction ;\n
!>      ;\n
!>     OUTPUT: ;\n
!>      ;\n
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine kspace_model_norm(model_sph,lmod,
     1     nterms_sph,wtsr,ncur,rmodelnorm)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     Compute norm of model in k-space in L2 using spherical 
c     harmonic basis on successive spheres.
c
c     INPUT: 
c
c     model_sph()  the model in Fourier space, discretized as a 
c                  spherical harmonic expansion on successive spheres
c                  There are ngridr spheres, of which 1,...,ncur
c                  will be used. This is stored in packed (1D) format
c     lmod         length of modhat_sph
c     sph_start()  array of length ngridr indicating where in the modhat_sph
c                  vector the coefficients for the corresponding 
c                  sphere begin
c     nterms_sph() array of length ngridr defining the orders of the 
c                  spherical harmonic expansions on successive spheres.
c     ncur         number of points in radial direction
c
c     OUTPUT:
c
      implicit none
      integer lmod,ncur
      integer nterms_sph(ncur)
      integer i,j,nsphstart,nsph
      real *8 wtsr(ncur)
      real *8 rmodelnorm,rmod,pi
      complex *16 model_sph(0:lmod-1)
c      
      pi = 4.0d0*datan(1.0d0)
      nsphstart = 0
      rmodelnorm = 0
      do i = 1,ncur
         nsph = (nterms_sph(i)+1)**2
         rmod = 0.0d0
         do j = nsphstart,nsphstart+nsph-1
            rmod = rmod + 4*pi*abs(model_sph(j))**2
         enddo
         rmod = rmod*wtsr(i)
         rmodelnorm = rmodelnorm + rmod
         nsphstart = nsphstart + nsph
      enddo
      rmodelnorm = dsqrt(rmodelnorm)/(dsqrt(2*pi)**3)
c
      return
      end

!> Doxygen comment: ;\n
!>  A version of lsqsolvespharm which solves a least squares problem ;\n
!>  including a complex-valued factor (eg CTF) on each data point ;\n
!>    ;\n
!>  The measured data f takes the form of  ;\n
!>  f = A alpha = D T S alpha, where S is spherical harmonic transform, ;\n
!>                             T is interpolation ;\n
!>                             and D is CTF weights (diagonal mult by d_i) ;\n
!>  The Normal equations are  ;\n
!>    ;\n
!>     S^H T^H D^H D T S alpha = S^H T^H D^H f ;\n
!>                       ;\n
!>  which are solved with CG. ;\n
!>    ;\n
!>  Solves the least-squares problem for a ;\n
!>  truncated spherical harmonic expansion up to degree nterms, times weights, ;\n
!>  matching complex data ;\n
!>  given at arbitrary points (thetas,phis) on the sphere. Useful for cryo-EM to ;\n
!>  get Fourier data on a k-shell given set of image rings at the same k. ;\n
!>    ;\n
!>  Let S[c] := \sum_{n=0}^nterms \sum_{m=-n}^n c_{nm} Y_{nm}(z) e^{im\phi} ;\n
!>    ;\n
!>  define the a function on S^2 that is the spherical harmonic expansion with ;\n
!>  length-(nterms+1)^2 coefficient vector c. Let (theta,phi) define a point ;\n
!>  on S^2. ;\n
!>    ;\n
!>  Then the routine returns ;\n
!>    ;\n
!>      \hat{c}  =     arg min   \sum_{i=1}^nout | b_i - d_i S[c](z_i,\phi_i)|^2 ;\n
!>                c in C^{(nterms+1)^2} ;\n
!>    ;\n
!>  ie the least-squares solution to Ac=b where A is the matrix of spherical ;\n
!>  harmonics evaluated at the data points then multiplied by the CTL weights d_i ;\n
!>    ;\n
!>  It uses conjugate gradient on the normal equations and a fast algorithm  ;\n
!>  that requires O(nout + nterms^3) work per iteration, where nout is number of  ;\n
!>  data points. ;\n
!>    ;\n
!>     INPUT: ;\n
!>    ;\n
!>     phiout:   input data (including CTF contribution), length nout ;\n
!>     thetas:   input theta values, length nout ;\n
!>     phis:     input phi values, length nout ;\n
!>     nout:     number of data points ;\n
!>     nterms:   order of spherical harmonic approximation (ie P) ;\n
!>     nquad:    number of theta discretization points on regular grid ;\n
!>               (used for interpolation) ;\n
!>     k:        interpolation order of accuracy to irregular points ;\n
!>     ctfw:     ctf weight for each data point, called d_i above. ;\n
!>               Note: All points from the same great circle on the same ;\n
!>               k-space sphere have the same ctf weight but we assume ;\n
!>               each data point has its own ctf weight on input and pay ;\n
!>               no attention to which point comes from which reference ;\n
!>               image ;\n
!>     multaha   matvec for CG iteration (passed external subroutine) ;\n
!>    ;\n
!>     OUTPUT: ;\n
!>    ;\n
!>     localp:   spherical harmonic coefficients in unrolled format ;\n
!>               ie ordered (0,0), (1,-1), ;\n
!>               (1,0), (1,1), (2,-2), ... (nterms,nterms). ;\n
!>               Length is (nterms+1)^2. ;\n
!>    ;\n
!>   Things you can adjust in code & should be made arguments: ;\n
!>   eps = CG tolerance ;\n
!>    ;\n
!>   Below is a wrapper that omits the multaha argument, which can thus be ;\n
!>   called from MATLAB ;\n
!>    ;\n
!>   Fortran files this code needs: ;\n
!>   spharmroutsnew.f        (note: not "p" version) ;\n
!>   ccongrlsq.f ;\n
!>    ;\n
!>  Old doc notes: ;\n
!>  Matvec:  A * localp -> ;\n
!>           (1) localp -> vals on grid VALS(nquad*nquadm) vector. ;\n
!>           (2) vals are INTERP*VALS  (sparse nout * nquad*nquadm matrix) ;\n
!>    ;\n
!>  MatvecH: a.  INTERP^H,  ( nquad*nquadm x nout sparse matrix) ;\n
!>           b.  FORMMP from reg grid ;\n
!>           (2) vals are INTERP*VALS. ;\n
!>    ;\n
!>  Greengard based on Barnett lsqsolvespharm MATLAB code. ;\n
!>  Doc updated ahb 3/1/16 ;\n
!> Doxygen comment: ;\n
c  A version of lsqsolvespharm which solves a least squares problem
c  including a complex-valued factor (eg CTF) on each data point
c
c  The measured data f takes the form of 
c  f = A alpha = D T S alpha, where S is spherical harmonic transform,
c                             T is interpolation
c                             and D is CTF weights (diagonal mult by d_i)
c  The Normal equations are 
c
c     S^H T^H D^H D T S alpha = S^H T^H D^H f
c                      
c  which are solved with CG.
c
c  Solves the least-squares problem for a
c  truncated spherical harmonic expansion up to degree nterms, times weights,
c  matching complex data
c  given at arbitrary points (thetas,phis) on the sphere. Useful for cryo-EM to
c  get Fourier data on a k-shell given set of image rings at the same k.
c
c  Let S[c] := \sum_{n=0}^nterms \sum_{m=-n}^n c_{nm} Y_{nm}(z) e^{im\phi}
c
c  define the a function on S^2 that is the spherical harmonic expansion with
c  length-(nterms+1)^2 coefficient vector c. Let (theta,phi) define a point
c  on S^2.
c
c  Then the routine returns
c
c      \hat{c}  =     arg min   \sum_{i=1}^nout | b_i - d_i S[c](z_i,\phi_i)|^2
c                c in C^{(nterms+1)^2}
c
c  ie the least-squares solution to Ac=b where A is the matrix of spherical
c  harmonics evaluated at the data points then multiplied by the CTL weights d_i
c
c  It uses conjugate gradient on the normal equations and a fast algorithm 
c  that requires O(nout + nterms^3) work per iteration, where nout is number of 
c  data points.
c
c     INPUT:
c   
c     phiout:   input data (including CTF contribution), length nout
c     thetas:   input theta values, length nout
c     phis:     input phi values, length nout
c     nout:     number of data points
c     nterms:   order of spherical harmonic approximation (ie P)
c     nquad:    number of theta discretization points on regular grid
c               (used for interpolation)
c     k:        interpolation order of accuracy to irregular points
c     ctfw:     ctf weight for each data point, called d_i above.
c               Note: All points from the same great circle on the same
c               k-space sphere have the same ctf weight but we assume
c               each data point has its own ctf weight on input and pay
c               no attention to which point comes from which reference
c               image
c     multaha   matvec for CG iteration (passed external subroutine)
c
c     OUTPUT:
c
c     localp:   spherical harmonic coefficients in unrolled format
c               ie ordered (0,0), (1,-1),
c               (1,0), (1,1), (2,-2), ... (nterms,nterms).
c               Length is (nterms+1)^2.
c
c Things you can adjust in code & should be made arguments:
c   eps = CG tolerance
c
c Below is a wrapper that omits the multaha argument, which can thus be
c called from MATLAB
c
c Fortran files this code needs:
c   spharmroutsnew.f        (note: not "p" version)
c   ccongrlsq.f
c
c Old doc notes:
c  Matvec:  A * localp ->
c           (1) localp -> vals on grid VALS(nquad*nquadm) vector.
c           (2) vals are INTERP*VALS  (sparse nout * nquad*nquadm matrix)
c
c  MatvecH: a.  INTERP^H,  ( nquad*nquadm x nout sparse matrix)
c           b.  FORMMP from reg grid
c           (2) vals are INTERP*VALS.
c
c Greengard based on Barnett lsqsolvespharm MATLAB code.
c Doc updated ahb 3/1/16

      subroutine lsqctfsolve(phiout,thetas,phis,nout,localp,nterms,
     1           nquad,k,ctfw,multaha,eps,numit,niter)

      implicit real *8 (a-h,o-z)
      integer nterms,nquad,nquadm,numit,nitermax,niter
      integer, allocatable :: icols(:,:)
      real *8, allocatable :: xnodes(:),wts(:),twork(:),sthetas(:)
      real *8 thetas(nout)
      real *8 phis(nout)
      real *8 errs(1000),eps
      real *8, allocatable :: values(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 phiout(nout)
      complex *16 ctfw(nout)
      complex *16, allocatable :: y(:)
      complex *16, allocatable :: ugrid(:)
      complex *16, allocatable :: phivals(:)
      complex *16, allocatable :: work(:)
      complex *16 a,z1,z2,z3
      external multaha

c     alex used for print output to matlab shell... (fails with std fortran)
      integer i
      character(len=80) str
c     integer*4, external :: mexPrintf
c     
c
      nquadm = 2*nquad
      allocate(xnodes(nquad))
      allocate(wts(nquad))
      allocate(sthetas(nquad))
      allocate(twork(nquad))
      call getgridth(nquad,twork,xnodes,sthetas,wts)

      np = (nterms+1)*(nterms+1)
      allocate(icols(nout,k*k))
      allocate(values(nout,k*k))
      allocate(y(np))
      allocate(ugrid(nquadm*nquad))
      allocate(phivals(nout))
      allocate(work(5*np+1000))
c
c     solving neq:   
c
      t1 = second()
ccc      call prinf(' calling mkshinterp nout is *',nout,1)
      call mkshinterp(thetas,phis,nout,k,nquad,nquadm,values,icols)
      t2 = second()
c      write(str,*) 'interp build time =',t2-t1,achar(15)
c      i = mexPrintf(str)
c
      do i = 1,nout
         phivals(i) = dconjg(ctfw(i))*phiout(i)    
      enddo

ccc      call prinf(' calling shinterp_adj nout is *',nout,1)
      call shinterp_adj(nout,k,nquad,nquadm,values,icols,phivals,ugrid)
ccc      call prinf(' calling shevalspherep_adj nout is *',nout,1)
      call shevalspherep_adj(nterms,nquad,nquadm,xnodes,ugrid,y)
ccc      call prin2(' ugrid is *',ugrid,2*nquad*nquadm)
ccc      call prin2(' y is *',y,2*np)
c
      call ccongr2(ier,np,a,multaha,nterms,nquad,nquadm,nout,k,icols,
     1    xnodes,wts,values,phivals,ugrid,ctfw,y,eps,numit,localp,niter,
     1    errs,work)
c      call prinf(' ier *',ier,1)
c$$$      call prinf(' niter *',niter,1)
c$$$      call prin2(' errs *',errs,niter)

c     alex printing to matlab:
c      write(str,*) 'niter =',niter,achar(5)
c      i = mexPrintf(str)
      return
      end
c
c

cCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c
c    This does the A^H A apply. Other matvecs can be used by changing the
c    function name passed into lsqctfsolve:
c
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      subroutine multaha(a,x,y,n,nterms,nquad,nquadm,nout,k,icols,
     1                   xnodes,wts,values,phiout,ugrid,ctfw)
      implicit real *8 (a-h,o-z)
      real *8 icols(nout,k*k)
      real *8 xnodes(nquad)
      real *8 wts(nquad)
      real *8 values(nout,k*k)
      real *8 p3
      complex *16 ugrid(nquadm*nquad)
      complex *16 phiout(nout),z3
      complex *16 a,x(n),y(n),d
      complex *16 ctfw(nout)
c
ccc      call prinf(' calling shevalspherep *',n,1)
      call shevalspherep(x,ugrid,nterms,nquad,nquadm,xnodes)
ccc      call prinf(' calling shinterp *',n,1)
      call shinterp(nout,k,nquad,nquadm,values,icols,ugrid,phiout)
c
      do i = 1,nout
         phiout(i) = dconjg(ctfw(i))*ctfw(i)*phiout(i)    
      enddo
ccc      call prinf(' calling shinterp_adj *',n,1)
      call shinterp_adj(nout,k,nquad,nquadm,values,icols,phiout,ugrid)
ccc      call prinf(' calling shevalspherep_adj *',n,1)
      call shevalspherep_adj(nterms,nquad,nquadm,xnodes,ugrid,y)
c
      return
      end
c
c

ccccccccccccccccccccccccccccc debugging codes ccccccccccccccccccccccccccccccc
c
c     This code sets up spares interp matrix then does phiout=Ax and
c     ahax=A^H Ax on given coeff vecotr x (=cnm)
C     to allow testing against matlab.  Hardwired to CTF=1
C     See spharm.mw for checkmatvec MATLAB driver and comparelsqsolvers.m
c     do run the test.
c
C     barnett 6/22/16
      subroutine checkmatvecs(phiout,thetas,phis,nout,x,ahax,nterms,
     1           nquad,nquadm,k,xnodes,wts,ctfw)

      implicit real *8 (a-h,o-z)
      integer nterms,nquad,nquadm,nitermax
      integer, allocatable :: icols(:,:)
      real *8 xnodes(nquad),wts(nquad)
      real *8 thetas(nout)
      real *8 phis(nout)
      real *8 errs(1000),eps
      real *8, allocatable :: values(:,:)
      complex *16 x((nterms+1)*(nterms+1))
      complex *16 ahax((nterms+1)*(nterms+1))
      complex *16 phiout(nout)
      complex *16 ctfw(nout)
      complex *16, allocatable :: ugrid(:)
      complex *16, allocatable :: work(:)
      complex *16 a,z1,z2,z3
c
      np = (nterms+1)*(nterms+1)
      allocate(icols(nout,k*k))
      allocate(values(nout,k*k))
      allocate(ugrid(nquadm*nquad))
      allocate(work(5*np+1000))
c
c     set up interp matrix... (fills values,icols)
      call mkshinterp(thetas,phis,nout,k,nquad,nquadm,values,icols)
c     do Ax ... (takes x -> ugrid -> phiout)
      call shevalspherep(x,ugrid,nterms,nquad,nquadm,xnodes)
      call shinterp(nout,k,nquad,nquadm,values,icols,ugrid,phiout)
c     do A^H on the Ax from above... (takes phiout -> ugrid -> ahax)
      call shinterp_adj(nout,k,nquad,nquadm,values,icols,phiout,ugrid)
      call shevalspherep_adj(nterms,nquad,nquadm,xnodes,ugrid,ahax)
c
      return
      end
c
!> Doxygen comment: ;\n
!>      From density in physical space, generate slices of Fourier  ;\n
!>      transform on 2D grids at requested parameters : ;\n
!>      alpha2d -> (cos(beta==theta),alpha==phi,gamma_z,delta_x,delta_y). ;\n
!>       ;\n
!>      Note: The parameters gamma and delta correspond to the following ;\n
!>      perturbation of the slice in real-space (i.e., x-space):  ;\n
!>      *FIRST* translate by (+delta_x,+delta_y), and ;\n
!>      *SECOND* rotate by +gamma_z. ;\n
!> ;\n
!>      Note: This means that when comparing this slice (as an image) to ;\n
!>      various templates, one must: ;\n
!>      *FIRST* rotate by -gamma_z, and ;\n
!>      *SECOND*  translate by (-delta_x,-delta_y). ;\n
!>----------------------------------------------------------------------- ;\n
!>    INPUT: ;\n
!>     ;\n
!>    density       ngrid x ngrid x ngrid array in REAL space ;\n
!>    ngrid         dimension of density array ;\n
!>    boxsize       in physical space [-boxsize/2,boxsize/2]^3. ;\n
!>    eps           NUFFT tolerance  ;\n
!>     ;\n
!>    ngridr        the extent of fourier array in the radial direction  ;\n
!>    ngridc()      number of output points on successive circles ;\n
!>                  in slices ;\n
!>    rkmax         max frequency ;\n
!>    n_alpha       leading dimension of alpha2d ;\n
!>    alpha2d        n_alpha x nimage array of parameters for each simulated image ;\n
!>                  parameter list for each image: ;\n
!>                  1: polar angle (e.g., beta) ;\n
!>                  2: azimutha angle (e.g., alpha) ;\n
!>                  3: planar angle (i.e., gamma_z) ;\n
!>                  4: delta_x ;\n
!>                  5: delta_y ;\n
!>                  plus any other parameters ;\n
!>                  Note that we assume n_alpha is at least 5. ;\n
!>    nslices       number of slices to generate ;\n
!>    nslice_size   size of slice ;\n
!>     ;\n
!>    OUTPUT: ;\n
!>     ;\n
!>    cslices:      nslice_size x nslices array of central slices. ;\n
!> Doxygen comment: ;\n
c***********************************************************************
      subroutine mk_simulated_slices_alpha2d(density,ngrid,boxsize,eps
     $     ,ngridr,ityper,ngridc,rkmax,alpha2d,nslices
     $     ,nslice_size ,cslices)
c***********************************************************************
c$$$      From density in physical space, generate slices of Fourier 
c$$$      transform on 2D grids at requested parameters :
c$$$      alpha2d -> (cos(beta==theta),alpha==phi,gamma_z,delta_x,delta_y).
c$$$      
c$$$      Note: The parameters gamma and delta correspond to the following
c$$$      perturbation of the slice in real-space (i.e., x-space): 
c$$$      *FIRST* translate by (+delta_x,+delta_y), and
c$$$      *SECOND* rotate by +gamma_z.
c$$$
c$$$      Note: This means that when comparing this slice (as an image) to
c$$$      various templates, one must:
c$$$      *FIRST* rotate by -gamma_z, and
c$$$      *SECOND*  translate by (-delta_x,-delta_y).

c-----------------------------------------------------------------------
c     INPUT:
c
c     density       ngrid x ngrid x ngrid array in REAL space
c     ngrid         dimension of density array
c     boxsize       in physical space [-boxsize/2,boxsize/2]^3.
c     eps           NUFFT tolerance 
c
c     ngridr        the extent of fourier array in the radial direction 
c     ngridc()      number of output points on successive circles
c                   in slices
c     rkmax         max frequency
c     n_alpha       leading dimension of alpha2d
c     alpha2d        n_alpha x nimage array of parameters for each simulated image
c                   parameter list for each image:
c                   1: polar angle (e.g., beta)
c                   2: azimutha angle (e.g., alpha)
c                   3: planar angle (i.e., gamma_z)
c                   4: delta_x
c                   5: delta_y
c                   plus any other parameters
c                   Note that we assume n_alpha is at least 5.
c     nslices       number of slices to generate
c     nslice_size   size of slice
c
c     OUTPUT:
c
c     cslices:      nslice_size x nslices array of central slices.
c-----------------------------------------------------------------------
      implicit none
      include 'omp_lib.h'
      integer verbose
      data verbose / 1 /
      integer ngrid,ngridr,nslices,nslice_size,ityper,ier,iflag,ii,ir
      integer istart,npts,nptsk,n_A
      integer ngridc(ngridr)
      complex *16  density(ngrid,ngrid,ngrid)
      real *8  boxsize,cthetause,phiuse,gammause,rkmax,rk
      real *8 delta_x,delta_y,gamma_z
      real *8  a,h,eps,t0,t1,t2
      include 'nalpha_define.f'
      real *8  alpha2d(n_alpha,nslices)
      real *8, allocatable :: rkx(:,:)
      real *8, allocatable :: rky(:,:)
      real *8, allocatable :: rkz(:,:)
      real *8, allocatable :: x(:,:,:)
      real *8, allocatable :: y(:,:,:)
      real *8, allocatable :: z(:,:,:)
      real *8, allocatable :: xnodesr(:),wtsr(:)
      complex *16 cslices(nslice_size,nslices)
      if (verbose.gt.1) write(6,'(A)')
     $     '[entering mk_simulated_slices_alpha2d]'
c
      allocate(xnodesr(ngridr))
      allocate(wtsr(ngridr))
      allocate(rkx(nslice_size,nslices))
      allocate(rky(nslice_size,nslices))
      allocate(rkz(nslice_size,nslices))
      allocate(x(ngrid,ngrid,ngrid))
      allocate(y(ngrid,ngrid,ngrid))
      allocate(z(ngrid,ngrid,ngrid))
c
c     create physical space grid and sample function on it.
c
      a = boxsize/2.0d0
      call mkphysgrid(a,ngrid,h,x,y,z)
c
c     create k-space output points
c
      call getgridr(rkmax,ngridr,ityper,xnodesr,wtsr)
c
      t0 = omp_get_wtime()
      istart = 1
      do ir = 1,ngridr
         rk = xnodesr(ir)
         do ii = 1,nslices
            cthetause = dcos(alpha2d(1+nalpha_polar_a,ii))
            phiuse = alpha2d(1+nalpha_azimu_b,ii)
            gammause = 0.0d0
            call mkonegreatcircle(rk,cthetause,phiuse,gammause,
     1         ngridc(ir),rkx(istart,ii),rky(istart,ii),rkz(istart,ii))
         enddo
         istart =  istart + ngridc(ir)
ccc         call prinf(' istart is *',istart,1)
      enddo
      t1 = omp_get_wtime()
c
c     compute Fourier transform
c
      npts = ngrid*ngrid*ngrid
      nptsk = nslice_size*nslices
      iflag = 1
      if (verbose.gt.1) then
         write(6,'(A,I0)') ' (si) npts is ',npts
         write(6,'(A,I0)') ' nptsk is ',nptsk
      end if
      call finufft3d3_f(npts,x,y,z,density,iflag,eps,nptsk,
     1     rkx,rky,rkz,cslices,ier)

      n_A = 0
      do ir = 1,ngridr
         n_A = n_A + ngridc(ir)
      end do
      if (n_A.ne.nslice_size) then
         write(6,'(A,A)') ' Warning, nslice_size.neq.sum(ngridc)'
     $        ,' in mk_simulated_slices_alpha2d'
      end if

      do ii = 1,nslices
         do ir = 1,nslice_size
            cslices(ir,ii) = cslices(ir,ii)*h*h*h
         enddo
         delta_x = +alpha2d(1+nalpha_delta_x,ii)
         delta_y = +alpha2d(1+nalpha_delta_y,ii)
         call transf_p_to_p(ngridr,xnodesr,ngridc,nslice_size,cslices(1
     $        ,ii),+delta_x,+delta_y,cslices(1,ii))
         gamma_z = +alpha2d(1+nalpha_gamma_z,ii)
         call rotate_p2p_fz(ngridr,ngridc,nslice_size,cslices(1,ii)
     $        ,gamma_z,cslices(1,ii))
      enddo
      t2 = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A,F16.8)') ' time for data extraction ',t1-t0
         write(6,'(A,F16.8)') ' time for nufft ',t2-t1
      end if
c
      if (verbose.gt.1) write(6,'(A)')
     $     '[finished mk_simulated_slices_alpha2d]'
      return
      end
!> Doxygen comment: ;\n
!>    integer function next235 returns a multiple of 2, 3, and 5 ;\n
!>    next235 = 2^p 3^q 5^r >= base  where p>=1, q>=0, r>=0 ;\n
!> Doxygen comment: ;\n
************************************************************************
      function next235(base)
      implicit none
      integer next235, numdiv
      real*8 base
c ----------------------------------------------------------------------
c     integer function next235 returns a multiple of 2, 3, and 5
c
c     next235 = 2^p 3^q 5^r >= base  where p>=1, q>=0, r>=0
************************************************************************
      next235 = 2 * int(base/2d0+.9999d0)
      if (next235.le.0) next235 = 2

100   numdiv = next235
      do while (numdiv/2*2 .eq. numdiv)
         numdiv = numdiv /2
      enddo
      do while (numdiv/3*3 .eq. numdiv)
         numdiv = numdiv /3
      enddo
      do while (numdiv/5*5 .eq. numdiv)
         numdiv = numdiv /5
      enddo
      if (numdiv .eq. 1) return
      next235 = next235 + 2
      goto 100
      end

!> Doxygen comment: ;\n
!>    Builds new model Y_ (i.e., in spherical harmonic basis)  ;\n
!>    from images M_k_p_ (in k-space polar coordinates), ;\n
!>    with image parameters given by alpha2d__ array. ; ;\n
!>--------------------------------------------------------------------- ;\n
!>    INPUT: ;\n
!>     ;\n
!>    n_M            integer: number of images ; ;\n
!>    I_M_sample_    integer: array indexing the relevant nM entries of M_k_p__. ; ;\n
!>    ld_M           integer: leading dimension of images in k-space polar coordinates. ; ;\n
!>    M_k_p__        complex *16: stack of images in k-space polar coordinates (size ld_M*n_M). ; ;\n
!>    n_CTF          integer: number of ctf-functions. ; ;\n
!>    ld_CTF         integer: leading dimension of CTF-array (usually ld_M). ; ;\n
!>    CTF_k_p_       complex *16: stack of ctf-functions in k-space polar coordinates (size ld_CTF*n_CTF). ; ;\n
!>    n_alpha        integer: size of alpha2d__. ; ;\n
!>    alpha2d__(3,*) real *8: 2d array of image parameters (see nalpha_define.f). ; ;\n
!>    n_w_csum_()     integer: indexing array for points on successive circles within each image. ;  ;\n
!>                   n_w_csum_(nk) represents the number of points (in angle-w) on ring at radius grid_k_p_(nk). ; ;\n
!>    n_polar_a_()   integer:  number of quadrature nodes in polar_a on sphere defined by index n_k_cur. ; ;\n
!>    quadrature_type_azimu_b integer: flag determining quadrature scheme in azimu_b direction. ; ;\n
!>                      0 = same on all latitudes (which oversamples poles). ; ;\n
!>                      1 = adaptive (appropriately samples toward poles). ; ;\n
!>                   if quadrature_type_azimu_b=0, then n_azimu_b = nint(n_polar_a_(nk)*phi_over). ; ;\n
!>                   if quadrature_type_azimu_b=1, then n_azimu_b = nint(n_polar_a_(nk)*phi_over*sin(polar_a)). ; ;\n
!>                   Note: phi_over is set in getgridph (typically = 2). ; ;\n
!>    grid_k_p_()    real *8: radius associated with successive circles in templates in k-space polar coordinates. ; ;\n
!>    n_w_()         integer: number of output points on successive circles in templates in k-space polar coordinates. ; ;\n
!>    n_k_low        integer: index of lowest frequency sphere under consideration. Note that this runs from 1 to n_k_p_max. ; ;\n
!>    n_k_cur        integer: index of highest frequency sphere under consideration. Note that this runs from 1 to n_k_p_max. ; ;\n
!>    n_Y_lm_csum_()  integer: array of length n_k_p_max indicating where the Y_ for that shell begins. ; ;\n
!>    n_Y_l_()       integer: array of length n_k_p_max defining the orders of the various Y_ on successive shells. ; ;\n
!>    lsq_oversample integer: lsq_oversampling parameter for least-squares solver. ; ;\n
!>    lsq_interpolation_order integer: interpolation order for least-squares solver. ; ;\n
!>    lsq_eps        real *8: tolerance epsilon passed into least-squares solver ;\n
!>     ;\n
!>    OUTPUT:  ;\n
!>     ;\n
!>    Y_(:)         complex *16: solution to least-squares problem expressed in spherical harmonics in successive shells. ; ;\n
!>     ;\n
!> Doxygen comment: ;\n
C***********************************************************************
      subroutine rebuild_model_2(n_M,I_M_sample_,ld_M,M_k_p__,n_CTF
     $     ,ld_CTF,CTF_k_p_,alpha2d__,n_w_csum_,n_polar_a_
     $     ,quadrature_type_azimu_b ,grid_k_p_,n_w_,n_k_low,n_k_cur
     $     ,n_Y_lm_csum_ ,n_Y_l_ ,lsq_oversample,lsq_interpolation_order
     $     ,lsq_eps ,Y_)
C***********************************************************************
C     Builds new model Y_ (i.e., in spherical harmonic basis) 
C     from images M_k_p_ (in k-space polar coordinates),
C     with image parameters given by alpha2d__ array. ;
C---------------------------------------------------------------------
C     INPUT:
C
C     n_M            integer: number of images ;
C     I_M_sample_    integer: array indexing the relevant nM entries of M_k_p__. ;
C     ld_M           integer: leading dimension of images in k-space polar coordinates. ;
C     M_k_p__        complex *16: stack of images in k-space polar coordinates (size ld_M*n_M). ;
C     n_CTF          integer: number of ctf-functions. ;
C     ld_CTF         integer: leading dimension of CTF-array (usually ld_M). ;
C     CTF_k_p_       complex *16: stack of ctf-functions in k-space polar coordinates (size ld_CTF*n_CTF). ;
c     n_alpha        integer: size of alpha2d__. ;
c     alpha2d__(3,*) real *8: 2d array of image parameters (see nalpha_define.f). ;
c     n_w_csum_()     integer: indexing array for points on successive circles within each image. ; 
c                    n_w_csum_(nk) represents the number of points (in angle-w) on ring at radius grid_k_p_(nk). ;
c     n_polar_a_()   integer:  number of quadrature nodes in polar_a on sphere defined by index n_k_cur. ;
c     quadrature_type_azimu_b integer: flag determining quadrature scheme in azimu_b direction. ;
c                       0 = same on all latitudes (which oversamples poles). ;
c                       1 = adaptive (appropriately samples toward poles). ;
c                    if quadrature_type_azimu_b=0, then n_azimu_b = nint(n_polar_a_(nk)*phi_over). ;
c                    if quadrature_type_azimu_b=1, then n_azimu_b = nint(n_polar_a_(nk)*phi_over*sin(polar_a)). ;
c                    Note: phi_over is set in getgridph (typically = 2). ;
c     grid_k_p_()    real *8: radius associated with successive circles in templates in k-space polar coordinates. ;
c     n_w_()         integer: number of output points on successive circles in templates in k-space polar coordinates. ;
c     n_k_low        integer: index of lowest frequency sphere under consideration. Note that this runs from 1 to n_k_p_max. ;
c     n_k_cur        integer: index of highest frequency sphere under consideration. Note that this runs from 1 to n_k_p_max. ;
c     n_Y_lm_csum_()  integer: array of length n_k_p_max indicating where the Y_ for that shell begins. ;
c     n_Y_l_()       integer: array of length n_k_p_max defining the orders of the various Y_ on successive shells. ;
c     lsq_oversample integer: lsq_oversampling parameter for least-squares solver. ;
c     lsq_interpolation_order integer: interpolation order for least-squares solver. ;
c     lsq_eps        real *8: tolerance epsilon passed into least-squares solver
C
C     OUTPUT: 
c
C     Y_(:)         complex *16: solution to least-squares problem expressed in spherical harmonics in successive shells. ;
c
C***********************************************************************
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_M,I_M_sample_(0:n_M-1),ld_M,n_CTF,ld_CTF
      integer n_w_csum_(0:0),n_polar_a_(0:0)
      integer quadrature_type_azimu_b
      include '/usr/include/fftw3.f'
      include 'nalpha_define.f'
      integer n_w_(0:0)
      integer n_k_low,n_k_cur
      integer *8, allocatable :: fftw_plan_frwd_(:)
      integer *8, allocatable :: fftw_plan_back_(:)
      complex *16, allocatable :: fftw_in1_(:)
      complex *16, allocatable :: fftw_out_(:)
      integer n_Y_lm_csum_(0:0),n_Y_l_(0:0)
      integer lsq_interpolation_order
      real *8 alpha2d__(0:n_alpha-1,0:n_M-1)
      real *8 grid_k_p_(0:n_k_cur-1)
      real *8 lsq_oversample,lsq_eps
      complex *16 M_k_p__(0:0)
      complex *16 CTF_k_p_(0:ld_CTF*n_CTF-1)
      complex *16 Y_(0:0)
      integer nk,n_A,na,n_w,nw
      integer n_iteration,niteration
      integer n_w_M,n_w_M_max
      integer n_Y_lm_max,n_Y_lm,n_Y_l,n_polar_a_oversample
      real *8, allocatable :: polar_a_(:)
      real *8, allocatable :: azimu_b_(:)
      complex *16, allocatable :: Y_cur_(:)
      complex *16, allocatable :: M_k_c_(:)
      complex *16, allocatable :: weight_CTF_k_c_(:)
      external multaha
      character(len=1024) format_string
      if (verbose.gt.0) then
         write(6,*) '[entering rebuild_model_2]'
      end if
      if (verbose.gt.1) then
         write(6,*) 'ld_M: ',ld_M
         write(6,*) 'n_M: ',n_M
         write(6,*) 'n_w_csum_: ',(n_w_csum_(nk),nk=0,n_k_cur-1)
         write(6,*) 'n_polar_a_: ',(n_polar_a_(nk),nk=0,n_k_cur-1)
         write(6,*) 'quadrature_type_azimu_b: ',quadrature_type_azimu_b
         write(6,*) 'grid_k_p_: ',(grid_k_p_(nk),nk=0,n_k_cur-1)
         write(6,*) 'n_w_: ',(n_w_(nk),nk=0,n_k_cur-1)
         write(6,*) 'n_k_low: ',n_k_low
         write(6,*) 'n_k_cur: ',n_k_cur
         write(6,*) 'n_Y_lm_csum_: ',(n_Y_lm_csum_(nk),nk=0,n_k_cur-1)
         write(6,*) 'n_Y_l_: ',(n_Y_l_(nk),nk=0,n_k_cur-1)
         write(6,*) 'lsq_oversample: ',lsq_oversample
         write(6,*) 'lsq_interpolation_order: ',lsq_interpolation_order
      end if

      n_A = 0
      do nk = 0,n_k_cur-1
         n_A = n_A + n_w_(nk)
      end do !do nk = 0,n_k_cur-1
      if (n_A.gt.ld_M) then
         write(6,*) 'Warning, ld_M: ',ld_M
     $        ,' .neq. n_A: ',n_A,' in rebuild_model_2'
      end if
      if (verbose.gt.1) then
         write(6,'(2(A,I0))') ' n_k_cur ' , n_k_cur , ' n_A ' , n_A
      end if !if (verbose.gt.1) then
c
      allocate(fftw_plan_frwd_(0:n_k_cur-1))
      allocate(fftw_plan_back_(0:n_k_cur-1))
      allocate(fftw_in1_(0:n_A-1))
      allocate(fftw_out_(0:n_A-1))
      na = 0
      do nk=0,n_k_cur-1
         call dfftw_plan_dft_1d_(fftw_plan_frwd_(nk),n_w_(nk)
     $        ,fftw_in1_(na),fftw_out_(na),FFTW_FORWARD,FFTW_MEASURE) 
         call dfftw_plan_dft_1d_(fftw_plan_back_(nk),n_w_(nk)
     $        ,fftw_out_(na),fftw_in1_(na),FFTW_BACKWARD,FFTW_MEASURE) 
         na = na + n_w_(nk)
      enddo !do nk=0,n_k_cur-1
c
      n_Y_l = n_Y_l_(n_k_cur-1)
      n_Y_lm_max = (n_Y_l+1)**2
      if (verbose.gt.1) then
         write(6,*) ' n_Y_l = ',n_Y_l
         write(6,*) ' n_Y_lm_max = ',n_Y_lm_max
      end if
      allocate(Y_cur_(0:1+n_Y_lm_max))
      call cs1_c16(n_Y_lm_max,Y_cur_)
c
      n_polar_a_oversample = nint(lsq_oversample*n_polar_a_(n_k_cur-1))
      if (verbose.gt.1) then
         write(6,*) ' lsq_oversample = ',lsq_oversample
         write(6,*) ' n_polar_a_oversample = ',n_polar_a_oversample
      end if
c
      n_w_M_max = n_M*n_w_(n_k_cur-1)
      if (verbose.gt.1) then
         write(6,*) ' n_w_M_max = ',n_w_M_max
      end if
      allocate(M_k_c_(0:1+n_w_M_max-1))
      call cs1_c16(n_w_M_max,M_k_c_)
      allocate(polar_a_(0:1+n_w_M_max-1))
      call cs1_r8(n_w_M_max,polar_a_)
      allocate(azimu_b_(0:1+n_w_M_max-1))
      call cs1_r8(n_w_M_max,azimu_b_)
      allocate(weight_CTF_k_c_(0:1+n_w_M_max-1))
      call cs1_c16(n_w_M_max,weight_CTF_k_c_)
c
      na = 0
      do nk = 0,n_k_cur-1
         if (verbose.gt.1) then
            write(6,'(2(A,I0))') ' nk ' , nk , ' n_k_cur ' , n_k_cur
         end if
         if (nk.ge.0) then
            call get_lsqdata_2(n_M,I_M_sample_,ld_M,M_k_p__,n_CTF,ld_CTF
     $           ,CTF_k_p_,grid_k_p_(nk),fftw_plan_frwd_(nk)
     $           ,fftw_plan_back_(nk),n_w_csum_(nk),n_w_(nk)
     $           ,fftw_in1_(na),fftw_out_(na),alpha2d__,M_k_c_ ,polar_a_
     $           ,azimu_b_ ,weight_CTF_k_c_ ,n_w_M)
            if (verbose.gt.1) then
               n_w = 1*n_w_(nk)
               write(format_string,'(A,I0,A)') '(A,',n_w*2,'F8.3)'
               write(6,format_string) 'M_k_c_: ',(M_k_c_(nw),nw=0,n_w
     $              -1)
               write(6,format_string) 'weight_CTF_k_c_: '
     $              ,(weight_CTF_k_c_(nw),nw=0,n_w-1)
            end if              !verbose
c
c     set up parameters for tensor product grid on sphere
c     to be used in least-squares solve (for interpolation
c     to arbitrary points)
c     
            n_Y_l = n_Y_l_(nk)
            n_Y_lm = (n_Y_l+1)**2
            n_iteration = 1000
            niteration = 0
            call lsqctfsolve(M_k_c_,polar_a_,azimu_b_,n_w_M,Y_cur_,n_Y_l
     $           ,nint(lsq_oversample*n_polar_a_(nk))
     $           ,lsq_interpolation_order,weight_CTF_k_c_,multaha
     $           ,lsq_eps,n_iteration ,niteration)
            call cp1_c16(n_Y_lm,Y_cur_,Y_(n_Y_lm_csum_(nk)))
         end if                 !if (nk.ge.0) then
         na = na + n_w_(nk)
      enddo                     !do nk = n_k_low-1,n_k_cur-1

      if (verbose.gt.-1) then
         write(6,'(A)') ' Destroying fftw_plans for local use.'
      end if
      do nk=0,n_k_cur-1
         call dfftw_destroy_plan(fftw_plan_frwd_(nk))
         call dfftw_destroy_plan(fftw_plan_back_(nk))
      enddo !do nk=0,n_k_cur-1
      if (verbose.gt.-1) then
         write(6,'(A)') ' deallocating. '
      end if
      deallocate(fftw_plan_frwd_)
      deallocate(fftw_plan_back_)
      deallocate(fftw_in1_)
      deallocate(fftw_out_)

      if (verbose.gt.0) write(6,*)
     $     '[finished rebuild_model_2]'
      return
      end

c$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!> Doxygen comment: ;\n
!>  Fortran library for spherical harmonic projection and evaluation ;\n
!>  on spherical grids (tensor product or quasiuniform/sparse grids) ;\n
!>  using packed storage format for expansion coefficients. ;\n
!>   ;\n
!>--------------------------------------------------------------------- ;\n
!>  projshexp               Compute spherical harmonic expansion on unit  ;\n
!>	            	      sphere of function tabulated on sphere. ;\n
!>  packshexp               Packs a complex 2d spherical expansion format  ;\n
!>			      to a 1d list ;\n
!>  unpackshexp             Unpacks a packed 1d list to a 2d spherical  ;\n
!>			      expansion format  ;\n
!>  evalshexp               Evaluates a spherical harmonic expansion on a  ;\n
!>		              unit sphere at discretization points  ;\n
!>  sheval_greatcircs       Evaluates a spherical harmonic expansion at  ;\n
!>   			      the equatorial circles for z-axis rotation to ;\n
!>			      all points on discretized sphere  ;\n
!>  mkallgreatcircles       Create Cartesian coordinates for equatorial  ;\n
!>			      circles on sphere of radius rk with z-axis  ;\n
!>			      rotated to all discretization nodes ;\n
!>  mkonegreatcircle        Create Cartesian coordinates for equatorial  ;\n
!>			      circle on sphere of radius rk with z-axis  ;\n
!>			      rotated to single discretization node ;\n
!>  sheval_greatcirc        Evaluates a spherical harmonic expansion at a  ;\n
!>			      single equatorial circle corresponding to one  ;\n
!>                            z-axis rotation  ;\n
!>  mkshinterp              Create interpolation matrix in sparse format ;\n
!>  getinterpsparse         Create row of interp. matrix in sparse format ;\n
!>  getlagrangewt           Create interpolation weights for getinterpsparse ;\n
!>  shinterp                Apply interpolation matrix in sparse format ;\n
!>  shinterp_adj            Apply adjoint of interp. matrix in sparse format ;\n
!>  sheval_spheregrid_adj   Apply adjoint of evalshexp  ;\n
!>  quadscale               Scales function on sphere by quadrature weights ;\n
!>  sheval_spheregrid       Evaluates a spherical harmonic expansion on a  ;\n
!>		              tensor product grid on unit sphere. Duplicates ;\n
!>                            evalshexp but calling sequence is different ;\n
!>                            and seems best to keep both.  ;\n
!>                            .......Perhaps to be made obsolete .... ;\n
!>  kspacegrid_to_model     takes discrete values on spherical grid and ;\n
!>                          converts to spherical harmonic representation ;\n
!>  model_to_kspacegrid     takes spherical harmonic representation and  ;\n
!>                          converts to values on spherical grid ;\n
!>---------------------------------------------------------------------- ;\n
!>  Alex Barnett, Leslie Greengard, Andras Pataki, Marina Spivak  ;\n
!>  various precursor libraries merged/updated here (12/26/16). ;\n
!> Doxygen comment: ;\n
C   Fortran library for spherical harmonic projection and evaluation
C   on spherical grids (tensor product or quasiuniform/sparse grids)
C   using packed storage format for expansion coefficients.
C
C----------------------------------------------------------------------
C   projshexp               Compute spherical harmonic expansion on unit 
C 	            	      sphere of function tabulated on sphere.
C   packshexp               Packs a complex 2d spherical expansion format 
C			      to a 1d list
C   unpackshexp             Unpacks a packed 1d list to a 2d spherical 
C			      expansion format 
C   evalshexp               Evaluates a spherical harmonic expansion on a 
C		              unit sphere at discretization points 
C   sheval_greatcircs       Evaluates a spherical harmonic expansion at 
C    			      the equatorial circles for z-axis rotation to
C			      all points on discretized sphere 
C   mkallgreatcircles       Create Cartesian coordinates for equatorial 
C			      circles on sphere of radius rk with z-axis 
C			      rotated to all discretization nodes
C   mkonegreatcircle        Create Cartesian coordinates for equatorial 
C			      circle on sphere of radius rk with z-axis 
C			      rotated to single discretization node
C   sheval_greatcirc        Evaluates a spherical harmonic expansion at a 
C			      single equatorial circle corresponding to one 
C                             z-axis rotation 
C   mkshinterp              Create interpolation matrix in sparse format
C   getinterpsparse         Create row of interp. matrix in sparse format
C   getlagrangewt           Create interpolation weights for getinterpsparse
C   shinterp                Apply interpolation matrix in sparse format
C   shinterp_adj            Apply adjoint of interp. matrix in sparse format
C   sheval_spheregrid_adj   Apply adjoint of evalshexp 
C   quadscale               Scales function on sphere by quadrature weights
C   sheval_spheregrid       Evaluates a spherical harmonic expansion on a 
C		              tensor product grid on unit sphere. Duplicates
C                             evalshexp but calling sequence is different
C                             and seems best to keep both. 
C                             .......Perhaps to be made obsolete ....
C   kspacegrid_to_model     takes discrete values on spherical grid and
C                           converts to spherical harmonic representation
C   model_to_kspacegrid     takes spherical harmonic representation and 
C                           converts to values on spherical grid
C----------------------------------------------------------------------
C   Alex Barnett, Leslie Greengard, Andras Pataki, Marina Spivak 
C   various precursor libraries merged/updated here (12/26/16).
C
C
C
C***********************************************************************
      subroutine projshexp(phival,numonsphere,ngridt,itypep,
     1           nterms,shexp)
C***********************************************************************
C     Compute spherical harmonic expansion on unit sphere
C     of function tabulated on sphere.
C---------------------------------------------------------------------
C     INPUT:
C
C     phival()       tabulated function
c     numonsphere    number of points used on sphere, defined by 
c                    ngridt,itypep
c     ngridt         number of latitude points used on sphere
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(ngridt*phi_over)
c                    if itypep=1
c                       nphi = nint(ngridt*phi_over*sin(theta))
c
c                    phi_over is set in getgridph (typically = 2).
C     nterms         order of spherical harmonic expansion
C
C---------------------------------------------------------------------
C     OUTPUT:
C
C     shexp()   = coefficients of s.h. expansion
C
C     NOTE:
C
C     yrecursion.f produces Ynm with a nonstandard scaling:
C     (without the 1/sqrt(4*pi)). Thus the orthogonality relation
C     is
C             \int_S  Y_nm Y_n'm'*  dA = delta(n) delta(m) * 4*pi. 
C
C     In the first loop below, you see
C
C           marray(jj,m) = sum*phsteps(jj)/(4*pi)
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nterms,ngridt,nquadm,numonsphere
      integer l,m,jj,kk
      integer, allocatable ::  ngridps(:)
      real *8, allocatable :: phsteps(:)
      real *8, allocatable :: sthetas(:)
      real *8, allocatable :: xnodesth(:)
      real *8, allocatable :: wtsth(:)
      real *8, allocatable ::  ynm(:,:)
c
      complex *16 phival(numonsphere)
      complex *16 shexp((nterms+1)*(nterms+1))
      complex *16 ephi,imag,emul,sum,zmul,emul1
      complex *16, allocatable :: marray(:,:)
      data imag/(0.0d0,1.0d0)/
C
      pi = 4.0d0*datan(1.0d0)
      allocate(ynm(0:nterms,0:nterms))
      allocate(marray(ngridt,-nterms:nterms))
      allocate(xnodesth(ngridt))
      allocate(sthetas(ngridt))
      allocate(wtsth(ngridt))
      allocate(ngridps(ngridt))
      allocate(phsteps(ngridt))
c
      call getspheregrid(ngridt,itypep,xnodesth,
     1     sthetas,wtsth,ngridps,phsteps,numonsphere)

c            
c     initialize shexp exp to zero
c
      do ix = 1,(nterms+1)*(nterms+1)
         shexp(ix) = 0.0d0
      enddo
c
c     create marray (intermediate array)
c
      do m=-nterms,nterms
         nnn = 0
         do jj=1,ngridt
            emul = cdexp(imag*m*2*pi/ngridps(jj))
            sum = 0
            ephi = 1.0d0
            do kk = 1,ngridps(jj)
               nnn=nnn+1
               sum = sum + phival(nnn)*dconjg(ephi)
               ephi = ephi*emul
            enddo
            marray(jj,m) = sum*phsteps(jj)/(4*pi)
         enddo
      enddo
c
c     get shexp 
c
      do jj=1,ngridt
         cthetaj = xnodesth(jj)
         call ylgndr(nterms,cthetaj,ynm)
         do m=-nterms,nterms
            zmul = marray(jj,m)*wtsth(jj)
            do l=abs(m),nterms
               ix = l*(l+1) + m + 1
               shexp(ix) = shexp(ix) + zmul*ynm(l,abs(m))
            enddo
         enddo
      enddo

      return
      end
C
c**********************************************************************
      subroutine packshexp(nterms,in,out)
C***********************************************************************
c     Packs a complex *16 2d local expansion array in a 1d array.
c     Alex Barnett 3/28/12   Leslie Greengard modified 12/25/16
C---------------------------------------------------------------------
c     INPUT:
c
c     nterms  degree of expansion
c     in(:,:) expansion in 2d matrix format
c
C---------------------------------------------------------------------
c     OUTPUT:
c
c     out(:)     coefficients packed in 1D array
C***********************************************************************
      implicit none
      integer i,n,m,nterms,stride
      complex *16 in(0:nterms,-nterms:nterms), out(*)
      
      i = 1
      stride = 1
      do n=0,nterms
         do m=-n,n
            out(i) = in(n,m)
            i = i+stride
         enddo
      enddo
      end

c**********************************************************************
      subroutine unpackshexp(nterms,in,out)
C***********************************************************************
c     Unpacks a complex *16 local expansion stored in 1d array
c     in standard 2d array format.
c     Alex Barnett 2/4/13     Leslie Greengard modified 12/25/16
C---------------------------------------------------------------------
c     INPUT:
c
c     nterms  degree of expansion
c     in(:)      coefficients packed in 1D array
c
C---------------------------------------------------------------------
c     OUTPUT:
c
c     out(:,:)     expansion in 2d matrix format
c
c**********************************************************************
      implicit none
      integer i,n,m,nterms,stride
      complex *16 out(0:nterms,-nterms:nterms), in((nterms+1)**2)
      
      i = 1
      stride = 1
      do n=0,nterms
         do m=-n,n
            out(n,m) = in(i)
            i = i+stride
         enddo
      enddo
      end
C
C
C
C***********************************************************************
      subroutine evalshexp(localp,nterms,ngridt,itypep,
     1           numonsphere,phival)
C***********************************************************************
C     This subroutine evaluates a spherical harmonic expansion on a 
C     unit sphere at discretization points defined by ngridt, itypep.
C---------------------------------------------------------------------
C     INPUT:
C
C     localp()       packed coefficients of s.h. expansion
C     nterms         order of spherical harmonic expansion
c     ngridt         number of latitude points used on sphere
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    phi_over is set in getgridph (typically = 2).
C     numonsphere    total number of points on sphere
C---------------------------------------------------------------------
C     OUTPUT:
C
C     phival()       tabulated function
C***********************************************************************
C     converted to OPENMP, Barnett 6/22/16
C
      implicit real *8 (a-h,o-z)
      integer nterms,ngridt,itypep,numonsphere
      integer jj,m,n,ix,nnn
      integer, allocatable ::  ngridps(:)
      real *8 phi
      real *8, allocatable :: phsteps(:)
      real *8, allocatable :: sthetas(:)
      real *8, allocatable :: xnodesth(:)
      real *8, allocatable :: wtsth(:)
      real *8, allocatable ::  ynm(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 phival(numonsphere)
      complex *16, allocatable :: phitemp(:,:)
      complex *16 imag
      complex *16 ephi,ephik
C
      data imag/(0.0d0,1.0d0)/

c     needed for output that makes it to MATLAB terminal
c      character(len=80) str
c      integer*4, external :: mexPrintf
c     needed for omp
c      integer OMP_GET_THREAD_NUM, omp_get_num_threads
c
c
      pi = 4.0d0*datan(1.0d0)
      allocate(ngridps(ngridt))
      allocate(phsteps(ngridt))
      allocate(sthetas(ngridt))
      allocate(xnodesth(ngridt))
      allocate(wtsth(ngridt))
      allocate(ynm(0:nterms,0:nterms))
      allocate(phitemp(-nterms:nterms,ngridt))
c
      call getspheregrid(ngridt,itypep,xnodesth,
     1     sthetas,wtsth,ngridps,phsteps,numonsphere)
c
c$OMP PARALLEL DO
      do jj=1,ngridt
      do m=-nterms,nterms
         phitemp(m,jj) = 0.0d0
      enddo
      enddo
c$OMP END PARALLEL DO
c
cccc$OMP PARALLEL
c      if (omp_get_thread_num().eq.0) then
c         write(str,*) omp_get_num_threads(), ' threads',achar(10)
c         i=mexPrintf(str)
c      endif
      
c$OMP PARALLEL DO PRIVATE(ctheta,stheta,ynm,m,mabs,ix,n)
      do jj=1,ngridt
         ctheta = xnodesth(jj)
         stheta = sthetas(jj)
         call ylgndr(nterms,ctheta,ynm)
         do m=-nterms,nterms
            mabs = abs(m)
            do n=mabs,nterms
               ix = n*(n+1) + m + 1
               phitemp(m,jj) = phitemp(m,jj) +
     1                localp(ix)*ynm(n,mabs)
            enddo
         enddo
      enddo
c$OMP END PARALLEL DO
c
cccc$OMP PARALLEL DO PRIVATE(kk,ephik,ephi,m)
c
      nnn = 0
      do jj = 1,ngridt
      do kk = 1,ngridps(jj)
         nnn=nnn+1
         phival(nnn) = 0.0d0
         phi = 2*pi*(kk-1)/ngridps(jj)
         ephik = cdexp(imag*phi)
         ephi = cdexp(-nterms*imag*phi)
         do m = -nterms,nterms
            phival(nnn) = phival(nnn) + phitemp(m,jj)*ephi
            ephi = ephi*ephik
         enddo
      enddo
      enddo
cccc$OMP END PARALLEL DO
      return
      end
C
cc
C***********************************************************************
      subroutine sheval_greatcircs(localp,nterms,
     1           ngridt,itypep,numonsphere,nquadc,phival,ldp)
C***********************************************************************
C     This subroutine evaluates a spherical harmonic expansion at
C     the equatorial circles for z-axis rotation to all points on 
C     discretized sphere with numonsphere points. 
C     nquadc is the number of points desired on each great circle.
C---------------------------------------------------------------------
C     INPUT:
C
C     localp()       coefficients of spherical harmonic exp. (packed)
C     nterms         number of terms in the orig. expansion
c     ngridt         number of latitude points used on sphere
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    phi_over is set in getgridph (typically = 2).
C     numonsphere    total number of points on sphere
C
C     nquadc   : number of points on equator for each rotation
C     ldp      : leading dimenson of phival array (must be at least
C                nquadc)
C---------------------------------------------------------------------
C     OUTPUT:
C
C     phival()  : (l,m) corresponds to lth node on equatorial circle
C                        for normal corresponding to (theta_m,phi_m).
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nterms,ngridt,itypep,numonsphere,nquadc
      integer ii,ll,m,n,ix,nnn
      integer, allocatable ::  ngridps(:)
      real *8, allocatable :: phsteps(:)
      real *8, allocatable :: sthetas(:)
      real *8, allocatable :: xnodesth(:)
      real *8, allocatable :: wtsth(:)
      real *8, allocatable ::  ynm(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
ccc      complex *16 phival(nquadc,numonsphere)
      complex *16 phival(ldp,numonsphere)
      complex *16, allocatable :: phitemp(:,:,:)
      complex *16 imag
      complex *16 ephi,ephik
C
      data imag/(0.0d0,1.0d0)/
C
      pi = 4.0d0*datan(1.0d0)
      allocate(phitemp(-nterms:nterms,nquadc,ngridt))
ccc      allocate(ynm(0:nterms,0:nterms))
      allocate(xnodesth(ngridt))
      allocate(sthetas(ngridt))
      allocate(wtsth(ngridt))
      allocate(ngridps(ngridt))
      allocate(phsteps(ngridt))
c
      call getspheregrid(ngridt,itypep,xnodesth,
     1     sthetas,wtsth,ngridps,phsteps,numonsphere)
c

      do ii=1,ngridt
      do ll=1,nquadc
      do m=-nterms,nterms
         phitemp(m,ll,ii) = 0.0d0
      enddo
      enddo
      enddo
ccc      call prin2(' initalized phitemp *',pi,0)
c
c$OMP PARALLEL PRIVATE(ynm)
c     each thread gets own allocation of ynm
      allocate(ynm(0:nterms,0:nterms))
C$OMP DO PRIVATE(ll,calphai,salphai,phil,cphil,ctheta,m,mabs,ix,n)
      do ii=1,ngridt
         calphai = xnodesth(ii)
         salphai = sthetas(ii)
         do ll=1,nquadc
            phil = 2*pi*(ll-1)/nquadc
            cphil = dcos(phil)
            ctheta = -salphai*cphil
            call ylgndr(nterms,ctheta,ynm)
            do m=-nterms,nterms
               mabs = abs(m)
               do n=mabs,nterms
                  ix = n*(n+1) + m + 1
                  phitemp(m,ll,ii) = phitemp(m,ll,ii) +
     1                localp(ix)*ynm(n,mabs)
               enddo
            enddo
         enddo
      enddo
C$OMP END DO
C$OMP END PARALLEL

ccc      call prin2(' computed phitemp *',pi,0)
c

cccC$OMP PARALLEL DO PRIVATE(jj,ll,calphai,salphai,betaj,cbetaj,sbetaj,phil,cphil,&
cccC$OMP& sphil,x,y,phi,ephik,ephi,m)
      nnn = 0
      do ii = 1,ngridt
         calphai = xnodesth(ii)
         salphai = sthetas(ii)
         do jj = 1,ngridps(ii)
            betaj = 2*pi*(jj-1)/ngridps(ii)
            cbetaj = dcos(betaj)
            sbetaj = dsin(betaj)
            nnn=nnn+1
            do ll = 1,nquadc
               phil = 2*pi*(ll-1)/nquadc
               cphil = dcos(phil)
               sphil = dsin(phil)
               x = cbetaj*calphai*cphil-sbetaj*sphil
               y = sbetaj*calphai*cphil+cbetaj*sphil
               phi = datan2(y,x)
c         
               phival(ll,nnn) = 0.0d0
               ephik = cdexp(imag*phi)
               ephi = ephik**(-nterms)
               do m = -nterms,nterms
                  phival(ll,nnn)=phival(ll,nnn)+phitemp(m,ll,ii)*ephi
                  ephi = ephi*ephik
               enddo
ccc         if ( ((ii.eq.1).and.(jj.eq.1)).and.(ll.eq.1)) then
ccc         call prin2('111 phival is *', phival(ll,jj,ii),2)
ccc         endif
            enddo
         enddo
      enddo
cccC$OMP END PARALLEL DO

ccc      call prin2(' computed phival *',pi,0)
      return
      end
C
C
C
C***********************************************************************
      subroutine mkallgreatcircles(rk,ngridt,itypep,
     1           numonsphere,ngridc,xg,yg,zg)
C***********************************************************************
c
c     create Cartesian coordinates for equatorial circles on sphere of
c     radius rk with z-axis rotated to sparse grid locations.
c
C---------------------------------------------------------------------
c     INPUT:
c
c     rk             radius of sphere
c     ngridt         number of latitude points used on sphere
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    phi_over is set in getgridph (typically = 2).
C     numonsphere    total number of points on sphere
C     ngridc     number of nodes on great circle
c
C---------------------------------------------------------------------
c     OUTPUT:
c
c     xg(l,m)  xcoord of lth node in equatorial circle for
c                z-axis rotated to mth sparse sphere point.
c     yg(l,m)  y-coord of lth node in equatorial circle for
c                z-axis rotated to mth sparse sphere point.
c     zg(l,m)  z-coord of lth node in equatorial circle for
c                z-axis rotated to mth sparse sphere point.
C***********************************************************************
      implicit none
      integer i,j,l,ngridc,ngridt,itypep,numonsphere
      integer nnn
      integer, allocatable ::  ngridps(:)
      real *8 pi,rk,calphai,salphai
      real *8 betaj,cbetaj,sbetaj,phil,cphil,sphil
      real *8 xg(ngridc,numonsphere)
      real *8 yg(ngridc,numonsphere)
      real *8 zg(ngridc,numonsphere)
      real *8, allocatable :: phsteps(:)
      real *8, allocatable :: sthetas(:)
      real *8, allocatable :: xnodesth(:)
      real *8, allocatable :: wtsth(:)
c
      pi = 4.0d0*datan(1.0d0)
      allocate(ngridps(ngridt))
      allocate(phsteps(ngridt))
      allocate(sthetas(ngridt))
      allocate(xnodesth(ngridt))
      allocate(wtsth(ngridt))
c
      call getspheregrid(ngridt,itypep,xnodesth,
     1     sthetas,wtsth,ngridps,phsteps,numonsphere)
c
      nnn=0
      do i = 1,ngridt
         calphai = xnodesth(i)
         salphai = sthetas(i)
         do j = 1,ngridps(i)
            betaj = 2*pi*(j-1)/ngridps(i)
            cbetaj = dcos(betaj)
            sbetaj = dsin(betaj)
            nnn=nnn+1
            do l = 1,ngridc
               phil = 2*pi*(l-1)/ngridc
               cphil = dcos(phil)
               sphil = dsin(phil)
               xg(l,nnn) = rk*(cbetaj*calphai*cphil-sbetaj*sphil)
               yg(l,nnn) = rk*(sbetaj*calphai*cphil+cbetaj*sphil)
               zg(l,nnn) = rk*(-salphai*cphil)
            enddo
         enddo
      enddo
      return
      end
c
c
c
c
C***********************************************************************
      subroutine mkonegreatcircle(rk,cthetause,phiuse,rgamma,
     1           ngridc,xg,yg,zg)
C***********************************************************************
c     Create Cartesian coordinates a single equatorial circle on 
c     sphere of radius rk with z-axis rotated to location 
c     (cthetause, phiuse).
C---------------------------------------------------------------------
c     INPUT:
c
c     rk         radius of sphere
c     ngridt     number of discretization nodes in theta in lab frame
c     xnodesth   discretization nodes in theta in lab frame
c     ngridp     number of discretization nodes in phi in lab frame
c     xnodesph   discretization nodes in phi in lab frame
c     ngridc     number of nodes on great circle
C---------------------------------------------------------------------
c     OUTPUT:
c
c     xg(l)  xcoord of lth node in equatorial circle for
c                z-axis rotated to (xnodesth(i),xnodesph(j)).
c     yg(l)  y-coord of lth node in equatorial circle for
c                z-axis rotated to (xnodesth(i),xnodesph(j)).
c     zg(l)  z-coord of lth node in equatorial circle for
c                z-axis rotated to (xnodesth(i),xnodesph(j)).
c
C***********************************************************************
      implicit none
      integer l,ngridc
      real *8 cthetause, phiuse, rgamma
      real *8 pi,rk,calphai,salphai
      real *8 betaj,cbetaj,sbetaj,phil,cphil,sphil
      real *8 xg(ngridc)
      real *8 yg(ngridc)
      real *8 zg(ngridc)
c
      pi = 4.0d0*datan(1.0d0)
c
      calphai = cthetause
      salphai = dsqrt(1 - calphai**2)
      betaj = phiuse
      cbetaj = dcos(betaj)
      sbetaj = dsin(betaj)
      do l = 1,ngridc
         phil = 2*pi*(l-1)/ngridc
         phil = phil + rgamma
         cphil = dcos(phil)
         sphil = dsin(phil)
         xg(l) = rk*(cbetaj*calphai*cphil-sbetaj*sphil)
         yg(l) = rk*(sbetaj*calphai*cphil+cbetaj*sphil)
         zg(l) = rk*(-salphai*cphil)
      enddo

      return
      end
C
C***********************************************************************
      subroutine sheval_greatcirc(localp,nterms,cthetause,phiuse,
     1           rgamma,nquadc,phival)
C***********************************************************************
C     This subroutine evaluates a spherical harmonic expansion at
C     a single equatorial circle corresponding to z-axis rotation 
C     to (theta,phi), where ctheta = cos(theta).
C     nquadc is the number of points desired on each great circle.
C---------------------------------------------------------------------
C     INPUT:
C
C     localp()  : coefficients of spherical harmonic exp. (packed)
C     nterms    : number of terms in the orig. expansion
C     cthetause : cos theta for y-axis rotation.
C     phiuse    : angle for extrinsic z-axis rotation.
C     rgamma    : rotation of reference image
C     nquadc    : number of output points 
C---------------------------------------------------------------------
C     OUTPUT:
C
C     phival()  : phival(l) corresponds to lth node on equatorial circle
C                for normal corresponding to (theta,phi) rotated
C                by gamma
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nterms
      real *8, allocatable ::  ynm(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 phival(nquadc)
      complex *16, allocatable :: phitemp(:,:)
      complex *16 imag
      complex *16 ephi,ephik
C
      integer m,ix
      data imag/(0.0d0,1.0d0)/
C
      pi = 4.0d0*datan(1.0d0)
      allocate(ynm(0:nterms,0:nterms))
      allocate(phitemp(-nterms:nterms,nquadc))
c
      do ll=1,nquadc
      do m=-nterms,nterms
         phitemp(m,ll) = 0.0d0
      enddo
      enddo
c
      do ll=1,nquadc
         phival(ll) = 0.0d0
      enddo
c
      do ll=1,nquadc
         calphai = cthetause
         salphai = dsqrt(1.0d0 - calphai**2)
         phil = 2*pi*(ll-1)/nquadc
         phil = phil + rgamma
         cphil = dcos(phil)
         ctheta = -salphai*cphil
         call ylgndr(nterms,ctheta,ynm)
         do m=-nterms,nterms
            mabs = abs(m)
            do n=mabs,nterms
               ix = n*(n+1) + m + 1
               phitemp(m,ll) = phitemp(m,ll) +
     1                localp(ix)*ynm(n,mabs)
            enddo
         enddo
      enddo
c
      do ll = 1,nquadc
         calphai = cthetause
         salphai = dsqrt(1.0d0 - calphai**2)
         betaj = phiuse
         cbetaj = dcos(betaj)
         sbetaj = dsin(betaj)
         phil = 2*pi*(ll-1)/nquadc
         phil = phil + rgamma
         cphil = dcos(phil)
         sphil = dsin(phil)
         x = cbetaj*calphai*cphil-sbetaj*sphil
         y = (sbetaj*calphai*cphil+cbetaj*sphil)
         phi = datan2(y,x)
c         
         phival(ll) = 0.0d0
         ephik = cdexp(imag*phi)
         ephi = ephik**(-nterms)
         do m = -nterms,nterms
            phival(ll) = phival(ll) + phitemp(m,ll)*ephi
            ephi = ephi*ephik
         enddo
      enddo
      return
      end
C
C
C
C
C***********************************************************************
      subroutine mkshinterp(thetas,phis,nout,k,nquad,nquadm,values,
     1           icols)
C***********************************************************************
c
c     Create interpolation matrix in simple sparse storage 
c     format. Since we are using a kxk interpolation stencil,
c     we only need to know the column index and interpolation
c     weights.
C---------------------------------------------------------------------
c     INPUT:
c    
c     thetas(),phis() :  coordinates of target points
c     nout            :  number of target points
c     k               :  interpolation order
c     nquad           :  number of nodes in theta
c     nquadm          :  number of nodes in phi
c
C---------------------------------------------------------------------
c     OUTPUT:
c    
c     values(:,:)     :  interpolation weights from reg grid.
c     icols (:,:)     :  unrolled indices of source points for interp.
c
c
c     For each target point, compute the next k*k interpolation
c     weights and increment values,icols.
C***********************************************************************
      implicit real *8 (a-h,o-z)
      real *8 thetas(nout)
      real *8 phis(nout)
      real *8 values(nout,k*k)
      real *8, allocatable :: wtemp(:)
      integer icols(nout,k*k)
      integer, allocatable :: icoltemp(:) 
c
      pi = 4*datan(1.0d0)
      iwrite = 1
C$OMP PARALLEL PRIVATE(icoltemp,wtemp)
c     note each thread gets own copy of these local temp arrays...
      allocate(icoltemp(k*k)) 
      allocate(wtemp(k*k))
c     multithread the loop over filling sparse matrix rows...
C$OMP DO PRIVATE(j)
      do i = 1,nout
         call getinterpsparse(thetas(i),phis(i),k,nquad,nquadm,
     1                    icoltemp,wtemp)
         do j = 1,k*k
            icols(i,j) = icoltemp(j)
            values(i,j) = wtemp(j)
         enddo
      enddo
C$OMP END DO
C$OMP END PARALLEL
      return
      end
c
c
c
c
c
C***********************************************************************
      subroutine getinterpsparse(theta,phi,k,nquad,nquadm,icol,
     1           wtemp)
C***********************************************************************
c     Create one row of interpolation matrix in simple sparse storage 
c     format. Since we are using a kxk interpolation stencil,
c     we only need to know the column index and interpolation
c     weights
C---------------------------------------------------------------------
c     INPUT:
c    
c     theta,phi  : coordinates of target point
c     k          : interpolation order
c     nquad      : number of equspaced nodes in theta
c     nquadm     : number of equspaced node in phi
C---------------------------------------------------------------------
c     OUTPUT:
c
c     icol()     : source pt on sphere in unrolled vector format.
c                  Assuming phival is given in the 2d fortran format:
c                  phival(nquadm,nquad)
c     wtemp()    : corresponding interpolation weights
c
c     f(x,y) = sum_{j1,j_2} f(j_1h_1,j_2h_2) l_{j_1,j_2}(x,y)
c
c     l_{j_1,j_2}(x,y)=\prod_{k_1\neq j_1} (x_1-k_1h_1)/(j_1h_1-k_1h_1)
c                      * \prod_{k_2\neq j_2} (x_2-k_2h_2)/(j_2h_2-k_2h_2)
c
c     Need to grab correctly wrapped (NP,NT) values for "source pt" 
c     weight is computed without regard for wrapping
C***********************************************************************
      implicit real *8 (a-h,o-z)
      real *8 pi,theta,phi
      real *8 wtemp(k*k)
      integer icol(k*k)
c
      pi = 4*datan(1.0d0)
c
c     get nearest grid coords (np0,nt0)
c
      np0 = 1 + nint(nquadm*phi/(2*pi))
ccc      nt0 = 1 + nint(nquad*(theta + pi/(2*nquad))/pi)
      nt0 = nint(nquad*(theta + pi/(2*nquad))/pi)
c
c     need to compute offset from base point before thinking about
c     wrapping interpolation points...
c
      ht = pi/nquad
      hp = 2*pi/nquadm
      dp = phi - (np0-1)*hp
      dth = theta - ((2*nt0-1)*pi)/(2*nquad) 
c
      if (np0 .gt. nquadm) np0 = np0- nquadm
      if (nt0 .gt. nquad) nt0 = nt0-1
c
      if ( (np0.lt.1).or.(np0.gt.nquadm)) then
         call prinf(' np0 is *',np0,1)
      endif
      if ( (nt0.lt.1).or.(nt0.gt.nquad)) then
         call prinf(' nt0 is *',nt0,1)
      endif
c
c
      incr = 0
      do i = -k/2,k/2
      do j = -k/2,k/2
         incr = incr+1
         ip = np0 +i
         it = nt0 +j
         if (it .lt. 1) then
            ip = ip + nquadm/2
            it = 1 - it
         else if (it .gt. nquad) then
            ip = ip + nquadm/2
            it = 2*nquad + 1 - it
         endif
         if (ip .gt. nquadm) then
            ip = ip - nquadm 
         else if (ip .lt. 1) then
            ip = ip + nquadm 
         endif
         if ( (ip.lt.1).or.(ip.gt.nquadm)) then
            call prinf(' ip is *',ip,1)
         endif
         if ( (it.lt.1).or.(it.gt.nquad)) then
            call prinf(' it is *',it,1)
         endif
c
c     now, ip,it are indices of desired contributor to interpolant
c     value ->  lagrange poyl eval.
c
ccc         write(6,*) ' np0, nt0 ',np0, nt0
ccc         write(6,*) ' ip-1 x hp ',(ip-1)*hp
ccc         write(6,*) ' phi,theta ',phi,theta
ccc         if ( (abs(dp).gt.hp/2).or.(abs(dt).gt.ht/2)) then
ccc            write(6,*) ' dp,dth,ht,hp ',dp,dth,ht,hp
ccc         endif
ccc         write(6,*) ' phi,theta ',phi,theta
ccc         write(6,*) ' np0,nt0 ',np0,nt0
ccc         write(6,*) ' dp,dth,ht,hp ',dp,dth,ht,hp
ccc         write(6,*) ' k,i,j,ip,it ',k,i,j,ip,it
         call getlagrangewt(dth,dp,k,i,j,ht,hp,val)
ccc         write(6,*) ' val ',val
         icol(incr) = (it-1)*nquadm + ip
         wtemp(incr) = val               
      enddo
      enddo
ccc      pause
      return
      end
c
c
c
c
C***********************************************************************
      subroutine getlagrangewt(dth,dp,k,i,j,ht,hp,val)
C***********************************************************************
c     Compute interpolation weight at (dth,dp) from i,j node.
C---------------------------------------------------------------------
c     INPUT:
c
c     dth,dp     : offsets from base point (assumed to be origin).
c     k          : interpolation order
c     i,j        : particular grid point whose lagrange polynomial
c                  is evaluated at (dp,dth).
c     ht,hp      : grid spacing in theta and phi, respectively.
c
C---------------------------------------------------------------------
c     OUTPUT:
c
c     val        : value of Lagrange interpolant assoc with i,j point.
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer k,i,j
      real *8 dth,dp,ht,hp,val
c
      prodp = 1.0d0
      dploc = dp/hp
      dtloc = dth/ht
      do ip = -k/2,k/2
         if (i.ne.ip) prodp = prodp*(dp-ip*hp)/(i*hp-ip*hp)  
      enddo
c
      prodt = 1.0d0
      do jt = -k/2,k/2
         if (j.ne.jt) prodt = prodt*(dth-jt*ht)/(j*ht-jt*ht)  
      enddo
      val = prodp*prodt
      return
      end        
c
c
c
c
C***********************************************************************
      subroutine shinterp(nout,k,nquad,nquadm,values,
     1           icols,uval,uout)
C***********************************************************************
c     Apply interpolation matrix in sparse formt.
C---------------------------------------------------------------------
c     INPUT:
c
c     nout          : number of targets
c     k             : interpolation order
c     nquad         : number of nodes in theta
c     nquadm        : number of nodes in phi
c     values(:,:)   : sparse format interpolation weights
c     icols(:,:)    : sparse format col indices
c     uval()        : values on regular grid
C---------------------------------------------------------------------
c     OUTPUT:
c
c     uout()        : values at irregular nodes corresp. to 
c                     rows of values/icols
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer icols(nout,k*k)
      real *8 values(nout,k*k)
      complex *16 uout(nout)
      complex *16 uval(nquadm*nquad)
c
c
C$OMP PARALLEL DO PRIVATE(j)
      do i = 1,nout
         uout(i) = 0.0d0
         do j = 1,k*k
            uout(i) = uout(i) + values(i,j)*uval(icols(i,j))
         enddo
      enddo
C$OMP END PARALLEL DO
      return
      end
c
c
c
c
C***********************************************************************
      subroutine shinterp_adj(nout,k,nquad,nquadm,values,
     1           icols,uin,ugrid)
C***********************************************************************
c     Apply adjoint of interpolation matrix in sparse formt.
C---------------------------------------------------------------------
c     INPUT:
c
c     nout          : number of targets
c     k             : interpolation order
c     nquad         : number of nodes in theta
c     nquadm        : number of nodes in phi
c     values(:,:)   : sparse format interpolation weights
c     icols(:,:)    : sparse format col indices
c     uin()         : input vector (dimensioned as values on irregular grid)
c
c     OUTPUT:
c
c     ugrid()       : adjoint of interp matrix applied to uin
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer icols(nout,k*k)
      real *8 values(nout,k*k)
      complex *16 uin(nout)
      complex *16 ugrid(nquadm*nquad)
c
      ngrid = nquadm*nquad
      do i = 1,ngrid
         ugrid(i) = 0.0d0
      enddo
C     Note since ugrid is added to by different threads, need reduction...
C$OMP PARALLEL DO PRIVATE(i,iuse) REDUCTION(+:ugrid)
      do j = 1,nout
      do i = 1,k*k
         iuse = icols(j,i)
         ugrid(iuse) = ugrid(iuse)+values(j,i)*uin(j)
      enddo
      enddo
C$OMP END PARALLEL DO
      return
      end
c
c
C***********************************************************************
      subroutine sheval_spheregrid_adj(nterms,nquad,nquadm,xnodes,
     1           phival,localp)
C***********************************************************************
C     Compute adjoint of spherical harmonic expansion on unit 
C     sphere of function tabulated at nquadm*nquad grid points.
C---------------------------------------------------------------------
C     INPUT:
C
C     nterms        : order of spherical harmonic expansion
C     nquad         : number of quadrature nodes in theta direction.
C     nquadm        : number of quadrature nodes in phi direction.
C     xnodes()      : Gauss-Legendre nodes x_j = cos theta_j
C     phival(:,:)   : tabulated function
C                      phival(i,j) = phi(sin theta_j cos phi_i,
C                                      sin theta_j sin phi_i,
C                                      cos theta_j).
C
C     NOTE:    We assume phi_i = (i-1)*2*pi/nquadm, as do the 
C              routines in projection.f. However, we permit
C              different numbers of nodes in theta and phi.
C---------------------------------------------------------------------
C     OUTPUT:
C
C     localp()      : cadjoint of sheval applied to phival
C
C           This is different from projshexp since it omits the 
C           quadrature weights. Thus the lines below are commented out
C
Cccc        marray(jj,m) = sum*2*pi/nquadm
Cccc        marray(jj,m) = sum/(2*nquadm)
C
ccc         zmul = marray(jj,m)*wts(jj)
c
C     The latter has incorporated the 1/(4*pi) normalization factor
C     into the azimuthal quadrature weight (2*pi/nquadm).
C
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nterms,nquad,nquadm
      integer l,m,jj,kk,ix
      real *8 xnodes(nquad)
      real *8, allocatable ::  ynm(:,:)
      complex *16 phival(nquadm,nquad)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 ephi,imag,emul,sum,zmul,emul1
      complex *16, allocatable :: marray(:,:)
      data imag/(0.0d0,1.0d0)/
C
      pi = 4.0d0*datan(1.0d0)
      allocate(marray(nquad,-nterms:nterms))
c
c     initialize localp exp to zero
c
      do ix = 1,(nterms+1)*(nterms+1)
         localp(ix) = 0.0d0
      enddo
c
c     create marray (intermediate array)
c
      do m=-nterms,nterms
         emul = cdexp(imag*m*2*pi/nquadm)
c     for simplicity we thread over jj since m loop has emul changing...
C$OMP PARALLEL DO PRIVATE(sum,ephi,kk)
         do jj=1,nquad
            sum = 0
            ephi = 1.0d0
            do kk = 1,nquadm
ccc               ephi = cdexp(imag*m*(kk-1)*2*pi/nquadm)
               sum = sum + phival(kk,jj)*dconjg(ephi)
               ephi = ephi*emul
            enddo
ccc         marray(jj,m) = sum*2*pi/nquadm
ccc         marray(jj,m) = sum/(2*nquadm)
            marray(jj,m) = sum
         enddo
C$OMP END PARALLEL DO
c     I don't understand what value emul1 has - it's never set! (ahb):
         emul = emul*emul1
      enddo
c
c     get local exp
c
C$OMP PARALLEL PRIVATE(ynm)
c     note each thread gets own allocation of ynm output from ylgndr
      allocate(ynm(0:nterms,0:nterms))
C$OMP DO PRIVATE(cthetaj,m,zmul,l,ix) REDUCTION(+:localp) 
      do jj=1,nquad
         cthetaj = xnodes(jj)
         call ylgndr(nterms,cthetaj,ynm)
         do m=-nterms,nterms
ccc            zmul = marray(jj,m)*wts(jj)
            zmul = marray(jj,m)
            do l=abs(m),nterms
               ix = l*(l+1) + m + 1
               localp(ix) = localp(ix) + zmul*ynm(l,abs(m))
            enddo
         enddo
      enddo
C$OMP END DO
C$OMP END PARALLEL
      return
      end
c
c
C***********************************************************************
      subroutine quadscale(nquad,nquadm,wts,phival)
C***********************************************************************
C     scale function phival on sphere by quadrature weights.
C---------------------------------------------------------------------
C     INPUT:
C
C     nquad       : number of quadrature nodes in theta direction.
C     nquadm      : number of quadrature nodes in phi direction.
C     wts()       : quadrature wrights in theta
C     phival(:,:) : tabulated function
C---------------------------------------------------------------------
C     OUTPUT:
C
C     phival(:,:) : OVER-WRITTEN by phival*(quadrature weight)
C
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nquad,nquadm
      integer jj,kk
      real *8 wts(1)
      complex *16 phival(nquadm,nquad)
C
      pi = 4.0d0*datan(1.0d0)
c
      do jj=1,nquad
         w = wts(jj)/(2*nquadm)
         do kk = 1,nquadm
            phival(kk,jj) = phival(kk,jj)*w
         enddo
      enddo
      return
      end
C
C
C
C
C***********************************************************************
      subroutine sheval_spheregrid(localp,phival,
     1           nterms,nquad,nquadm,xnodes)
C***********************************************************************
C     Evaluates a spherical harmonic expansion on a tensor product
C     nquad x nquadm grid on the unit sphere. 
C---------------------------------------------------------------------
C     INPUT:
C
C     localp      : coefficients of spherical harmonic exp. (packed)
C     nterms      : number of terms in the orig. expansion
C     nquad       : number of quadrature nodes in theta
C     nquadm      : number of quadrature nodes in phi
C     xnodes()    : Legendre nodes in theta (x_j = cos theta_j).
C---------------------------------------------------------------------
C     OUTPUT:
C
C     phival(:,:) : function value on tensor product
C                mesh on target sphere. phi is the fast variable, theta slow
C***********************************************************************
C     converted to OPENMP, Barnett 6/22/16
C
      implicit real *8 (a-h,o-z)
      integer nterms
      real *8 xnodes(nquad)
      real *8, allocatable ::  ynm(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 phival(nquadm,nquad)
      complex *16, allocatable :: phitemp(:,:)
      complex *16 imag
      complex *16 ephi,ephik
C
      integer m
      data imag/(0.0d0,1.0d0)/

c     needed for output that makes it to MATLAB terminal
c      character(len=80) str
c      integer*4, external :: mexPrintf
c     needed for omp
c      integer OMP_GET_THREAD_NUM, omp_get_num_threads


      pi = 4.0d0*datan(1.0d0)
      allocate(ynm(0:nterms,0:nterms))
      allocate(phitemp(-nterms:nterms,nquad))
c
c$OMP PARALLEL DO
      do jj=1,nquad
      do m=-nterms,nterms
         phitemp(m,jj) = 0.0d0
      enddo
      enddo
c$OMP END PARALLEL DO
c
cccc$OMP PARALLEL
c      if (omp_get_thread_num().eq.0) then
c         write(str,*) omp_get_num_threads(), ' threads',achar(10)
c         i=mexPrintf(str)
c      endif
      
c$OMP PARALLEL DO PRIVATE(ctheta,stheta,ynm,m,mabs,ix,n)
      do jj=1,nquad
         ctheta = xnodes(jj)
         stheta = dsqrt(1.0d0 - ctheta**2)
         call ylgndr(nterms,ctheta,ynm)
         do m=-nterms,nterms
            mabs = abs(m)
            do n=mabs,nterms
               ix = n*(n+1) + m + 1
               phitemp(m,jj) = phitemp(m,jj) +
     1                localp(ix)*ynm(n,mabs)
            enddo
         enddo
      enddo
c$OMP END PARALLEL DO
c
c$OMP PARALLEL DO PRIVATE(kk,ephik,ephi,m)
      do jj = 1,nquad
      do kk = 1,nquadm
         phival(kk,jj) = 0.0d0
         ephik = cdexp(2*pi*(kk-1)*imag/nquadm)
         ephi = ephik**(-nterms)
         do m = -nterms,nterms
            phival(kk,jj) = phival(kk,jj) + phitemp(m,jj)*ephi
            ephi = ephi*ephik
         enddo
      enddo
      enddo
c$OMP END PARALLEL DO
      return
      end
c
c
c
C
C
C***********************************************************************
      subroutine kspacegrid_to_model(ffhat,rkmax,nterms_sph,
     1                  ityper,ngridr,nlats,itypep,numonsphere,modsph,
     2                  nsphstore)
C***********************************************************************
C     Converts from discrete spherical grid to model: spherical harmonic
c     expansions on successive spheres.
C---------------------------------------------------------------------
C     INPUT:
C
C     ffhat      : samples of fucntion in k space on spherical grid
C     rkmax      : maximul radius in k space
c     nterms_sph : array of length ngridr defining the orders of the 
c                  spherical harmonic expansions on successive spheres.
c     ityper       quadrature scheme in radial direction
c                     1 = Gaussian
c                     0 = uniform grid from 1..ngridr
c                         rad(i) = rkmax*i/ngridr
c     ngridr       number of nodes in r
c     nlats()      number of latitude points used on each sphere
c                  permits coarser sampling near origin 
c     itypep       quadrature scheme in phi direction
c                     0 = same on all latitudes (which oversamples poles)
c                     1 = adaptive (undersamples toward poles)
c                  if itypep=0
c                     nphi = nint(nlats(i)*phi_over)
c                  if itypep=1
c                     nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                  phi_over is defined in getgridph and typically
c                  set to 2.
c     numonsphere  number of points used on sphere, defined by 
c                  ngridt,itypep
c     nsphstore    size of spherical harmonic model 
c                  (unrolled on all spheres)
C---------------------------------------------------------------------
C     OUTPUT:
C
C     modsph(:)  : ffhat  expressed in spherical harmonics in successive
C                  spheres
C***********************************************************************

      implicit real *8 (a-h,o-z)
      integer ityper,ngridr,itypep
      integer i,nstart,nsphstart
      integer nlats(ngridr)
      integer numonsphere(ngridr)
      integer nterms_sph(ngridr)
      complex *16 ffhat(*)
      complex *16 modsph(0:nsphstore-1)
c
c
      pi = 4.0d0*datan(1.0d0)
      nstart = 1
      nsphstart = 0
      do i = 1,ngridr
         call projshexp(ffhat(nstart),numonsphere(i),nlats(i),itypep,
     1       nterms_sph(i),modsph(nsphstart))
         nstart = nstart + numonsphere(i)
         nsph = (nterms_sph(i)+1)**2
         nsphstart = nsphstart + nsph
      enddo
      return
      end

c
C
C
C***********************************************************************
      subroutine model_to_kspacegrid(ffhat,rkmax,nterms_sph,
     1                  ityper,ngridr,nlats,itypep,numonsphere,modsph,
     2                  nsphstore)
c
C***********************************************************************
C     Evaluates model at discrete points: 
c     spherical harmonic expansions on successive 
c     spheres (nodsph) to discrete spherical grid.
C---------------------------------------------------------------------
C     INPUT:
C
C     modsph(:)  : ffhat  expressed in spherical harmonics in successive
C                  spheres
C
C     rkmax      : maximul radius in k space
c     nterms_sph : array of length ngridr defining the orders of the 
c                  spherical harmonic expansions on successive spheres.
c     ityper       quadrature scheme in radial direction
c                     1 = Gaussian
c                     0 = uniform grid from 1..ngridr
c                         rad(i) = rkmax*i/ngridr
c     ngridr       number of nodes in r
c     nlats()      number of latitude points used on each sphere
c                  permits coarser sampling near origin 
c     itypep       quadrature scheme in phi direction
c                     0 = same on all latitudes (which oversamples poles)
c                     1 = adaptive (undersamples toward poles)
c                  if itypep=0
c                     nphi = nint(nlats(i)*phi_over)
c                  if itypep=1
c                     nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                  phi_over is defined in getgridph and typically
c                  set to 2.
c     numonsphere  number of points used on sphere, defined by 
c                  ngridt,itypep
c     nsphstore    size of spherical harmonic model 
c                  (unrolled on all spheres)
C---------------------------------------------------------------------
C     OUTPUT:
C
C     ffhat      : samples of function in k space on spherical grid
C***********************************************************************

      implicit real *8 (a-h,o-z)
      integer ityper,ngridr,itypep
      integer i,nstart,nsphstart
      integer nlats(ngridr)
      integer numonsphere(ngridr)
      integer nterms_sph(ngridr)
      real *8, allocatable :: xnodesr(:),wtsr(:)
      complex *16 ffhat(*)
      complex *16 modsph(0:nsphstore-1)
c
      allocate(xnodesr(ngridr))
      allocate(wtsr(ngridr))
      call getgridr(rkmax,ngridr,ityper,xnodesr,wtsr)
c
      pi = 4.0d0*datan(1.0d0)
      nstart = 1
      nsphstart = 0
      do i = 1,ngridr
         call evalshexp(modsph(nsphstart),nterms_sph(i),nlats(i),
     1          itypep,numonsphere(i),ffhat(nstart))
         nstart = nstart + numonsphere(i)
         nsph = (nterms_sph(i)+1)**2
         nsphstart = nsphstart + nsph
      enddo
      return
      end

!> Doxygen comment: ;\n
!>    Fortran library for sph harm projection and eval on grids & circles ;\n
!>    ;\n
!>    Stuff from Leslie/Zydrunas FMMLIB3D, and localexp3d. ;\n
!>    pulled by Barnett 7/31/15 ;\n
!>    modified by Greengard 8/1/15 ;\n
!>    ;\n
!>    routines that end in 'p' use the packed representation of spherical harmonic coefficients ;\n
!>    stored linearly without gaps in the (n,m) order of ;\n
!>      (0,0), (1,-1), (1,0), (1,1), (2,-2), (2,-1), (2,0), (2,1), (2,2), (3,-3), ... ;\n
!>    The total number of coefficients is (nterms+1)*(nterms+1) ;\n
!>    for an expansion up to order nterms (inclusive). ;\n
!>    Using 1 based indexing, the linear index for element (n, m) is ix = n*(n+1)+m+1 ;\n
!>    ;\n
!>    ;\n
!>********************************************************************** ;\n
!>    calling sequences changed from Barnett's spharmrouts.f  ;\n
!>********************************************************************** ;\n
!> Doxygen comment: ;\n
C     Fortran library for sph harm projection and eval on grids & circles
C
C     Stuff from Leslie/Zydrunas FMMLIB3D, and localexp3d.
C     pulled by Barnett 7/31/15
C     modified by Greengard 8/1/15
C
C     routines that end in 'p' use the packed representation of spherical harmonic coefficients
C     stored linearly without gaps in the (n,m) order of
C       (0,0), (1,-1), (1,0), (1,1), (2,-2), (2,-1), (2,0), (2,1), (2,2), (3,-3), ...
C     The total number of coefficients is (nterms+1)*(nterms+1)
C     for an expansion up to order nterms (inclusive).
C     Using 1 based indexing, the linear index for element (n, m) is ix = n*(n+1)+m+1
C
C
C***********************************************************************
C     calling sequences changed from Barnett's spharmrouts.f 
C***********************************************************************
c
C***********************************************************************
      subroutine projloc3dp(nterms,nquad,nquadm,xnodes,wts,
     1           phival,localp)
C***********************************************************************
C     Usage:
C
C           compute spherical harmonic expansion on unit sphere
C           of function tabulated at nquad*nquad grid points.
C---------------------------------------------------------------------
C     INPUT:
C
C           nterms = order of spherical harmonic expansion
C           nquad  = number of quadrature nodes in theta direction.
C           nquadm = number of quadrature nodes in phi direction.
C           xnodes = Gauss-Legendre nodes x_j = cos theta_j
C           wts    = Gauss quadrature weights
C           phival = tabulated function
C                    phival(i,j) = phi(sin theta_j cos phi_i,
C                                      sin theta_j sin phi_i,
C                                      cos theta_j).
C
C           NOTE:    We assume phi_i = (i-1)*2*pi/nquadm, as do the 
C                    routines in projection.f. However, we permit
C                    different numbers of nodes in theta and phi.
C***********************************************************************
C     OUTPUT:
C
C           localp = coefficients of s.h. expansion (packed)
C
C     NOTE:
C
C     yrecursion.f produces Ynm with a nonstandard scaling:
C     (without the 1/sqrt(4*pi)). Thus the orthogonality relation
C     is
C             \int_S  Y_nm Y_n'm'*  dA = delta(n) delta(m) * 4*pi. 
C
C     In the first loop below, you see
C
Cccc        marray(jj,m) = sum*2*pi/nquadm
C           marray(jj,m) = sum/(2*nquadm)
C
C     The latter has incorporated the 1/(4*pi) normalization factor
C     into the azimuthal quadrature weight (2*pi/nquadm).
C
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nterms,nquad,nquadm
      integer l,m,jj,kk,ix
      real *8 wts(1),xnodes(1)
      real *8, allocatable ::  ynm(:,:)
      complex *16 phival(nquadm,nquad)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 ephi,imag,emul,sum,zmul,emul1
      complex *16, allocatable :: marray(:,:)
      data imag/(0.0d0,1.0d0)/
C
      pi = 4.0d0*datan(1.0d0)
      allocate(ynm(0:nterms,0:nterms))
      allocate(marray(nquad,-nterms:nterms))
c
c     initialize localp exp to zero
c
      do ix = 1,(nterms+1)*(nterms+1)
         localp(ix) = 0.0d0
      enddo
c
c     create marray (intermediate array)
c
      do m=-nterms,nterms
         emul = cdexp(imag*m*2*pi/nquadm)
         do jj=1,nquad
            sum = 0
            ephi = 1.0d0
            do kk = 1,nquadm
ccc               ephi = cdexp(imag*m*(kk-1)*2*pi/nquadm)
               sum = sum + phival(kk,jj)*dconjg(ephi)
               ephi = ephi*emul
            enddo
ccc         marray(jj,m) = sum*2*pi/nquadm
            marray(jj,m) = sum/(2*nquadm)
         enddo
c     I don't understand what value emul1 has - it's never set! (ahb):
         emul = emul*emul1
      enddo
c
c     get local exp
c
      do jj=1,nquad
         cthetaj = xnodes(jj)
         call ylgndr(nterms,cthetaj,ynm)
         do m=-nterms,nterms
            zmul = marray(jj,m)*wts(jj)
            do l=abs(m),nterms
               ix = l*(l+1) + m + 1
               localp(ix) = localp(ix) + zmul*ynm(l,abs(m))
            enddo
         enddo
      enddo
      return
      end



C***********************************************************************
      subroutine shevalspherep(localp,phival,
     1           nterms,nquad,nquadm,xnodes)
C***********************************************************************
C
C     This subroutine evaluates a spherical harmonic expansion on an 
C     nquad x nquadm grid on the unit sphere. 
C
C---------------------------------------------------------------------
C     INPUT:
C
C     localp   : coefficients of spherical harmonic exp. (packed)
C     nterms   : number of terms in the orig. expansion
C     nquad    : number of quadrature nodes in theta
C     nquadm   : number of quadrature nodes in phi
C     xnodes   : Legendre nodes in theta (x_j = cos theta_j).
C---------------------------------------------------------------------
C     OUTPUT:
C
C     phival   : function value on tensor product
C                mesh on target sphere. phi is the fast variable, theta slow
C***********************************************************************
C     converted to OPENMP, Barnett 6/22/16
C
      implicit real *8 (a-h,o-z)
      integer nterms
      real *8 xnodes(1)
      real *8, allocatable ::  ynm(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 phival(nquadm,nquad)
      complex *16, allocatable :: phitemp(:,:)
      complex *16 imag
      complex *16 ephi,ephik
C
      integer m
      data imag/(0.0d0,1.0d0)/

c     needed for output that makes it to MATLAB terminal
c      character(len=80) str
c      integer*4, external :: mexPrintf
c     needed for omp
c      integer OMP_GET_THREAD_NUM, omp_get_num_threads


      pi = 4.0d0*datan(1.0d0)
      allocate(ynm(0:nterms,0:nterms))
      allocate(phitemp(-nterms:nterms,nquad))
c
c$OMP PARALLEL DO
      do jj=1,nquad
      do m=-nterms,nterms
         phitemp(m,jj) = 0.0d0
      enddo
      enddo
c$OMP END PARALLEL DO
c
cccc$OMP PARALLEL
c      if (omp_get_thread_num().eq.0) then
c         write(str,*) omp_get_num_threads(), ' threads',achar(10)
c         i=mexPrintf(str)
c      endif
      
c$OMP PARALLEL DO PRIVATE(ctheta,stheta,ynm,m,mabs,ix,n)
      do jj=1,nquad
         ctheta = xnodes(jj)
         stheta = dsqrt(1.0d0 - ctheta**2)
         call ylgndr(nterms,ctheta,ynm)
         do m=-nterms,nterms
            mabs = abs(m)
            do n=mabs,nterms
               ix = n*(n+1) + m + 1
               phitemp(m,jj) = phitemp(m,jj) +
     1                localp(ix)*ynm(n,mabs)
            enddo
         enddo
      enddo
c$OMP END PARALLEL DO
c
c$OMP PARALLEL DO PRIVATE(kk,ephik,ephi,m)
      do jj = 1,nquad
      do kk = 1,nquadm
         phival(kk,jj) = 0.0d0
         ephik = cdexp(2*pi*(kk-1)*imag/nquadm)
         ephi = ephik**(-nterms)
         do m = -nterms,nterms
            phival(kk,jj) = phival(kk,jj) + phitemp(m,jj)*ephi
            ephi = ephi*ephik
         enddo
      enddo
      enddo
c$OMP END PARALLEL DO
      return
      end


cc
C***********************************************************************
      subroutine shevalspherecircsp(localp,phival,
     1           nterms,nquad,nquadm,xnodes,nquadc)
C***********************************************************************
C
C     This subroutine evaluates a spherical harmonic expansion at
C     the equatorial circles for z-axis rotation to all standard spherical
C     nodes (on an nquad x nquadm grid). nquadc is the number of points
C     desired on each great circle.
C
C---------------------------------------------------------------------
C     INPUT:
C
C     localp   : coefficients of spherical harmonic exp. (packed)
C     nterms   : number of terms in the orig. expansion
C     nquad    : number of quadrature nodes in theta
C     nquadm   : number of quadrature nodes in phi
C     xnodes   : Legendre nodes in theta (x_j = cos theta_j).
C     nquadc   : number of points on equator for each rotation
C---------------------------------------------------------------------
C     OUTPUT:
C
C     phival   : (l,j,i) corresponds to lth node on equatorial circle
C                        for normal corresponding to (theta_i,phi_j).
C     NOTE the ordering of output grids.
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nterms
      real *8 xnodes(1)
      real *8, allocatable ::  ynm(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 phival(nquadc,nquadm,nquad)
      complex *16, allocatable :: phitemp(:,:,:)
      complex *16 imag
      complex *16 ephi,ephik
C
      integer m,ix
      data imag/(0.0d0,1.0d0)/
C
      pi = 4.0d0*datan(1.0d0)
      allocate(phitemp(-nterms:nterms,nquadc,nquad))
c
      do ii=1,nquad
      do ll=1,nquadc
      do m=-nterms,nterms
         phitemp(m,ll,ii) = 0.0d0
      enddo
      enddo
      enddo
ccc      call prin2(' initalized phitemp *',pi,0)
c
c$OMP PARALLEL PRIVATE(ynm)
c     each thread gets own allocation of ynm
      allocate(ynm(0:nterms,0:nterms))
C$OMP DO PRIVATE(ll,calphai,salphai,phil,cphil,ctheta,m,mabs,ix,n)
      do ii=1,nquad
      do ll=1,nquadc
         calphai = xnodes(ii)
         salphai = dsqrt(1.0d0 - calphai**2)
ccc         phil = 2*pi*ll/nquadc
         phil = 2*pi*(ll-1)/nquadc
         cphil = dcos(phil)
         ctheta = -salphai*cphil
         call ylgndr(nterms,ctheta,ynm)
         do m=-nterms,nterms
            mabs = abs(m)
            do n=mabs,nterms
               ix = n*(n+1) + m + 1
               phitemp(m,ll,ii) = phitemp(m,ll,ii) +
     1                localp(ix)*ynm(n,mabs)
            enddo
         enddo
      enddo
      enddo
C$OMP END DO
C$OMP END PARALLEL

ccc      call prin2(' computed phitemp *',pi,0)
c

C$OMP PARALLEL DO PRIVATE(jj,ll,calphai,salphai,betaj,cbetaj,sbetaj,phil,cphil,&
C$OMP& sphil,x,y,phi,ephik,ephi,m)
      do ii = 1,nquad
      do jj = 1,nquadm
      do ll = 1,nquadc
         calphai = xnodes(ii)
         salphai = dsqrt(1.0d0 - calphai**2)
ccc         betaj = 2*pi*jj/nquadm
         betaj = 2*pi*(jj-1)/nquadm
         cbetaj = dcos(betaj)
         sbetaj = dsin(betaj)
ccc         phil = 2*pi*ll/nquadc
         phil = 2*pi*(ll-1)/nquadc
         cphil = dcos(phil)
         sphil = dsin(phil)
         x = cbetaj*calphai*cphil-sbetaj*sphil
         y = (sbetaj*calphai*cphil+cbetaj*sphil)
ccc         zg = -salphai*cphil
ccc         if ( ((ii.eq.1).and.(jj.eq.1)).and.(ll.eq.1)) then
ccc         call prin2('111 x is *', x,1)
ccc         call prin2('111 y is *', y,1)
ccc         call prin2('111 zg is *', zg,1)
ccc         endif
         phi = datan2(y,x)
c         
         phival(ll,jj,ii) = 0.0d0
         ephik = cdexp(imag*phi)
         ephi = ephik**(-nterms)
         do m = -nterms,nterms
            phival(ll,jj,ii) = phival(ll,jj,ii) + phitemp(m,ll,ii)*ephi
            ephi = ephi*ephik
         enddo
ccc         if ( ((ii.eq.1).and.(jj.eq.1)).and.(ll.eq.1)) then
ccc         call prin2('111 phival is *', phival(ll,jj,ii),2)
ccc         endif
      enddo
      enddo
      enddo
C$OMP END PARALLEL DO

ccc      call prin2(' computed phival *',pi,0)
      return
      end


C***********************************************************************
      subroutine shevalsphereonecircp(localp,nterms,cthetause,phiuse,
     1           rgamma,nquadc,phival)
C***********************************************************************
C
C     This subroutine evaluates a spherical harmonic expansion at
C     a single equatorial circle corresponding to z-axis rotation 
C     to (theta,phi), where ctheta = cos(theta).
C     nquadc is the number of points desired on each great circle.
C
C---------------------------------------------------------------------
C     INPUT:
C
C     localp    : coefficients of spherical harmonic exp. (packed)
C     nterms    : number of terms in the orig. expansion
C     cthetause : cos theta for y-axis rotation.
C     phiuse    : angle for extrinsic z-axis rotation.
C     rgamma    : rotation of reference image
C     nquadc   : number of output points 
C---------------------------------------------------------------------
C     OUTPUT:
C
C     phival   : phival(l) corresponds to lth node on equatorial circle
C                for normal corresponding to (theta,phi) rotated
C                by gamma
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nterms
      real *8, allocatable ::  ynm(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 phival(nquadc)
      complex *16, allocatable :: phitemp(:,:)
ccc      complex *16, allocatable :: phivaltemp(:)
ccc      complex *16, allocatable :: wsave(:)
      complex *16 imag
      complex *16 ephi,ephik
C
      integer m,ix
      data imag/(0.0d0,1.0d0)/
C
      pi = 4.0d0*datan(1.0d0)
      allocate(ynm(0:nterms,0:nterms))
      allocate(phitemp(-nterms:nterms,nquadc))
ccc      allocate(wsave(4*nquadc+16))

ccc      allocate(phivaltemp(nquadc))
c
      do ll=1,nquadc
      do m=-nterms,nterms
         phitemp(m,ll) = 0.0d0
      enddo
      enddo
c
      do ll=1,nquadc
         phival(ll) = 0.0d0
      enddo
ccc      call prin2(' initalized phitemp *',pi,0)
c
      do ll=1,nquadc
         calphai = cthetause
         salphai = dsqrt(1.0d0 - calphai**2)
ccc         call prin2(' calphai is *',calphai,1)
         phil = 2*pi*(ll-1)/nquadc
         phil = phil + rgamma
         cphil = dcos(phil)
         ctheta = -salphai*cphil
         call ylgndr(nterms,ctheta,ynm)
         do m=-nterms,nterms
            mabs = abs(m)
            do n=mabs,nterms
               ix = n*(n+1) + m + 1
               phitemp(m,ll) = phitemp(m,ll) +
     1                localp(ix)*ynm(n,mabs)
            enddo
         enddo
      enddo
ccc      call prin2(' computed phitemp *',phitemp(0,1),2)
ccc      call prin2(' computed phitemp *',phitemp,2*(2*nterms+1)*nquadc)
c
      do ll = 1,nquadc
c         call prinf(' ll= *',ll,1)
         calphai = cthetause
         salphai = dsqrt(1.0d0 - calphai**2)
         betaj = phiuse
         cbetaj = dcos(betaj)
         sbetaj = dsin(betaj)
         phil = 2*pi*(ll-1)/nquadc
         phil = phil + rgamma
         cphil = dcos(phil)
         sphil = dsin(phil)
         x = cbetaj*calphai*cphil-sbetaj*sphil
         y = (sbetaj*calphai*cphil+cbetaj*sphil)
         phi = datan2(y,x)
c         
         phival(ll) = 0.0d0
         ephik = cdexp(imag*phi)
         ephi = ephik**(-nterms)
         do m = -nterms,nterms
            phival(ll) = phival(ll) + phitemp(m,ll)*ephi
            ephi = ephi*ephik
c         call prin2(' computed phival(ll) = *',phival(ll),2)
         enddo
      enddo
ccc      do ll = 1,nquadc
ccc         phivaltemp(ll) = phival(ll)
ccc      enddo
ccc      
ccc      call dcffti(nquadc,wsave)
ccc      call dcfftf(nquadc,phivaltemp,wsave)
ccc      do ll = 1,nquadc
ccc         phivaltemp(ll) = phivaltemp(ll)/nquadc
ccc      enddo
ccc      call prin2(' phivaltemp *',phivaltemp,2*nquadc)
ccc      call prin2(' rgamma *',rgamma,1)
ccc      call prinf(' nquadc *',nquadc,1)
ccc      do ll = 1,nquadc
ccc         phival(ll) = 0.0d0
ccc         phi = 2*pi*(ll-1)/nquadc + rgamma
ccc         do ii = 1,nquadc/2
ccc            phival(ll) = phival(ll) + 
ccc     1                   cdexp(phi*(ii-1)*imag)*phivaltemp(ii)
ccc         enddo
ccc         do ii = 1,nquadc/2-1
ccc            iuse = -ii
ccc            phival(ll) = phival(ll) + 
ccc     1                  cdexp(phi*iuse*imag)*phivaltemp(nquadc-ii+1)
ccc         enddo
ccc      enddo
ccc      call prin2(' phival *',phival,2*nquadc)
      return
      end

C***********************************************************************
      subroutine shevalspherep_adj(nterms,nquad,nquadm,xnodes,
     1           phival,localp)
C***********************************************************************
C     Usage:
C
C           compute adjoint of spherical harmonic expansion on unit 
C           sphere of function tabulated at nquadm*nquad grid points.
C---------------------------------------------------------------------
C     INPUT:
C
C           nterms = order of spherical harmonic expansion
C           nquad  = number of quadrature nodes in theta direction.
C           nquadm = number of quadrature nodes in phi direction.
C           xnodes = Gauss-Legendre nodes x_j = cos theta_j
C           phival = tabulated function
C                    phival(i,j) = phi(sin theta_j cos phi_i,
C                                      sin theta_j sin phi_i,
C                                      cos theta_j).
C
C           NOTE:    We assume phi_i = (i-1)*2*pi/nquadm, as do the 
C                    routines in projection.f. However, we permit
C                    different numbers of nodes in theta and phi.
C***********************************************************************
C     OUTPUT:
C
C           localp = cadjoint of sheval applied to phival
C           This is different from projloc3dp since it omits the 
C           quadrature weights. Thus the lines below are commented out
C
Cccc        marray(jj,m) = sum*2*pi/nquadm
Cccc        marray(jj,m) = sum/(2*nquadm)
C
ccc         zmul = marray(jj,m)*wts(jj)
c
C     The latter has incorporated the 1/(4*pi) normalization factor
C     into the azimuthal quadrature weight (2*pi/nquadm).
C
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nterms,nquad,nquadm
      integer l,m,jj,kk,ix
      real *8 xnodes(1)
      real *8, allocatable ::  ynm(:,:)
      complex *16 phival(nquadm,nquad)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 ephi,imag,emul,sum,zmul,emul1
      complex *16, allocatable :: marray(:,:)
      data imag/(0.0d0,1.0d0)/
C
      pi = 4.0d0*datan(1.0d0)
      allocate(marray(nquad,-nterms:nterms))
c
c     initialize localp exp to zero
c
      do ix = 1,(nterms+1)*(nterms+1)
         localp(ix) = 0.0d0
      enddo
c
c     create marray (intermediate array)
c
      do m=-nterms,nterms
         emul = cdexp(imag*m*2*pi/nquadm)
c     for simplicity we thread over jj since m loop has emul changing...
C$OMP PARALLEL DO PRIVATE(sum,ephi,kk)
         do jj=1,nquad
            sum = 0
            ephi = 1.0d0
            do kk = 1,nquadm
ccc               ephi = cdexp(imag*m*(kk-1)*2*pi/nquadm)
               sum = sum + phival(kk,jj)*dconjg(ephi)
               ephi = ephi*emul
            enddo
ccc         marray(jj,m) = sum*2*pi/nquadm
ccc         marray(jj,m) = sum/(2*nquadm)
            marray(jj,m) = sum
         enddo
C$OMP END PARALLEL DO
c     I don't understand what value emul1 has - it's never set! (ahb):
         emul = emul*emul1
      enddo
c
c     get local exp
c
C$OMP PARALLEL PRIVATE(ynm)
c     note each thread gets own allocation of ynm output from ylgndr
      allocate(ynm(0:nterms,0:nterms))
C$OMP DO PRIVATE(cthetaj,m,zmul,l,ix) REDUCTION(+:localp) 
      do jj=1,nquad
         cthetaj = xnodes(jj)
         call ylgndr(nterms,cthetaj,ynm)
         do m=-nterms,nterms
ccc            zmul = marray(jj,m)*wts(jj)
            zmul = marray(jj,m)
            do l=abs(m),nterms
               ix = l*(l+1) + m + 1
               localp(ix) = localp(ix) + zmul*ynm(l,abs(m))
            enddo
         enddo
      enddo
C$OMP END DO
C$OMP END PARALLEL
      return
      end
c
c
C***********************************************************************
      subroutine quadscale99(nquad,nquadm,wts,phival)
C***********************************************************************
      implicit real *8 (a-h,o-z)
      integer nquad,nquadm
      integer jj,kk
      real *8 wts(1)
      complex *16 phival(nquadm,nquad)
C
      pi = 4.0d0*datan(1.0d0)
c
      do jj=1,nquad
         w = wts(jj)/(2*nquadm)
         do kk = 1,nquadm
            phival(kk,jj) = phival(kk,jj)*w
         enddo
      enddo
      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sph_gridconfig199(ngridr, sph_size, sph_nterms, 
     1     sph_sizes,sph_startix)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     Configure the grid of spherical harmonics expansions by radius
c
c     Inputs:
c     ngridr: number of radial grid points
c
c     Outputs:
c     sph_size:            total size of the array required to store the spherical harmonics expansions
c     sph_sizes(ngridr):   individual sizes of spherical hardmonics expansion by radius
c     sph_nterms(ngridr):  number of terms of the expansion by radius (nterms)
c     sph_startix(ngridr): starting index for an expansion by radius
c
      implicit none
      integer ngridr
      integer sph_size, sph_sizes(ngridr), sph_startix(ngridr)
      integer sph_nterms(ngridr)
c
      integer i, n
c
      sph_size = 0
      do i = 1,ngridr
c        hard code for all expansions
c         n = 30
c     size of expansions varies with i
c         n = max(5,i)
         n = i+2
         sph_nterms(i) = n
         sph_sizes(i) = (n+1)*(n+1)
         sph_startix(i) = sph_size

         sph_size = sph_size + (n+1)*(n+1)
      enddo

      return
      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sph_gridconfig99(ngridr, sph_size, sph_nterms, 
     1     sph_sizes,sph_startix, xnodesr)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     Configure the grid of spherical harmonics expansions by radius
c
c     Inputs:
c     ngridr: number of radial grid points
c
c     Outputs:
c     sph_size:            total size of the array required to store the spherical harmonics expansions
c     sph_sizes(ngridr):   individual sizes of spherical hardmonics expansion by radius
c     sph_nterms(ngridr):  number of terms of the expansion by radius (nterms)
c     sph_startix(ngridr): starting index for an expansion by radius
c
      implicit none
      integer ngridr
      integer sph_size, sph_sizes(ngridr), sph_startix(ngridr)
      integer sph_nterms(ngridr)
      real *8 xnodesr(ngridr)
c
      integer i, n
c
      sph_size = 0
      do i = 1,ngridr
c        hard code for all expansions
c         n = 30
c     size of expansions varies with i
         n = floor(xnodesr(i))+2
c         write(6,*) i, xnodesr(i),n
         sph_nterms(i) = n
         sph_sizes(i) = (n+1)*(n+1)
         sph_startix(i) = sph_size

         sph_size = sph_size + (n+1)*(n+1)
      enddo

      return
      end






!> Doxygen comment: ;\n
!> get_template_size: ;\n
!>    Generate quasiuniform grid on concentric circles, with ;\n
!>    the number of points on each circle at radius k corresponding  ;\n
!>    to the number for the great circle on the corresponding sphere ;\n
!>    of radius k (encoded n nlats). ;\n
!>--------------------------------------------------------------------- ;\n
!>    INPUT ;\n
!>    nlats()        number of quarature nodes in theta on sphere ;\n
!>                   defined by index ncur. ;\n
!>    ncur           index of highest frequency sphere under consideration ;\n
!>    OUTPUT          ;\n
!>    ngridc()       number of output points on successive circles  ;\n
!>                   in templates ;\n
!>    ntemplatesize  total number of pts in templates  ;\n
!>    icstart()      indexing array for points on successive circles  ;\n
!>--------------------------------------------------------------------- ;\n
!> template_gen: ;\n
!>********************************************************************* ;\n
!>    Generate all band-limited templates from a model defined by its  ;\n
!>    spherical harmonic expansion on spheres from radius  ;\n
!>    xnodesr(1)... xnoodesr(ncur).  ;\n
!>    This correspondence is implicit:  ;\n
!>    xnodesr is not used in this subroutine. ;\n
!>    A discretization of the outermost sphere with "numonsphere" points  ;\n
!>    (i.e. normal orientations) is defined ;\n
!>    by nlats(ncur),itypep, and phiover.  ;\n
!>    The corresponding central slice intersects ;\n
!>    the model (discretized on spheres) on a sequence of great circles. ;\n
!>    For each point on those great circles, we evaluate the spherical ;\n
!>    harmonic expansion for the corresponding sphere.  ;\n
!>    This yields a central slice sampled on a polar grid for each  ;\n
!>    normal orientation. ;\n
!>--------------------------------------------------------------------- ;\n
!>    INPUT  ;\n
!>    model_sph()  the model in Fourier space, discretized as a  ;\n
!>                 spherical harmonic expansion on successive spheres ;\n
!>                 There are ngridr spheres, of which 1,...,ncur ;\n
!>                 will be used. This is stored in packed (1D) format ;\n
!>    lmod         length of modhat_sph ;\n
!>    isph_start()  array of length ngridr indicating where in the modhat_sph ;\n
!>                 vector the coefficients for the corresponding  ;\n
!>                 sphere begin ;\n
!>    nterms_sph() array of length ngridr defining the orders of the  ;\n
!>                 spherical harmonic expansions on successive spheres. ;\n
!>    ngridr       number of points in radial direction ;\n
!>    ngridc()     number of output points on successive circles in templates ;\n
!>    ntemplatesize    total number of points on quasiuniformly sampled  ;\n
!>                     template ;\n
!>    icstart()    indexing array for points on successive circles  ;\n
!>    nlats()      number of quarature nodes in theta on sphere ;\n
!>                 defined by index ncur. ;\n
!>    itypep       quadrature scheme in phi direction ;\n
!>                      0 = same on all latitudes (which oversamples poles) ;\n
!>                      1 = adaptive (undersamples toward poles) ;\n
!>                   if itypep=0 ;\n
!>                      nphi = nint(nlats(i)*phi_over) ;\n
!>                   if itypep=1 ;\n
!>                      nphi = nint(nlats(i)*phi_over*sin(theta)) ;\n
!>                   phi_over is set in getgridph (typically = 2). ;\n
!>    ncur          index of largest sphere under consideration ;\n
!>    numonsphere   number of points on sphere at ncur... ;\n
!>    OUTPUT ;\n
!>    templates(:,:)  the "numonsphere" templates, in standard ordering  ;\n
!> Doxygen comment: ;\n
C**********************************************************************
      subroutine get_template_size(nlats,ncur,ntemplatesize,ngridc,
     1           icstart)
C**********************************************************************
c     Generate quasiuniform grid on concentric circles, with
c     the number of points on each circle at radius k corresponding 
c     to the number for the great circle on the corresponding sphere
c     of radius k (encoded n nlats).
c
C----------------------------------------------------------------------
c     INPUT
c
c     nlats()        number of quarature nodes in theta on sphere
c                    defined by index ncur.
c     ncur           index of highest frequency sphere under consideration
c
c     OUTPUT         
c
c     ngridc()       number of output points on successive circles 
c                    in templates
c     ntemplatesize  total number of pts in templates 
c     icstart()      indexing array for points on successive circles 
C----------------------------------------------------------------------
      implicit none
      integer ntemplatesize,nlats(ncur),ncur,ngridc(ncur),icstart(ncur)
      integer i
c
      icstart(1) = 1
      do i = 1,ncur-1
         ngridc(i) = nlats(i)*2     
         icstart(i+1) = icstart(i) + ngridc(i)
      enddo
      ngridc(ncur) = nlats(ncur)*2     
      ntemplatesize = icstart(ncur) + ngridc(ncur) - 1
      return
      end
c
c
C**********************************************************************
      subroutine template_gen(model_sph,lmod,isph_start,
     1     nterms_sph,ngridr,ngridc,ntemplatesize,icstart,
     2     nlats,itypep,ncur,numonsphere,templates)
C**********************************************************************
c     Generate all band-limited templates from a model defined by its 
c     spherical harmonic expansion on spheres from radius 
c     xnodesr(1)... xnoodesr(ncur). 
c     This correspondence is implicit: 
c     xnodesr is not used in this subroutine.
c     A discretization of the outermost sphere with "numonsphere" points 
c     (i.e. normal orientations) is defined
c     by nlats(ncur),itypep, and phiover. 
c     The corresponding central slice intersects
c     the model (discretized on spheres) on a sequence of great circles.
c     For each point on those great circles, we evaluate the spherical
c     harmonic expansion for the corresponding sphere. 
c     This yields a central slice sampled on a polar grid for each 
c     normal orientation.
c
C----------------------------------------------------------------------
c     INPUT 
c
c     model_sph()  the model in Fourier space, discretized as a 
c                  spherical harmonic expansion on successive spheres
c                  There are ngridr spheres, of which 1,...,ncur
c                  will be used. This is stored in packed (1D) format
c     lmod         length of modhat_sph
c     isph_start()  array of length ngridr indicating where in the modhat_sph
c                  vector the coefficients for the corresponding 
c                  sphere begin
c     nterms_sph() array of length ngridr defining the orders of the 
c                  spherical harmonic expansions on successive spheres.
c     ngridr       number of points in radial direction
c     ngridc()     number of output points on successive circles in templates
c     ntemplatesize    total number of points on quasiuniformly sampled 
c                      template
c     icstart()    indexing array for points on successive circles 
c     nlats()      number of quarature nodes in theta on sphere
c                  defined by index ncur.
c     itypep       quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    phi_over is set in getgridph (typically = 2).
c     ncur          index of largest sphere under consideration
c     numonsphere   number of points on sphere at ncur...
c
c     OUTPUT
c
c     templates(:,:)  the "numonsphere" templates, in standard ordering 
C----------------------------------------------------------------------
      implicit none
      integer ngridc(ncur),nlats(ncur),ngridr,ncur,itypep,numonsphere
      integer ntemplatesize,lmod,isph_start(ngridr),nterms_sph(ngridr)
      integer icstart(ncur)
      integer ngcmax
      complex *16 model_sph(0:lmod-1)
      complex *16 templates(ntemplatesize,numonsphere)
c
      integer nn,jj,ns
      real *8 t1,t2
      complex *16, allocatable ::  values(:,:)
c      
      ngcmax = ngridc(ncur)
cc$OMP PARALLEL PRIVATE(values)
      allocate(values(ngcmax,numonsphere))
cc$OMP DO PRIVATE(nn,ns,jj)
      do nn = 1,ncur
         call sheval_greatcircs(model_sph(isph_start(nn)),
     1        nterms_sph(nn),nlats(ncur),itypep,numonsphere,
     1        ngridc(nn),values,ngcmax)
         do ns = 1,numonsphere
            do jj = 1,ngridc(nn)
              templates(icstart(nn)+jj-1,ns) = values(jj,ns)
            enddo
         enddo
      enddo
cc$OMP END DO
cc$OMP END PARALLEL

      return
      end

!> Doxygen comment: ;\n
!>    testing Fourier transform routines: ;\n
!>    create function on physical space grid ;\n
!>    create spherical grid in k-space (tensor product or sparse) ;\n
!>    compute Fourier transform on spherical grid using nufft type 3. ;\n
!>    compare with exact transform ;\n
!>    convert to spherical harmonic basis and comute norm in that basis ;\n
!>    convert from spherical harmonic basis to grid ;\n
!>    compute inverse Fourier transform back to rectangular grid  ;\n
!>            using nufft type 3. ;\n
!>    compare with original function ;\n
!> Doxygen comment: ;\n
      subroutine testfourier(ngrid,ngridr,rmax,ityper,itypep,
     1            nlats,fgauss,ns,x0y0z0,sigma,err,errback)
c
c
c     testing Fourier transform routines:
c
c     create function on physical space grid
c     create spherical grid in k-space (tensor product or sparse)
c     compute Fourier transform on spherical grid using nufft type 3.
c     compare with exact transform
c     convert to spherical harmonic basis and comute norm in that basis
c     convert from spherical harmonic basis to grid
c     compute inverse Fourier transform back to rectangular grid 
c             using nufft type 3.
c     compare with original function
c
      implicit real *8 (a-h,o-z)
      integer nlats(ngridr)
      integer, allocatable :: numonsphere(:)
      integer, allocatable :: nterms_sph(:)
      integer, allocatable :: isph_start(:)

      real *8 x0y0z0(3,ns)
      real *8 fnorm,rmodelnorm,phi_over
      real *8, allocatable :: x(:,:,:)
      real *8, allocatable :: y(:,:,:)
      real *8, allocatable :: z(:,:,:)
      real *8, allocatable :: xnodesr(:),wtsr(:)
      real *8, allocatable :: xnodesth(:),wtsth(:)
      real *8, allocatable :: xnodesph(:),wtsph(:)
      real *8, allocatable :: kgridx(:)
      real *8, allocatable :: kgridy(:)
      real *8, allocatable :: kgridz(:)
      real *8, allocatable :: wts(:)
      complex *16, allocatable :: ff(:,:,:)
      complex *16, allocatable :: ff2(:,:,:)
      complex *16, allocatable :: ffhat(:)
      complex *16, allocatable :: modsph(:)
      complex *16 eye,uex
      external fgauss
c
      eye = dcmplx(0.0d0,1.0d0)
      pi = 4.0d0*datan(1.0d0)
      call prini(6,13)
c
c     ifpr is printing flag (1 = on)
c
      ifpr = 1
c
      allocate(x(ngrid,ngrid,ngrid))
      allocate(y(ngrid,ngrid,ngrid))
      allocate(z(ngrid,ngrid,ngrid))
      allocate(ff(ngrid,ngrid,ngrid))
      allocate(ff2(ngrid,ngrid,ngrid))
      allocate(xnodesr(ngridr))
      allocate(wtsr(ngridr))
      allocate(xnodesth(nlats(ngridr)))
      allocate(wtsth(nlats(ngridr)))
      allocate(xnodesph(2*nlats(ngridr)))
      allocate(wtsph(2*nlats(ngridr)))
c
c     create physical space grid and sample function on it.
c
      a = 1.0d0
      call createfun_xspace(a,ngrid,h,x,y,z,x0y0z0,ns,sigma,
     1     fgauss,ff,fnorm)
      ifpr = 1
      if (ifpr.eq.1) write(6,*) '  h is ',h
      if (ifpr.eq.1) write(6,*) '  fnorm is ',fnorm
c
c     Determine size of spherical grid, allocate space and compute
c     Fourier transform at corresponding points in k-space.
c 
      call get_ntot(ngridr,nlats,itypep,ntot)
      if (ifpr.eq.1) write(6,*) '  ntot is ',ntot
      allocate(kgridx(ntot))
      allocate(kgridy(ntot))
      allocate(kgridz(ntot))
      allocate(wts(ntot))
      allocate(ffhat(ntot))
c
c     Determine size of spherical harmonic model 
c
      allocate(numonsphere(ngridr))
      allocate(nterms_sph(ngridr))
      allocate(isph_start(ngridr))
      nsphstore = 0
      call getgridr(rmax,ngridr,ityper,xnodesr,wtsr)
      do i = 1,ngridr
         isph_start(i) = nsphstore
         nterms_sph(i) = nint(xnodesr(i) + 2)
         nsphstore = nsphstore + (nterms_sph(i)+1)**2
      enddo
      call prinf(' nterms_sph is *',nterms_sph,ngridr)
      call prinf(' nsphstore is *',nsphstore,1)
      allocate(modsph(0:nsphstore-1))
c
      eps = 1.0d-6
c
      call fun_to_kspacegrid(x,y,z,ff,h,ngrid,eps,rmax,ngridr,
     1                  ityper,nlats,itypep,ntot,numonsphere,
     2                  kgridx,kgridy,kgridz,wts,ffhat,ffhatnorm,ier)
      if (ifpr.eq.1) write(6,*) '  ffhatnorm is ',ffhatnorm
c
c     check error in ffhat using exact transform of Gaussian
c
      err = 0 
      stot = 0 
      do ii = 1,ntot
         rkx = kgridx(ii)
         rky = kgridy(ii)
         rkz = kgridz(ii)
         uex = 0.0d0
         do is = 1,ns
            arg = rkx*x0y0z0(1,is)+rky*x0y0z0(2,is)+rkz*x0y0z0(3,is)
            uex = uex+dexp(-(rkx*rkx+rky*rky+rkz*rkz)*sigma*sigma/2)*
     1           cdexp(eye*arg)*(2*pi)*dsqrt(2*pi)*sigma**3
         enddo
         err = err + abs(ffhat(ii)-uex)**2
         stot = stot + abs(uex)**2
      enddo
      err = sqrt(err/stot)
      if (ifpr.eq.1) call prin2(' l2 err in ffhat is *',err,1)
c
      call kspacegrid_to_model(ffhat,rmax,nterms_sph,
     1         ityper,ngridr,nlats,itypep,numonsphere,modsph,nsphstore)
      call kspace_model_norm(modsph,nsphstore,nterms_sph,wtsr,ngridr,
     1     rmodelnorm)
      if (ifpr.eq.1) write(6,*) '  rmodelnorm is ',rmodelnorm
      call model_to_kspacegrid(ffhat,rmax,nterms_sph,
     1         ityper,ngridr,nlats,itypep,numonsphere,modsph,nsphstore)
c
c    now carry out inverse transform and check against original function.
c
      do ii = 1,ntot
         ffhat(ii) = ffhat(ii)*wts(ii)
      enddo
      iflag = -1
      npts = ngrid*ngrid*ngrid
      call finufft3d3_f(ntot,kgridx,kgridy,kgridz,ffhat,iflag,eps,
     1        npts,x,y,z,ff2,ier)
c
      errback = 0 
      stot = 0 
      do i = 1,ngrid
      do j = 1,ngrid
      do k = 1,ngrid
          ff2(i,j,k) = ff2(i,j,k)/(8*pi*pi*pi)
          errback = errback + abs(ff2(i,j,k)-ff(i,j,k))**2
          stot = stot + abs(ff(i,j,k))**2
      enddo
      enddo
      enddo
      errback = sqrt(errback/stot)
      if (ifpr.eq.1) call prin2(' l2 err in ff is *',errback,1)
      return
      end
C
      subroutine createfun_xspace(a,ngrid,h,x,y,z,x0y0z0,ns,sigma,
     1     fgauss,ff,fnorm)
c
      implicit real *8 (a-h,o-z)
      integer ngrid,ns
      real *8 a,h,sigma,pi
      real *8 x0y0z0(3,ns)
      real *8 x(ngrid,ngrid,ngrid)
      real *8 y(ngrid,ngrid,ngrid)
      real *8 z(ngrid,ngrid,ngrid)
      complex *16 ff(ngrid,ngrid,ngrid)
      external fgauss
c
c
c$$$      write(6,*) ' Calling: ','mkphysgrid'
      call mkphysgrid(a,ngrid,h,x,y,z)
c$$$      write(6,*) 'x: ',(x(i,1,1),i=1,ngrid)
c$$$      write(6,*) 'y: ',(y(1,j,1),j=1,ngrid)
c$$$      write(6,*) 'z: ',(z(1,1,k),k=1,ngrid)
c$$$      do i = 1,ngrid
c$$$         do j = 1,ngrid
c$$$            do k = 1,ngrid
c$$$               write(6,*) 'i,j,k: ',i,j,k,'; x,y,z: ',x(i,j,k),y(i,j,k)
c$$$     $              ,z(i,j,k)
c$$$            enddo
c$$$         enddo
c$$$      enddo
c$$$      write(6,*) ' Calling: ','evalgrid'
      call evalgrid(x,y,z,ngrid,ngrid,ngrid,x0y0z0,ns,sigma,
     1     fgauss,ff)
c 
c$$$      write(6,*) ' Computing: ','fnorm'
      fnorm = 0.0d0
      do i = 1,ngrid
      do j = 1,ngrid
      do k = 1,ngrid
         fnorm = fnorm + h*h*h*cdabs(ff(i,j,k))**2
      enddo
      enddo
      enddo
      fnorm = dsqrt(fnorm)
      return
      end

!> Doxygen comment: ;\n
!>     greatcircle_test. ;\n
!>     a) makes all great circles for normals corresponding to all  ;\n
!>     grid points on sphere.   ;\n
!>     b) Get Cartesian coords of all such target points and evaluate ;\n
!>        some potential directly. ;\n
!>     c) Make interpoolation matrix from tensor product grid to all  ;\n
!>     target points.  ;\n
!>     d) Evaluate field at all targets via interpoaltion. ;\n
!>     e) Then, evaluate field at all targets via subroutine  ;\n
!>        shevalspherecircsp. ;\n
!>     Check errors ;\n
!>     Invokes:  mkgreatcircles, mkshinterp, shinterp, shevalspherecircsp ;\n
!>    INPUT: ;\n
!>    ngridth        number of latitude points used on sphere ;\n
!>    itypep         quadrature scheme in phi direction         ;\n
!>                     0 = same on all latitudes (which oversamples poles) ;\n
!>                     1 = adaptive (undersamples toward poles) ;\n
!>    wavek          frequency defining test Helmholtz field ;\n
!>    rk             radius of testing sphere ;\n
!>    source         locations of Helmholtz sources ;\n
!>    charge         strengths of Helmholtz sources ;\n
!>    ns             number of Helmholtz sources ;\n
!>    local          local spherical harmonic expansion of Helmholtz field ;\n
!>    nterms         order of local expansion  ;\n
!>    ngridc         number of points on each great circle ;\n
!> Doxygen comment: ;\n
      subroutine testgreatcircles(ngridth,itypep,wavek,rk,
     1           source,charge,ns,local,nterms,ngridc)
c
c      greatcircle_test.
c
c      a) makes all great circles for normals corresponding to all 
c      grid points on sphere.  
c      b) Get Cartesian coords of all such target points and evaluate
c         some potential directly.
c      c) Make interpoolation matrix from tensor product grid to all 
c      target points. 
c      d) Evaluate field at all targets via interpoaltion.
c      e) Then, evaluate field at all targets via subroutine 
c         shevalspherecircsp.
c      Check errors
c
c      Invokes:  mkgreatcircles, mkshinterp, shinterp, shevalspherecircsp
c
c     INPUT:
c     ngridth        number of latitude points used on sphere
c     itypep         quadrature scheme in phi direction        
c                      0 = same on all latitudes (which oversamples poles)
c                      1 = adaptive (undersamples toward poles)
c     wavek          frequency defining test Helmholtz field
c     rk             radius of testing sphere
c     source         locations of Helmholtz sources
c     charge         strengths of Helmholtz sources
c     ns             number of Helmholtz sources
c     local          local spherical harmonic expansion of Helmholtz field
c     nterms         order of local expansion 
c     ngridc         number of points on each great circle
c
      implicit real *8 (a-h,o-z)
      real *8 source(3,ns),center(3),ztrg(3)
      integer, allocatable :: ngridps(:)
      integer, allocatable :: icols(:,:)
      real *8, allocatable :: xx(:),yy(:),zz(:)
      real *8, allocatable :: xnodesth(:),wtsth(:)
      real *8, allocatable :: sthetas(:),phsteps(:)
      real *8, allocatable :: xnodesph(:),wtsph(:)
      real *8, allocatable :: xg(:,:)
      real *8, allocatable :: yg(:,:)
      real *8, allocatable :: zg(:,:)
      real *8, allocatable :: values(:,:)
      real *8, allocatable :: phis(:)
      real *8, allocatable :: thetas(:)

      complex *16 wavek,eye,charge(ns)
      complex *16 opot,ofld(3)
      complex *16 local((nterms+1)**2)
      complex *16, allocatable :: phiall(:,:)
      complex *16, allocatable :: phiall2(:,:)
      complex *16, allocatable :: phival(:)
      complex *16, allocatable :: phival2(:)
      complex *16, allocatable :: uout(:,:)
c   
      data eye/(0.0d0,1.0d0)/
      pi=4.0*datan(1.0d0)
c
c     print output flag (1 turns on)
c
      ifpr = 0
c
c      create grid on sphere of radius rk according to 
c      itypep
c      get Cartesian coordinates for spherical grid
c
      allocate(xnodesth(ngridth))
      allocate(sthetas(ngridth))
      allocate(wtsth(ngridth))
      allocate(ngridps(ngridth))
      allocate(phsteps(ngridth))

      call getspheregrid(ngridth,itypep,xnodesth,
     1             sthetas,wtsth,ngridps,phsteps,numonsphere)
      call prinf(' numonsphere is *',  numonsphere,1)
c
      allocate(xg(ngridc,numonsphere))
      allocate(yg(ngridc,numonsphere))
      allocate(zg(ngridc,numonsphere))
      allocate(phiall(ngridc,numonsphere))
      allocate(phiall2(ngridc,numonsphere))
      allocate(phis(ngridc*numonsphere))
      allocate(thetas(ngridc*numonsphere))
c
      call mkallgreatcircles(rk,ngridth,itypep,
     1           numonsphere,ngridc,xg,yg,zg)
c
c     get phi/theta values for all great circles
c     and define phiall to be exact sol at those points.
c
      iffld=1
      iincr = 0
      do ii = 1,numonsphere
      do ll = 1,ngridc
         ztrg(1) = xg(ll,ii)
         ztrg(2) = yg(ll,ii)
         ztrg(3) = zg(ll,ii)
         call hpotfld3dall(iffld,source,charge,ns,ztrg,wavek,opot,ofld)
         ctheta = ztrg(3)
         phi = datan2(ztrg(2),ztrg(1))
         if (phi.lt.0.0d0) phi = phi + 2*pi
         phiall(ll,ii) = opot
         iincr = iincr+1
         phis(iincr) = phi
         thetas(iincr) = dacos(ctheta)
         write(76,*) ctheta
         write(77,*) thetas(iincr)
         write(78,*) phis(iincr)
      enddo
      enddo
      call prin2('finished direct evaluation *', sqrt(err/stot),0)
      nout = ngridc*numonsphere
      call prinf('nout is *', nout,1)
c
c     set order of interpolation
c
      kord = 7
c
c     create interpolation matrix using tensor product grid
c
      ngridph = 2*ngridth
      allocate(uout(ngridc,numonsphere))
      allocate(values(ngridc*numonsphere,kord*kord))
      allocate(icols(ngridc*numonsphere,kord*kord))
      t1 = second()
c
c
      call mkshinterp(thetas,phis,nout,kord,ngridth,ngridph,values,
     1           icols)
      t2 = second()
      call prin2(' time for mkshinterp is *',t2-t1,1)
c
c     get data on tensor product grid
c
      allocate(phival2(ngridth*ngridph))
      itensor = 0
      call evalshexp(local,nterms,ngridth,itensor,
     1          numonsphere,phival2)
ccc      call prin2(' phival2 is *',phival2,2*numonsphere)
c
c     perform checksum
c
      sum = 0.0d0
      do j = 1,kord*kord
         do i = 1,nout
            sum = sum + values(i,j)
         enddo
      enddo
      sum = sum/nout
      call prin2(' sum is is *',sum,1)
      call prin2(' sum should be 0.10000E+01 *',sum,0)
c
c     perform interpolation phival2 -> uout
c
      t1 = second()
      call shinterp(nout,kord,ngridth,ngridph,values,
     1           icols,phival2,uout)
      t2 = second()
      call prin2(' time for shinterp is *',t2-t1,1)
c
      t1 = second()
      ldp = ngridc
      call sheval_greatcircs(local,nterms,
     1           ngridth,itypep,numonsphere,ngridc,phiall2,ldp)
      t2 = second()
      call prin2('evaluate by spherical harmonics, time is *',t2-t1,1)
c
c     compare error for interp (uout) and for eval of SH exp (phiall2)
c
      err = 0.0d0
      stot = 0.0d0
      errsh = 0.0d0
      do ii = 1,numonsphere
      do ll = 1,ngridc
         errsh = errsh + abs(phiall(ll,ii)-phiall2(ll,ii))**2
         err = err + abs(phiall(ll,ii)-uout(ll,ii))**2
         stot = stot + abs(phiall(ll,ii))**2
      enddo
      enddo
      call prin2('err from shinterp is*', sqrt(err/stot),1)
      call prin2('err from shevalspherecircsp is*', sqrt(errsh/stot),1)
      return
      end
c
c
!> Doxygen comment: ;\n
!>     Define complex-valed potential U using solution to Helmholtz ;\n
!>     equation via subroutine hpotfld3dall. ;\n
!>     1)  sample U on sphere. ;\n
!>     2)  project on spherical harmonic expansions. ;\n
!>     3)  evaluate back on grid and compare ;\n
!>         with values from step 1. ;\n
!> Doxygen comment: ;\n
      subroutine testprojeval(ngridth,itypep,wavek,rk,
     1           source,charge,ns,local,nterms)
c
c      Define complex-valed potential U using solution to Helmholtz
c      equation via subroutine hpotfld3dall.
c
c      1)  sample U on sphere.
c      2)  project on spherical harmonic expansions.
c      3)  evaluate back on grid and compare
c          with values from step 1.
c
      implicit real *8 (a-h,o-z)
      real *8 source(3,ns),center(3),ztrg(3)
      integer, allocatable :: ngridps(:)
      real *8, allocatable :: xx(:),yy(:),zz(:)
      real *8, allocatable :: xnodesth(:),wtsth(:)
      real *8, allocatable :: sthetas(:),phsteps(:)
      real *8, allocatable :: xnodesph(:),wtsph(:)
      complex *16 wavek,eye,charge(ns)
      complex *16 opot,ofld(3)
      complex *16, allocatable :: phival(:)
      complex *16, allocatable :: phival2(:)
      complex *16 local((nterms+1)**2)
c   
      data eye/(0.0d0,1.0d0)/
c
c     print output flag (1 turns on)
c
      ifpr = 0
c
c      create grid on sphere of radius rk
c      and get Cartesian coordinates for spherical grid
c
      allocate(xnodesth(ngridth))
      allocate(sthetas(ngridth))
      allocate(wtsth(ngridth))
      allocate(ngridps(ngridth))
      allocate(phsteps(ngridth))
c
      call getspheregrid(ngridth,itypep,xnodesth,
     1             sthetas,wtsth,ngridps,phsteps,numonsphere)
      if (ifpr.eq.1) call prinf(' numonsphere is *',numonsphere,1)
      if (ifpr.eq.1) call prin2(' xnodesth is *',xnodesth,ngridth)
      if (ifpr.eq.1) call prin2(' sthetas is *',sthetas,ngridth)
      if (ifpr.eq.1) call prin2(' phsteps is *',phsteps,ngridth)
c
      allocate(xx(numonsphere))
      allocate(yy(numonsphere))
      allocate(zz(numonsphere))
      allocate(phival(numonsphere))
      allocate(phival2(numonsphere))
c
      nnn=0
      do kk = 1,ngridth
         ctheta = xnodesth(kk)
         stheta = sthetas(kk)
         phstep = phsteps(kk)
c
         do ll = 1,ngridps(kk)
            phi = (ll-1)*phstep
            nnn = nnn+1
            xx(nnn) = rk*stheta*dcos(phi)
            yy(nnn) = rk*stheta*dsin(phi)
            zz(nnn) = rk*ctheta
         enddo
      enddo
c
c       direct calculation:
c
      iffld=1
      do kk = 1,numonsphere
         ztrg(1) = xx(kk)
         ztrg(2) = yy(kk)
         ztrg(3) = zz(kk)
         call hpotfld3dall(iffld,source,charge,ns,ztrg,wavek,opot,ofld)
         phival(kk) = opot
      enddo
      if (ifpr.eq.1) call prin2(' phival is *',phival,2*numonsphere)
c
c    project on spherical harmonics
c
ccc      allocate(local((nterms+1)**2))
c
      t1 = second()
      call projshexp(phival,numonsphere,ngridth,itypep,
     1       nterms,local)
      t2 = second()
      call prin2('time for proj is *',t2-t1,1)
c
c     evaluate spherical harmonic expansion back at grid points.
c      
      t1 = second()
      call evalshexp(local,nterms,ngridth,itypep,
     1          numonsphere,phival2)
      t2 = second()
      call prin2('time for sheval is *',t2-t1,1)
      if (ifpr.eq.1) call prin2(' phival2 is *',phival2,2*numonsphere)
c
      err = 0.0d0
      stot = 0.0d0
      do kk = 1,numonsphere
         err = err + abs(phival(kk)-phival2(kk))**2
         stot = stot + abs(phival(kk))**2
      enddo
      call prin2('l2 of function *', sqrt(stot),1)
      call prin2('l2 err, forwrd/back SH transform*', sqrt(err/stot),1)
      return
      end
c
!> Doxygen comment: ;\n
!> multiplies by (A) in the least-squares setup ;\n
!> calls 'multa' ;\n
      subroutine test_residual_multa(thetas,phis,nout,localp,nterms,
     1           nquad,k,ctfw,output)

      implicit real *8 (a-h,o-z)
      integer verbose
      data verbose / 0 /
      integer nterms,nquad,nquadm
      integer, allocatable :: icols(:,:)
      real *8, allocatable :: xnodes(:),wts(:),twork(:),sthetas(:)
      real *8 thetas(nout)
      real *8 phis(nout)
      real *8, allocatable :: values(:,:)
      complex *16 localp((nterms+1)*(nterms+1))
      complex *16 phiout(nout)
      complex *16 ctfw(nout)
      complex *16 output(nout)
      complex *16, allocatable :: ugrid(:)
      complex *16, allocatable :: phivals(:)
      complex *16 a,z1,z2,z3
      integer i
      character(len=80) str

      if (verbose.gt.0) then
         write(6,'(A,I0)') '[entering test_residual_multa], nout: ' , nout
      end if

      nquadm = 2*nquad
      allocate(xnodes(nquad))
      allocate(wts(nquad))
      allocate(sthetas(nquad))
      allocate(twork(nquad))
      call getgridth(nquad,twork,xnodes,sthetas,wts)

      np = (nterms+1)*(nterms+1)
      allocate(icols(nout,k*k))
      allocate(values(nout,k*k))
      allocate(ugrid(nquadm*nquad))
      allocate(phivals(nout))

      call mkshinterp(thetas,phis,nout,k,nquad,nquadm,values,icols)
      call multa(a,localp,output,np,nterms,nquad,nquadm,nout,k,icols,
     1    xnodes,wts,values,phivals,ugrid,ctfw)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished test_residual_multa]'
      end if

      end
c
c

cCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c
c    This does the A apply. 
c
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      subroutine multa(a,x,y,n,nterms,nquad,nquadm,nout,k,icols, xnodes
     $     ,wts,values,phiout,ugrid,ctfw)
      implicit real *8 (a-h,o-z)
c$$$      real *8 icols(nout,k*k)
      integer *4 icols(nout,k*k)
      real *8 xnodes(nquad)
      real *8 wts(nquad)
      real *8 values(nout,k*k)
      real *8 p3
      complex *16 ugrid(nquadm*nquad)
      complex *16 phiout(nout),z3
      complex *16 a,x(n),y(n),d
      complex *16 ctfw(nout)
c
ccc      call prinf(' calling shevalspherep *',n,1)
      call shevalspherep(x,ugrid,nterms,nquad,nquadm,xnodes)
ccc      call prinf(' calling shinterp *',n,1)
      call shinterp(nout,k,nquad,nquadm,values,icols,ugrid,phiout)
c
      do i = 1,nout
c$$$         phiout(i) = dconjg(ctfw(i))*ctfw(i)*phiout(i)    
         y(i) = ctfw(i)*phiout(i)    
      enddo
c
      return
      end
c
c
!> Doxygen comment: ;\n
!> multiplies by transpose(A) in the least-squares setup ;\n
!> calls 'multah' ;\n
      subroutine test_residual_multah(thetas,phis,nout,residua,nterms,
     1           nquad,k,ctfw,output)

      implicit real *8 (a-h,o-z)
      integer verbose
      data verbose / 0 /
      integer nterms,nquad,nquadm
      integer, allocatable :: icols(:,:)
      real *8, allocatable :: xnodes(:),wts(:),twork(:),sthetas(:)
      real *8 thetas(nout)
      real *8 phis(nout)
      real *8, allocatable :: values(:,:)
      complex *16 residua(*)
      complex *16 phiout(nout)
      complex *16 ctfw(nout)
      complex *16 output(nout)
      complex *16, allocatable :: ugrid(:)
      complex *16, allocatable :: phivals(:)
      complex *16 a,z1,z2,z3
      integer i
      character(len=80) str

      if (verbose.gt.0) then
         write(6,'(A,I0)') '[entering test_residual_multah], nout: ' , nout
      end if

      nquadm = 2*nquad
      allocate(xnodes(nquad))
      allocate(wts(nquad))
      allocate(sthetas(nquad))
      allocate(twork(nquad))
      call getgridth(nquad,twork,xnodes,sthetas,wts)

      np = (nterms+1)*(nterms+1)
      allocate(icols(nout,k*k))
      allocate(values(nout,k*k))
      allocate(ugrid(nquadm*nquad))
      allocate(phivals(nout))

      call mkshinterp(thetas,phis,nout,k,nquad,nquadm,values,icols)
      call multah(a,residua,output,np,nterms,nquad,nquadm,nout,k,icols,
     1    xnodes,wts,values,phivals,ugrid,ctfw)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished test_residual_multah]'
      end if

      end
c
c

cCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
c
c    This does the A* apply. 
c
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      subroutine multah(a,x,y,n,nterms,nquad,nquadm,nout,k,icols, xnodes
     $     ,wts,values,phiout,ugrid,ctfw)
      implicit real *8 (a-h,o-z)
c$$$      real *8 icols(nout,k*k)
      integer *4 icols(nout,k*k)
      real *8 xnodes(nquad)
      real *8 wts(nquad)
      real *8 values(nout,k*k)
      real *8 p3
      complex *16 ugrid(nquadm*nquad)
      complex *16 phiout(nout),z3
      complex *16 a,x(n),y(n),d
      complex *16 ctfw(nout)
c
      do i = 1,nout
         phiout(i) = dconjg(ctfw(i))*x(i)    
      enddo

      call shinterp_adj(nout,k,nquad,nquadm,values,icols,phiout
     $     ,ugrid)
      call shevalspherep_adj(nterms,nquad,nquadm,xnodes,ugrid,y)

c
      return
      end
c
c
!> Doxygen comment: ;\n
!>    Calculates residuals and estimates cross-correlation. ;\n
!>    Uses model Y_ (in spherical harmonic basis)  ;\n
!>    as well as images M_k_p_ (in k-space polar coordinates), ;\n
!>    with image parameters given by alpha2d__ array. ; ;\n
!> -------------------------------------------------------------------- ;\n
!>    INPUT: ;\n
!>     ;\n
!>    rseed          integer *4: random seed ; ;\n
!>    n_M            integer: number of images ; ;\n
!>    I_M_sample_    integer: indexing array used to reference n_M images in M_k_p__ ;\n
!>    ld_M           integer: leading dimension of images in k-space polar coordinates. ; ;\n
!>    M_k_p__        complex *16: stack of images in k-space polar coordinates. ; ;\n
!>    n_CTF          integer: number of ctf-functions. ; ;\n
!>    ld_CTF         integer: leading dimension of CTF-array (usually ld_M). ; ;\n
!>    CTF_k_p__       complex *16: stack of ctf-functions in k-space polar coordinates (size ld_CTF*n_CTF). ; ;\n
!>    n_alpha        integer: size of alpha2d__. ; ;\n
!>    alpha2d__(3,*) real *8: 2d array of image parameters (see nalpha_define.f). ; ;\n
!>    n_w_csum_()     integer: indexing array for points on successive circles within each image. ;  ;\n
!>                   n_w_csum_(nk) represents the number of points (in angle-w) on ring at radius grid_k_p_(nk). ; ;\n
!>    n_polar_a_()   integer:  number of quadrature nodes in polar_a on sphere defined by index n_k_cur. ; ;\n
!>    quadrature_type_azimu_b integer: flag determining quadrature scheme in azimu_b direction. ; ;\n
!>                      0 = same on all latitudes (which oversamples poles). ; ;\n
!>                      1 = adaptive (appropriately samples toward poles). ; ;\n
!>                   if quadrature_type_azimu_b=0, then n_azimu_b = nint(n_polar_a_(nk)*phi_over). ; ;\n
!>                   if quadrature_type_azimu_b=1, then n_azimu_b = nint(n_polar_a_(nk)*phi_over*sin(polar_a)). ; ;\n
!>                   Note: phi_over is set in getgridph (typically = 2). ; ;\n
!>    grid_k_p_()    real *8: radius associated with successive circles in templates in k-space polar coordinates. ; ;\n
!>    n_w_()         integer: number of output points on successive circles in templates in k-space polar coordinates. ; ;\n
!>    n_k_low        integer: index of lowest frequency sphere under consideration. Note that this runs from 1 to n_k_p_max. ; ;\n
!>    n_k_cur        integer: index of highest frequency sphere under consideration. Note that this runs from 1 to n_k_p_max. ; ;\n
!>    n_Y_lm_csum_()  integer: array of length n_k_p_max indicating where the Y_ for that shell begins. ; ;\n
!>    n_Y_l_()       integer: array of length n_k_p_max defining the orders of the various Y_ on successive shells. ; ;\n
!>    lsq_oversample integer: lsq_oversampling parameter for least-squares solver. ; ;\n
!>    lsq_interpolation_order integer: interpolation order for least-squares solver. ; ;\n
!>    Y_(:)          complex *16: solution to least squares problem expressed in spherical harmonics in successive shells. ; ;\n
!>    n_residual_loading    integer: number of M_loading_ vectors per image. ; ;\n
!>    n_residual_iteration  integer: number of iterations to perform. ; ;\n
!>     ;\n
!>    OUTPUT:  ;\n
!>     ;\n
!>    M_residual__(:)  complex *16: M_residual__ = M_transform_ - Y_slice_. ; ;\n
!>    M_loading_(:)    complex *16: M_loading_ vectors. ; ;\n
!>     ;\n
!> Doxygen comment: ;\n
C***********************************************************************
      subroutine test_residual_5(rseed,n_M,I_M_sample_,ld_M,M_k_p__
     $     ,n_CTF,ld_CTF,CTF_k_p__,alpha2d__,n_w_csum_,n_polar_a_
     $     ,quadrature_type_azimu_b ,grid_k_p_ ,n_w_,n_k_low,n_k_cur
     $     ,n_Y_lm_csum_cur,n_Y_lm_csum_ ,n_Y_l_ ,lsq_oversample
     $     ,lsq_interpolation_order ,Y_ ,M_residual__,n_residual_loading
     $     ,n_residual_iteration,M_loading_)
C***********************************************************************
C     Calculates residuals and estimates cross-correlation.
C     Uses model Y_ (in spherical harmonic basis) 
C     as well as images M_k_p_ (in k-space polar coordinates),
C     with image parameters given by alpha2d__ array. ;
C---------------------------------------------------------------------
C     INPUT:
C
C     rseed          integer *4: random seed ;
C     n_M            integer: number of images ;
C     I_M_sample_    integer: indexing array used to reference n_M images in M_k_p__
C     ld_M           integer: leading dimension of images in k-space polar coordinates. ;
C     M_k_p__        complex *16: stack of images in k-space polar coordinates. ;
C     n_CTF          integer: number of ctf-functions. ;
C     ld_CTF         integer: leading dimension of CTF-array (usually ld_M). ;
C     CTF_k_p__       complex *16: stack of ctf-functions in k-space polar coordinates (size ld_CTF*n_CTF). ;
c     n_alpha        integer: size of alpha2d__. ;
c     alpha2d__(3,*) real *8: 2d array of image parameters (see nalpha_define.f). ;
c     n_w_csum_()     integer: indexing array for points on successive circles within each image. ; 
c                    n_w_csum_(nk) represents the number of points (in angle-w) on ring at radius grid_k_p_(nk). ;
c     n_polar_a_()   integer:  number of quadrature nodes in polar_a on sphere defined by index n_k_cur. ;
c     quadrature_type_azimu_b integer: flag determining quadrature scheme in azimu_b direction. ;
c                       0 = same on all latitudes (which oversamples poles). ;
c                       1 = adaptive (appropriately samples toward poles). ;
c                    if quadrature_type_azimu_b=0, then n_azimu_b = nint(n_polar_a_(nk)*phi_over). ;
c                    if quadrature_type_azimu_b=1, then n_azimu_b = nint(n_polar_a_(nk)*phi_over*sin(polar_a)). ;
c                    Note: phi_over is set in getgridph (typically = 2). ;
c     grid_k_p_()    real *8: radius associated with successive circles in templates in k-space polar coordinates. ;
c     n_w_()         integer: number of output points on successive circles in templates in k-space polar coordinates. ;
c     n_k_low        integer: index of lowest frequency sphere under consideration. Note that this runs from 1 to n_k_p_max. ;
c     n_k_cur        integer: index of highest frequency sphere under consideration. Note that this runs from 1 to n_k_p_max. ;
c     n_Y_lm_csum_()  integer: array of length n_k_p_max indicating where the Y_ for that shell begins. ;
c     n_Y_l_()       integer: array of length n_k_p_max defining the orders of the various Y_ on successive shells. ;
c     lsq_oversample integer: lsq_oversampling parameter for least-squares solver. ;
c     lsq_interpolation_order integer: interpolation order for least-squares solver. ;
C     Y_(:)          complex *16: solution to least squares problem expressed in spherical harmonics in successive shells. ;
c     n_residual_loading    integer: number of M_loading_ vectors per image. ;
c     n_residual_iteration  integer: number of iterations to perform. ;
cC
C     OUTPUT: 
c
c     M_residual__(:)  complex *16: M_residual__ = M_transform_ - Y_slice_. ;
c     M_loading_(:)    complex *16: M_loading_ vectors. ;
c
C***********************************************************************
      implicit none
      integer verbose
      data verbose / 1 /
      integer *4 rseed
      real *8 adi_rand_f
      include 'adi_rand_f_define.f'
      integer n,n_M,I_M_sample_(0:n_M-1),ld_M,n_CTF,ld_CTF
      complex *16 M_k_p__(0:0)
      complex *16 CTF_k_p__(0:ld_CTF*n_CTF-1)
      include '/usr/include/fftw3.f'
      integer *8, allocatable :: fftw_plan_frwd_(:)
      integer *8, allocatable :: fftw_plan_back_(:)
      complex *16, allocatable :: fftw_in1_(:)
      complex *16, allocatable :: fftw_out_(:)
      include 'nalpha_define.f'
      real *8 alpha2d__(0:n_alpha-1,0:n_M-1)
      integer n_w_csum_(0:n_k_cur-1)
      integer n_polar_a_(0:n_k_cur-1)
      integer n_w_(0:n_k_cur-1)
      integer quadrature_type_azimu_b
      real *8 grid_k_p_(0:n_k_cur-1)
      integer n_k_low,n_k_cur
      integer n_Y_lm_csum_cur
      integer n_Y_lm_csum_(0:n_k_cur-1)
      integer n_Y_l_(0:n_k_cur-1)
      complex *16 Y_(0:n_Y_lm_csum_cur-1)
      real *8 lsq_oversample
      integer lsq_interpolation_order
      complex *16  M_residual__(0:0)
      integer n_residual_loading,n_residual_iteration
      complex *16 M_loading_(0:n_residual_loading*n_M-1)
      integer nM,nk,nA,n_A,nw,ntmp,nctf
      integer n_w_M_max,n_polar_a_oversample
      integer n_Y_lm_max,n_Y_l,n_polar_a_oversample_max
      real *8, allocatable :: polar_a__(:)
      real *8, allocatable :: azimu_b__(:)
      complex *16, allocatable :: M_transform_(:)
      complex *16, allocatable :: Y_slice_(:)
      complex *16, allocatable :: weight_CTF_k_c__(:)
      integer *4 , allocatable :: n_w_M_(:)
      integer nM_loading,nY_lm_sum
c$$$      Below the array G stores a collection of vectors G_{1}, G_{2}, etc, ;
c$$$      which are constructed according to: ;
c$$$      G^{j} = \sum_{nM} Et_{nM}*R_{nM}*v_{nM}^{j}, ;
c$$$      where: ;
c$$$      nM sums over all the images. ;
c$$$      Et_{nM} refers to the adjoint of the evaluation operator En_{nM}, ;
c$$$      where En_{nM} serves to evaluate a spherical harmonic expansion ;
c$$$      on the points (in k-space cartesian coordinates) associated with '
c$$$      image nM (which depend on the image parameters alpha_{nM}). ;
c$$$      R_{nM} refers to the residual associated with image nM. ;
c$$$      v_{nM}^{j} refers to the nM-element of the j^{th} 'loading' vector. ;
c$$$      The vector H is a temporary variable storing Et_{nM}*R_{nM}. ;
      complex *16, allocatable :: G_(:) !temporary: stores array of \sum Et*R*v^{j} (one for each loading, each in terms of spherical harmonic coefficients). ;
c$$$      complex *16, allocatable :: H_(:) !temporary: stores single Et*R (in terms of spherical harmonic coefficients). ;
      complex *16, allocatable :: H__(:) !temporary: stores all Et*R (in terms of spherical harmonic coefficients) across all images. ;
      complex *16, allocatable :: HH_(:) !temporary: stores dot(H,H) for each image. ;
      complex *16 HH,HG,RR
      integer n_iteration,niteration
      real *8 al2_c16_f
      complex *16 dot_c16_f
      character(len=1024) format_string
      logical flag_memory_checkset
      if (verbose.gt.0) then
         write(6,*) '[entering test_residual_5]'
      end if
      if (verbose.gt.1) then
         write(6,*) 'ld_M: ',ld_M
         write(6,*) 'n_M: ',n_M
         write(6,*) 'n_w_csum_: ',(n_w_csum_(nk),nk=0,n_k_cur-1)
         write(6,*) 'n_CTF: ',n_CTF
         write(6,*) 'ld_CTF: ',ld_CTF
         write(6,*) 'n_alpha: ',n_alpha
         write(6,*) 'n_polar_a_: ',(n_polar_a_(nk),nk=0,n_k_cur-1)
         write(6,*) 'quadrature_type_azimu_b: ',quadrature_type_azimu_b
         write(6,*) 'grid_k_p_: ',(grid_k_p_(nk),nk=0,n_k_cur-1)
         write(6,*) 'n_w_: ',(n_w_(nk),nk=0,n_k_cur-1)
         write(6,*) 'n_k_low: ',n_k_low
         write(6,*) 'n_k_cur: ',n_k_cur
         write(6,*) 'n_Y_lm_csum_cur: ',n_Y_lm_csum_cur
         write(6,*) 'n_Y_lm_csum_: ',(n_Y_lm_csum_(nk),nk=0,n_k_cur-1)
         write(6,*) 'n_Y_l_: ',(n_Y_l_(nk),nk=0,n_k_cur-1)
         write(6,*) 'lsq_oversample: ',lsq_oversample
         write(6,*) 'lsq_interpolation_order: ',lsq_interpolation_order
         write(6,*) 'n_residual_loading: ',n_residual_loading
      end if
c
      n_Y_l = n_Y_l_(n_k_cur-1)
      n_Y_lm_max = (n_Y_l+1)**2
      if (verbose.gt.1) then
         write(6,*) ' n_Y_l = ',n_Y_l
         write(6,*) ' n_Y_lm_max = ',n_Y_lm_max
      end if
c
      n_polar_a_oversample_max = nint(lsq_oversample*n_polar_a_(n_k_cur
     $     -1))
      if (verbose.gt.1) then
         write(6,*) ' lsq_oversample = ',lsq_oversample
         write(6,*) ' n_polar_a_oversample_max = '
     $        ,n_polar_a_oversample_max
      end if
c
      n_w_M_max = n_M*n_w_(n_k_cur-1)
      if (verbose.gt.1) then
         write(6,*) ' n_w_M_max = ',n_w_M_max
      end if
      allocate(polar_a__(0:1+ld_M*n_M-1))
      n = ld_M*n_M
      call cs1_r8(n,polar_a__)
      allocate(azimu_b__(0:1+ld_M*n_M-1))
      n = ld_M*n_M
      call cs1_r8(n,azimu_b__)
      allocate(weight_CTF_k_c__(0:1+ld_M*n_M-1))
      n = ld_M*n_M
      call cs1_c16(n,weight_CTF_k_c__)
      allocate(n_w_M_(0:1+n_k_cur-1))
      n = n_k_cur
      call cs1_i4(n,n_w_M_)
c     
      n_A = 0
      do nk = 0,n_k_cur-1
         n_A = n_A + n_w_(nk)
      end do
      if (n_A.gt.ld_M) then
         write(6,*) 'Warning, ld_M: ',ld_M,' .neq. n_A: ',n_A
     $        ,' in test_residual_5'
      end if
      if (verbose.gt.1) then
         write(6,*) ' n_A = ',n_A
      end if

      allocate(fftw_plan_frwd_(0:n_k_cur-1))
      allocate(fftw_plan_back_(0:n_k_cur-1))
      allocate(fftw_in1_(0:1+n_A-1))
      n = n_A
      call cs1_c16(n,fftw_in1_)
      allocate(fftw_out_(0:1+n_A-1))
      n = n_A
      call cs1_c16(n,fftw_out_)
      na = 0
      do nk=0,n_k_cur-1
         call dfftw_plan_dft_1d_(fftw_plan_frwd_(nk),n_w_(nk)
     $        ,fftw_in1_(na),fftw_out_(na),FFTW_FORWARD,FFTW_MEASURE) 
         call dfftw_plan_dft_1d_(fftw_plan_back_(nk),n_w_(nk)
     $        ,fftw_out_(na),fftw_in1_(na),FFTW_BACKWARD,FFTW_MEASURE) 
         na = na + n_w_(nk)
      enddo !do nk=0,n_k_cur-1
      allocate(M_transform_(0:1+ld_M-1))
      n = ld_M
      call cs1_c16(n,M_transform_)
      allocate(Y_slice_(0:1+ld_M-1))
      n = ld_M
      call cs1_c16(n,Y_slice_)

c$$$      allocate(H_(0:1+n_Y_lm_csum_cur-1))
c$$$      n = n_Y_lm_csum_cur
c$$$      call cs1_c16(n,H_)
      allocate(H__(0:1+n_Y_lm_csum_cur*n_M-1))
      n = n_Y_lm_csum_cur*n_M
      call cs1_c16(n,H__)
      allocate(HH_(0:1+n_M-1))
      n = n_M
      call cs1_c16(n,HH_)
      allocate(G_(0:1+n_residual_loading*n_Y_lm_csum_cur-1))
      n = n_residual_loading*n_Y_lm_csum_cur
      call cs1_c16(n,G_)

      include 'test_residual_5_checkset.f'

      if (verbose.gt.1) then
         write(6,'(A)') ' M_transform_ - Y_slice_ = M_residual__'
      end if !if (verbose.gt.1) then
      do nM=0,n_M-1
         call cl1_c16(ld_M,M_transform_)
         nctf = nint(alpha2d__(nalpha_ctf_ind,nM))
         if ((verbose.gt.1).and.(nM.eq.0)) then
            write(6,'(A,I0,A,I0,A,I0)') ' nM: ' , nM , ' nctf: ' , nctf,
     $           ' ld_M: ' , ld_M
         end if !if ((verbose.gt.1).and.(nM.eq.0)) then
         na = 0
         do nk = n_k_low-1,n_k_cur-1
            if ((verbose.gt.2).and.(nM.eq.0)) then
               write(6,'(A,I0,A,I0)') ' nk = ' , nk , ' n_w_csum_(nk) '
     $              ,n_w_csum_(nk)
            end if !if verbose
            call get_lsqdata_2(1,I_M_sample_(nM),ld_M,M_k_p__,n_CTF
     $           ,ld_CTF,CTF_k_p__,grid_k_p_(nk),fftw_plan_frwd_(nk)
     $           ,fftw_plan_back_(nk) ,n_w_csum_(nk),n_w_(nk)
     $           ,fftw_in1_(na) ,fftw_out_(na),alpha2d__(0,nM)
     $           ,M_transform_(n_w_csum_(nk) -1),polar_a__(n_w_csum_(nk)-1
     $           + ld_M*nM) ,azimu_b__(n_w_csum_(nk)-1 + ld_M*nM)
     $           ,weight_CTF_k_c__(n_w_csum_(nk)-1 + ld_M*nM)
     $           ,n_w_M_(nk))
            na = na + n_w_(nk)
         enddo                  ! do nk = n_k_low-1,n_k_cur-1
         include 'test_residual_5_checkset.f'
         if ((verbose.gt.2).and.(nM.eq.0)) then
            call print_sub_c16(n_A,M_k_p__(I_M_sample_(nM)*ld_M)
     $           ,' M_k_p__: ')
            call print_sub_c16(n_A,M_transform_
     $           ,' M_transform_: ')
         end if !if verbose
         call cl1_c16(ld_M,Y_slice_)
         do nk = n_k_low-1,n_k_cur-1
            if ((verbose.gt.3).and.(nM.eq.0)) then
               write(6,'(A,I0,A,I0)') ' nk = ' , nk , ' n_w_csum_(nk) '
     $              ,n_w_csum_(nk)
            end if !if verbose
            n_Y_l = n_Y_l_(nk)
            n_polar_a_oversample = nint(lsq_oversample*n_polar_a_(nk))
            call test_residual_multa(polar_a__(n_w_csum_(nk)-1 + ld_M*nM)
     $           ,azimu_b__(n_w_csum_(nk)-1 + ld_M*nM),n_w_M_(nk)
     $           ,Y_(n_Y_lm_csum_(nk)),n_Y_l,n_polar_a_oversample
     $           ,lsq_interpolation_order ,weight_CTF_k_c__(n_w_csum_(nk)
     $           -1 + ld_M*nM) ,Y_slice_(n_w_csum_(nk)-1))
         enddo                  ! do nk = n_k_low-1,n_k_cur-1
         include 'test_residual_5_checkset.f'
         if ((verbose.gt.3).and.(nM.eq.0)) then
            call print_sub_c16(n_A,Y_slice_
     $           ,' Y_slice_: ')
         end if !if verbose
         call cl1_c16(ld_M,M_residual__(nM*ld_M))
         do nk=max(2,n_k_low-1),n_k_cur-1
            do nw=0,n_w_(nk)-1
               M_residual__(n_w_csum_(nk)-1+nw + nM*ld_M) =
     $              M_transform_(n_w_csum_(nk)-1+nw)
     $              -Y_slice_(n_w_csum_(nk)-1+nw)
            enddo !do nw=0,n_w_(nk)-1
         enddo !         do nk=max(2,n_k_low-1),n_k_cur-1
         include 'test_residual_5_checkset.f'
         if ((verbose.gt.2).and.(nM.eq.0)) then
            call print_sub_c16(n_A,M_transform_
     $           ,' M_transform_: ')
            call print_sub_c16(n_A,Y_slice_
     $           ,' Y_slice_: ')
            call print_sub_c16(n_A,M_residual__(nM*ld_M)
     $           ,' M_residual__: ')
         end if !if verbose
      enddo                     ! do nM=0,n_M-1      
      include 'test_residual_5_checkset.f'

      if (verbose.gt.0) then
         write(6,'(A)') ' initializing H__ = Et*R across images. '
      end if !if verbose
      if (verbose.gt.0) then
         write(6,'(A,I0,A)') ' H__ requires ' , n_Y_lm_csum_cur*n_M ,
     $        ' elements'
         write(6,'(A,F6.3,A)') ' H__ requires ' , n_Y_lm_csum_cur*n_M*16
     $        *1.0d-9 ,' GB'
      end if !if verbose
      do nM=0,n_M-1
         do nk = n_k_low-1,n_k_cur-1
            n_Y_l = n_Y_l_(nk)
            n_polar_a_oversample = nint(lsq_oversample
     $           *n_polar_a_(nk))
            call test_residual_multah(polar_a__(n_w_csum_(nk)-1 + ld_M
     $           *nM),azimu_b__(n_w_csum_(nk)-1 + ld_M*nM),n_w_M_(nk)
     $           ,M_residual__(n_w_csum_(nk)-1+nM*ld_M),n_Y_l
     $           ,n_polar_a_oversample ,lsq_interpolation_order
     $           ,weight_CTF_k_c__(n_w_csum_(nk)-1 + ld_M*nM)
     $           ,H__(n_Y_lm_csum_(nk) + nM*n_Y_lm_csum_cur))
         enddo                  ! do nk = n_k_low-1,n_k_cur-1
         include 'test_residual_5_checkset.f'
         if ((verbose.gt.2).and.(nM.eq.0)) then
            call print_sub_c16(n_Y_lm_csum_cur,H__(nM*n_Y_lm_csum_cur)
     $           ,' H__: ')
         end if !if verbose
      enddo                     ! do nM=0,n_M-1
      include 'test_residual_5_checkset.f'

      if (verbose.gt.1) then
         write(6,'(A)') ' initializing HH_ = dot(H,H) across images. '
      end if !if verbose
      do nM=0,n_M-1
         call dot_c16(n_Y_lm_csum_cur,H__(0 + nM*n_Y_lm_csum_cur),H__(0
     $        + nM*n_Y_lm_csum_cur),HH)
         if ((verbose.gt.2) .and. (nM.le.0)) then
            write(6,'(A,I0,A,2F8.4)') ' nM ' , nM , ' HH ' , HH
         end if !if ((verbose.gt.2) .and. (nM.le.0)) then
         HH_(nM) = HH
      enddo                     ! do nM=0,n_M-1
      include 'test_residual_5_checkset.f'
      if (verbose.gt.1) then
         call print_sub_c16(n_M,HH_,' HH_: ')
      end if !if (verbose.gt.1) then

      if (verbose.gt.1) then
         write(6,'(A)') ' calculating M_loading_'
      end if !if verbose
      do nM_loading=0,n_residual_loading*n_M-1
         M_loading_(nM_loading) = cmplx(adi_rand_f(rseed)-0.5d0,0.0d0)
      enddo !do nM_loading=0,n_residual_loading*n_M-1
      include 'test_residual_5_checkset.f'
      if (verbose.gt.2) then
         call print_sub_c16(n_residual_loading*n_M,M_loading_
     $        ,' M_loading_: ')
      end if !if (verbose.gt.2) then
      
      n_iteration = n_residual_iteration
      do niteration=0,n_iteration-1
         if (verbose.gt.1) then
            write(6,'(A,I0)') ' niteration ' , niteration
         end if !if verbose
         if (niteration.eq.0) then
            do nM_loading=0,n_residual_loading-1
               do nY_lm_sum=0,n_Y_lm_csum_cur-1
                  G_(nY_lm_sum+nM_loading*n_Y_lm_csum_cur) =
     $                 cmplx(adi_rand_f(rseed)-0.5,0.0d0)
               enddo            !do nY_lm_sum=0,n_Y_lm_csum_cur-1
               call normalize_c16(n_Y_lm_csum_cur,G_(nM_loading
     $              *n_Y_lm_csum_cur))
            enddo               !do nM_loading=0,n_residual_loading*n_Y_lm_csum_cur-1
            if (verbose.gt.2) then
               call print_sub_c16(n_residual_loading*n_Y_lm_csum_cur,G_
     $              ,' G_: ')
            end if !if verbose
         end if                 !if (niteration.eq.0) then
         if (niteration.gt.0) then
            call cl1_c16(n_Y_lm_csum_cur*n_residual_loading,G_)
            if (verbose.gt.2) then
               call print_sub_c16(n_residual_loading*n_M,M_loading_
     $              ,' M_loading_pre_: ')
               call print_sub_c16(n_Y_lm_csum_cur*n_M,H__ ,' H__pre_: ')
            end if !if verbose
            do nM=0,n_M-1
               do nM_loading=0,n_residual_loading-1
                  call ac1_c16(
     $             n_Y_lm_csum_cur,
     $             M_loading_(nM_loading + n_residual_loading*(nM)),
     $             1.0d0*cmplx(0.0d0),
     $             H__(0 + nM *n_Y_lm_csum_cur),
     $             G_(0 + nM_loading*n_Y_lm_csum_cur)
     $             )
               enddo            !do nM_loading=0,n_residual_loading-1
            enddo               ! do nM=0,n_M-1
            if (verbose.gt.2) then
               call print_sub_c16(n_residual_loading*n_Y_lm_csum_cur,G_
     $              ,' G_pos_: ')
            end if !if verbose
            call gramschmidt_c16(n_Y_lm_csum_cur,n_residual_loading,G_)
            if ((verbose.gt.2) .and. (n_residual_loading.ge.2)) then
               write(6,*) ' iteration: ' , niteration
               nM_loading = 0
               write(6,*) ' loading 0: ' , al2_c16_f(n_Y_lm_csum_cur,G_(0
     $              +nM_loading*n_Y_lm_csum_cur))
               nM_loading = 1
               write(6,*) ' loading 1: ' , al2_c16_f(n_Y_lm_csum_cur,G_(0
     $              +nM_loading*n_Y_lm_csum_cur))
               write(6,*) ' <0,0>: ' , dot_c16_f(n_Y_lm_csum_cur,G_(0 + 0
     $              *n_Y_lm_csum_cur),G_(0 + 0 *n_Y_lm_csum_cur))
               write(6,*) ' <0,1>: ' , dot_c16_f(n_Y_lm_csum_cur,G_(0 + 0
     $              *n_Y_lm_csum_cur),G_(0 + 1 *n_Y_lm_csum_cur))
               write(6,*) ' <1,0>: ' , dot_c16_f(n_Y_lm_csum_cur,G_(0 + 1
     $              *n_Y_lm_csum_cur),G_(0 + 0 *n_Y_lm_csum_cur))
               write(6,*) ' <1,1>: ' , dot_c16_f(n_Y_lm_csum_cur,G_(0 + 1
     $              *n_Y_lm_csum_cur),G_(0 + 1 *n_Y_lm_csum_cur))
            end if !if verbose
         end if                 !if (niteration.gt.0) then
         include 'test_residual_5_checkset.f'
         do nM=0,n_M-1
            HH = HH_(nM)
            if ((verbose.gt.2) .and. (nM.le.0)) then
               write(6,'(A,2F8.4)') ' HH: ' , HH
            end if !if ((verbose.gt.2) .and. (nM.le.0)) then
            do nM_loading=0,n_residual_loading-1
               call dot_c16(n_Y_lm_csum_cur,H__(0 + nM*n_Y_lm_csum_cur)
     $              ,G_(0+nM_loading*n_Y_lm_csum_cur),HG)
               if ((verbose.gt.2) .and. (nM.le.0)) then
                  write(6,'(A,I0,A,2F8.4)') ' nM_loading ' ,
     $              nM_loading ,' HG ' , HG
               end if !if ((verbose.gt.2) .and. (nM.le.0)) then
               M_loading_(nM_loading + n_residual_loading*(nM)) =
     $              dreal(HG)/max(1.0d-15,dreal(HH))
            enddo               !do nM_loading=0,n_residual_loading-1
         enddo                  ! do nM=0,n_M-1
         include 'test_residual_5_checkset.f'
         if (verbose.gt.2) then
            nM=0
            call print_sub_c16(n_residual_loading
     $           ,M_loading_(n_residual_loading*nM)
     $           ,' M_loading_(nM==0): ')
            call print_sub_c16(n_residual_loading*n_M,M_loading_
     $           ,' M_loading_: ')
         end if                 !if verbose
      include 'test_residual_5_checkset.f'
      enddo                     !do niteration=0,n_iteration-1
c$$$      deallocate(H_)
      deallocate(H__)
      deallocate(G_)
      deallocate(polar_a__)
      deallocate(azimu_b__)
      deallocate(weight_CTF_k_c__)
      deallocate(n_w_M_)

      if (verbose.gt.1) then
         write(6,'(A)') ' Destroying fftw_plans for local use.'
      end if
      do nk=0,n_k_cur-1
         call dfftw_destroy_plan(fftw_plan_frwd_(nk))
         call dfftw_destroy_plan(fftw_plan_back_(nk))
      enddo !do nk=0,n_k_cur-1
      if (verbose.gt.1) then
         write(6,'(A)') ' deallocating. '
      end if
      deallocate(fftw_plan_frwd_)
      deallocate(fftw_plan_back_)
      deallocate(fftw_in1_)
      deallocate(fftw_out_)

      if (verbose.gt.0) write(6,*)
     $     '[finished test_residual_5]'
      return
      end

!> Doxygen comment: ;\n
!>     Utilities creating Cartesian and spherical grids for ;\n
!>     physical and Fourier space, respectively. ;\n
!> Doxygen comment: ;\n
C     Utilities creating Cartesian and spherical grids for
C     physical and Fourier space, respectively.
C
C
      subroutine writevol(iout,ngrid,x1,x,y,z,ff)
c
c     dump abs(ff) to output file
c
      implicit real *8 (a-h,o-z)
      dimension x1(ngrid)
      dimension x(ngrid,ngrid,ngrid)
      dimension y(ngrid,ngrid,ngrid)
      dimension z(ngrid,ngrid,ngrid)
      complex *16 ff(ngrid,ngrid,ngrid)
c
      do i = 1,ngrid
      do j = 1,ngrid
      do k = 1,ngrid
         write(iout,*) abs(ff(i,j,k))
      enddo
      enddo
      enddo
      return
      end
c
c
      subroutine mkphysgrid(a,ngrid,h,xg,yg,zg)
c
c     create uniform ngrid x ngrid x ngrid grid on [-a,a]^3.
c
c     INPUT:
c
c     a       box dimension
c     ngrid   number of grid points in each dimension
c   
c     OUTPUT:
c
c     h         grid spacing
c     xg        x component of all grid points
c     yg        y component of all grid points
c     zg        z component of all grid points
c     
      implicit none
      integer ngrid
      real *8 a, h
      real *8 xg(ngrid,ngrid,ngrid)
      real *8 yg(ngrid,ngrid,ngrid)
      real *8 zg(ngrid,ngrid,ngrid)

      integer i, j, k
      real *8 x, y, z
c     
c     create physical space grid 
c     grab data in physical space on given grid.
c
      h = 2*a/ngrid
      do i = 1,ngrid
         x = -a + i*h
         do j = 1,ngrid
            y = -a + j*h
            do k = 1,ngrid
               z = -a + k*h
               xg(i,j,k) = x
               yg(i,j,k) = y
               zg(i,j,k) = z
c$$$               write(6,*) 'i,j,k: ',i,j,k,'; x,y,z: ',x,y,z
            enddo
         enddo
      enddo
c
      return
      end

ccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fgauss(x,y,z,x0y0z0,ns,sigma,ff)
c
c     INPUT:
c
c     x,y,z   target location
c     x0y0z0  location of Gaussian sources
c     ns      number of Gaussian sources
c     sigma   number variance of all Gaussian sources
c   
c     OUTPUT:
c
c     ff        complex function value at corresponding grid pt.
ccccccccccccccccccccccccccccccccccccccccccccccccc     
c
      implicit real *8 (a-h,o-z)
      real *8 x0y0z0(3,ns)
      complex *16 ff
c
c$$$      write(6,*) 'Entering fgauss'
      ff = 0.0d0
      do i = 1,ns
c$$$         write(6,*) 'i: ',i
         xx = x - x0y0z0(1,i)
         yy = y - x0y0z0(2,i)
         zz = z - x0y0z0(3,i)
         rr = xx*xx+yy*yy+zz*zz
         ff = ff + dexp(-rr/(2*sigma*sigma))
      enddo
c$$$      write(6,*) 'finishing fgauss'
      return
      end
c
ccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fgauss_many_sigma(x,y,z,x0y0z0,ns,sigmas,ff)
c
c      INPUT:
c
c     x,y,z   target location
c     x0y0z0  location of Gaussian sources
c     ns      number of Gaussian sources
c     sigmas   different variance for each Gaussian sources
c   
c     OUTPUT:
c
c     ff        complex function value at corresponding grid pt.
ccccccccccccccccccccccccccccccccccccccccccc     
c
      implicit none
      integer ns
      real *8 x,y,z
      real *8 x0y0z0(3,ns)
      real *8 sigmas(ns)
      complex *16 ff
c
      integer i
      real *8 sigma,rr,xx,yy,zz
c     
      ff = 0.0d0
      do i = 1,ns
         sigma = sigmas(i)
         xx = x - x0y0z0(1,i)
         yy = y - x0y0z0(2,i)
         zz = z - x0y0z0(3,i)
         rr = xx*xx+yy*yy+zz*zz
         ff = ff + dexp(-rr/(2*sigma*sigma))
      enddo
      return
      end
c
      subroutine fgaussft_many_sigma(kx,ky,kz,x0y0z0,ns,sigmas,ffhat)
c
c     Compute the Fourier transform of Gaussians (as defined in fgauss)
c
c     INPUT:
c
c     kx,ky,kz target location (in Fourier space)
c     x0y0z0   location of Gaussian sources
c     ns       number of Gaussian sources
c     sigmas    number variance for every Gaussian
c   
c     OUTPUT:
c
c     ffhat    complex function value at corresponding grid pt.
c     
c
      implicit none
      integer ns
      real *8 kx, ky, kz, sigma
      real *8 x0y0z0(3,ns),sigmas(ns)
      complex *16 ffhat
c
      integer i
      real *8 arg1, arg2
      complex *16 eye
      real *8 pi
c
      pi = 4.0d0*datan(1.0d0)
      eye = dcmplx(0.0d0,1.0d0)
      ffhat = 0.0d0
      do i = 1,ns
         sigma = sigmas(i)
         arg1 = kx*x0y0z0(1,i) + ky*x0y0z0(2,i) + kz*x0y0z0(3,i)
         arg2 = -(kx*kx + ky*ky + kz*kz) * sigma*sigma/2
         ffhat = ffhat + cdexp(eye*arg1 + arg2)*(2*pi)*
     1        dsqrt(2*pi)*sigma**3
      enddo
      return
      end
c
      subroutine evalgrid_many_sigma(x,y,z,n1,n2,n3,x0y0z0,ns,sigmas,
     1     fneval,ff)
c
      implicit none
      integer ns,n1,n2,n3
      real *8 x(n1,n2,n3), y(n1,n2,n3), z(n1,n2,n3)
      real *8 x0y0z0(3,ns),sigmas(ns)
      complex *16 ff(n1,n2,n3)
      external fneval
c
      integer i1, i2, i3
c
      do i3 = 1,n3
         do i2 = 1,n2
            do i1 = 1,n1
               call fneval(x(i1,i2,i3), y(i1,i2,i3), z(i1,i2,i3),
     1              x0y0z0, ns, sigmas, ff(i1,i2,i3))
            enddo
         enddo
      enddo
c
      return
      end
c
c     
      subroutine fgaussft(kx,ky,kz,x0y0z0,ns,sigma,ffhat)
c
c     Compute the Fourier transform of Gaussians (as defined in fgauss)
c
c     INPUT:
c
c     kx,ky,kz target location (in Fourier space)
c     x0y0z0   location of Gaussian sources
c     ns       number of Gaussian sources
c     sigma    number variance of all Gaussian sources
c   
c     OUTPUT:
c
c     ffhat    complex function value at corresponding grid pt.
c     
      implicit none
      integer ns
      real *8 kx, ky, kz, sigma
      real *8 x0y0z0(3,ns)
      complex *16 ffhat
c
      integer i
      real *8 arg1, arg2
      complex *16 eye
      real *8 pi
c
      pi = 4.0d0*datan(1.0d0)
      eye = dcmplx(0.0d0,1.0d0)
      ffhat = 0.0d0
      do i = 1,ns
         arg1 = kx*x0y0z0(1,i) + ky*x0y0z0(2,i) + kz*x0y0z0(3,i)
         arg2 = -(kx*kx + ky*ky + kz*kz) * sigma*sigma/2
         ffhat = ffhat + cdexp(eye*arg1 + arg2)
      enddo
      ffhat = ffhat * (2*pi)*dsqrt(2*pi)*sigma**3
      return
      end
c 
c
      subroutine evalgrid(x,y,z,n1,n2,n3,x0y0z0,ns,sigma,fneval,ff)
c
      implicit none
      integer ns,n1,n2,n3
      real *8 x(n1,n2,n3), y(n1,n2,n3), z(n1,n2,n3), sigma
      real *8 x0y0z0(3,ns)
      complex *16 ff(n1,n2,n3)
      complex *16 ftmp
      external fneval
c 
      integer i1, i2, i3
c$$$      write(6,*) 'entering evalgrid'
c$$$      write(6,*) 'ns: ',ns
c$$$      do i1=1,3
c$$$         write(6,*) (x0y0z0(i1,i2),i2=1,ns)
c$$$      enddo
c$$$      write(6,*) 'sigma: ',sigma
      call fneval(0d0,0d0,0d0,x0y0z0,32,1.0d0/32.0d0,ftmp)
c
      do i3 = 1,n3
         do i2 = 1,n2
            do i1 = 1,n1
c$$$               write(6,*) 'i1,i2,i3: ',i1,i2,i3
c$$$               write(6,*) 'x: ',x(i1,i2,i3)
c$$$               write(6,*) 'y: ',x(i1,i2,i3)
c$$$               write(6,*) 'z: ',x(i1,i2,i3)
c$$$               write(6,*) 'S: ',ff(i1,i2,i3)
c$$$               write(6,*) 'Calling fneval'
               call fneval(x(i1,i2,i3),y(i1,i2,i3),z(i1,i2,i3),
     1               x0y0z0,ns,sigma,ff(i1,i2,i3))
            enddo
         enddo
      enddo

c$$$      write(6,*) 'finished evalgrid'
c
      return
      end
c
c
c
      subroutine l2error_c(a1, a2, n, l2err, l2)
c
c     Compute L2 norm of a1-a2
c
c     INPUT:
c     a1      First array of complex numbers
c     a2      Second array of complex numbers
c     n       Number of elements
c
c     OUTPUT:
c     l2err   L2 norm of (a1 - a2)
c     l2      L2 norm of a1
c
      implicit none
      complex *16 a1(n), a2(n)
      integer n
      real *8 l2err, l2
c
      integer i
c
      l2 = 0.0d0
      l2err = 0.0d0
      do i=1,n
         l2 = l2 + abs(a1(i))**2
         l2err = l2err + abs(a1(i) - a2(i))**2
      enddo
c
      l2 = sqrt(l2)
      l2err = sqrt(l2err)
c 
      return
      end
c
c

C
C***********************************************************************
      subroutine sph_gridconfig1(ngridr, sph_size, sph_nterms, 
     1     sph_sizes,sph_startix)
C***********************************************************************
c     Set spherical harmonic expansion degrees according to radius
c     and determine size of various arrays
C---------------------------------------------------------------------
C     INPUT:
c
c     ngridr 		: number of radial grid points
c
C---------------------------------------------------------------------
C     OUTPUT:
C
c     sph_size:            size of the array required to store all 
c                          spherical harmonics expansions
c     sph_sizes(ngridr):   size of spherical harmonic expansion for 
c                          radius r(ngridr)
c     sph_nterms(ngridr):  spherical harmonic degree for radius r(ngridr)
c     sph_startix(ngridr): starting index for expansion at radius r(ngridr)
C***********************************************************************
      implicit none
      integer ngridr
      integer sph_size, sph_sizes(ngridr), sph_startix(ngridr)
      integer sph_nterms(ngridr)
c
      integer i, n
c
      sph_size = 0
      do i = 1,ngridr
c        hard code for all expansions
c         n = 30
c     size of expansions varies with i
c         n = max(5,i)
         n = i+2
         sph_nterms(i) = n
         sph_sizes(i) = (n+1)*(n+1)
         sph_startix(i) = sph_size

         sph_size = sph_size + (n+1)*(n+1)
      enddo

      return
      end

cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine sph_gridconfig(ngridr, sph_size, sph_nterms, 
     1     sph_sizes,sph_startix, xnodesr)
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     Configure the grid of spherical harmonics expansions by radius
c
c     Inputs:
c     ngridr: number of radial grid points
c
c     Outputs:
c     sph_size:            total size of the array required to store the spherical harmonics expansions
c     sph_sizes(ngridr):   individual sizes of spherical hardmonics expansion by radius
c     sph_nterms(ngridr):  number of terms of the expansion by radius (nterms)
c     sph_startix(ngridr): starting index for an expansion by radius
c
      implicit none
      integer ngridr
      integer sph_size, sph_sizes(ngridr), sph_startix(ngridr)
      integer sph_nterms(ngridr)
      real *8 xnodesr(ngridr)
c
      integer i, n
c
      sph_size = 0
      do i = 1,ngridr
c        hard code for all expansions
c         n = 30
c     size of expansions varies with i
         n = floor(xnodesr(i))+2
c         write(6,*) i, xnodesr(i),n
         sph_nterms(i) = n
         sph_sizes(i) = (n+1)*(n+1)
         sph_startix(i) = sph_size

         sph_size = sph_size + (n+1)*(n+1)
      enddo

      return
      end
C
c
c
c
C
C
      SUBROUTINE PRINM(MPOLE,NTERMS)
      implicit real *8 (a-h,o-z)
      real *8 MPOLE0(0:NTERMS,-nterms:NTERMS)
      real *8 MPOLE2(0:NTERMS,0:NTERMS)
      COMPLEX *16 MPOLE(0:NTERMS,-nterms:NTERMS)
      INTEGER NTERMS
C
C     print out coefficients of multipole expansion
C
1000  FORMAT(6E12.5)
1001  FORMAT(/)
      DO 100 L = 0,NTERMS
         WRITE(6,1000)(MPOLE(L,M),M=-L,L)
         WRITE(13,1000)(MPOLE(L,M),M=-L,L)
         WRITE(6,1001)
         WRITE(13,1001)
100   CONTINUE
        return
C
C
C
C
      ENTRY PRINM0(MPOLE0,NTERMS)
      DO 200 L = 0,NTERMS
         WRITE(6,1000)(MPOLE0(L,M),M=-L,L)
         WRITE(13,1000)(MPOLE0(L,M),M=-L,L)
         WRITE(6,1001)
         WRITE(13,1001)
200   CONTINUE
      RETURN
C
C
      ENTRY PRINM2(MPOLE2,NTERMS)
      DO L = 0,NTERMS
         WRITE(6,1000)(MPOLE2(L,M),M=0,L)
         WRITE(13,1000)(MPOLE2(L,M),M=0,L)
         WRITE(6,1001)
         WRITE(13,1001)
      ENDDO
c
c
      RETURN
      end
c
c
c
c**********************************************************************
      subroutine hpotfld3dall(iffld,sources,charge,ns,
     1                   target,wavek,pot,fld)
      implicit real *8 (a-h,o-z)
c**********************************************************************
c
c     This subroutine calculates the potential POT and field FLD
c     at the target point TARGET, due to a collection of charges at 
c     SOURCE(3,ns). The scaling is that required of the delta function
c     response: i.e.,
c     
c              	pot = exp(i*k*r)/r
c		fld = grad(pot)
c
c     INPUT:
c
c     iffld  (integer *4)      : flag for computing gradient
c	                 	   ffld = 0 -> don't compute 
c		                   ffld = 1 -> do compute 
c     sources(3,ns)  (real *8) : location of the sources
c     charge(ns) (complex *16) : charge strength
c     target(3)  (real *8)     : location of the target
c     wavek  (complex *16)     : helmholtz parameter
c
c     OUTPUT:
c
c     pot   (real *8)        : calculated potential
c     fld   (real *8)        : calculated gradient
c
      real *8 sources(3,ns),target(3)
      complex *16 wavek,pot,fld(3),potloc,fldloc(3)
      complex *16 h0,h1,cd,eye,z,ewavek
      complex *16 charge(ns)
c
      data eye/(0.0d0,1.0d0)/
c
      pot = 0.0d0
      if (iffld.eq.1) then
         fld(1) = 0.0d0
         fld(2) = 0.0d0
         fld(3) = 0.0d0
      endif
c
      do i = 1,ns
         call hpotfld3d(iffld,sources(1,i),charge(i),target,wavek,
     1        potloc,fldloc)
         pot = pot + potloc
         fld(1) = fld(1) + fldloc(1)
         fld(2) = fld(2) + fldloc(2)
         fld(3) = fld(3) + fldloc(3)
      enddo
      return
      end
c
c
c
c
c
c**********************************************************************
      subroutine hpotfld3d(iffld,source,charge,target,wavek,pot,fld)
      implicit real *8 (a-h,o-z)
c**********************************************************************
c
c     This subroutine calculates the potential POT and field FLD
c     at the target point TARGET, due to a charge at 
c     SOURCE. The scaling is that required of the delta function
c     response: i.e.,
c     
c              	pot = exp(i*k*r)/r
c		fld = grad(pot)
c
c     INPUT:
c
c     iffld  (integer *4)    : flag for computing gradient
c	                 	ffld = 0 -> don't compute 
c		                ffld = 1 -> do compute 
c     source(3)  (real *8)   : location of the source 
c     charge  (complex *16)  : charge strength
c     target(3)  (real *8)   : location of the target
c     wavek  (complex *16)   : helmholtz parameter
c
c     OUTPUT:
c
c     pot   (real *8)        : calculated potential
c     fld   (real *8)        : calculated gradient
c
      real *8 source(3),target(3)
      complex *16 wavek,pot,fld(3)
      complex *16 h0,h1,cd,eye,z,ewavek
      complex *16 charge
c
      data eye/(0.0d0,1.0d0)/
c
c ... Caculate offsets and distance
c
      xdiff=target(1)-source(1)
      ydiff=target(2)-source(2)
      zdiff=target(3)-source(3)
      dd=xdiff*xdiff+ydiff*ydiff+zdiff*zdiff
      d=sqrt(dd)
c
c ... Calculate the potential and field in the regular case:
c
      z=d*wavek
      call h3d01(z,h0,h1)
c
c ... Get potential and field as per required
c
c     Field is - grad(pot).
c
      ewavek=eye*wavek
      pot=h0*ewavek*charge
      if (iffld.eq.1) then
ccc         dinv=-1.0d0/d
         dinv=1.0d0/d
         cd=h1*dinv*ewavek*wavek*charge
         fld(1)=cd*xdiff
         fld(2)=cd*ydiff
         fld(3)=cd*zdiff
      endif
c
      return
      end
c
c
c**********************************************************************
      subroutine h3d01(z,h0,h1)
c**********************************************************************
c
c     Compute spherical Hankel functions of order 0 and 1.
c
c     h0 = exp(i*z)/(i*z),
c     h1 = - h0' = -h0*(i-1/z) = h0*(1/z-i)
c
c-----------------------------------------------------------------------
c     INPUT:
c
c	z    argument of Hankel functions
c            if abs(z)<1.0d-15, returns zero.
c
c-----------------------------------------------------------------------
c     OUTPUT:
c
c	h0 =  h0(z)    (spherical Hankel function of order 0).
c	h1 =  -h0'(z)  (spherical Hankel function of order 1).
c
c-----------------------------------------------------------------------
      implicit real *8 (a-h,o-z)
      complex *16 z,zinv,eye,cd,h0,h1
      data eye/(0.0d0,1.0d0)/, thresh/1.0d-15/, done/1.0d0/
c
      if (abs(z).lt.thresh) then
         h0=0.0d0
         h1=0.0d0
         return
      endif
c
c     Otherwise, use formula
c
      cd = eye*z
      h0=exp(cd)/cd
      h1=h0*(done/z - eye)
c
      return
      end
c


!> Doxygen comment: ;\n
!> This file contains a suite of evaluation codes for associated  ;\n
!> Legendre functions with various scalings, arguent types, etc. ;\n
!> Following is a brief description of the user-callable subroutines. ;\n
!> (FORTRAN 77 VERSION). ;\n
!> Doxygen comment: ;\n
cc Copyright (C) 2009-2011: Leslie Greengard and Zydrunas Gimbutas
cc Contact: greengard@cims.nyu.edu
cc 
cc This program is free software; you can redistribute it and/or modify 
cc it under the terms of the GNU General Public License as published by 
cc the Free Software Foundation; either version 2 of the License, or 
cc (at your option) any later version.  This program is distributed in 
cc the hope that it will be useful, but WITHOUT ANY WARRANTY; without 
cc even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
cc PARTICULAR PURPOSE.  See the GNU General Public License for more 
cc details. You should have received a copy of the GNU General Public 
cc License along with this program; 
cc if not, see <http://www.gnu.org/licenses/>.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c    $Date$
c    $Revision$
c
c
c  This file contains a suite of evaluation codes for associated 
c  Legendre functions with various scalings, arguent types, etc.
c  Following is a brief description of the user-callable subroutines.
c  (FORTRAN 77 VERSION).
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Simple routines for real argument.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       ylgndr - evaluate normalized Legendre functions
c
c       ylgndr2 - evaluate normalized Legendre functions 
c                 and their derivatives
c
c       ylgndr2s - evaluate normalized Legendre functions and their
c            derivatives with scaling. 
c            For m>0, the Ynm(x) values are scaled by 1/sqrt(1-x^2),
c            For m>0, the Ynm(x) derivatives with respect to x are 
c            scaled by sqrt(1-x^2).
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Simple routines for real argument (not scaled by sqrt(2*n+1))
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       ylgndru - evaluate normalized Legendre functions
c
c       ylgndru2 - evaluate normalized Legendre functions 
c                 and their derivatives
c
c       ylgndru2s - evaluate normalized Legendre functions and their
c            derivatives with scaling. 
c            For m>0, the Ynm(x) values are scaled by 1/sqrt(1-x^2),
c            For m>0, the Ynm(x) derivatives with respect to x are 
c            scaled by sqrt(1-x^2).
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Simple routines for real argument
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       ylgndr2sm - evaluate normalized Legendre functions and their
c            derivatives with scaling. 
c            For m>0, the Ynm(x) values are scaled by 1/sqrt(1-x^2)**m,
c            For m>0, the Ynm(x) derivatives with respect to x are 
c            scaled by 1/sqrt(1-x^2)**(m-2).
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Accelerated codes with precompution for real argument.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       ylgndrini - precomputation routine for recursion coefficients.
c                   Used by "fast" routines ylgndrf, ylgndr2f, ylgndr2sf.
c
c       ylgndrf - faster evaluation of normalized Legendre functions. 
c                 Requires prior call to ylgndrini.
c
c       ylgndr2f - faster evaluation of normalized Legendre functions 
c                  and their derivatives. 
c                  Requires prior call to ylgndrini.
c
c       ylgndr2sf - faster evaluation of  normalized Legendre functions 
c                   and their derivatives (with scaling as in ylgndr2s).
c                   Requires prior call to ylgndrini.
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Simple codes for complex argument.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       zylgndr - evaluate normalized Legendre functions 
c                 of a complex argument
c
c       zylgndr2 - evaluate normalized Legendre functions 
c                  of a complex argument and their derivatives 
c
c       zylgndr2s - evaluate normalized Legendre functions 
c                  of a complex argument and their derivatives 
c                  (with scaling as in ylgndr2s)
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Accelerated codes with precompution for complex argument.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       zylgndrf - faster evaluation of normalized Legendre functions 
c                  of a complex argument.
c                  Requires prior call to ylgndrini.
c
c       zylgndr2f - faster evaluation of normalized Legendre functions 
c                   of a complex argument and their derivatives.
c                   Requires prior call to ylgndrini.
c
c       zylgndr2sf - faster evaluation of normalized Legendre functions 
c                    of a complex argument and their derivatives 
c                   (with scaling as in ylgndr2s).
c                   Requires prior call to ylgndrini.
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Miscellaneous, special purpose codes.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       zylgndrbr - evaluate normalized Legendre functions of a 
c            complex argument with modified branch cut.
c
c       zylgndrsc - evaluate normalized Legendre functions of a complex
c            argument with scaling to prevent overflow for large values
c            of z.
c
c       ylgndrpm, ylgndrpm_opt - Given Y_nm(x), return Y_nm(-x)
c
c       ylgndr2pm. ylgndrpm_opt - Given Y_nm(x) and Y'_nm(x), 
c                                 return Y_nm(-x) and Y'_nm(-x)
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Truncated evaluation routines: computation carried out for
c       orders up to specified parameter rather than max degree.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       ylgndr2s_trunc - evaluate normalized Legendre functions and their
c            derivatives (with scaling as in ylgndr2s), 
c            BUT recursion carried out only to m = m2 rather than nmax.
c
c       ylgndrf_trunc - faster evaluation of normalized Legendre functions. 
c            Same as ylgndrf, BUT recursion carried out only to m = m2 
c            rather than nmax.
c            Requires prior call to ylgndrini.
c
c       ylgndr2f_trunc - faster evaluation of  normalized Legendre 
c            functions and their derivatives. Same as ylgndr2f, 
c            BUT recursion carried out only to m = m2 rather than nmax.
c
c       ylgndr2sf_trunc - faster evaluation of normalized Legendre 
c            functions and their derivatives (with scaling). 
c            Same as ylgndr2sf, BUT recursion carried out only to 
c            m = m2 rather than nmax.
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Accelerated codes with precompution for real argument: 
c       precomputation is done only once for orders up to nmax, 
c       the routines are able to revert to simple routines for
c       higher orders
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       ylgndrfwini - precomputation routine for recursion coefficients.
c                   Used by "fast" routines ylgndrfw, ylgndr2fw, ylgndr2sfw.
c
c       ylgndrfw - faster evaluation of normalized Legendre functions. 
c                 Requires prior call to ylgndrfwini.
c
c       ylgndr2fw - faster evaluation of normalized Legendre functions 
c                  and their derivatives. 
c                  Requires prior call to ylgndrfwini.
c
c       ylgndr2sfw - faster evaluation of  normalized Legendre functions 
c                   and their derivatives (with scaling as in ylgndr2s).
c                   Requires prior call to ylgndrfwini.
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       (not scaled by sqrt(2*n+1))
c
c       ylgndrufw - faster evaluation of normalized Legendre functions. 
c                 Requires prior call to ylgndrfwini.
c
c       ylgndru2fw - faster evaluation of normalized Legendre functions 
c                  and their derivatives. 
c                  Requires prior call to ylgndrfwini.
c
c       ylgndru2sfw - faster evaluation of  normalized Legendre functions 
c                   and their derivatives (with scaling as in ylgndr2s).
c                   Requires prior call to ylgndrfwini.
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     CODES
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
      subroutine ylgndr(nmax, x, y)
      implicit none
c
c     Evaluate normalized Legendre functions defined as:
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                 must be non-negative
c     x                    -1 <= x <= 1
c     y(0:nmax,0:nmax)     resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x)
c     for 0 <= n <= nmax  and  0 <= m <= n.  Other elements of y
c     will contain undefined values.
c
cf2py intent(in) nmax
cf2py intent(in) x
cf2py intent(out) y

      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), u
c
      u=-sqrt((1-x)*(1+x))
      y(0,0)=1
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
      subroutine ylgndr2(nmax, x, y, d)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, x
cf2py intent(out) y,d
c
      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, du
c
      u=-sqrt((1-x)*(1+x))
      du=x/sqrt((1-x)*(1+x))
      y(0,0)=1
      d(0,0)=0
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x/u**2
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
         if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
            d(n,m)=((2*n-1)*(x*d(n-1,m)+y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
      subroutine ylgndr2s(nmax, x, y, d)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     For m>0, 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, x
cf2py intent(out) y,d
c
      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u
      u=-sqrt((1-x)*(1+x))
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
      if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*sqrt(2*m+1.0d0)
      do n=m+2, nmax
        y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
        d(n,m)=((2*n-1)*(x*d(n-1,m)+y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, nmax
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
         if (m.lt.nmax)  
     $      d(m+1,m)=(x*d(m,m)+(1-x**2)*y(m,m))*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
            d(n,m)=((2*n-1)*(x*d(n-1,m)+(1-x**2)*y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
c
      subroutine ylgndru(nmax, x, y)
      implicit none
c
c     Evaluate normalized Legendre functions defined as:
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                 must be non-negative
c     x                    -1 <= x <= 1
c     y(0:nmax,0:nmax)     resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x)
c     for 0 <= n <= nmax  and  0 <= m <= n.  Other elements of y
c     will contain undefined values.
c
cf2py intent(in) nmax
cf2py intent(in) x
cf2py intent(out) y

      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), u
c
c
      u=-sqrt((1-x)*(1+x))
      y(0,0)=1
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c      do n=0, nmax
c        do m=0, n
c           y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
c         enddo
c      enddo
      return
      end
c
c
c
c
c
      subroutine ylgndru2(nmax, x, y, d)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, x
cf2py intent(out) y,d
c
      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, du
c
      u=-sqrt((1-x)*(1+x))
      du=x/sqrt((1-x)*(1+x))
      y(0,0)=1
      d(0,0)=0
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x/u**2
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
         if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
            d(n,m)=((2*n-1)*(x*d(n-1,m)+y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c      do n=0, nmax
c        do m=0, n
c           y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
c           d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
c         enddo
c      enddo
      return
      end
c
c
c
c
c
      subroutine ylgndru2s(nmax, x, y, d)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     For m>0, 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, x
cf2py intent(out) y,d
c
      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, u2
c
      u=-sqrt((1-x)*(1+x))
      u2 = (1-x)*(1+x)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
      if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*sqrt(2*m+1.0d0)
      do n=m+2, nmax
        y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
        d(n,m)=((2*n-1)*(x*d(n-1,m)+y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, nmax
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
         if (m.lt.nmax)  
     $      d(m+1,m)=(x*d(m,m)+u2*y(m,m))*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
            d(n,m)=((2*n-1)*(x*d(n-1,m)+u2*y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c      do n=0, nmax
c        do m=0, n
c           y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
c           d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
c         enddo
c      enddo
      return
      end
c
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
c
c
      subroutine ylgndr2sm(nmax, x, y, d)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     For m>0, 
c          the functions are scaled by 1/sqrt(1-x**2)**m
c          the derivatives are scaled by 1/sqrt(1-x**2)**(m-2)
c
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, x
cf2py intent(out) y,d
c
      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, u2
c
      u=-sqrt((1-x))*sqrt((1+x))
      u2 = (1-x)*(1+x)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
      if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*sqrt(2*m+1.0d0)
      do n=m+2, nmax
        y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
        d(n,m)=((2*n-1)*(x*d(n-1,m)+y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, nmax
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*(-1)*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
         if (m.lt.nmax)  
     $      d(m+1,m)=(x*d(m,m)+u2*y(m,m))*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
            d(n,m)=((2*n-1)*(x*d(n-1,m)+u2*y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       faster version for real argument 
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
      subroutine ylgndrini(nmax, rat1, rat2)
      implicit none
c
c     Precompute the recurrence coefficients for the fast
c     evaluation of normalized Legendre functions and their derivatives
c    
c     Parameters:
c       nmax                      must be non-negative
c       rat1(0:nmax,0:nmax)       recurrence coefficient
c       rat2(0:nmax,0:nmax)       recurrence coefficient
c
cf2py intent(in) nmax
cf2py intent(out) rat1, rat2
c
      integer nmax, m, n
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      rat1(0,0)=1
      rat2(0,0)=1
      do m=0, nmax
         if (m.gt.0)  rat1(m,m)=sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  rat2(m,m)=1
         if (m.lt.nmax)  rat1(m+1,m)=sqrt(2*m+1.0d0)
         if (m.lt.nmax)  rat2(m+1,m)=1
         do n=m+2, nmax
            rat1(n,m)=(2*n-1)
            rat2(n,m)=sqrt((n+m-1.0d0)*(n-m-1.0d0))
            rat1(n,m)=rat1(n,m)/sqrt(dble(n-m)*(n+m))
            rat2(n,m)=rat2(n,m)/sqrt(dble(n-m)*(n+m))
         enddo
      enddo
c
c      do m=0, nmax
c        do n=m, nmax
c            rat1(m,n)=rat1(n,m)
c            rat2(m,n)=rat2(n,m)
c         enddo
c      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndrf(nmax, x, y, rat1, rat2)
      implicit none
c
c     Evaluate normalized Legendre functions
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. 
c
cf2py intent(in) nmax, x, rat1, rat2
cf2py intent(out) y
c
      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), u
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      y(0,0)=1
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndr2f(nmax, x, y, d, rat1, rat2)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, x, rat1, rat2
cf2py intent(out) y, d
c
      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, du
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
c
      u=-sqrt((1-x)*(1+x))
      du=x/sqrt((1-x)*(1+x))
      y(0,0)=1
      d(0,0)=0
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x/u**2
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndr2sf(nmax, x, y, d, rat1, rat2)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, x, rat1, rat2
cf2py intent(out) y, d
c
      integer nmax, m, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, u2
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      u2 = (1-x)*(1+x)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
      if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
      do n=m+2, nmax
        y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
        d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, nmax
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*rat1(m,m)
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nmax)  
     $      d(m+1,m)=(x*d(m,m)+u2*y(m,m))*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+u2*y(n-1,m))-
     $         rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
      subroutine ylgndru2sf(nmax, x, y, d, rat1, rat2)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) =  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx =  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, x, rat1, rat2
cf2py intent(out) y, d
c
      integer nmax, n, m
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, u2
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      u2 = (1-x)*(1+x)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
      if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
      do n=m+2, nmax
        y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
        d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, nmax
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*rat1(m,m)
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nmax)  
     $      d(m+1,m)=(x*d(m,m)+u2*y(m,m))*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+u2*y(n-1,m))-
     $         rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
c      do n=0, nmax
c        do m=0, n
c           y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
c           d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
c        enddo
c      enddo
      return
      end
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       complex valued Legendre functions
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
      subroutine zylgndr(nmax, z, y)
      implicit none
c
c     Evaluate normalized Legendre function for complex argument
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     z                     complex*16
c     y(0:nmax,0:nmax)      resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(z)
c     for 0 <= n <= nmax  and  0 <= m <= n.  Other elements of y
c     will contain undefined values.
c
cf2py intent(in) nmax, z
cf2py intent(out) y
c
      integer nmax
      complex*16 z, y(0:nmax,0:nmax)
c
      integer m,n
      complex*16 u
c
      u=-sqrt(1-z*z)
      y(0,0)=1
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*z*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
      subroutine zylgndr2(nmax, z, y, d)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c       for complex argument
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     z                     complex *16
c     y(0:nmax,0:nmax)      resulting function values, complex *16
c     d(0:nmax,0:nmax)      resulting derivative values, complex *16
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention is valid for the derivative.
c
cf2py intent(in) nmax, z
cf2py intent(out) y, d
c
      integer nmax, m, n
      complex *16 z, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, du
      u=-sqrt(1-z*z)
      du=-z/u
      y(0,0)=1
      d(0,0)=0
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*z/u**2
         if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*sqrt(2*m+1.0d0)
         if (m.lt.nmax)  d(m+1,m)=(z*d(m,m)+y(m,m))*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*z*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
            d(n,m)=((2*n-1)*(z*d(n-1,m)+y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
      subroutine zylgndr2s(nmax, z, y, d)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(z) with m>0 
c          the functions are scaled by 1/sqrt(1-z**2)
c          the derivatives are scaled by sqrt(1-z**2)
c
c
c      Ynm(z) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(z)
c
c      d Ynm(z) / dz = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(z) / dz
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     z                     complex *16
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(z) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, z
cf2py intent(out) y, d
c
      integer nmax, m, n
      complex *16 z, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u
      u=-sqrt(1-z*z)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*sqrt(2*m+1.0d0)
      if (m.lt.nmax)  d(m+1,m)=(z*d(m,m)+y(m,m))*sqrt(2*m+1.0d0)
      do n=m+2, nmax
        y(n,m)=((2*n-1)*z*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
        d(n,m)=((2*n-1)*(z*d(n-1,m)+y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, nmax
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*z
c
         if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*sqrt(2*m+1.0d0)
         if (m.lt.nmax)  
     $      d(m+1,m)=(z*d(m,m)+(1-z**2)*y(m,m))*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*z*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
            d(n,m)=((2*n-1)*(z*d(n-1,m)+(1-z**2)*y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
      subroutine zylgndrf(nmax, z, y, rat1, rat2)
      implicit none
c
c     Evaluate normalized Legendre functions
c
c      Ynm(z) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(z)
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     z                     complex *16
c     y(0:nmax,0:nmax)      resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(z) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. 
c
cf2py intent(in) nmax, z, rat1, rat2
cf2py intent(out) y
c
      integer nmax, m, n
      complex *16 z, y(0:nmax,0:nmax), u
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt(1-z*z)
      y(0,0)=1
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*z*y(n-1,m)-rat2(n,m)*y(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine zylgndr2f(nmax, z, y, d, rat1, rat2)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(z) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(z)
c
c      d Ynm(z) / dz = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(z) / dz
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     z                     complex *16
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(z) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, z, rat1, rat2
cf2py intent(out) y, d
c
      integer nmax, m, n
      complex *16 z, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, du
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt(1-z*z)
      du=z/sqrt(1-z*z)
      y(0,0)=1
      d(0,0)=0
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=(d(m-1,m-1)*u+du)*rat1(m,m)
ccc      if (m.gt.0)  d(m,m)=y(m,m)*(-m)*z/u**2
         if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*rat1(m+1,m)
         if (m.lt.nmax)  d(m+1,m)=(z*d(m,m)+y(m,m))*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*z*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(z*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine zylgndr2sf(nmax, z, y, d, rat1, rat2)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(z) with m>0 
c          the functions are scaled by 1/sqrt(1-z**2)
c          the derivatives are scaled by sqrt(1-z**2)
c
c
c      Ynm(z) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(z)
c
c      d Ynm(z) / dz = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(z) / dz
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     z                     complex *16
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(z) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, z, rat1, rat2
cf2py intent(out) y, d
c
      integer nmax, m, n
      complex *16 z, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt(1-z*z)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*rat1(m+1,m)
      if (m.lt.nmax)  d(m+1,m)=(z*d(m,m)+y(m,m))*rat1(m+1,m)
      do n=m+2, nmax
        y(n,m)=rat1(n,m)*z*y(n-1,m)-rat2(n,m)*y(n-2,m)
        d(n,m)=rat1(n,m)*(z*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, nmax
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*rat1(m,m)
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*z
c
         if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*rat1(m+1,m)
         if (m.lt.nmax)  
     $      d(m+1,m)=(z*d(m,m)+(1-z**2)*y(m,m))*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*z*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(z*d(n-1,m)+(1-z**2)*y(n-1,m))-
     $         rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       complex valued Legendre functions, modified branch cut
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
      subroutine zylgndrbr(nmax, z, y)
      implicit none
c
c     Evaluate normalized Legendre function for complex argument
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     z                     complex*16
c     y(0:nmax,0:nmax)      resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(z)
c     for 0 <= n <= nmax  and  0 <= m <= n.  Other elements of y
c     will contain undefined values.
c
c       Modified branch cut at (0,+i) 
c
cf2py intent(in) nmax, z
cf2py intent(out) y
c
      integer nmax
      complex*16 z, y(0:nmax,0:nmax)
c
      integer m,n
      complex*16 u
c
      u=-sqrt(1-z*z)
c
c     branch cut at (0,+i), select the lower branch 
c     of complex square root
c
      if( imag(1-z*z) .gt. 0 .and. real(1-z*z) .lt. 0) u=+sqrt(1-z*z)
ccc      call prin2('in zylgndrbr, u=*', -u, 2)
ccc      call prin2('in zylgndrbr, 1-z^2=*', 1-z*z, 2)
c
      y(0,0)=1
      do m=0, nmax
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.lt.nmax)  y(m+1,m)=z*y(m,m)*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*z*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       complex valued Legendre functions (scaled)
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
c
c
      subroutine zylgndrsc(nmax, z,scale, ysc)
      implicit none
c
c     Evaluate scaled versions of zylgndr.  zylgndr is the complex version
c     of the normalized Legendre function.  Scaling removes the possible
c     conditioning errors from zylgndr evaluated at large arguments.
c
c     y_nm = scale**(-n) * ysc_nm
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                      must be non-negative
c     z (complex*16)            complex *16 argument
c     scale (real*8)
c          looks like scale wants to be O(1/z) and scale<1.
c     ysc(0:nmax,0:nmax)        resulting function values
c
cf2py intent(in) nmax, z, scale
cf2py intent(out) ysc
c
      integer nmax
      complex*16 z, ysc(0:nmax,0:nmax)
      real*8 scale
c
      integer m,n
      complex*16 u
c
      u=-sqrt(1-z*z)
      ysc(0,0)=1
      do m=0, nmax
         if (m.gt.0)  then
            ysc(m,m)=ysc(m-1,m-1)*scale*u*sqrt((2*m-1.0d0)/(2*m))
c           call prinf('m=*',m,1)
c           call prin2('ysc(m,m)=*',ysc(m,m),2)
         endif
         if (m.lt.nmax)  then
            ysc(m+1,m)=z*scale*ysc(m,m)*sqrt(2*m+1.0d0)
         endif
         do n=m+2, nmax
            ysc(n,m)=((2*n-1)*scale*z*ysc(n-1,m) - 
     1           sqrt((n+m-1.0d0)*(n-m-1.0d0))*scale**2*ysc(n-2,m))
     2           /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c
      do n=0, nmax
         do m=0, n
            ysc(n,m)=ysc(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       truncated recurrences for Legendre functions:
c    
c       Ynm(theta) for n = 0,nmax  but m = -m2,...,m2  with m2 < nmax.
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
c
      subroutine ylgndr2s_trunc(nmax, m2, x, y, d)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, m2, x
cf2py intent(out) y, d
c
      integer nmax, m, m2, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u
      u=-sqrt((1-x)*(1+x))
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
      if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*sqrt(2*m+1.0d0)
      do n=m+2, nmax
        y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
        d(n,m)=((2*n-1)*(x*d(n-1,m)+y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, m2
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*sqrt((2*m-1.0d0)/(2*m))
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*sqrt(2*m+1.0d0)
         if (m.lt.nmax)  
     $      d(m+1,m)=(x*d(m,m)+(1-x**2)*y(m,m))*sqrt(2*m+1.0d0)
         do n=m+2, nmax
            y(n,m)=((2*n-1)*x*y(n-1,m) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*y(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
            d(n,m)=((2*n-1)*(x*d(n-1,m)+(1-x**2)*y(n-1,m)) - 
     1               sqrt((n+m-1.0d0)*(n-m-1.0d0))*d(n-2,m))
     2               /sqrt((n-m+0.0d0)*(n+m))
         enddo
      enddo
c
      do n=0, nmax
         do m=0, min(n,m2)
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
c
      subroutine ylgndrf_trunc(nmax, m2, x, y, rat1, rat2)
      implicit none
c
c     Evaluate normalized Legendre functions
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., min(m2,n).
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. 
c
cf2py intent(in) nmax, m2, x, rat1, rat2
cf2py intent(out) y
c
      integer nmax, m, m2, n
      real *8 x, y(0:nmax,0:nmax), u
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      y(0,0)=1
      do m=0, m2
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, min(n,m2)
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndr2f_trunc(nmax, m2, x, y, d, rat1, rat2)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c    
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c    
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c    
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., min(m2,n).
c    
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c    
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, m2, x, rat1, rat2
cf2py intent(out) y, d
c
      integer nmax, m, m2, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, du
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      du=x/sqrt((1-x)*(1+x))
      y(0,0)=1
      d(0,0)=0
      do m=0, m2
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x/u**2
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, min(n,m2)
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndr2sf_trunc(nmax, m2, x, y, d, rat1, rat2)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nmax
c     and  m = 0, 1,..., min(n,m2).
c
c     Parameters:
c     nmax                  must be non-negative
c     x                     -1 <= x <= 1
c     y(0:nmax,0:nmax)      resulting function values
c     d(0:nmax,0:nmax)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nmax and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nmax, m2, x, rat1, rat2
cf2py intent(out) y, d
c
      integer nmax, m, m2, n
      real *8 x, y(0:nmax,0:nmax), d(0:nmax,0:nmax), u, u2
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
c
      u=-sqrt((1-x)*(1+x))
      u2 = (1-x)*(1+x)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
      if (m.lt.nmax)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
      do n=m+2, nmax
        y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
        d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, m2
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*rat1(m,m)
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nmax)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nmax)  
     $      d(m+1,m)=(x*d(m,m)+u2*y(m,m))*rat1(m+1,m)
         do n=m+2, nmax
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+u2*y(n-1,m))-
     $         rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      do n=0, nmax
         do m=0, min(n,m2)
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       Symmetries for Legendre functions
c    
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
        subroutine ylgndrpm(nterms,y)
        implicit none
        integer n,m,nterms
        real *8 y(0:nterms,0:nterms)
c
c       Given Y_nm(x), return Y_nm(-x)
c
        do n=0,nterms
           do m=0,n
              if( mod(n+m,2) .eq. 1 ) y(n,m)=-y(n,m)
           enddo       
        enddo
c
        return
        end
c
c
c
c
c
        subroutine ylgndr2pm(nterms,y,d)
        implicit none
        integer nterms,n,m
        real *8 y(0:nterms,0:nterms)
        real *8 d(0:nterms,0:nterms)
c
c       Given Y_nm(x), return Y_nm(-x)
c       Given Y'_nm(x), return Y'_nm(-x)
c
cf2py intent(in) nterms, y
cf2py intent(out) d
c
        do n=0,nterms
           do m=0,n
              if( mod(n+m,2) .eq. 1 ) y(n,m)=-y(n,m)
              if( mod(n+m,2) .eq. 0 ) d(n,m)=-d(n,m)
           enddo       
        enddo
c
        return
        end
c
c
c
c
c
        subroutine ylgndrpm_opt(nterms,y)
        implicit none
        integer nterms,n,m
        real *8 y(0:nterms,0:nterms)
c
c       Given Y_nm(x), return Y_nm(-x)
c
        do n=0,nterms,2
           do m=1,n,2
              y(n,m)=-y(n,m)
           enddo       
        enddo
c
        do n=1,nterms,2
           do m=0,n,2
              y(n,m)=-y(n,m)
           enddo       
        enddo
c
        return
        end
c
c
c
c
c
        subroutine ylgndr2pm_opt(nterms,y,d)
        implicit none
        integer nterms,n,m
        real *8 y(0:nterms,0:nterms)
        real *8 d(0:nterms,0:nterms)
c
c       Given Y_nm(x), return Y_nm(-x)
c       Given Y'_nm(x), return Y'_nm(-x)
c
cf2py intent(in) nterms, y
cf2py intent(out) d
c
        do n=0,nterms,2
           do m=0,n,2
              d(n,m)=-d(n,m)
           enddo       
           do m=1,n,2
              y(n,m)=-y(n,m)
           enddo       
        enddo
c
        do n=1,nterms,2
           do m=0,n,2
              y(n,m)=-y(n,m)
           enddo       
           do m=1,n,2
              d(n,m)=-d(n,m)
           enddo       
        enddo
c
        return
        end
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c       fast version of real valued Legendre functions, with storage
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
c
      subroutine ylgndrfwini(nmax, w, lw, lused)
      implicit none
c
c     Precompute the recurrence coefficients for the fast
c     evaluation of normalized Legendre functions and their derivatives
c    
c     Parameters:
c       nmax             must be non-negative
c       w                  contains rat1 and rat2 arrays
c
      integer nmax,irat1,irat2,lw,lused
      real *8 w(*)
c
cf2py intent(in) nmax, lw
cf2py intent(out) w, lused
c
      irat1=1
      irat2=1+(nmax+1)**2
      lused=2*(nmax+1)**2
      if( lused .gt. lw ) return
      
      call ylgndrini(nmax, w(irat1), w(irat2))
      return
      end
c
c
c
c
c
      subroutine ylgndrfw(nterms, x, y, w, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)          resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. 
c
cf2py intent(in) nterms, x, w, nmax
cf2py intent(out) y
c
      integer nterms,nmax,irat1,irat2
      real *8 x, y(0:nterms,0:nterms), w(*)
c
      if( nterms .le. nmax ) then
        irat1=1
        irat2=1+(nmax+1)**2
        call ylgndrfw0(nterms, x, y, w(irat1), w(irat2), nmax)
      else
        call ylgndr(nterms, x, y)
      endif
c
      return
      end
c
c
c
c
c
      subroutine ylgndr2fw(nterms, x, y, d, w, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, w, nmax
cf2py intent(out) y, d
c
      integer nterms,nmax,irat1,irat2
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), w(*)
c
      if( nterms .le. nmax ) then
        irat1=1
        irat2=1+(nmax+1)**2
        call ylgndr2fw0(nterms, x, y, d, w(irat1), w(irat2), nmax)
      else
        call ylgndr2(nterms, x, y, d)
      endif
c
      return
      end
c
c
c
c
c
      subroutine ylgndr2sfw(nterms, x, y, d, w, nmax)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, w, nmax
cf2py intent(out) y, d
c
      integer nterms,nmax,irat1,irat2
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), w(*)
c
      if( nterms .le. nmax ) then
        irat1=1
        irat2=1+(nmax+1)**2
        call ylgndr2sfw0(nterms, x, y, d, w(irat1), w(irat2), nmax)
      else
        call ylgndr2s(nterms, x, y, d)
      endif
c
      return
      end
c
c
c
c
c
      subroutine ylgndrfw0(nterms, x, y, rat1, rat2, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. 
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y
c
      integer nterms,nmax,m,n
      real *8 x, y(0:nterms,0:nterms), u
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      y(0,0)=1
      do m=0, nterms
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.lt.nterms)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         do n=m+2, nterms
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
         enddo
      enddo
c
      do n=0, nterms
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndr2fw0(nterms, x, y, d, rat1, rat2, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y, d
c
      integer nterms, nmax, m, n
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), u, du
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      du=x/sqrt((1-x)*(1+x))
      y(0,0)=1
      d(0,0)=0
      do m=0, nterms
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x/u**2
         if (m.lt.nterms)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nterms)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
         do n=m+2, nterms
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      do n=0, nterms
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndr2sfw0(nterms, x, y, d, rat1, rat2, nmax)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt(2n+1)  sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y, d
c
      integer nterms, nmax, m, n
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), u, u2
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      u2 = (1-x)*(1+x)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nterms)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
      if (m.lt.nterms)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
      do n=m+2, nterms
        y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
        d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
      enddo
c
c       ... then, evaluate scaled associated Legendre functions
c
      do m=1, nterms
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*rat1(m,m)
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nterms)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nterms)  
ccc     $      d(m+1,m)=(x*d(m,m)+(1-x**2)*y(m,m))*rat1(m+1,m)
     $      d(m+1,m)=(x*d(m,m)+u2*y(m,m))*rat1(m+1,m)
         do n=m+2, nterms
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
ccc         d(n,m)=rat1(n,m)*(x*d(n-1,m)+(1-x**2)*y(n-1,m))-
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+u2*y(n-1,m))-
     $         rat2(n,m)*d(n-2,m)
         enddo
      enddo
      do n=0, nterms
         do m=0, n
            y(n,m)=y(n,m)*sqrt(2*n+1.0d0)
            d(n,m)=d(n,m)*sqrt(2*n+1.0d0)
         enddo
      enddo
      return
      end
c
c
c
c
c
      subroutine ylgndrufw(nterms, x, y, w, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)          resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. 
c
cf2py intent(in) nterms, x, w, nmax
cf2py intent(out) y
c
      integer nterms,nmax,irat1,irat2
      real *8 x, y(0:nterms,0:nterms), w(*)
c
      if( nterms .le. nmax ) then
        irat1=1
        irat2=1+(nmax+1)**2
        call ylgndrufw0(nterms, x, y, w(irat1), w(irat2), nmax)
      else
        call ylgndru(nterms, x, y)
      endif
c
      return
      end
c
c
c
c
c
      subroutine ylgndru2fw(nterms, x, y, d, w, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, w, nmax
cf2py intent(out) y, d
c
      integer nterms,nmax,irat1,irat2
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), w(*)
c
      if( nterms .le. nmax ) then
        irat1=1
        irat2=1+(nmax+1)**2
        call ylgndru2fw0(nterms, x, y, d, w(irat1), w(irat2), nmax)
      else
        call ylgndru2(nterms, x, y, d)
      endif
c
      return
      end
c
c
c
c
c
      subroutine ylgndru2sfw(nterms, x, y, d, w, nmax)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, w, nmax
cf2py intent(out) y, d
c
      integer nterms,nmax,irat1,irat2
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), w(*)
c
      if( nterms .le. nmax ) then
        irat1=1
        irat2=1+(nmax+1)**2
        call ylgndru2sfw0(nterms, x, y, d, w(irat1), w(irat2), nmax)
      else
        call ylgndru2s(nterms, x, y, d)
      endif
c
      return
      end
c
c
c
c
c
      subroutine ylgndrufw0_old(nterms, x, y, rat1, rat2, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. 
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y
c
      integer nterms, nmax, n, m
      real *8 x, y(0:nterms,0:nterms), u
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      y(0,0)=1
      do 10 m=0, nterms
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.lt.nterms)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         do 20 n=m+2, nterms
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
 20      continue
 10   continue
c
      return
      end
c
c
c
c
c
      subroutine ylgndrufw0(nterms, x, y, rat1, rat2, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. 
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y
c
      integer nterms, nmax, n, m
      real *8 x, y(0:nterms,0:nterms), u
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)

      y(0,0)=1
      if( nterms .eq. 0 ) return

      y(1,0)=x*y(0,0)*rat1(1,0)

      u=-sqrt((1-x)*(1+x))
      do m=1, nterms-1
         y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         y(m+1,m)=x*y(m,m)*rat1(m+1,m)
      enddo

      y(nterms,nterms)=y(nterms-1,nterms-1)*u*rat1(nterms,nterms)

c      do m=0, nterms-1
c        do n=m+2, nterms
c           y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
c         enddo
c      enddo

      do n=2, nterms
         do m=0, n-2
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndru2fw0_old(nterms, x, y, d, rat1, rat2, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y, d
c
      integer nterms, nmax, n, m
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), u, du
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      du=x/sqrt((1-x)*(1+x))
      y(0,0)=1
      d(0,0)=0
      do 10 m=0, nterms
         if (m.gt.0)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x/u**2
         if (m.lt.nterms)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nterms)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
         do 20 n=m+2, nterms
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
 20      continue
 10   continue
c
      return
      end
c
c
c
c
c
      subroutine ylgndru2fw0(nterms, x, y, d, rat1, rat2, nmax)
      implicit none
c
c     Evaluate normalized Legendre functions and their derivatives
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y, d
c
      integer nterms, nmax, n, m
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), u, u2
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)

      y(0,0)=1
      d(0,0)=0
      if( nterms .eq. 0 ) return

      y(1,0)=x*y(0,0)*rat1(1,0)
      d(1,0)=(x*d(0,0)+y(0,0))*rat1(1,0)

      u=-sqrt((1-x)*(1+x))
      u2=(1-x)*(1+x)
      do m=1, nterms-1
         y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         d(m,m)=y(m,m)*(-m)*x/u2
         y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         d(m+1,m)=(x*d(m,m)+u2*y(m,m))*rat1(m+1,m)
      enddo

      y(nterms,nterms)=y(nterms-1,nterms-1)*u*rat1(nterms,nterms)
      d(nterms,nterms)=y(nterms,nterms)*(-nterms*x)

      do n=2, nterms
         do m=0, n-2
         y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
         d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      return
      end
c
c
c
c
c
      subroutine ylgndru2sfw0_old(nterms, x, y, d, rat1, rat2, nmax)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y, d
c
      integer nterms, nmax, n, m
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), u, u2
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)
      u=-sqrt((1-x)*(1+x))
      u2 = (1-x)*(1+x)
      y(0,0)=1
      d(0,0)=0
c
c       ... first, evaluate standard Legendre polynomials
c
      m=0
      if (m.lt.nterms)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
      if (m.lt.nterms)  d(m+1,m)=(x*d(m,m)+y(m,m))*rat1(m+1,m)
      do 120 n=m+2, nterms
        y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
        d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
120   continue
c
c       ... then, evaluate scaled associated Legendre functions
c
      do 210 m=1, nterms
c
         if (m.eq.1)  y(m,m)=y(m-1,m-1)*(-1)*rat1(m,m)
         if (m.gt.1)  y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         if (m.gt.0)  d(m,m)=y(m,m)*(-m)*x
c
         if (m.lt.nterms)  y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         if (m.lt.nterms)  
     $      d(m+1,m)=(x*d(m,m)+u2*y(m,m))*rat1(m+1,m)
         do 220 n=m+2, nterms
            y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
            d(n,m)=rat1(n,m)*(x*d(n-1,m)+u2*y(n-1,m))-
     $         rat2(n,m)*d(n-2,m)
220      continue
210   continue
c
      return
      end
c
c
c

      subroutine ylgndru2sfw0(nterms, x, y, d, rat1, rat2, nmax)
      implicit none
c
c     Evaluate scaled normalized Legendre functions and their derivatives
c
c     Only for Ynm(x) with m>0 
c          the functions are scaled by 1/sqrt(1-x**2)
c          the derivatives are scaled by sqrt(1-x**2)
c
c
c      Ynm(x) = sqrt( (n-m)!/ (n+m)! ) Pnm(x)
c
c      d Ynm(x) / dx = sqrt( (n-m)!/ (n+m)! ) d Pnm(x) / dx
c
c     for n = 0, 1, 2,..., nterms
c     and  m = 0, 1,..., n.
c
c     Parameters:
c     nterms                      must be non-negative
c     x                         -1 <= x <= 1
c     y(0:nterms,0:nterms)      resulting function values
c     d(0:nterms,0:nterms)      resulting derivative values
c
c     Upon return, y(n,m) will contain the function value Ynm(x) for 0
c     <= n <= nterms and 0 <= m <= n.  Other elements of y will contain
c     undefined values. The same convention for the derivatives.
c
cf2py intent(in) nterms, x, rat1, rat2, nmax
cf2py intent(out) y, d
c
      integer nterms, nmax, n, m
      real *8 x, y(0:nterms,0:nterms), d(0:nterms,0:nterms), u, u2
      real *8 rat1(0:nmax,0:nmax), rat2(0:nmax,0:nmax)

      y(0,0)=1
      d(0,0)=0
      if( nterms .eq. 0 ) return

      y(1,0)=x*y(0,0)*rat1(1,0)
      d(1,0)=(x*d(0,0)+y(0,0))*rat1(1,0)

      u=-sqrt((1-x)*(1+x))
      u2=(1-x)*(1+x)
      do m=1, nterms-1
         if( m .eq. 1 ) y(m,m)=y(m-1,m-1)*(-1)*rat1(m,m)
         if( m .gt. 1 ) y(m,m)=y(m-1,m-1)*u*rat1(m,m)
         d(m,m)=y(m,m)*(-m)*x
         y(m+1,m)=x*y(m,m)*rat1(m+1,m)
         d(m+1,m)=(x*d(m,m)+u2*y(m,m))*rat1(m+1,m)
      enddo

      y(nterms,nterms)=y(nterms-1,nterms-1)*u*rat1(nterms,nterms)
      d(nterms,nterms)=y(nterms,nterms)*(-nterms*x)

      do n=2, nterms
         m=0
         y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
         d(n,m)=rat1(n,m)*(x*d(n-1,m)+y(n-1,m))-rat2(n,m)*d(n-2,m)
         do m=1, n-2
         y(n,m)=rat1(n,m)*x*y(n-1,m)-rat2(n,m)*y(n-2,m)
         d(n,m)=rat1(n,m)*(x*d(n-1,m)+u2*y(n-1,m))-rat2(n,m)*d(n-2,m)
         enddo
      enddo
c
      return
      end
!> Doxygen comment: ;\n
!> Printing routines ;\n
!> Doxygen comment: ;\n
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c    $Date: 2010-11-16 14:26:35 -0500 (Tue, 16 Nov 2010) $
c    $Revision: 1452 $
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c       Printing routines
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
C
C
C
        SUBROUTINE PRINI(IP1,IQ1)
        CHARACTER *1 MES(1), AA(1)
         save
        REAL *4 A(1)
        REAL *8 A2(1)
        REAL *8 A4(1)
ccc        INTEGER *4 IA(1)
        INTEGER IA(1)
        INTEGER *4 IA1(1)
        INTEGER *2 IA2(1)
        data IP/0/,IQ/0/
        IP=IP1
        IQ=IQ1
        RETURN

C
C
C
C
C
        ENTRY PRIN(MES,A,N)
        CALL MESSPR(MES,IP,IQ)
        IF(IP.NE.0 .AND. N.NE.0) WRITE(IP,1200)(A(J),J=1,N)
        IF(IQ.NE.0 .AND. N.NE.0) WRITE(IQ,1200)(A(J),J=1,N)
 1200 FORMAT(6(2X,E11.5))
         RETURN
C
C
C
C
        ENTRY PRIN2(MES,A2,N)
        CALL MESSPR(MES,IP,IQ)
        IF(IP.NE.0 .AND. N.NE.0) WRITE(IP,1400)(A2(J),J=1,N)
        IF(IQ.NE.0 .AND. N.NE.0) WRITE(IQ,1400)(A2(J),J=1,N)
 1400 FORMAT(6(2X,E11.5))
        RETURN
C
C
C
C
        ENTRY PRINQ(MES,A4,N)
        CALL MESSPR(MES,IP,IQ)
        IF(IP.NE.0 .AND. N.NE.0) WRITE(IP,1500)(A4(J),J=1,N)
        IF(IQ.NE.0 .AND. N.NE.0) WRITE(IQ,1500)(A4(J),J=1,N)
 1500 FORMAT(6(2X,e11.5))
        RETURN
C
C
C
C
        ENTRY PRINF(MES,IA,N)
        CALL MESSPR(MES,IP,IQ)
        IF(IP.NE.0 .AND. N.NE.0) WRITE(IP,1600)(IA(J),J=1,N)
        IF(IQ.NE.0 .AND. N.NE.0) WRITE(IQ,1600)(IA(J),J=1,N)
 1600 FORMAT(10(1X,I7))
        RETURN
C
C
C
C
        ENTRY PRINF1(MES,IA1,N)
        CALL MESSPR(MES,IP,IQ)
        IF(IP.NE.0 .AND. N.NE.0) WRITE(IP,1600)(IA1(J),J=1,N)
        IF(IQ.NE.0 .AND. N.NE.0) WRITE(IQ,1600)(IA1(J),J=1,N)
        RETURN
C
C
C
C
        ENTRY PRINF2(MES,IA2,N)
        CALL MESSPR(MES,IP,IQ)
        IF(IP.NE.0 .AND. N.NE.0) WRITE(IP,1600)(IA2(J),J=1,N)
        IF(IQ.NE.0 .AND. N.NE.0) WRITE(IQ,1600)(IA2(J),J=1,N)
        RETURN
C
C
C
C
        ENTRY PRINA(MES,AA,N)
        CALL MESSPR(MES,IP,IQ)
 2000 FORMAT(1X,80A1)
        IF(IP.NE.0 .AND. N.NE.0) WRITE(IP,2000)(AA(J),J=1,N)
        IF(IQ.NE.0 .AND. N.NE.0) WRITE(IQ,2000)(AA(J),J=1,N)
        RETURN
        END
c
c
c
c
c
        SUBROUTINE MESSPR(MES,IP,IQ)
        CHARACTER *1 MES(1),AST
        DATA AST/'*'/
C
C         DETERMINE THE LENGTH OF THE MESSAGE
C
        I=0
        DO 1400 I=1,10000
        IF(MES(I).EQ.AST) GOTO 1600
        I1=I
 1400 CONTINUE
 1600 CONTINUE
         IF ( (I1.NE.0) .AND. (IP.NE.0) )
     1     WRITE(IP,1800) (MES(I),I=1,I1)
         IF ( (I1.NE.0) .AND. (IQ.NE.0) )
     1     WRITE(IQ,1800) (MES(I),I=1,I1)
 1800 FORMAT(1X,80A1)
         RETURN
         END
c
c
c
c
c
        subroutine msgmerge(a,b,c)
        character *1 a(1),b(1),c(1),ast
        data ast/'*'/
c
        do 1200 i=1,1000
c
        if(a(i) .eq. ast) goto 1400
        c(i)=a(i)       
        iadd=i
 1200 continue
c
 1400 continue
c
        do 1800 i=1,1000
c
        c(iadd+i)=b(i)
        if(b(i) .eq. ast) return
 1800 continue
        return
        end
c
!> Doxygen comment: ;\n
!> this subroutine constructs the chebychev nodes ;\n
!> on the interval [-1,1], and the weights for the ;\n
!> corresponding order n quadrature. it also constructs ;\n
!> the matrix converting the coefficients ;\n
!> of a chebychev expansion into its values at the n ;\n
!> chebychev nodes. no attempt has been made to ;\n
!> make this code efficient, but its speed is normally ;\n
!> sufficient, and it is mercifully short. ;\n
!> Doxygen comment: ;\n
cc Copyright (C) 2009: Vladimir Rokhlin
cc 
cc This program is free software; you can redistribute it and/or modify 
cc it under the terms of the GNU General Public License as published by 
cc the Free Software Foundation; either version 2 of the License, or 
cc (at your option) any later version.  This program is distributed in 
cc the hope that it will be useful, but WITHOUT ANY WARRANTY; without 
cc even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
cc PARTICULAR PURPOSE.  See the GNU General Public License for more 
cc details. You should have received a copy of the GNU General Public 
cc License along with this program; 
cc if not, see <http://www.gnu.org/licenses/>.
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c               this is the end of the debugging code and the beginning
c               of the actual chebychev expansion routine
c 
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c 
c 
c 
        subroutine chebexps(itype,n,x,u,v,whts)
        implicit real *8 (a-h,o-z)
        save
        dimension x(1),whts(1),u(n,n),v(n,n)
c 
c         this subroutine constructs the chebychev nodes
c         on the interval [-1,1], and the weights for the
c         corresponding order n quadrature. it also constructs
c         the matrix converting the coefficients
c         of a chebychev expansion into its values at the n
c         chebychev nodes. no attempt has been made to
c         make this code efficient, but its speed is normally
c         sufficient, and it is mercifully short.
c 
c                 input parameters:
c 
c  itype - the type of the calculation to be performed
c          itype=0 means that only the chebychev nodes are
c                  to be constructed.
c          itype=1 means that only the nodes and the weights
c                  are to be constructed
c          itype=2 means that the nodes, the weights, and
c                  the matrices u, v are to be constructed
c  n - the number of chebychev nodes and weights to be generated
c 
c                 output parameters:
c 
c  x - the order n chebychev nodes - computed independently
c          of the value of itype.
c  u - the n*n matrix converting the  values at of a polynomial of order
c         n-1 at n chebychev nodes into the coefficients of its
c         chebychev expansion - computed only in itype=2
c  v - the n*n matrix converting the coefficients
c         of an n-term chebychev expansion into its values at
c         n chebychev nodes (note that v is the inverse of u)
c          - computed only in itype=2
c  whts - the corresponding quadrature weights - computed only
c         if itype .ge. 1
c 
c       . . . construct the chebychev nodes on the interval [-1,1]
c 
        ZERO=0
        DONE=1
        pi=datan(done)*4
        h=pi/(2*n)
ccc        do 1200 i=n,1,-1
        do 1200 i=1,n
        t=(2*i-1)*h
        x(n-i+1)=dcos(t)
1200  CONTINUE
cccc        call prin2('chebychev nodes as constructed*',x,n)
c 
        if(itype .eq. 0) return
c 
c        construct the weights of the quadrature
c        formula based on the chebychev nodes,
c        and also the matrix of the chebychev transform
c 
c        . . . construct the first two rows of the matrix
c 
         if(itype .le. 1) goto 1350
        do 1300 i=1,n
        u(1,i)=1
        u(2,i)=x(i)
 1300 continue
 1350 continue
c 
c       construct all quadrature weights and the rest of the rows
c 
        do 2000 i=1,n
c 
c       construct the weight for the i-th node
c 
        Tjm2=1
        Tjm1=x(i)
        whts(i)=2
c 
        ic=-1
        do 1400 j=2,n-1
c 
c       calculate the T_j(x(i))
c 
        Tj=2*x(i)*Tjm1-Tjm2
c 
        if(itype .eq. 2) u(j+1,i)=tj
c 
        tjm2=tjm1
        tjm1=tj
c 
c       calculate the contribution of this power to the
c       weight
c 
  
        ic=-ic
        if(ic .lt. 0) goto 1400
        rint=-2*(done/(j+1)-done/(j-1))
        whts(i)=whts(i)-rint*tj
ccc        whts(i)=whts(i)+rint*tj
 1400 continue
        whts(i)=whts(i)/n
 2000 continue
           if(itype .ne. 2) return
c 
c        now, normalize the matrix of the chebychev transform
c 
        do 3000 i=1,n
c 
        d=0
        do 2200 j=1,n
        d=d+u(i,j)**2
 2200 continue
        d=done/dsqrt(d)
        do 2400 j=1,n
        u(i,j)=u(i,j)*d
 2400 continue
 3000 continue
c 
c        now, rescale the matrix
c 
        ddd=2
        ddd=dsqrt(ddd)
        dd=n
        dd=done/dsqrt(dd/2)
        do 3400 i=1,n
        do 3200 j=1,n
        u(j,i)=u(j,i)*dd
 3200 continue
        u(1,i)=u(1,i)/ddd
 3400 continue
c 
c        finally, construct the matrix v, converting the values at the
c        chebychev nodes into the coefficients of the chebychev
c        expansion
c 
        dd=n
        dd=dd/2
        do 4000 i=1,n
        do 3800 j=1,n
        v(j,i)=u(i,j)*dd
 3800 continue
 4000 continue
c 
        do 4200 i=1,n
        v(i,1)=v(i,1)*2
 4200 continue
        return
        end
c 
c 
c 
c 
c 
        subroutine chebinmt(n,ainte,adiff,x,whts,endinter,
     1      itype,w)
        implicit real *8 (a-h,o-z)
        save
        dimension ainte(1),w(1),x(1),whts(1),adiff(1),endinter(1)
c 
c 
c        for the user-specified n, this subroutine constructs
c        the matrices of spectral indefinite integration and/or
c        spectral differentiation on the n Chebychev nodes
c        on the interval [-1,1]. Actually, this is only a
c        memory management routine. All the actual work is done
c        by the subroutine legeinm0 (see)
c 
c                           input parameters:
c 
c  n - the number of Chebychev nodes on the interval [-1,1]
c  itype - the type of the calculation to be performed
c          EXPLANATION:
c       itype=1 means that only the matrix ainte will
c               be constructed
c       itype=2 means that only the matrix adiff will
c               be constructed
c       itype=3 means that both matrices ainte and adiff
c               will be constructed
c 
c                           output paramaters:
c 
c  ainte - the matrix of spectral indefinite integration on
c          the Chebychev nodes
c  adiff - the matrix of spectral differentiation on
c          the Chebychev nodes
c  x - the n Chebychev nodes on the intervl [-1,1]
c  whts - the n Chebychev weights on the interval [-1,1]
c  endinter - the interpolation coefficients converting the
c          values of a function at n Chebychev nodes into its
c          value at 1 (the right end of the interval)
c 
c                           work arrays:
c 
c  w - must be 3* n**2 + 2*n +50 *8 locations long
c 
c        . . . allocate memory for the construction of the integrating
c              matrix
c 
        ipolin=1
        lpolin=n+5
c 
        ipolout=ipolin+lpolin
        lpolout=n+5
c 
        iu=ipolout+lpolout
        lu=n**2+1
c 
        iv=iu+lu
        lv=n**2+1
c 
        iw=iv+lv
        lw=n**2+1
c 
        ltot=iw+lw
c 
c        construct the integrating matrix
c 
        call chebinm0(n,ainte,adiff,w(ipolin),w(ipolout),
     1      x,whts,w(iu),w(iv),w(iw),itype,endinter)
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine chebinm0(n,ainte,adiff,polin,polout,
     1      x,whts,u,v,w,itype,endinter)
        implicit real *8 (a-h,o-z)
        save
        dimension ainte(n,n),u(n,n),v(n,n),w(n,n),
     1      endinter(1),x(n),whts(n),polin(n),polout(n),
     2      adiff(n,n)
c 
c        for the user-specified n, this subroutine constructs
c        the matrices of spectral indefinite integration and/or
c        spectral differentiation on the n Chebychev nodes
c        on the interval [-1,1]
c 
c                           input parameters:
c 
c  n - the number of Chebychev nodes on the interval [-1,1]
c  itype - the type of the calculation to be performed
c          EXPLANATION:
c       itype=1 means that only the matrix ainte will
c               be constructed
c       itype=2 means that only the matrix adiff will
c               be constructed
c       itype=3 means that both matrices ainte and adiff
c               will be constructed
c 
c                           output paramaters:
c 
c  ainte - the matrix of spectral indefinite integration on
c          the Chebychev nodes
c  adiff - the matrix of spectral differentiation on
c          the Chebychev nodes
c  x - the n Chebychev nodes on the intervl [-1,1]
c  whts - the n Chebychev weights on the interval [-1,1]
c 
c                           work arrays:
c 
c  polin, polout - must be n+3 real *8 locations each
c 
c  u, v, w - must be n**2+1 real *8 locations each
c 
c        . . . construct the matrices of the forward and inverse
c              Chebychev transforms
c 
        itype2=2
        call chebexps(itype2,n,x,u,v,whts)
c 
cccc         call prin2('after chebexps, u=*',u,n*n)
c 
c        if the user so requested,
c        construct the matrix converting the coefficients of
c        the Chebychev series of a function into the coefficients
c        of the indefinite integral of that function
c 
        if(itype. eq. 2) goto 2000
c 
        do 1600 i=1,n
c 
        do 1200 j=1,n
        polin(j)=0
 1200 continue
c 
        polin(i)=1
        call chebinte(polin,n+1,polout)
c 
        do 1400 j=1,n
        ainte(j,i)=polout(j)
 1400 continue
c 
 1600 continue
c 
c        multiply the three, obtaining the integrating matrix
c 
        call matmul_cheb(ainte,u,w,n)
        call matmul_cheb(v,w,ainte,n)
c 
 2000 continue
c 
c        if the user so requested,
c        construct the matrix converting the coefficients of
c        the Chebychev series of a function into the coefficients
c        of the derivative of that function
c 
        if(itype. eq. 1) goto 3000
c 
        do 2600 i=1,n
c 
        do 2200 j=1,n+3
        polin(j)=0
 2200 continue
c 
        polin(i)=1
        call chebdiff(polin,n+1,polout)
c 
        do 2400 j=1,n
        adiff(j,i)=polout(j)
 2400 continue
c 
 2600 continue
c 
cccc         call prin2('adiff initially is*',adiff,n*n)
c 
c        multiply the three, obtaining the differentiating matrix
c 
        call matmul_cheb(adiff,u,w,n)
        call matmul_cheb(v,w,adiff,n)
c 
 3000 continue
c 
c        construct the vector of interpolation coefficients
c        converting the values of a polynomial at the Chebychev
c        nodes into its value at the right end of the interval
c 
        do 3400 i=1,n
c 
        d=0
        do 3200 j=1,n
        d=d+u(j,i)
 3200 continue
        endinter(i)=d
 3400 continue
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine chebpol(x,n,pol,der)
        implicit real *8 (a-h,o-z)
c 
        save
        d=dacos(x)
        pol=dcos(n*d)
        der=dsin(n*d)*n/dsqrt(1-x**2)
        return
        end
c 
c 
c 
c 
c 
        subroutine chebpols(x,n,pols)
        implicit real *8 (a-h,o-z)
        save
        dimension pols(*)
c 
        pkm1=1
        pk=x
c 
        pk=1
        pkp1=x
c 
c 
c        if n=0 or n=1 - exit
c 
        if(n .ge. 2) goto 1200
        pols(1)=1
        if(n .eq. 0) return
c 
        pols(2)=x
        return
 1200 continue
c 
        pols(1)=1
        pols(2)=x
c 
c       n is greater than 2. conduct recursion
c 
        do 2000 k=1,n-1
        pkm1=pk
        pk=pkp1
        pkp1=2*x*pk-pkm1
        pols(k+2)=pkp1
 2000 continue
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine chebinte(polin,n,polout)
        implicit real *8 (a-h,o-z)
        save
        dimension polin(*),polout(*)
c 
c       this subroutine computes the indefinite integral of the
c       Chebychev expansion polin getting the expansion polout
c 
c 
c                       input parameters:
c 
c  polin - the Chebychev expansion to be integrated
c  n - the order of the expansion polin
c   IMPORTANT NOTE: n is {\bf the order of the expansion, which is
c         one less than the number of terms in the expansion!!}
c         also nothe that the order of the integrated expansion is
c         n+1 (who could think!)
c 
c                       output parameters:
c 
c  polout - the Chebychev expansion of the integral of the function
c         represented by the expansion polin
c 
        do 1200 i=1,n+2
        polout(i)=0
 1200 continue
c 
        polout(2)=polin(1)
        if(n .eq. 0) return
        polout(3)=polin(2)/4
        if(n .eq. 1) return
c 
        do 2000 k=3,n
c 
        polout(k+1)=polin(k)/(2*k)
        polout(k-1)=-polin(k)/(2*k-4)+polout(k-1)
c 
 2000 continue
c 
        dd=0
        sss=-1
        do 2200 k=2,n+1
c 
        dd=dd+polout(k)*sss
        sss=-sss
 2200 continue
c 
        call prin2('dd=*',dd,1)
        polout(1)=-dd
c 
        return
        end
c 
c 
c 
c 
c 
        subroutine chebdiff(polin,n,polout)
        implicit real *8 (a-h,o-z)
        save
        dimension polin(1),polout(1)
c 
c       this subroutine differentiates the Chebychev
c       expansion polin getting the expansion polout
c 
c 
c                       input parameters:
c 
c  polin - the Chebychev expansion to be differentiated
c  n - the order of the expansion polin
c   IMPORTANT NOTE: n is {\bf the order of the expansion, which is
c         one less than the number of terms in the expansion!!}
c         also nothe that the order of the integrated expansion is
c         n+1 (who could think!)
c 
c                       output parameters:
c 
c  polout - the Chebychev expansion of the derivative of the function
c         represented by the expansion polin
c 
        do 1200 i=1,n+1
        polout(i)=0
 1200 continue
c 
        do 2000 k=1,n-1
c 
        polout(n-k)=polout(n-k+2)+(n-k)*polin(n-k+1) *2
 2000 continue
        polout(1)=polout(1)/2
c 
        return
        end
c 
c 
c 
c 
c 
      SUBROUTINE chebexev(X,VAL,TEXP,N)
      IMPLICIT REAL *8 (A-H,O-Z)
        save
      REAL *8 TEXP(*)
C 
C     This subroutine computes the value o a Chebychev
c     expansion with coefficients TEXP at point X in interval [-1,1]
C 
c                input parameters:
c 
C     X = evaluation point
C     TEXP = expansion coefficients
C     N  = order of expansion
c   IMPORTANT NOTE: n is {\bf the order of the expansion, which is
c         one less than the number of terms in the expansion!!}
c 
c                output parameters:
c 
C     VAL = computed value
C 
        done=1
        pjm2=1
        pjm1=x
c 
        val=texp(1)*pjm2+texp(2)*pjm1
c 
        DO 600 J = 2,N
c 
        pj= 2*x*pjm1-pjm2
        val=val+texp(j+1)*pj
c 
        pjm2=pjm1
        pjm1=pj
 600   CONTINUE
c 
        RETURN
        END
c 
c 
c 
c 
c 
      SUBROUTINE CHFUNDER(X,VAL,der,TEXP,N)
C 
C     This subroutine computes the value and the derivative
c     of a chebychev expansion with coefficients TEXP
C     at point X in interval [-1,1]
C 
c                input parameters:
c 
C     X = evaluation point
C     TEXP = expansion coefficients
C     N  = order of expansion
c   IMPORTANT NOTE: n is {\bf the order of the expansion, which is
c         one less than the number of terms in the expansion!!}
c 
c                output parameters:
c
C     VAL = computed value
C     der = computed value of the derivative
C 
      IMPLICIT REAL *8 (A-H,O-Z)
        save
      REAL *8 TEXP(*)
C 
        done=1
        tjm2=1
        tjm1=x
        derjm2=0
        derjm1=1
c 
        val=texp(1)*tjm2+texp(2)*tjm1
        der=texp(2)
c 
      DO 600 J = 2,N
c 
        tj=2*x*tjm1-tjm2
        val=val+texp(j+1)*tj
c 
        derj=2*tjm1+2*x*derjm1-derjm2
        der=der+texp(j+1)*derj
c 
        tjm2=tjm1
        tjm1=tj
        derjm2=derjm1
        derjm1=derj
 600   CONTINUE
c 
      RETURN
      END
c 
c 
c 
c 
c 
      SUBROUTINE CHebcval(X,VAL,TEXP,N)
C 
C     This subroutine computes the value and the derivative
c     of a chebychev expansion with coefficients TEXP
C     at point X in interval [-1,1]
C 
c                input parameters:
c 
C     X = evaluation point
C     TEXP = expansion coefficients
C     N  = order of expansion
c   IMPORTANT NOTE: n is {\bf the order of the expansion, which is
c         one less than the number of terms in the expansion!!}
c 
c                output parameters:
c 
C     VAL = computed value
C     der = computed value of the derivative
C 
      IMPLICIT REAL *8 (A-H,O-Z)
        save
      complex *16 TEXP(*),val
C 
        done=1
        tjm2=1
        tjm1=x
c 
        val=texp(1)*tjm2+texp(2)*tjm1
c 
      DO 600 J = 2,N
c 
        tj=2*x*tjm1-tjm2
        val=val+texp(j+1)*tj
c 
        tjm2=tjm1
        tjm1=tj
 600   CONTINUE
c 
      RETURN
      END
c 
c 
c 
c 
c 
      SUBROUTINE CHebval(X,VAL,TEXP,N)
C 
C     This subroutine computes the value and the derivative
c     of a chebychev expansion with coefficients TEXP
C     at point X in interval [-1,1]
C 
c                input parameters:
c 
C     X = evaluation point
C     TEXP = expansion coefficients
C     N  = order of expansion
c   IMPORTANT NOTE: n is {\bf the order of the expansion, which is
c         one less than the number of terms in the expansion!!}
c 
c                output parameters:
c 
C     VAL = computed value
C     der = computed value of the derivative
C 
      IMPLICIT REAL *8 (A-H,O-Z)
        save
      real *8 TEXP(*),val
C 
        done=1
        tjm2=1
        tjm1=x
c 
        val=texp(1)*tjm2+texp(2)*tjm1
c 
      DO 600 J = 2,N
c 
        tj=2*x*tjm1-tjm2
        val=val+texp(j+1)*tj
c 
        tjm2=tjm1
        tjm1=tj
 600   CONTINUE
c 
      RETURN
      END
c 
c 
c 
c 
c 
      SUBROUTINE CHFUNcDER(X,VAL,der,TEXP,N)
C 
C     This subroutine computes the value and the derivative
c     of a chebychev expansion with coefficients TEXP
C     at point X in interval [-1,1]
C 
c                input parameters:
c 
C     X = evaluation point
C     TEXP = expansion coefficients
C     N  = order of expansion
c   IMPORTANT NOTE: n is {\bf the order of the expansion, which is
c         one less than the number of terms in the expansion!!}
c 
c                output parameters:
c 
C     VAL = computed value
C     der = computed value of the derivative
C 
      IMPLICIT REAL *8 (A-H,O-Z)
        save
      complex *16 TEXP(*),val,der
C 
        done=1
        tjm2=1
        tjm1=x
        derjm2=0
        derjm1=1
c 
        val=texp(1)*tjm2+texp(2)*tjm1
        der=texp(2)
c 
      DO 600 J = 2,N
c 
        tj=2*x*tjm1-tjm2
        val=val+texp(j+1)*tj
c 
        derj=2*tjm1+2*x*derjm1-derjm2
        der=der+texp(j+1)*derj
c 
        tjm2=tjm1
        tjm1=tj
        derjm2=derjm1
        derjm1=derj
 600   CONTINUE
c 
      RETURN
      END
c 
c 
c 
c 
c 
        subroutine matmul_cheb(a,b,c,n)
        implicit real *8 (a-h,o-z)
        save
        dimension a(n,n),b(n,n),c(n,n)
c 
        do 2000 i=1,n
        do 1800 j=1,n
        d=0
        do 1600 k=1,n
        d=d+a(i,k)*b(k,j)
 1600 continue
        c(i,j)=d
 1800 continue
 2000 continue
        return
        end
c 
c 
c 
c 
c 
        subroutine chematrin(n,m,xs,amatrint,ts,w)
        implicit real *8 (a-h,o-z)
        save
        dimension amatrint(m,n),xs(1),w(1),ts(1)
c 
c 
c        This subroutine constructs the matrix interpolating
c        functions from the n-point Chebychev grid on the interval [-1,1]
c        to an arbitrary m-point grid (the nodes of the latter are
c        user-provided)
c 
c                 Input parameters:
c 
c  n - the number of interpolation nodes
c  m - the number of nodes to which the functions will be interpolated
c  xs - the points at which the function is to be interpolated
c 
c                  Output parameters:
c 
c  amatrint - the m \times n matrix conerting the values of a function
c        at the n Chebychev nodes into its values at m user-specified
c        (arbitrary) nodes
c  ts - the n Chebychev nodes on the interval [-1,1]
c 
c                  Work arrays:
c 
c  w - must be at least 2*n**2+n + 100 real *8 locations long
c 
  
        icoefs=1
        lcoefs=n+2
c 
        iu=icoefs+lcoefs
        lu=n**2+10
c 
        iv=iu+lu
c 
        ifinit=1
        do 2000 i=1,m
c 
        call chevecin(n,xs(i),ts,w(iu),w(iv),w(icoefs),ifinit)
c 
        do 1400 j=1,n
        amatrint(i,j)=w(j)
 1400 continue
c 
        ifinit=0
 2000 continue
c 
        return
        end
  
c 
c 
c 
c 
c 
        subroutine chevecin(n,x,ts,u,v,coefs,ifinit)
        implicit real *8 (a-h,o-z)
        save
        dimension u(n,n),v(n,n),ts(1),coefs(1)
c 
c        This subroutine constructs the coefficients of the
c        standard interpolation formula connecting the values of a
c        function at n Chebychev nodes on the interval [a,b] with
c        its value at the point x \in R^1
c 
c                 Input parameters:
c 
c  n - the number of interpolation nodes
c  x - the points at which the function is to be interpolated
c  ts - the n Chebychev nodes on the interval [-1,1]; please note that
c        it is an input parameter only if the parameter ifinit (see
c        below) has been set to 1; otherwise, it is an output parameter
c  u - the n*n matrix converting the  values at of a polynomial of order
c         n-1 at n Chebychev nodes into the coefficients of its
c        Chebychev expansion; please note that
c        it is an input parameter only if the parameter ifinit (see
c        below) has been set to 1; otherwise, it is an output parameter
c  ifinit - an integer parameter telling the subroutine whether it should
c        initialize the Chebychev expander;
c     ifinit=1 will cause the subroutine to perform the initialization
c     ifinit=0 will cause the subroutine to  skip the initialization
c 
c                  Output parameters:
c 
c  coefs - the interpolation coefficients
c 
c                 Work arrays:
c 
c  v - must be at least n*n real *8 locations long
c 
c       . . . construct the n Chebychev nodes on the interval [-1,1];
c             also the corresponding Chebychev expansion-evaluation
c             matrices
c 
        itype=2
        if(ifinit .ne.0) call chebexps(itype,n,ts,u,v,coefs)
c 
c       evaluate the n Chebychev polynomials at the point where the
c       functions will have to be interpolated
c 
        call chebpols(x,n+1,v)
c 
c       apply the interpolation matrix to the ector of values
c       of polynomials from the right
c 
        call chematvec(u,v,coefs,n)
        return
        end
c 
c 
c 
c 
c 
        subroutine chematvec(a,x,y,n)
        implicit real *8 (a-h,o-z)
        save
        dimension a(n,n),x(n),y(n)
c 
        do 1400 i=1,n
        d=0
        do 1200 j=1,n
        d=d+a(j,i)*x(j)
 1200 continue
        y(i)=d
 1400 continue
        return
        end
  
c 
c 
c 
c 
c 
        subroutine chematvec2(a,n,m,x,y)
        implicit real *8 (a-h,o-z)
        save
        real *8 a(n,m),x(m),y(n),cd
c 
c        apply the matrix a to the vector x obtaining y
c 
        do 1400 i=1,n
        cd=0
        do 1200 j=1,m
        cd=cd+a(i,j)*x(j)
 1200 continue
        y(i)=cd
 1400 continue
c
        return
        end
!> Doxygen comment: ;\n
!> multiple routines for creating and organizing grids in 3d. ;\n
!> needs more comments! ;\n
!> Doxygen comment: ;\n
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine mkfouriergrid(rkmax,ngridr,ityper,
     1                    nlats,itypep,ntot,numonsphere,
     2                    kgridx,kgridy,kgridz,wts)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     ? add nphis(j,i) = number of azimuthal pts on jth latitude on
c                        ith sphere 
C     ? output theta, phi, r grid 
c
c     utility: given rk -> grid on that sphere, thetas/phis
c              
c
c     PURPOSE: Create spherical grid out to radius rkmax.
c     This routine can create either a tensor product
c     grid, or a discretization which uses different meshes on each
c     successive sphere, properly sampling in theta or phi or both.
c     
c     INPUT:
c
c     rkmax          outer radius of sphere (r in [0,rkmax])
c     ngridr         number of nodes in r
c     ityper         quadrature scheme in radial direction
c                       1 = Gaussian
c                       0 = uniform grid from 1..ngridr
c                           rad(i) = rkmax*i/ngridr
c     nlats()        number of latitude points used on each sphere
c                    permits coarser sampling near origin 
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    phi_over is defined in getgridph and typically
c                    set to 2.
c     ntot           total number of points in grid
c
c
c     OUTPUT:
c
c     numonsphere()  number of points on ith sphere
c                    sum_i numonsphere(i) should equal ntot (input).
c                    
c     kgridx()       1st Cartesian coordinate of k-space nodes
c     kgridy()       2nd Cartesian coordinate of k-space nodes
c     kgridz()       3rd Cartesian coordinate of k-space nodes
c     wts()          quadrature weights for k-space nodes
c
c----------------------------------------------------------------------
      implicit none
      integer ngridr,ngridp,ngridt,i
      integer ityper,itypep,ntot,nnn
      integer ifprint,jj,kk,ll,ngridtmax
      integer nlats(ngridr)
      integer numonsphere(ngridr)
      real *8 rkmax,u,v,pi,phi,phstep,rr
      real *8 ctheta,stheta
      integer, allocatable ::  ngridps(:)
      real *8, allocatable :: phsteps(:)
      real *8, allocatable :: xnodesr(:)
      real *8, allocatable :: wtsr(:)
      real *8, allocatable :: sthetas(:)
      real *8, allocatable :: xnodesth(:)
      real *8, allocatable :: wtsth(:)
      real *8 kgridx(ntot)
      real *8 kgridy(ntot)
      real *8 kgridz(ntot)
      real *8 wts(ntot)
c
      pi = 4.0d0*datan(1.0d0)
c
c     get max theta array size and allocate local arrays
c
      ngridtmax = nlats(1)
      do i = 2,ngridr
         ngridtmax = max(nlats(i),ngridtmax)
      enddo
c
      allocate(xnodesr(ngridr))
      allocate(wtsr(ngridr))
c
      allocate(xnodesth(ngridtmax))
      allocate(sthetas(ngridtmax))
      allocate(wtsth(ngridtmax))
      allocate(ngridps(ngridtmax))
      allocate(phsteps(ngridtmax))
c
      call getgridr(rkmax,ngridr,ityper,xnodesr,wtsr)
c      
      ifprint = 0
      if (ifprint.eq.1) call prin2(' xnodesr is *',xnodesr,ngridr)
      if (ifprint.eq.1) call prin2(' wtsr is *',wtsr,ngridr)
      if (ifprint.eq.1) write(6,*) ' ngridtmax is ',ngridtmax
c
      nnn = 0
      do jj = 1,ngridr
        rr = xnodesr(jj)
        ngridt = nlats(jj)
        call getspheregrid(ngridt,itypep,xnodesth,
     1           sthetas,wtsth,ngridps,phsteps,numonsphere(jj))
        do kk = 1,ngridt
           ctheta = xnodesth(kk)
           stheta = sthetas(kk)
           phstep = phsteps(kk)
c
           do ll = 1,ngridps(kk)
              phi = (ll-1)*phstep
              nnn = nnn+1
              kgridx(nnn) = rr*stheta*dcos(phi)
              kgridy(nnn) = rr*stheta*dsin(phi)
              kgridz(nnn) = rr*ctheta
              wts(nnn) = wtsr(jj)*wtsth(kk)*phstep
           enddo
        enddo
      enddo
      return
      end
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine getgridr(rkmax,ngridr,ityper,xnodesr,wtsr)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     PURPOSE: Create radial grid out to rkmax.
c     
c     INPUT:
c
c     rkmax          outer radius of sphere (r in [0,rkmax])
c     ngridr         number of nodes in r
c     ityper         quadrature scheme in radial direction
c                       1 = Gaussian
c                       0 = uniform grid from 1..ngridr
c                           rad(i) = rkmax*i/ngridr
c
c     OUTPUT:
c
c     xnodesr        nodes in radial direction
c     wtsr           quadrature weights in radial direction
c
c----------------------------------------------------------------------
      implicit none
      integer i,ngridr,ityper
      real *8 u,v,rkmax
      real *8 xnodesr(ngridr)
      real *8 wtsr(ngridr)
      real *8, allocatable :: b(:)
c
      if (ityper.eq.1) then
         allocate(b(ngridr))
c$$$         call gaussq(0, ngridr, 0, 0, 0, 0, b, xnodesr, wtsr)
         u = rkmax/2.0d0
         v = rkmax/2.0d0
         do i = 1,ngridr
            xnodesr(i) = u*xnodesr(i) + v
            wtsr(i) = xnodesr(i)*xnodesr(i)*wtsr(i)*rkmax/2.0d0
         enddo
      else
         do i = 1,ngridr
            xnodesr(i) = rkmax*(i)/ngridr
            wtsr(i) =  xnodesr(i)*xnodesr(i)*rkmax/ngridr
         enddo
      endif
c
      return
      end
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine getgridth(ngridt,t,xnodesth,sthetas,wtsth)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     PURPOSE: Create theta grid on sphere 
c     
c     INPUT:
c
c     ngridt         number of latitudes (equispaced in theta)
c     t              workspace of length ngridt
c
c     OUTPUT:
c
c     xnodesth       nodes in [-1,1] corresponding to cos(theta_j)
c                    where theta_j are equispaced at classical 
c                    Chebyshev nodes
c     sthetas        corresponding sin(theta) values
c     wtsth          quadrature weights in theta direction
c
c----------------------------------------------------------------------
      implicit none
      integer i,ngridt,itype
      real *8 alpha,beta
      real *8 u,v,rkmax
      real *8 t(ngridt)
      real *8 xnodesth(ngridt)
      real *8 sthetas(ngridt)
      real *8 wtsth(ngridt)
c
c    Chebyshev quadrature in theta (incorporates sin(theta) weight)
c    using equispaced (classical) nodes
c
      itype = 1
      alpha = 0.0d0
      beta = 0.0d0
      call chebexps(itype,ngridt,t,alpha,beta,wtsth)
      do i = 1,ngridt
         xnodesth(i) = t(ngridt+1-i)
         sthetas(i) = dsqrt(1.0d0 - xnodesth(i)**2)
      enddo
c
      return
      end
c 
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine getgridph(itypep,ngridt,stheta,ngridp,phstep)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     PURPOSE: Create phi grid on sphere at a specific latitude
c              theta.
c     
c     INPUT:
c
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    Typically, phi_over = 2 is sufficient for resolution,
c                    since we are integrating on a circle of radius
c                    [0,2 pi]*gridr(i)*sin(theta) while the
c                    nlats(i) points are integrating on the interval
c                    [0, pi]*gridr(i)
c
c     ngridt         number of grid points used in theta direction
c     stheta         value of sin(theta) on given latitude
c
c     OUTPUT:
c
c     ngridp       number of nodes in phi
c     phstep       quadrature weightin phi direction
c
c----------------------------------------------------------------------
c     IMPORTANT: phi_over is set here and all codes call this routine
c                to find ngridp, phstep... 
c----------------------------------------------------------------------
      implicit none
      integer itypep,ngridt,ngridp
      real *8 stheta,pi,phstep,phi_over
c
      pi = 4.0d0*datan(1.0d0)
      phi_over = 2.0d0
      if (itypep.eq.0) then
         ngridp = nint(ngridt*phi_over)
      else 
         ngridp = max(nint(ngridt*phi_over*stheta),6)
      endif
      phstep = pi*2.0d0/ngridp
      return
      end
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine getspheregrid(ngridt,itypep,xnodesth,
     1           sthetas,wtsth,ngridps,phsteps,numonsphere)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     PURPOSE: Create phi grid on sphere for each latitude
c     
c     INPUT:
c
c     ngridt         number of grid points used in theta direction
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    phi_over is set in getgridph (typically = 2).
c
c     OUTPUT:
c
c     xnodesth()     nodes in theta
c     sthetas()      corresponding sin(theta) values
c     wtsth()        quadrature weights in theta direction
c     ngridps()      number of nodes in phi for each latitude
c     phsteps()      quadrature weightin phi direction
c     numonsphere    total number of points on sphere
c
c----------------------------------------------------------------------
      implicit none
      integer i,ngridt,itypep,numonsphere,kk
      integer ngridps(ngridt)
      real *8 xnodesth(ngridt)
      real *8 sthetas(ngridt)
      real *8 wtsth(ngridt)
      real *8 phsteps(ngridt),pi
      real *8, allocatable :: t(:)
c
      allocate(t(ngridt))
c
      call getgridth(ngridt,t,xnodesth,sthetas,wtsth)
      numonsphere = 0
      do kk = 1,ngridt
           call getgridph(itypep,ngridt,sthetas(kk),
     1                    ngridps(kk),phsteps(kk))
           numonsphere = numonsphere+ngridps(kk)
      enddo
      return
      end
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_ntot(ngridr,nlats,itypep,ntot)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     PURPOSE: Compute total number of points used in spherical grid.
c     
c     INPUT:
c
c     ngridr         number of grid points used in radial direction
c     nlats()        number of latitude points used on each sphere
c                    permits coarser sampling near origin 
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    phi_over is set in getgridph (typically = 2). 
c
c     OUTPUT:
c
c     ntot           total number of points in grid
c----------------------------------------------------------------------
      implicit none
      integer ntot,ngridr,ntmax,nlats(ngridr)
      integer itypep,numonsphere,jj
      real *8 pi
      integer, allocatable ::  ngridps(:)
      real *8, allocatable :: phsteps(:)
      real *8, allocatable :: xnodesth(:)
      real *8, allocatable :: sthetas(:)
      real *8, allocatable :: wtsth(:)
c
      ntmax = nlats(1)
      do jj = 2,ngridr
         ntmax = max(nlats(jj),ntmax)
      enddo
c
      allocate(ngridps(ntmax))
      allocate(phsteps(ntmax))
      allocate(xnodesth(ntmax))
      allocate(sthetas(ntmax))
      allocate(wtsth(ntmax))

      ntot = 0
      do jj = 1,ngridr
         call getspheregrid(nlats(jj),itypep,xnodesth,
     1           sthetas,wtsth,ngridps,phsteps,numonsphere)
         ntot = ntot + numonsphere
      enddo
      return
      end
c
c
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine fun_to_kspacegrid(x,y,z,ff,h,ngrid,eps,rmax,ngridr,
     1                  ityper,nlats,itypep,ntot,numonsphere,
     2                  kgridx,kgridy,kgridz,wts,ffhat,ffhatnorm,ier)
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     PURPOSE: compute transform from density in physical space to 
c              spherical grid in k-space
c     
c     INPUT:
c
c     x,y,z          3D arrays of physical space coordinates
c     ff             3D array  of density in physical space
c     h              grid spacing in x,y,z
c     ngrid          number of grid pts in each linear dimension
c     eps            NUFFT tolerance
c     rmax           max k-space radius
c     ngridr         number of grid points used in radial direction
c     ityper         quadrature scheme in radial direction
c                       1 = Gaussian
c                       0 = uniform grid from 1..ngridr
c                           rad(i) = rkmax*i/ngridr
c     nlats()        number of latitude points used on each sphere
c                    permits coarser sampling near origin 
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c     ntot           total number of points in k-space grid
c     numonsphere    number of points on successive spheres
c
c     OUTPUT:
c
c     kgridx         first coordinates of target points in k-space 
c     kgridy         second coordinates of target points in k-space 
c     kgridz         third coordinates of target points in k-space 
c     wts            quad weights in radial direction
c     ffhat          Fourier transform values on spherical grid
c     ffhatnorm      L2 norm of computed Fourier transform 
c     ier            error return code from NUFFT
c----------------------------------------------------------------------
      implicit real *8 (a-h,o-z)
      integer ngrid,ngridr,ityper,itypep,ntot,ier
      integer nlats(ngridr)
      integer numonsphere(ngridr)
      real *8 pi,eps,rmax,ffhatnorm
      real *8 x(ngrid,ngrid,ngrid)
      real *8 y(ngrid,ngrid,ngrid)
      real *8 z(ngrid,ngrid,ngrid)
      real *8 kgridx(ntot)
      real *8 kgridy(ntot)
      real *8 kgridz(ntot)
      real *8 wts(ntot)
      complex *16 ff(ngrid,ngrid,ngrid)
      complex *16 ffhat(ntot)
c
      pi = 4.0d0*datan(1.0d0)
c
      call mkfouriergrid(rmax,ngridr,ityper,
     1                    nlats,itypep,ntot,numonsphere,
     2                    kgridx,kgridy,kgridz,wts)
      ifpr = 0
      if (ifpr.eq.1) call prinf('ntot is *',ntot,1)
      if (ifpr.eq.1) call prinf('numonsphere is *',numonsphere,ngridr)
      npts = ngrid*ngrid*ngrid
c
c     construct fourier transform of ff
c
      if (ifpr.eq.1) call prinf(' (gr) npts is *',npts,1)
      iflag = 1
      call finufft3d3_f(npts,x,y,z,ff,iflag,eps,ntot,
     1        kgridx,kgridy,kgridz,ffhat,ier)
c
c     rescale to account for trapezodal rule quadrature weight
c
      ffhatnorm = 0.0d0
      do ii = 1,ntot
         ffhat(ii) = ffhat(ii)*h*h*h
         ffhatnorm = ffhatnorm + wts(ii)*cdabs(ffhat(ii))**2
      enddo
      ffhatnorm = dsqrt(ffhatnorm)/(dsqrt(2*pi)**3)
      return
      end
c
c
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine get_thetas_phis(nlats,itypep,numonsphere,thetas,phis)
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     PURPOSE: Create theta/phi values for pts on sphere
c              with nlats latitudes. 
c     
c     INPUT:
c
c     nlats          number of latitude points on sphere
c     itypep         quadrature scheme in phi direction
c                       0 = same on all latitudes (which oversamples poles)
c                       1 = adaptive (undersamples toward poles)
c                    if itypep=0
c                       nphi = nint(nlats(i)*phi_over)
c                    if itypep=1
c                       nphi = nint(nlats(i)*phi_over*sin(theta))
c
c                    phi_over is defined in getgridph and typically
c                    set to 2.
c
c     OUTPUT:
c
c     numonsphere    number of points on sphere
c     thetas         theta components of pts on sphere                    
c     phis           phi components of pts on sphere                    
c
c----------------------------------------------------------------------
      implicit none
      integer ngridp,ngridt,i
      integer itypep,ntot,nnn
      integer ifprint,jj,kk,ll,ngridtmax
      integer nlats
      integer numonsphere
      real *8 rkmax,u,v,pi,phi,phstep,rr
      real *8 ctheta,stheta
      real *8 phis(numonsphere)
      real *8 thetas(numonsphere)
      integer, allocatable ::  ngridps(:)
      real *8, allocatable :: phsteps(:)
      real *8, allocatable :: sthetas(:)
      real *8, allocatable :: xnodesth(:)
      real *8, allocatable :: wtsth(:)
c
      pi = 4.0d0*datan(1.0d0)
c
c     get max theta array size and allocate local arrays
c
      allocate(xnodesth(nlats))
      allocate(sthetas(nlats))
      allocate(wtsth(nlats))
      allocate(ngridps(nlats))
      allocate(phsteps(nlats))
c
      nnn = 0
      ngridt = nlats
      call getspheregrid(ngridt,itypep,xnodesth,
     1         sthetas,wtsth,ngridps,phsteps,numonsphere)
      do kk = 1,ngridt
         ctheta = xnodesth(kk)
         stheta = sthetas(kk)
         phstep = phsteps(kk)
c
         do ll = 1,ngridps(kk)
            phi = (ll-1)*phstep
            nnn = nnn+1
            phis(nnn) = phi
            thetas(nnn) = dacos(ctheta)
         enddo
      enddo
      return
      end
!> Doxygen comment: ;\n
!> simple print function: ;\n
      subroutine ping(n)
      implicit none
      integer n
      write(6,'(A,I0)') ' % ping: ' , n
      end
!> Doxygen comment: ;\n
!> create a pseudo-random real *8 from rseed: ;\n
!> this is useful when you want your ;\n
!> random numbers to be fixed from one build to another. ;\n
      real *8 function adi_rand_f(rseed)
      implicit none
      integer *4 rseed
      include 'adi_rand_f_define.f'
      rseed = mod(rseed * POW2RPOWPLUSRADD,POW22RPOWMINUSONE)
      adi_rand_f = max(0.0d0,min(1.0d0,max(1,rseed)
     $     *POW22RPOWMINUSONE_INVERSE))
c$$$      adi_rand_f = max(0.0d0,min(1.0d0,max(1,rseed)/(1.0d0
c$$$     $     *POW22RPOWMINUSONE)))
      end
!> Doxygen comment: ;\n
!> A particular class of functions in 3d: ;\n
!> Used when defining simulated molecules. ;\n
      subroutine get_F2_x_c(max_x_c,X_x_c,Y_x_c,F_x_c,param_1,param_2)
      real *8 max_x_c,X_x_c,Y_x_c,param_1,param_2
      complex *16 F_x_c
      real *8 pi,R_x_c,W_x_c
      real *8 sx,mx,sy,my,tmp_a,tmp_b,tmp_c,tmp_d
      real *8 tmp_crop
      pi = 4*atan(1.0)
      R_x_c = dsqrt(X_x_c**2 + Y_x_c**2)
      W_x_c = atan2(Y_x_c,X_x_c)
      sx=0.1
      mx=0.2-1*0.5 + param_1*1
      call periodize_r8(mx,-0.5d0,+0.5d0,mx)
      sy=0.2
      my=0.2-1*0.5 + param_1*3
      call periodize_r8(my,-0.5d0,+0.5d0,my)
      tmp_a = 1/(2*pi*max_x_c*sx*max_x_c*sy)*exp(-(X_x_c - max_x_c *mx)
     $     **2/2/(max_x_c*sx)**2)*exp(-(Y_x_c - max_x_c*my)**2 /2
     $     /(max_x_c*sy)**2)
      sx=0.1
      mx=0.6-1*0.5 + param_1*5
      call periodize_r8(mx,-0.5d0,+0.5d0,mx)
      sy=0.1
      my=0.3-1*0.5 + param_1*7
      call periodize_r8(my,-0.5d0,+0.5d0,my)
      tmp_b = 1/(2*pi*max_x_c*sx*max_x_c*sy)*exp(-(X_x_c - max_x_c
     $     *mx)**2/2/(max_x_c*sx)**2)*exp(-(Y_x_c - max_x_c*my)**2
     $     /2 /(max_x_c*sy)**2)
      sx=0.1
      mx=0.7-1*0.5 + param_1*11
      call periodize_r8(mx,-0.5d0,+0.5d0,mx)
      sy=0.2
      my=0.8-1*0.5 + param_1*13
      call periodize_r8(my,-0.5d0,+0.5d0,my)
      tmp_c = 1/(2*pi*max_x_c*sx*max_x_c*sy)*exp(-(X_x_c - max_x_c
     $     *mx)**2/2/(max_x_c*sx)**2)*exp(-(Y_x_c - max_x_c*my)**2
     $     /2 /(max_x_c*sy)**2)
      sx=0.1
      mx=0.2-1*0.5 + param_1*17
      call periodize_r8(mx,-0.5d0,+0.5d0,mx)
      sy=0.2
      my=0.8-1*0.5 + param_1*19
      call periodize_r8(my,-0.5d0,+0.5d0,my)
      tmp_d = 1/(2*pi*max_x_c*sx*max_x_c*sy)*exp(-(X_x_c - max_x_c
     $     *mx)**2/2/(max_x_c*sx)**2)*exp(-(Y_x_c - max_x_c*my)**2
     $     /2 /(max_x_c*sy)**2)
      tmp_crop = 0.5*(1+erf(-16.0*(R_x_c-0.25*(1 + 0.5*cos(param_2
     $     *W_x_c)))))
      F_x_c = cmplx(tmp_crop*(tmp_a+tmp_b+tmp_c+tmp_d),0.0)
      end
!> Doxygen comment: ;\n
!> defines a simulated molecule in x_c coordinates ;\n
!> (i.e., real-space cartesian grid) ;\n
      subroutine get_F2_x_c_(n_x,grid_x_c_,max_x_c,n_y,grid_y_c_,max_y_c
     $     ,S_x_c_,get_F2_x_c,param_1,param_2)
      implicit none
      integer n_x,n_y
      real *8 grid_x_c_(0:n_x-1),grid_y_c_(0:n_y-1)
      real *8 max_x_c,max_y_c,param_1,param_2
      complex *16 S_x_c_(0:n_x*n_y-1)
      integer ny,nx
      real *8 X_x_c,Y_x_c
      complex *16 F_x_c
      external get_F2_x_c
      do ny=0,n_y-1
         if (ny.lt.n_y/2) then
            Y_x_c = grid_y_c_(ny)
         else
            Y_x_c = grid_y_c_(ny) - max_y_c
         end if
         do nx=0,n_x-1
            if (nx.lt.n_x/2) then
               X_x_c = grid_x_c_(nx)
            else
               X_x_c = grid_x_c_(nx) - max_x_c
            end if
            call get_F2_x_c(max_x_c,X_x_c,Y_x_c,F_x_c,param_1,param_2)
            S_x_c_(nx+ny*n_x) = F_x_c
         enddo
      enddo
      end
!> Doxygen comment: ;\n
!> gets star-shaped ctf in k_p coordinates: ;\n
      subroutine get_ctf_star_k_p_(n_r,grid_k_p_,n_w_,n_A,CTF_k_p_
     $     ,param_0,param_1,param_2)
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_k_p_(0:n_r-1)
      complex *16 CTF_k_p_(0:0)
      real *8 param_0,param_1,param_2
      real *8 pi,Rval,Wval,RR,WW,WS,FF
      integer nr,nw,na

      if (verbose.gt.0) then
         write(6,'(A,I0)') '[entering get_ctf_star_k_p_]'
      end if
      
      pi = 4*atan(1.0d0)
      na = 0
      do nr=0,n_r-1
         Rval = grid_k_p_(nr)
         if (param_0.gt.0.0d0) then
            RR = exp(-Rval/param_0)
         else
            RR = 1.0d0
         end if
         do nw=0,n_w_(nr)-1
            Wval = (2*pi*nw)/n_w_(nr)
            WW = cos(param_2*(Wval-param_1))
            if (WW.ge.0.0d0) then
               WS = 1.0d0
            else
               WS = -1.0d0
            end if
            FF = RR*WS
            CTF_k_p_(na) = cmplx( FF , 0.0d0) 
            na = na+1
         enddo
      enddo
      
      if (verbose.gt.0) then
         write(6,'(A,I0)') '[finished get_ctf_star_k_p_]'
      end if

      end
!> Doxygen comment: ;\n
!> gets trivial identity ctf in k_p coordinates : ;\n
      subroutine get_ctf_ones_k_p_(n_r,grid_k_p_,n_w_,n_A,CTF_k_p_)
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_k_p_(0:n_r-1)
      complex *16 CTF_k_p_(0:0)
      integer nr,nw,na

      if (verbose.gt.0) then
         write(6,'(A,I0)') '[entering get_ctf_ones_k_p_]'
      end if
      
      na = 0
      do nr=0,n_r-1
         do nw=0,n_w_(nr)-1
            CTF_k_p_(na) = cmplx( 1.0d0 , 0.0d0) 
            na = na+1
         enddo
      enddo
      
      if (verbose.gt.0) then
         write(6,'(A,I0)') '[finished get_ctf_ones_k_p_]'
      end if

      end
!> Doxygen comment: ;\n
!> calculates mean and standard-deviation for c16 array. ;\n
      subroutine stdlim_c16(n_A,real_or_imag,S_,avg,std)
      implicit none
      integer n_A
      logical real_or_imag
      complex *16 S_(0:n_A-1)
      real *8 avg,std,var
      integer na
      avg=0
      var=0
      std=0
      do na=0,n_A-1
         if (real_or_imag.eqv..true.) then
            avg = avg + real(S_(na))
            var = var + real(S_(na))**2
         else
            avg = avg + aimag(S_(na))
            var = var + aimag(S_(na))**2
         end if
      enddo
      avg = avg / max(1,n_A)
      var = var / max(1,n_A)
      std = dsqrt(var - avg*avg)
      end
      
!> Doxygen comment: ;\n
!> calculates pearson correlation between two c16 arrays. ;\n
      subroutine pearson_c16(n_z,A_,A_start,A_stride,B_,B_start,B_stride
     $     ,C)
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_z,A_start,A_stride,B_start,B_stride
      complex *16 A_(0:(A_start + A_stride*n_z - 1))
      complex *16 B_(0:(A_start + A_stride*n_z - 1))
      complex *16 C,A_avg,A_std,B_avg,B_std
      real *8 A_std_use,B_std_use
      integer nz,na,nb
      if (verbose.gt.0) then
         write (6,'(A,I0)') ' % [entering pearson_c16] n_z ',n_z
      end if
      if (verbose.gt.0) then
         write (6,'(A)') ' A_: '
         write (6,'(4(2F8.3,1X))') (A_(na),na=A_start,A_start+A_stride
     $        *n_z,A_stride)
      end if
      if (verbose.gt.0) then
         write (6,'(A)') ' B_: '
         write (6,'(4(2F8.3,1X))') (B_(nb),nb=B_start,B_start+B_stride
     $        *n_z,B_stride)
      end if
      A_avg = cmplx( 0.0 , 0.0 )
      A_std = cmplx( 0.0 , 0.0 )
      B_avg = cmplx( 0.0 , 0.0 )
      B_std = cmplx( 0.0 , 0.0 )
      na = A_start
      nb = B_start
      do nz=0,n_z-1
         A_avg = A_avg + A_(na)
         A_std = A_std + dconjg(A_(na))*A_(na)
         B_avg = B_avg + B_(nb)
         B_std = B_std + dconjg(B_(nb))*B_(nb)
         na = na + A_stride
         nb = nb + B_stride
      enddo
      A_avg = A_avg/max(1,n_z)
      A_std = zsqrt(A_std/max(1,n_z) - dconjg(A_avg)*A_avg)
      if (real(A_std).lt.0.0d0) then
         A_std = cmplx( 1.0 , 0.0)
      end if
      B_avg = B_avg/max(1,n_z)
      B_std = zsqrt(B_std/max(1,n_z) - dconjg(B_avg)*B_avg)
      if (real(B_std).lt.0.0d0) then
         B_std = cmplx( 1.0 , 0.0)
      end if
      if (verbose.gt.0) then
         write (6,'(A,2F16.3,2F16.3)') ' % % A_avg A_std',A_avg,A_std
         write (6,'(A,2F16.3,2F16.3)') ' % % B_avg B_std',B_avg,B_std
      end if
      A_std_use = zabs(A_std)
      if (A_std_use.lt.0.000001d0) then
         A_std_use = 1.0d0
      end if
      B_std_use = zabs(B_std)
      if (B_std_use.lt.0.000001d0) then
         B_std_use = 1.0d0
      end if
      if (verbose.gt.0) then
         write (6,'(A,F16.3,1X,F16.3)') ' % % A_std_use B_std_use'
     $        ,A_std_use,B_std_use
      end if
      C = cmplx( 0.0 , 0.0 )
      na = A_start
      nb = B_start
      do nz=0,n_z-1
         C = C + dconjg(A_(na) - A_avg)/A_std_use * (B_(nb) - B_avg)
     $        /B_std_use
         na = na + A_stride
         nb = nb + B_stride
      enddo
      C = C/max(1,n_z)
      if (verbose.gt.0) then
         write (6,'(A,2F16.3)') ' % % C: ',C
      end if
      if (verbose.gt.0) then
         write (6,'(A)') ' % [finished pearson_c16]'
      end if
      end
!> Doxygen comment: ;\n
!> clears logical array ;\n
      subroutine cl1_l2(n_x,A_)
      implicit none
      integer n_x
      logical A_(0:0)
      integer nx
      nx = 0
      do nx=0,n_x-1
         A_(nx) = .false.
      enddo
      end
!> Doxygen comment: ;\n
!> clears integer *4 array ;\n
      subroutine cl1_i4(n_x,A_)
      implicit none
      integer n_x
      integer *4 A_(0:0)
      integer nx
      nx = 0
      do nx=0,n_x-1
         A_(nx) = 0
      enddo
      end
!> Doxygen comment: ;\n
!> clears real *8 array ;\n
      subroutine cl1_r8(n_x,A_)
      implicit none
      integer n_x
      real *8 A_(0:0)
      integer nx
      nx = 0
      do nx=0,n_x-1
         A_(nx) = 0.0d0
      enddo
      end
!> Doxygen comment: ;\n
!> clears complex *16 array ;\n
      subroutine cl1_c16(n_x,A_)
      implicit none
      integer n_x
      complex *16 A_(0:0)
      integer nx
      nx = 0
      do nx=0,n_x-1
         A_(nx) = cmplx(0.0d0,0.0d0)
      enddo
      end
!> Doxygen comment: ;\n
!> clears logical array ;\n
!> sets final+1 entry for memory checking ;\n
      subroutine cs1_l2(n_x,A_)
      implicit none
      integer n_x
      logical A_(0:0)
      integer nx
      nx = 0
      do nx=0,n_x-1
         A_(nx) = .false.
      enddo
      A_(n_x) = .true.
      end
!> Doxygen comment: ;\n
!> clears integer *4 array ;\n
!> sets final+1 entry for memory checking ;\n
      subroutine cs1_i4(n_x,A_)
      implicit none
      integer n_x
      integer *4 A_(0:0)
      integer nx
      nx = 0
      do nx=0,n_x-1
         A_(nx) = 0
      enddo
      A_(n_x) = -1
      end
!> Doxygen comment: ;\n
!> clears real *8 array ;\n
!> sets final+1 entry for memory checking ;\n
      subroutine cs1_r8(n_x,A_)
      implicit none
      integer n_x
      real *8 A_(0:0)
      integer nx
      nx = 0
      do nx=0,n_x-1
         A_(nx) = 0.0d0
      enddo
      A_(n_x) = -1.0d0
      end
!> Doxygen comment: ;\n
!> clears complex *16 array ;\n
!> sets final+1 entry for memory checking ;\n
      subroutine cs1_c16(n_x,A_)
      implicit none
      integer n_x
      complex *16 A_(0:0)
      integer nx
      nx = 0
      do nx=0,n_x-1
         A_(nx) = cmplx(0.0d0,0.0d0)
      enddo
      A_(n_x) = cmplx(-1.0d0,0.0d0)
      end
!> Doxygen comment: ;\n
!> checks final+1 entry in logical array ;\n
!> assumes array is set with cs1_l2 ;\n
      subroutine cxs_l2(n_x,A_,prefix_string,flag_pass)
      implicit none
      integer n_x
      logical A_(0:0)
      character(len=*) prefix_string
      logical flag_pass
      if (A_(n_x).neqv..true.) then
         write(6,'(A,A,A,I0,A)') ' Warning: cxs_l2 failed for: ' ,
     $        prefix_string , '(' , n_x , ')'
         flag_pass = .false.
      end if !if (A_(n_x).neqv..true.) then
      end
!> Doxygen comment: ;\n
!> checks final+1 entry in integer *4 array ;\n
!> assumes array is set with cs1_i4 ;\n
      subroutine cxs_i4(n_x,A_,prefix_string,flag_pass)
      implicit none
      integer n_x
      integer *4 A_(0:0)
      character(len=*) prefix_string
      logical flag_pass
      if (A_(n_x).ne.-1) then         
         write(6,'(A,A,A,I0,A)') ' Warning: cxs_i4 failed for: ' ,
     $        prefix_string , '(' , n_x , ')'
         flag_pass = .false.
      end if !if (A_(n_x).ne.-1) then
      end
!> Doxygen comment: ;\n
!> checks final+1 entry in real *8 array ;\n
!> assumes array is set with cs1_r8 ;\n
      subroutine cxs_r8(n_x,A_,prefix_string,flag_pass)
      implicit none
      integer n_x
      real *8 A_(0:0)
      character(len=*) prefix_string      
      logical flag_pass
      if (A_(n_x).ne.-1.0d0) then
         write(6,'(A,A,A,I0,A)') ' Warning: cxs_r8 failed for: ' ,
     $        prefix_string , '(' , n_x , ')'
         flag_pass = .false.
      end if !if (A_(n_x).ne.-1.0d0) then
      end
!> Doxygen comment: ;\n
!> checks final+1 entry in complex *16 array ;\n
!> assumes array is set with cs1_c16 ;\n
      subroutine cxs_c16(n_x,A_,prefix_string,flag_pass)
      implicit none
      integer n_x
      complex *16 A_(0:0)
      character(len=*) prefix_string
      logical flag_pass
      if (A_(n_x).ne.cmplx(-1.0d0,0.0d0)) then
         write(6,'(A,A,A,I0,A)') ' Warning: cxs_c16 failed for: ' ,
     $        prefix_string , '(' , n_x , ')'
         flag_pass = .false.
      end if !if (A_(n_x).ne.cmplx(-1.0d0,0.0d0)) then
      end
!> Doxygen comment: ;\n
!> copies logical array ; \n
      subroutine cp1_l2(n_x,A_,B_)
      implicit none
      integer n_x
      logical A_(0:0),B_(0:0)
      integer nx,na,nb
      na = 0
      nb = 0
      do nx=0,n_x-1
         B_(nb) = A_(na)
         na = na + 1
         nb = nb + 1
      enddo
      end
!> Doxygen comment: ;\n
!> copies integer *4 array ; \n
      subroutine cp1_i4(n_x,A_,B_)
      implicit none
      integer n_x
      integer *4 A_(0:0),B_(0:0)
      integer nx,na,nb
      na = 0
      nb = 0
      do nx=0,n_x-1
         B_(nb) = A_(na)
         na = na + 1
         nb = nb + 1
      enddo
      end
!> Doxygen comment: ;\n
!> copies real *8 array ; \n
      subroutine cp1_r8(n_x,A_,B_)
      implicit none
      integer n_x
      real *8 A_(0:0),B_(0:0)
      integer nx,na,nb
      na = 0
      nb = 0
      do nx=0,n_x-1
         B_(nb) = A_(na)
         na = na + 1
         nb = nb + 1
      enddo
      end
!> Doxygen comment: ;\n
!> copies complex *16 array ; \n
      subroutine cp1_c16(n_x,A_,B_)
      implicit none
      integer n_x
      complex *16 A_(0:0),B_(0:0)
      integer nx,na,nb
      na = 0
      nb = 0
      do nx=0,n_x-1
         B_(nb) = A_(na)
         na = na + 1
         nb = nb + 1
      enddo
      end
!> Doxygen comment: ;\n
!> copies complex *16 array ; \n
!> allows for arbitrary stride ;\n
      subroutine cps_c16(n_x,A_,A_stride,B_,B_stride)
      implicit none
      integer n_x
      complex *16 A_(0:0),B_(0:0)
      integer A_stride,B_stride
      integer nx,na,nb
      na = 0
      nb = 0
      do nx=0,n_x-1
         B_(nb) = A_(na)
         na = na + A_stride
         nb = nb + B_stride
      enddo
      end
!> Doxygen comment: ;\n
!> affine transformation for complex *16 array ;\n
!> B = A*alpha+beta ;\n
      subroutine af1_c16(n_x,alpha,beta,A_,B_)
      implicit none
      integer n_x
      complex *16 alpha,beta
      complex *16 A_(0:0),B_(0:0)
      integer nx,na,nb
      na = 0
      nb = 0
      do nx=0,n_x-1
         B_(nb) = A_(na)*alpha + beta
         na = na + 1
         nb = nb + 1
      enddo
      end
!> Doxygen comment: ;\n
!> affine transformation for complex *16 array ;\n
!> B = A*alpha+beta ;\n
!> allows for arbitrary stride ;\n
      subroutine afs_c16(n_x,alpha,beta,A_,A_stride,B_,B_stride)
      implicit none
      integer n_x
      complex *16 alpha,beta
      complex *16 A_(0:0),B_(0:0)
      integer A_stride,B_stride
      integer nx,na,nb
      na = 0
      nb = 0
      do nx=0,n_x-1
         B_(nb) = A_(na)*alpha + beta
         na = na + A_stride
         nb = nb + B_stride
      enddo
      end
!> Doxygen comment: ;\n
!> non-conjugate multiply two complex *16 arrays ;\n
!> C = A*B ;\n
      subroutine xx1_c16(n_x,A_,B_,C_)
      implicit none
      integer n_x
      complex *16 A_(0:0),B_(0:0),C_(0:0)
      integer nx,na,nb,nc
      na = 0
      nb = 0
      nc = 0
      do nx=0,n_x-1
         C_(nc) = A_(na)*B_(nb)
         na = na + 1
         nb = nb + 1
         nc = nc + 1
      enddo
      end
!> Doxygen comment: ;\n
!> conjugate multiply two complex *16 arrays ;\n
!> C = A*dconjg(B) ;\n
      subroutine xc1_c16(n_x,A_,B_,C_)
      implicit none
      integer n_x
      complex *16 A_(0:0),B_(0:0),C_(0:0)
      integer nx,na,nb,nc
      na = 0
      nb = 0
      nc = 0
      do nx=0,n_x-1
         C_(nc) = A_(na)*dconjg(B_(nb))
         na = na + 1
         nb = nb + 1
         nc = nc + 1
      enddo
      end
!> Doxygen comment: ;\n
!> transpose real *8 array ;\n
!> B = transpose(A) ;\n
      subroutine trn0_r8(n_r,n_c,A_,B_)
      implicit none
      integer n_r,n_c
      real *8 A_(0:n_r*n_c-1),B_(0:n_r*n_c-1)
      integer nr,nc
      real *8 C_(0:n_r*n_c-1)
      do nc=0,n_c-1
         do nr=0,n_r-1
            C_(nc+nr*n_c) = A_(nr+nc*n_r)
         enddo
      enddo
      call cp1_r8(n_r*n_c,C_,B_)
      end
!> Doxygen comment: ;\n
!> transpose complex *16 array ;\n
!> B = transpose(A) ;\n
      subroutine trn0_c16(n_r,n_c,A_,B_)
      implicit none
      integer n_r,n_c
      complex *16 A_(0:n_r*n_c-1),B_(0:n_r*n_c-1)
      integer nr,nc
      complex *16 C_(0:n_r*n_c-1)
      do nc=0,n_c-1
         do nr=0,n_r-1
            C_(nc+nr*n_c) = A_(nr+nc*n_r)
         enddo
      enddo
      call cp1_c16(n_r*n_c,C_,B_)
      end
!> Doxygen comment: ;\n
!> transpose complex *16 array ;\n
!> B = transpose(A) ;\n
!> assumes workspace C is preallocated ;\n
      subroutine trn0_1_c16(n_r,n_c,A_,B_,C_)
c$$$      C_ is workspace of same size as A_ and B_. ;
      implicit none
      integer n_r,n_c
      complex *16 A_(0:n_r*n_c-1),B_(0:n_r*n_c-1),C_(0:n_r*n_c-1)
      integer nr,nc
      do nc=0,n_c-1
         do nr=0,n_r-1
            C_(nc+nr*n_c) = A_(nr+nc*n_r)
         enddo
      enddo
      call cp1_c16(n_r*n_c,C_,B_)
      end
!> Doxygen comment: ;\n
!> several printing functions for various data types. ;\n
      subroutine print_all_i4(n_a,a_,prefix_string)
      implicit none
      integer n_a
      integer *4 a_(0:n_a-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer na
      write(format_string,'(A,I0,A)') '(A, ' , n_a , '(I0,1X))'
      write(6,format_string) prefix_string , (a_(na),na=0,n_a-1)
      end

      subroutine print_all_i4__(n_r,n_c,a_,prefix_string)
      implicit none
      integer n_r,n_c
      integer *4 a_(0:n_r*n_c-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer nr,nc
      write(format_string,'(A,I0,A)') '(A, ' , n_c , '(I0,1X))'
      do nr=0,n_r-1
         write(6,format_string) prefix_string , (a_(nc),nc=nr+0*n_r,nr
     $        +(n_c-1)*n_r,n_r)
      enddo ! do nr=0,n_r-1
      end

      subroutine print_sub_i4(n_a,a_,prefix_string)
      implicit none
      integer n_a
      integer *4 a_(0:n_a-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer na
      if (n_a.lt.4) then
         call print_all_i4(n_a,a_,prefix_string)
      else
         write(format_string,'(A)') '(A,I0,1X,I0,1X,A,I0,1X,I0) '
         write(6,format_string) prefix_string , a_(0) , a_(1) ,
     $        ' ... ' , a_(n_a-2) , a_(n_a-1)
      end if ! if (n_a.lt.4) then
      end

      subroutine print_all_l2(n_a,a_,prefix_string)
      implicit none
      integer n_a
      logical a_(0:n_a-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer na
      write(format_string,'(A,I0,A)') '(A, ' , n_a , '(L1,1X))'
      write(6,format_string) prefix_string , (a_(na),na=0,n_a-1)
      end

      subroutine print_all_l2__(n_r,n_c,a_,prefix_string)
      implicit none
      integer n_r,n_c
      logical a_(0:n_r*n_c-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer nr,nc
      write(format_string,'(A,I0,A)') '(A, ' , n_c , '(L1,1X))'
      do nr=0,n_r-1
         write(6,format_string) prefix_string , (a_(nc),nc=nr+0*n_r,nr
     $        +(n_c-1)*n_r,n_r)
      enddo ! do nr=0,n_r-1
      end

      subroutine print_sub_l2(n_a,a_,prefix_string)
      implicit none
      integer n_a
      logical a_(0:n_a-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer na
      if (n_a.lt.4) then
         call print_all_l2(n_a,a_,prefix_string)
      else
         write(format_string,'(A)') '(A,L1,1X,L1,1X,A,L1,1X,L1) '
         write(6,format_string) prefix_string , a_(0) , a_(1) ,
     $        ' ... ' , a_(n_a-2) , a_(n_a-1)
      end if ! if (n_a.lt.4) then
      end

      subroutine print_all_r8(n_a,a_,prefix_string)
      implicit none
      integer n_a
      real *8 a_(0:n_a-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer na
      write(format_string,'(A,I0,A)') '(A, ' , n_a , '(F10.5,1X))'
      write(6,format_string) prefix_string , (a_(na),na=0,n_a-1)
      end

      subroutine print_sub_r8(n_a,a_,prefix_string)
      implicit none
      integer n_a
      real *8 a_(0:n_a-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer na
      if (n_a.lt.4) then
         call print_all_r8(n_a,a_,prefix_string)
      else
         write(format_string,'(A)')
     $        '(A,F16.8,1X,F16.8,1X,A,F16.8,1X,F16.8) '
         write(6,format_string) prefix_string , a_(0) , a_(1) ,
     $        ' ... ' , a_(n_a-2) , a_(n_a-1)
      end if ! if (n_a.lt.4) then
      end


      subroutine print_all_c16(n_a,a_,prefix_string)
      implicit none
      integer n_a
      complex *16 a_(0:n_a-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer na
      write(format_string,'(A,I0,A)') '(A, ' , n_a ,
     $     '(F16.8,1X,F16.8,4X))'
      write(6,format_string) prefix_string , (a_(na),na=0,n_a-1)
      end

      subroutine print_sub_c16(n_a,a_,prefix_string)
      implicit none
      integer n_a
      complex *16 a_(0:n_a-1)
      character(len=*) prefix_string
      character(len=1024) format_string
      integer na
      if (n_a.lt.4) then
         call print_all_c16(n_a,a_,prefix_string)
      else
         write(format_string,'(A,A,A,A,A,A,A)') '(A,'
     $        ,'A,F16.8,1X,F16.8,A,' ,'A,F16.8,1X,F16.8,A,' , 'A,' , 
     $        'A,F16.8,1X,F16.8,A,' ,'A,F16.8,1X,F16.8,A' , ') '
         write(6,format_string) prefix_string , ' (' , a_(0) , ') ' 
     $        , ' (' , a_(1) , ') ' , '...' , 
     $        ' (' , a_(n_a-2) , ') ' , ' (' , a_(n_a-1) , ') ' 
      end if ! if (n_a.lt.4) then
      end

!> Doxygen comment: ;\n
!> write integer *4 into multi-dimensional-array (mda) file ;\n
      subroutine MDA_write_i4(n_d,d_,A_,fname)
      implicit none
      integer n_d,nd,n_A,na
      integer d_(0:n_d-1)
      integer *4 A_(0:0)
      character(len=1024) fname
      n_A=1
      do nd=0,n_d-1
         n_A = n_A*d_(nd)
      enddo
      open(7,file=fname,status='replace',form='unformatted')
      write(7) n_d
      write(7) (d_(nd),nd=0,n_d-1)
      write(7) (A_(na),na=0,n_A-1)
      close(7,status='keep')
      end
!> Doxygen comment: ;\n
!> write real *8 into multi-dimensional-array (mda) file ;\n
      subroutine MDA_write_r8(n_d,d_,A_,fname)
      implicit none
      integer n_d,nd,n_A,na
      integer d_(0:n_d-1)
      real *8 A_(0:0)
      character(len=1024) fname
      n_A=1
      do nd=0,n_d-1
         n_A = n_A*d_(nd)
      enddo
      open(7,file=fname,status='replace',form='unformatted')
      write(7) n_d
      write(7) (d_(nd),nd=0,n_d-1)
      write(7) (A_(na),na=0,n_A-1)
      close(7,status='keep')
      end
!> Doxygen comment: ;\n
!> write complex *16 into multi-dimensional-array (mda) file ;\n
      subroutine MDA_write_c16(n_d,d_,A_,fname)
      implicit none
      integer n_d,nd,n_A,na
      integer d_(0:n_d-1)
      complex *16 A_(0:0)
      character(len=1024) fname
      n_A=1
      do nd=0,n_d-1
         n_A = n_A*d_(nd)
      enddo
      open(7,file=fname,status='replace',form='unformatted')
      write(7) n_d
      write(7) (d_(nd),nd=0,n_d-1)
      write(7) (A_(na),na=0,n_A-1)
      close(7,status='keep')
      end
!> Doxygen comment: ;\n
!> generate pseudo-random permutation of size n_A ;\n
      subroutine adi_randperm(rseed,n_A,I_)
      implicit none
      integer *4 rseed
      real *8 adi_rand_f
      integer n_A,na
      integer *4 I_(0:n_A-1)
      real *8, allocatable :: f_(:)
      allocate(f_(0:n_A-1))
      do na=0,n_A-1
         f_(na) = adi_rand_f(rseed)
         I_(na) = na
      enddo
      call quicksort_r8(0,n_A-1,f_,1,I_,1,quicksort_r8)
      deallocate(f_)
      end
!> Doxygen comment: ;\n
!> generate pseudo-random set of n_add entries from S_ for later use. ;\n
!> makes sure to skip any entries that are already flagged in S_used_ ;\n
      subroutine adi_randinclude(rseed,n_LT,LT_,n_S,S_used_,S_used_total
     $     ,n_add)
      implicit none
      integer *4 rseed
      integer *4 n_LT,nLT,n_S,nS,S_used_total,n_add
      integer *4 LT_(0:0)
      logical S_used_(0:0)
      integer *4, allocatable :: I_(:)
      integer *4 n_I,nI
      integer *4, allocatable :: J_(:)
      integer *4 n_J,nJ
      allocate(I_(0:n_S-1))
      allocate(J_(0:n_S-1))
      n_I = n_S - S_used_total
      n_J = min(n_add,n_I)
      do nJ=0,n_J-1
         J_(nJ) = nJ
      enddo
      call adi_randperm(rseed,n_I,I_)
      call quicksort_i4(0,n_J-1,I_,1,J_,1,quicksort_i4)
      nJ=0
      nI=0
      nS=0
      do while ((nS.lt.n_S) .and. (nI.lt.n_I) .and. (nJ.lt.n_J))
         if (S_used_(ns).eqv..true.) then
            ns = ns+1
         else if (S_used_(ns).eqv..false.) then
            if (nI.eq.I_(nJ)) then
               LT_(n_LT) = ns
               n_LT = n_LT+1
               S_used_(ns) = .true.
               S_used_total = S_used_total+1
               nJ = nJ+1
            end if !if not used but in I_
            nI = nI+1
            nS = nS+1
         end if !if
      enddo !do while
      deallocate(J_)
      deallocate(I_)
      end
!> Doxygen comment: ;\n
!> generate linearly spaced array. ;\n
!> note that this does not include the upper endpoint! ;\n
!> this is specifically for use with periodic array. ;\n
!> for example: linspace(0,2*pi,16,grid_) generates ;\n
!> 16 equispaced points from 0 to (15/16)*2*pi. ;\n
      subroutine linspace(d_start,d_endat,n_steps,grid_)
      implicit none
      real *8 d_start,d_endat
      integer n_steps
      real *8 grid_(0:n_steps-1)
      integer ns
      do ns=0,n_steps-1
         grid_(ns) = d_start + ns*(d_endat-d_start)/(n_steps)
      enddo
      end
!> Doxygen comment: ;\n
!> generates indices used for blocking arrays. ;\n
      subroutine block_0(verbose,n_A_sub__in,n_A,n_A_per_,n_A_sum_
     $     ,n_A_sub_use,nA_per_min,nA_per_max)
      implicit none
      integer *4 verbose !verbosity level. ;
      integer *4 n_A_sub__in !requested (maximum) number of blocks to split n_A into. ;
      integer *4 n_A !total number of elements in array. ;
      integer *4 n_A_per_(0:0) !array (of length n_A_sub_use) storing the number of elements per block. ;
      integer *4 n_A_sum_(0:0) !array (of length n_A_sub_use) storing the cumulative sum of n_A_per_. ;
      integer *4 n_A_sub_use !actual number of blocks used when splitting n_A. ;
      integer *4 nA_per_min !minimum number of elements in a block. ;
      integer *4 nA_per_max !maximum number of elements in a block. ;
      integer *4 nA_sub !temporary index. ;
      integer *4 n_A_quo !temporary quotient. ;
      integer *4 n_A_rem !temporary remainder. ;
      integer *4 min_i4_f !function output. ;
      integer *4 max_i4_f !function output. ;

      if (verbose.gt.0) then
         write (6,'(A)') ' [entering block_0] '
      end if ! if (verbose.gt.0) then

      n_A_sub_use = min(n_A_sub__in,n_A)
      if (verbose.gt.0) then
         write (6,'(3(A,I0))') ' n_A_sub__in ' , n_A_sub__in , ' n_A ' ,
     $        n_A , ' n_A_sub_use = ',n_A_sub_use
      end if ! if (verbose.gt.0) then
      n_A_quo = n_A/n_A_sub_use
      n_A_rem = mod(n_A,n_A_sub_use)
      if (verbose.gt.0) then
         write(6,'(2(A,I0))') ' n_A_quo ' , n_A_quo , ' n_A_rem ' ,
     $        n_A_rem
      end if !if (verbose.gt.0) then
      do nA_sub=0,n_A_sub_use-1
         if (nA_sub.lt.n_A_rem) then
            n_A_per_(nA_sub) = n_A_quo + 1
         end if !if (nA_sub.lt.n_A_rem) then
         if (nA_sub.ge.n_A_rem) then
            n_A_per_(nA_sub) = n_A_quo + 0
         end if !if (nA_sub.ge.n_A_rem) then
      enddo ! do nA_sub=0,n_A_sub_use-1
      if (n_A_sub_use.ge.1) then
         n_A_sum_(0) = 0
      end if !if (n_A_sub_use.ge.1) then
      do nA_sub=1,n_A_sub_use-1
         n_A_sum_(nA_sub) = n_A_sum_(nA_sub-1) + n_A_per_(nA_sub-1)
      enddo ! do nA_sub=1,n_A_sub_use-1
      nA_per_min = min_i4_f(n_A_sub_use,n_A_per_)
      nA_per_max = max_i4_f(n_A_sub_use,n_A_per_)
      if (verbose.gt.0) then
         call print_all_i4(n_A_sub_use,n_A_per_,' n_A_per_: ')
         call print_all_i4(n_A_sub_use,n_A_sum_,' n_A_sum_: ')
         write(6,'(A,I0,A,I0)') ' nA_per_min: ' , nA_per_min ,
     $        ' nA_per_max: ' , nA_per_max
      end if ! if (verbose.gt.1) then

      if (verbose.gt.0) then
         write (6,'(A)') ' [finished block_0] '
      end if ! if (verbose.gt.0) then
      end 
!> Doxygen comment: ;\n
!> generates indices used for blocking arrays. ;\n
      subroutine block_1(verbose,n_A_sub__in,n_A,n_A_per_,n_A_sum_
     $     ,n_A_sub_use,nA_per_min,nA_per_max)
      implicit none
      integer *4 verbose !verbosity level. ;
      integer *4 n_A_sub__in !requested (maximum) number of blocks to split n_A into. ;
      integer *4 n_A !total number of elements in array. ;
      integer *4 n_A_per_(0:0) !array (of length n_A_sub_use) storing the number of elements per block. ;
      integer *4 n_A_sum_(0:0) !array (of length n_A_sub_use) storing the cumulative sum of n_A_per_. ;
      integer *4 n_A_sub_use !actual number of blocks used when splitting n_A. ;
      integer *4 nA_per_min !minimum number of elements in a block. ;
      integer *4 nA_per_max !maximum number of elements in a block. ;
      integer *4 nA_sub !temporary index. ;
      integer *4 n_A_quo !temporary quotient. ;
      integer *4 n_A_rem !temporary remainder. ;
      integer *4 min_i4_f !function output. ;
      integer *4 max_i4_f !function output. ;

      if (verbose.gt.0) then
         write (6,'(A)') ' [entering block_1] '
      end if ! if (verbose.gt.0) then

      n_A_sub_use = min(n_A_sub__in,n_A)
      if (verbose.gt.0) then
         write (6,'(3(A,I0))') ' n_A_sub__in ' , n_A_sub__in , ' n_A ' ,
     $        n_A , ' n_A_sub_use = ',n_A_sub_use
      end if ! if (verbose.gt.0) then
      call cl1_i4(n_A_sub_use,n_A_per_)
      call cl1_i4(n_A_sub_use,n_A_sum_)
      n_A_quo = n_A/n_A_sub_use
      n_A_rem = mod(n_A,n_A_sub_use)
      if (verbose.gt.0) then
         write(6,'(2(A,I0))') ' n_A_quo ' , n_A_quo , ' n_A_rem ' ,
     $        n_A_rem
      end if !if (verbose.gt.0) then
      do nA_sub=0,n_A_sub_use-1
         if (nA_sub.lt.n_A_rem) then
            n_A_per_(nA_sub) = n_A_quo + 1
         end if !if (nA_sub.lt.n_A_rem) then
         if (nA_sub.ge.n_A_rem) then
            n_A_per_(nA_sub) = n_A_quo + 0
         end if !if (nA_sub.ge.n_A_rem) then
      enddo ! do nA_sub=0,n_A_sub_use-1
      if (n_A_sub_use.ge.1) then
         n_A_sum_(0) = 0
      end if !if (n_A_sub_use.ge.1) then
      do nA_sub=1,n_A_sub_use-1
         n_A_sum_(nA_sub) = n_A_sum_(nA_sub-1) + n_A_per_(nA_sub-1)
      enddo ! do nA_sub=1,n_A_sub_use-1
      nA_per_min = min_i4_f(n_A_sub_use,n_A_per_)
      nA_per_max = max_i4_f(n_A_sub_use,n_A_per_)
      if (verbose.gt.0) then
         call print_all_i4(n_A_sub_use,n_A_per_,' n_A_per_: ')
         call print_all_i4(n_A_sub_use,n_A_sum_,' n_A_sum_: ')
         write(6,'(A,I0,A,I0)') ' nA_per_min: ' , nA_per_min ,
     $        ' nA_per_max: ' , nA_per_max
      end if ! if (verbose.gt.1) then

      if (verbose.gt.0) then
         write (6,'(A)') ' [finished block_1] '
      end if ! if (verbose.gt.0) then
      end 
!> Doxygen comment: ;\n
!> piecewise linear interpolation in 1-dimension ;\n
!> designed for complex *16 arrays ;\n
!> assumes a regular grid for x, as well as periodic boundary conditions ;\n
      subroutine interp1_c16(n_x,min_x,max_x,F_,x_loc,output)
c$$$      assumes regular grid for x
c$$$      periodic boundary conditions
      integer *4 n_x
      real *8 min_x,max_x
      complex *16 F_(0:n_x-1)
      real *8 x_loc
      complex *16 output
      real *8 nx_d
      integer *4 nx_pre,nx_pos
      real *8 dx_pre,dx_pos
      real *8 d_pre,d_pos
      real *8 A,B,alpha,beta
      call periodize_r8(x_loc,min_x,max_x,x_loc)
      nx_d = n_x*(x_loc-min_x)/(max_x-min_x)
      nx_pre = floor(nx_d)
      dx_pre = dabs(nx_pre - nx_d)
      nx_pos = ceiling(nx_d)
      dx_pos = dabs(nx_pos - nx_d)
      if (nx_pos.ge.n_x) then
         nx_pos = nx_pos - n_x
      end if
      d_pre = (dx_pre)
      d_pos = (dx_pos)
      A = d_pre
      B = d_pos
      if (A+B.le.0) then
         output = F_(nx_pre)
      else
         alpha = A/(A+B)
         beta = B/(A+B)
         output = beta*F_(nx_pre) + alpha*F_(nx_pos)
      end if
      end
!> Doxygen comment: ;\n
!> piecewise linear interpolation in 2-dimensions ;\n
!> designed for complex *16 arrays ;\n
!> assumes a regular grid for x and y, ;\n
!> as well as periodic boundary conditions. ;\n
      subroutine interp2_c16(n_x,min_x,max_x,n_y,min_y,max_y,F_,x_loc
     $     ,y_loc,output)
c$$$      assumes regular grid for x and y
c$$$      periodic boundary conditions
      integer *4 n_x,n_y
      real *8 min_x,max_x,min_y,max_y
      complex *16 F_(0:n_x*n_y-1)
      real *8 x_loc,y_loc
      complex *16 output
      real *8 nx_d,ny_d
      integer *4 nx_pre,ny_pre,nx_pos,ny_pos
      real *8 dx_pre,dy_pre,dx_pos,dy_pos
      real *8 d_prepre,d_prepos,d_pospre,d_pospos
      real *8 A,B,C,D,alpha,beta
      logical E
      call periodize_r8(x_loc,min_x,max_x,x_loc)
      nx_d = n_x*(x_loc-min_x)/(max_x-min_x)
      nx_pre = floor(nx_d)
      dx_pre = dabs(nx_pre - nx_d)
      nx_pos = ceiling(nx_d)
      dx_pos = dabs(nx_pos - nx_d)
      if (nx_pos.ge.n_x) then
         nx_pos = nx_pos - n_x
      end if
      call periodize_r8(y_loc,min_y,max_y,y_loc)
      ny_d = n_y*(y_loc-min_y)/(max_y-min_y)
      ny_pre = floor(ny_d)
      dy_pre = dabs(ny_pre - ny_d)
      ny_pos = ceiling(ny_d)
      dy_pos = dabs(ny_pos - ny_d)
      if (ny_pos.ge.n_y) then
         ny_pos = ny_pos - n_y
      end if
      d_prepre = dsqrt((dx_pre)**2 + (dy_pre)**2)
      d_prepos = dsqrt((dx_pre)**2 + (dy_pos)**2)
      d_pospre = dsqrt((dx_pos)**2 + (dy_pre)**2)
      d_pospos = dsqrt((dx_pos)**2 + (dy_pos)**2)
      E=.true.
c$$$  case 1
      A = d_prepre
      B = d_prepos
      C = d_pospre
      D = d_pospos
      if (E .and. A.le.C .and. A.le.D .and. B.le.C .and. B.le.D) then
         E=.false.
         if (A+B.le.0) then
            output = F_(nx_pre + ny_pre*n_x)
         else
            alpha = A/(A+B)
            beta = B/(A+B)
            output = beta*F_(nx_pre + ny_pre*n_x) + alpha*F_(nx_pre +
     $           ny_pos*n_x)
         end if
      end if
c$$$  case 2
      A = d_prepre
      B = d_pospre
      C = d_prepos
      D = d_pospos
      if (E .and. A.le.C .and. A.le.D .and. B.le.C .and. B.le.D) then
         E=.false.
         if (A+B.le.0) then
            output = F_(nx_pre + ny_pre*n_x)
         else
            alpha = A/(A+B)
            beta = B/(A+B)
            output = beta*F_(nx_pre + ny_pre*n_x) + alpha*F_(nx_pos +
     $           ny_pre*n_x)
         end if
      end if
c$$$  case 3
      A = d_prepre
      B = d_pospos
      C = d_prepos
      D = d_pospre
      if (E .and. A.le.C .and. A.le.D .and. B.le.C .and. B.le.D) then
         E=.false.
         if (A+B.le.0) then
            output = F_(nx_pre + ny_pre*n_x)
         else
            alpha = A/(A+B)
            beta = B/(A+B)
            output = beta*F_(nx_pre + ny_pre*n_x) + alpha*F_(nx_pos +
     $           ny_pos*n_x)
         end if
      end if
c$$$  case 4
      A = d_prepos
      B = d_pospre
      C = d_prepre
      D = d_pospos
      if (E .and. A.le.C .and. A.le.D .and. B.le.C .and. B.le.D) then
         E=.false.
         if (A+B.le.0) then
            output = F_(nx_pre + ny_pos*n_x)
         else
            alpha = A/(A+B)
            beta = B/(A+B)
            output = beta*F_(nx_pre + ny_pos*n_x) + alpha*F_(nx_pos +
     $           ny_pre*n_x)
         end if
      end if
c$$$  case 5
      A = d_prepos
      B = d_pospos
      C = d_prepre
      D = d_pospre
      if (E .and. A.le.C .and. A.le.D .and. B.le.C .and. B.le.D) then
         E=.false.
         if (A+B.le.0) then
            output = F_(nx_pre + ny_pos*n_x)
         else
            alpha = A/(A+B)
            beta = B/(A+B)
            output = beta*F_(nx_pre + ny_pos*n_x) + alpha*F_(nx_pos +
     $           ny_pos*n_x)
         end if
      end if
c$$$  case 6
      A = d_pospre
      B = d_pospos
      C = d_prepre
      D = d_prepos
      if (E .and. A.le.C .and. A.le.D .and. B.le.C .and. B.le.D) then
         E=.false.
         if (A+B.le.0) then
            output = F_(nx_pos + ny_pre*n_x)
         else
            alpha = A/(A+B)
            beta = B/(A+B)
            output = beta*F_(nx_pos + ny_pre*n_x) + alpha*F_(nx_pos +
     $           ny_pos*n_x)
         end if
      end if      
      end
!> Doxygen comment: ;\n
!> Interpolate from cartesian to polar coordinates. ;\n
      subroutine interp_c_to_p(n_x,max_x_c,n_y,max_y_c,S_c_,n_r
     $     ,grid_p_,n_w_,n_A,S_p_)
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_x,n_y,n_r,n_A
      real *8 max_x_c,max_y_c
      complex *16 S_c_(0:n_x*n_y-1),S_p_(0:n_A-1)
      real *8 grid_p_(0:n_r-1)
      integer n_w_(0:n_r-1)
      complex *16, allocatable :: T_c_(:)
      real *8 pi,max_r_c
      integer ic,nr,nw
      real *8 X_c,Y_c,R_c,W_c
      complex *16 C_c
      allocate(T_c_(0:n_x*n_y-1));
      call recenter_c16(n_x,n_y,S_c_,T_c_)
      pi = 4.0*atan(1.0)
      max_r_c = sqrt(max_x_c**2 + max_y_c**2)
      ic=0
      do nr=0,n_r-1
         R_c = grid_p_(nr)
         if (verbose.gt.0) then
            write(6,*) 'R_c(',nr,') = ',R_c
         end if
         do nw=0,n_w_(nr)-1
            W_c = 0.0 + nw*(2*pi)/(n_w_(nr))
            X_c = R_c*cos(W_c)
            Y_c = R_c*sin(W_c)
            call interp2_c16(n_x,-max_x_c/2.0,max_x_c/2.0,n_y,-max_y_c
     $           /2.0,max_y_c/2.0,T_c_,X_c,Y_c ,C_c)
            S_p_(ic) = C_c
            ic = ic + 1
         enddo
      enddo
      deallocate(T_c_)
      end
!> Doxygen comment: ;\n
!> Interpolate from k_p (i.e., fourier-polar) to fourier-bessel coordinates. ;\n
!> Uses a simple brute-force fourier-transform. ;\n
      subroutine interp_p_to_q(n_r,n_w_,n_A,S_p_,S_q_)
      implicit none
      include 'omp_lib.h'
      integer verbose
      data verbose / 0 /
      integer n_r,n_w_(0:n_r-1),n_A
      complex *16 S_p_(0:n_A-1),S_q_(0:n_A-1)
      complex *16, allocatable :: Z_q_(:)
      integer ic,nr
      integer nt,n_t
      real *8 timing_tic,timing_toc
      if (verbose.gt.0) then
         write(6,*) '[entering interp_p_to_q]'
         timing_tic = omp_get_wtime()
      end if
      if (verbose.gt.0) then
         n_t = 10000
         write(6,*) 'running n_t times with n_t: ',n_t
      else
         n_t = 1
      end if
      allocate(Z_q_(0:n_A-1));
      do nt=0,n_t-1
      ic=0
      do nr=0,n_r-1
         call adi_fft1(-1,n_w_(nr),S_p_,ic,1,Z_q_,ic,1)
         call af1_c16(n_w_(nr),1.0d0*cmplx(1.0d0/dsqrt(1.0d0 *n_w_(nr)))
     $        ,1.0d0*cmplx(0.0d0),Z_q_(ic),Z_q_(ic))
         ic = ic + n_w_(nr)
      enddo
      enddo
      call cp1_c16(n_A,Z_q_,S_q_);
      deallocate(Z_q_)
      if (verbose.gt.0) then
         timing_toc = omp_get_wtime()
         write(6,'(A,F6.3)') ' [finished interp_p_to_q]: total time: '
     $        ,timing_toc-timing_tic
      end if
      end
!> Doxygen comment: ;\n
!> Interpolate from k_p (i.e., fourier-polar) to fourier-bessel coordinates. ;\n
!> Uses fftw. ;\n
      subroutine interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $     ,fftw_in1_,fftw_out_,S_p_,S_q_)
      implicit none
      include '/usr/include/fftw3.f'
      include 'omp_lib.h'
      integer verbose
      data verbose / 0 /
      integer n_r,n_w_(0:n_r-1),n_A
      integer *8 fftw_plan_frwd_(0:n_r-1)
      complex *16 fftw_in1_(0:n_A-1),fftw_out_(0:n_A-1)
      complex *16 S_p_(0:n_A-1),S_q_(0:n_A-1)
      integer n_w_max,ic,nr
      real *8 timing_tic,timing_toc
      if (verbose.gt.0) then
         write(6,*) '[entering interp_p_to_q_fftw]'
         timing_tic = omp_get_wtime()
      end if
      if (verbose.gt.0) then
         write(6,*) '% n_r: ',n_r
         write(6,*) '% n_w_: ',(n_w_(nr),nr=0,n_r-1)
         write(6,*) '% n_A: ',n_A
      end if
      n_w_max = n_w_(n_r-1)
      ic=0
      do nr=0,n_r-1
         if (n_w_(nr).gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling cp1_c16: '
            end if
            call cp1_c16(n_w_(nr),S_p_(ic),fftw_in1_(ic))
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; executing fftw_plan: '
            end if
            call dfftw_execute_(fftw_plan_frwd_(nr))
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling affine_c16: '
            end if
            call af1_c16(n_w_(nr),1.0d0*cmplx(1.0d0/dsqrt(1.0d0
     $           *n_w_(nr))),1.0d0*cmplx(0.0d0),fftw_out_(ic),S_q_(ic))
            if (verbose.gt.2) then
               write(6,*) '% % setting ic ',ic,' to ic ',ic + n_w_(nr)
            end if
            ic = ic + n_w_(nr)
         end if
      enddo
      if (verbose.gt.0) then
         timing_toc = omp_get_wtime()
         write(6,'(A,F6.3)')
     $        ' [finished interp_p_to_q_fftw]: total time: '
     $        ,timing_toc-timing_tic
      end if
      end
!> Doxygen comment: ;\n
!> periodize real *8 A within the limits [min,max) ;\n
!> Note that if input=max, the output will equal min. ;\n
      subroutine periodize_r8(A,min,max,B)
      implicit none
      real *8 A,min,max,B
      B = A
      do while (B.lt.min)
         B = B + (max-min)
      end do
      do while (B.ge.max)
         B = B - (max-min)
      end do
      end
!> Doxygen comment: ;\n
!> periodize integer A within the limits [min,max) ;\n
!> Note that if input=max, the output will equal min. ;\n
      subroutine periodize_i(A,min,max,B)
      implicit none
      integer A,min,max,B
      B = A
      do while (B.lt.min)
         B = B + (max-min)
      end do
      do while (B.ge.max)
         B = B - (max-min)
      end do
      end
!> Doxygen comment: ;\n
!> Applies translation in x_c (i.e., real-space cartesian) coordinates. ;\n
!> This amounts to a shift by some (fractional) number of pixels. ;\n
!> Uses linear interpolation. ;\n
!> Assumes that M_c_ is the same size and dimensions as S_c_. ;\n
      subroutine transl_c_to_c(n_x,max_x_c,n_y,max_y_c,S_c_,delta_x
     $     ,delta_y,M_c_)
c$$$      Assumes that M_c_ is the same size and dimensions as S_c_
      implicit none
      integer n_x,n_y
      real *8 max_x_c,max_y_c,delta_x,delta_y
      complex *16 S_c_(0:n_x*n_y-1),M_c_(0:n_x*n_y-1)
      complex *16, allocatable :: T_c_(:)
      complex *16, allocatable :: N_c_(:)
      integer nx,ny
      real *8 X_c,Y_c
      complex *16 C_c
      allocate(T_c_(0:n_x*n_y-1))
      allocate(N_c_(0:n_x*n_y-1))
      call recenter_c16(n_x,n_y,S_c_,T_c_)
      do ny=0,n_y-1
         do nx=0,n_x-1
            X_c = 0.0d0 + nx*max_x_c/n_x - delta_x
            Y_c = 0.0d0 + ny*max_y_c/n_y - delta_y
            call interp2_c16(n_x,0.0d0,max_x_c,n_y,0.0d0,max_y_c,T_c_
     $           ,X_c,Y_c,C_c)
            N_c_(nx+ny*n_x) = C_c
         enddo
      enddo
      call decenter_c16(n_x,n_y,N_c_,M_c_)
      deallocate(N_c_)
      deallocate(T_c_)
      end
!> Doxygen comment: ;\n
!> Applies translation in k_c (i.e., fourier-space cartesian) coordinates. ;\n
!> This amounts to a multiplication by a plane-wave. ;\n
!> Assumes that M_c_ is the same size and dimensions as S_c_. ;\n
!> Note that this recenters the image before applying the plane-wave. ;\n
!> i.e., we assume that the 'origin' is in the center of the image. ;\n
      subroutine transf_c_to_c(n_x,max_x_c,n_y,max_y_c,S_c_,delta_x
     $     ,delta_y,M_c_)
c$$$      Assumes that M_c_ is the same size and dimensions as S_c_
c$$$      Multiplication *should* be performed in place 
c$$$      (i.e., without temporary workspace)
      implicit none
      integer n_x,n_y
      real *8 max_x_c,max_y_c,delta_x,delta_y
      complex *16 S_c_(0:n_x*n_y-1),M_c_(0:n_x*n_y-1)
      complex *16, allocatable :: T_c_(:)
      complex *16, allocatable :: N_c_(:)
      real *8 pi
      integer nx,ny
      real *8 X_c,Y_c,L_c
      complex *16 C_c
      pi = 4.0*atan(1.0)
      allocate(T_c_(0:n_x*n_y-1))
      allocate(N_c_(0:n_x*n_y-1))
      call recenter_c16(n_x,n_y,S_c_,T_c_)
      do ny=0,n_y-1
         do nx=0,n_x-1
            X_c = 0.0d0 + nx*max_x_c/n_x - max_x_c/2.0
            Y_c = 0.0d0 + ny*max_y_c/n_y - max_y_c/2.0
            L_c = (X_c * delta_x) + (Y_c * delta_y)
            C_c = cmplx(+cos(2*pi*L_c),-sin(2*pi*L_c))
            N_c_(nx+ny*n_x) = C_c*T_c_(nx+ny*n_x)
         enddo
      enddo
      call decenter_c16(n_x,n_y,N_c_,M_c_)
      deallocate(N_c_)
      deallocate(T_c_)
      end
!> Doxygen comment: ;\n
!> Applies translation in k_p (i.e., fourier-space polar) coordinates. ;\n
!> This amounts to a multiplication by a plane-wave. ;\n
!> Assumes that M_p_ is the same size and dimensions as S_p_. ;\n
      subroutine transf_p_to_p(n_r,grid_p_,n_w_,n_A,S_p_,delta_x,delta_y
     $     ,M_p_)
c$$$      Assumes that M_p_ is the same size and dimensions as S_p_
c$$$      Multiplication performed in place
      implicit none
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_p_(0:n_r-1),delta_x,delta_y
      complex *16 S_p_(0:n_A-1),M_p_(0:n_A-1)
c$$$      complex *16, allocatable :: Z_p_(:)
      real *8 pi
      integer nr,ic,nw,nt_pre,nt_pos
      real *8 R_c,W_c,X_c,Y_c,L_c
      complex *16 C_c
c$$$      allocate(Z_p_(0:n_A-1))
      pi = 4.0*atan(1.0)
      ic=0
      do nr=0,n_r-1
         R_c = grid_p_(nr)
         do nw=0,n_w_(nr)-1
            W_c = 0.0 + nw*(2*pi)/(n_w_(nr))
            X_c = R_c*cos(W_c)
            Y_c = R_c*sin(W_c)
            L_c = (X_c * delta_x) + (Y_c * delta_y)
            C_c = cmplx(+cos(2*pi*L_c),-sin(2*pi*L_c))
c$$$            Z_p_(ic) = C_c*S_p_(ic)
            M_p_(ic) = C_c*S_p_(ic)
            ic = ic + 1
         enddo
      enddo
c$$$      call copy_c16(n_A,n_A,Z_p_,0,1,n_A,M_p_,0,1)
c$$$      deallocate(Z_p_)
      end
!> Doxygen comment: ;\n
!> Applies translation in k_p (i.e., fourier-space polar) coordinates. ;\n
!> This amounts to a multiplication by a plane-wave. ;\n
!> Assumes that M_p_ is the same size and dimensions as S_p_. ;\n
!> This only applies to a single ring of S_p_. ;\n
      subroutine transf_p_to_p_single(grid_p,n_w,S_p_1_,delta_x,delta_y
     $     ,M_p_1_)
c$$$      Assumes that M_p_1_ is the same size and dimensions as S_p_1_
c$$$      Multiplication performed in place
      implicit none
      integer n_w
      real *8 grid_p,delta_x,delta_y
      complex *16 S_p_1_(0:n_w-1),M_p_1_(0:n_w-1)
      real *8 pi
      integer ic,nw,nt_pre,nt_pos
      real *8 R_c,W_c,X_c,Y_c,L_c
      complex *16 C_c
      pi = 4.0*atan(1.0)
      ic=0
      R_c = grid_p
      do nw=0,n_w-1
         W_c = 0.0 + nw*(2*pi)/(n_w)
         X_c = R_c*cos(W_c)
         Y_c = R_c*sin(W_c)
         L_c = (X_c * delta_x) + (Y_c * delta_y)
         C_c = cmplx(+cos(2*pi*L_c),-sin(2*pi*L_c))
         M_p_1_(ic) = C_c*S_p_1_(ic)
         ic = ic + 1
      enddo
      end
!> Doxygen comment: ;\n
!> Applies translation in k_q (i.e., fourier-space bessel) coordinates. ;\n
!> This approximates a multiplication by a plane-wave. ;\n
!> Assumes that M_q_ is the same size and dimensions as S_q_. ;\n
!> Performs polynomial evaluation internally. ;\n
      subroutine transf_svd_q_to_q_5(svd_r_max,n_svd_r,svd_r_,svd_d_max
     $     ,n_svd_d,svd_d_,n_svd_l,svd_l_,svd_U_d_,svd_s_,svd_V_r_,n_r
     $     ,grid_p_,n_w_,n_A,S_q_,delta_x,delta_y,M_q_)
c$$$      Assumes that M_q_ is the same size and dimensions as S_q_ ;
c$$$      Currently brute force convolution using svd-expansion ;
c$$$      defined via n_svd_r, .. , svd_V_r_ ;
c$$$      Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;
      implicit none
      logical warning_flag
      data warning_flag / .true. /
      integer n_svd_r,n_svd_d,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_r_(0:n_svd_r-1),svd_d_(0:n_svd_d-1)
      real *8 svd_s_(0:n_svd_l-1)
      real *8 svd_U_d_(0:n_svd_d*n_svd_l-1)
      real *8 svd_V_r_(0:n_svd_r*n_svd_l-1)
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_p_(0:n_r-1),delta_x,delta_y
      complex *16 S_q_(0:n_A-1),M_q_(0:n_A-1)
      complex *16, allocatable :: Z_q_(:)
      real *8 pi
      real *8 svd_d_max,svd_d_m,svd_d_c,svd_d(0:0)
      real *8 svd_r_max,svd_r_m,svd_r_c,svd_r(0:0)
      real *8 D_V_r,D_U_d,D_s
      integer I_l
      real *16 R_q,delta,omega,theta
      integer nl,nr,ic,nw
      integer n_w_t             ! positive threshold for overlow. ;
      integer nwc               ! centered nw. ;
      integer nwd               ! displaced nw. ;
      integer nwt               ! periodized displaced nw. ;
      integer ict               ! lookup index for nwt. ;
      logical flag_ic0_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_ict_overflow ! notes whether or not S_q_ coefficient should be set to 0. ;
      complex *16 C_q,C_w
      complex *16, allocatable :: C_w_(:)
      real *8, allocatable :: U_d_(:)
      real *8, allocatable :: V_r_(:)
      pi = 4.0*atan(1.0)
      allocate(Z_q_(0:n_A-1))
      allocate(U_d_(0:n_svd_l-1))
      svd_d_m = svd_d_max / 2.0
      svd_d_c = svd_d_m
      delta = dsqrt(delta_x**2 + delta_y**2)
      omega = atan2(delta_y,delta_x)
      if (delta.gt.svd_d_max .and. warning_flag) then
         write(6,'(A,F6.3,A,F6.3,A,F6.3,A)') 'Warning, delta '
     $        ,delta,'>',svd_d_max,'; ratio = ',delta/svd_d_max,
     $        ' in transf_svd_q_to_q_5.f'
      end if !if (delta.gt.svd_d_max .and. warning_flag) then
      svd_d(0) = (delta - svd_d_m)/svd_d_c
      do nl=0,n_svd_l-1
         call polyval_r8_reverse_0(n_svd_d,svd_U_d_(0+nl*n_svd_d),1
     $        ,svd_d(0),U_d_(nl))
      enddo                     !do nl=0,n_svd_l-1
      allocate(V_r_(0:n_svd_l*n_r-1))
      svd_r_m = svd_r_max / 2.0
      svd_r_c = svd_r_m
      do nr=0,n_r-1
         if (grid_p_(nr).gt.svd_r_max .and. warning_flag) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)')
     $           'Warning, grid_p_(nr) ',grid_p_(nr),'>',svd_r_max
     $           ,'; ratio = ',grid_p_(nr)/svd_r_max
     $           ,' in transf_svd_q_to_q_5.f'
         end if
         svd_r(0) = (grid_p_(nr) - svd_r_m)/svd_r_c
         do nl=0,n_svd_l-1
            call polyval_r8_reverse_0(n_svd_r,svd_V_r_(0+nl*n_svd_r),1
     $           ,svd_r(0),V_r_(nl+nr*n_svd_l))
         enddo !do nl=0,n_svd_l-1         
      enddo !do nr=0,n_r-1
      allocate(C_w_(0:n_svd_l-1))
      ic=0
      do nr=0,n_r-1
         do nl=0,n_svd_l-1
            theta = svd_l_(nl)*(pi/2 - omega)
            C_w = cmplx( +cos(theta) , -sin(theta) )
            D_V_r = V_r_(nl+nr*n_svd_l)
            D_U_d = U_d_(nl)
            D_s = svd_s_(nl)
            C_w_(nl) = (D_U_d * D_s * D_V_r) * C_w
         enddo !do nl=0,n_svd_l-1
         do nw=0,n_w_(nr)-1
            Z_q_(ic) = cmplx( 0.0 , 0.0 )
            n_w_t = floor(1.0d0*n_w_(nr)/2.0d0)
            do nl=0,n_svd_l-1 
               I_l = svd_l_(nl)
               C_q = C_w_(nl)
               nwc = nw
               if (nwc.ge.n_w_t) then
                  nwc = nwc - n_w_(nr)
               end if !if (nwc.ge.n_w_t) then
               if (abs(nwc).lt.n_w_t) then
                  flag_ic0_overflow = .false.
               else
                  flag_ic0_overflow = .true.
               end if !if (abs(nwc).lt.n_w_t) then
               nwc = nw
               if (nwc.ge.n_w_t) then
                  nwc = nwc - n_w_(nr)
               end if           !if (nwc.ge.n_w_t) then
               flag_ict_overflow = .false.
               nwd = nwc + I_l
               if (abs(nwd).lt.n_w_t) then
                  call periodize_i(nwd,0,n_w_(nr),nwt)
               else
                  nwt = 0
                  flag_ict_overflow = .true.
               end if           !if (abs(nwd).lt.n_w_t) then
               ict = ic-nw+nwt
               if ((flag_ic0_overflow.eqv..false.) .and.
     $              (flag_ict_overflow.eqv..false.)) then
                  Z_q_(ic) = Z_q_(ic) + C_q*S_q_(ict)
               end if !if ((flag_ic0_overflow.eqv..false.) .and. (flag_ict_overflow.eqv..false.)) then
            enddo !do nl=0,n_svd_l-1 
            ic = ic + 1
         enddo !do nw=0,n_w_(nr)-1
      enddo !do nr=0,n_r-1
      call cp1_c16(n_A,Z_q_,M_q_)
      deallocate(C_w_)
      deallocate(V_r_)
      deallocate(U_d_)
      deallocate(Z_q_)
      end
!> Doxygen comment: ;\n
!> Applies translation in k_q (i.e., fourier-space bessel) coordinates. ;\n
!> This approximates a multiplication by a plane-wave. ;\n
!> Assumes that M_q_ is the same size and dimensions as S_q_. ;\n
!> Assumes that polynomial evaluation is precomputed. ;\n
      subroutine transf_svd_q_to_q_6(svd_r_max,n_svd_r,svd_r_,svd_d_max
     $     ,n_svd_d,svd_d_,n_svd_l,svd_l_,svd_U_d_,svd_polyval_U_d_
     $     ,svd_s_,svd_V_r_,svd_polyval_V_r_,n_r ,grid_p_,n_w_,n_A,S_q_
     $     ,delta_x,delta_y ,M_q_)
c$$$      Assumes that M_q_ is the same size and dimensions as S_q_ ;
c$$$      Currently brute force convolution using svd-expansion ;
c$$$      defined via n_svd_r, .. , svd_V_r_ ;
c$$$      Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;
      implicit none
      logical warning_flag
      data warning_flag / .true. /
      integer n_svd_r,n_svd_d,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_r_(0:n_svd_r-1),svd_d_(0:n_svd_d-1)
      real *8 svd_s_(0:n_svd_l-1)
      real *8 svd_U_d_(0:n_svd_d*n_svd_l-1)
      real *8 svd_polyval_U_d_(0:n_svd_l-1)
      real *8 svd_V_r_(0:n_svd_r*n_svd_l-1)
      real *8 svd_polyval_V_r_(0:n_svd_l*n_r-1)
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_p_(0:n_r-1),delta_x,delta_y
      complex *16 S_q_(0:n_A-1),M_q_(0:n_A-1)
      complex *16, allocatable :: Z_q_(:)
      real *8 pi
      real *8 svd_d_max,svd_d_m,svd_d_c,svd_d(0:0)
      real *8 svd_r_max,svd_r_m,svd_r_c,svd_r(0:0)
      real *8 D_V_r,D_U_d,D_s
      integer I_l
      real *16 R_q,delta,omega,theta
      integer nl,nr,ic,nw
      integer n_w_t             ! positive threshold for overlow. ;
      integer nwc               ! centered nw. ;
      integer nwd               ! displaced nw. ;
      integer nwt               ! periodized displaced nw. ;
      integer ict               ! lookup index for nwt. ;
      logical flag_ic0_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_ict_overflow ! notes whether or not S_q_ coefficient should be set to 0. ;
      complex *16 C_q,C_w
      complex *16, allocatable :: C_w_(:)
c$$$      real *8, allocatable :: U_d_(:)
c$$$      real *8, allocatable :: V_r_(:)
      pi = 4.0*atan(1.0)
      allocate(Z_q_(0:n_A-1))
c$$$      allocate(U_d_(0:n_svd_l-1))
      svd_d_m = svd_d_max / 2.0
      svd_d_c = svd_d_m
      delta = dsqrt(delta_x**2 + delta_y**2)
      omega = atan2(delta_y,delta_x)
      if (delta.gt.svd_d_max .and. warning_flag) then
         write(6,'(A,F6.3,A,F6.3,A,F6.3,A)') 'Warning, delta '
     $        ,delta,'>',svd_d_max,'; ratio = ',delta/svd_d_max,
     $        ' in transf_svd_q_to_q_6.f'
      end if !if (delta.gt.svd_d_max .and. warning_flag) then
      svd_d(0) = (delta - svd_d_m)/svd_d_c
c$$$      do nl=0,n_svd_l-1
c$$$         call polyval_r8_reverse_0(n_svd_d,svd_U_d_(0+nl*n_svd_d),1
c$$$     $        ,svd_d(0),U_d_(nl))
c$$$      enddo                     !do nl=0,n_svd_l-1
c$$$      allocate(V_r_(0:n_svd_l*n_r-1))
      svd_r_m = svd_r_max / 2.0
      svd_r_c = svd_r_m
      do nr=0,n_r-1
         if (grid_p_(nr).gt.svd_r_max .and. warning_flag) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)')
     $           'Warning, grid_p_(nr) ',grid_p_(nr),'>',svd_r_max
     $           ,'; ratio = ',grid_p_(nr)/svd_r_max
     $           ,' in transf_svd_q_to_q_6.f'
         end if
         svd_r(0) = (grid_p_(nr) - svd_r_m)/svd_r_c
c$$$         do nl=0,n_svd_l-1
c$$$            call polyval_r8_reverse_0(n_svd_r,svd_V_r_(0+nl*n_svd_r),1
c$$$     $           ,svd_r(0),V_r_(nl+nr*n_svd_l))
c$$$         enddo !do nl=0,n_svd_l-1         
      enddo !do nr=0,n_r-1
      allocate(C_w_(0:n_svd_l-1))
      ic=0
      do nr=0,n_r-1
         do nl=0,n_svd_l-1
            theta = svd_l_(nl)*(pi/2 - omega)
            C_w = cmplx( +cos(theta) , -sin(theta) )
            D_V_r = svd_polyval_V_r_(nl+nr*n_svd_l)
            D_U_d = svd_polyval_U_d_(nl)
            D_s = svd_s_(nl)
            C_w_(nl) = (D_U_d * D_s * D_V_r) * C_w
         enddo !do nl=0,n_svd_l-1
         do nw=0,n_w_(nr)-1
            n_w_t = floor(1.0d0*n_w_(nr)/2.0d0)
            Z_q_(ic) = cmplx( 0.0 , 0.0 )
            do nl=0,n_svd_l-1 
               I_l = svd_l_(nl)
               C_q = C_w_(nl)
               nwc = nw
               if (nwc.ge.n_w_t) then
                  nwc = nwc - n_w_(nr)
               end if !if (nwc.ge.n_w_t) then
               if (abs(nwc).lt.n_w_t) then
                  flag_ic0_overflow = .false.
               else
                  flag_ic0_overflow = .true.
               end if !if (abs(nwc).lt.n_w_t) then
               nwc = nw
               if (nwc.ge.n_w_t) then
                  nwc = nwc - n_w_(nr)
               end if           !if (nwc.ge.n_w_t) then
               flag_ict_overflow = .false.
               nwd = nwc + I_l
               if (abs(nwd).lt.n_w_t) then
                  call periodize_i(nwd,0,n_w_(nr),nwt)
               else
                  nwt = 0
                  flag_ict_overflow = .true.
               end if           !if (abs(nwd).lt.n_w_t) then
               ict = ic-nw+nwt
               if ((flag_ic0_overflow.eqv..false.) .and.
     $              (flag_ict_overflow.eqv..false.)) then
                  Z_q_(ic) = Z_q_(ic) + C_q*S_q_(ict)
               end if !if ((flag_ic0_overflow.eqv..false.) .and. (flag_ict_overflow.eqv..false.)) then
            enddo !do nl=0,n_svd_l-1 
            ic = ic + 1
         enddo !do nw=0,n_w_(nr)-1
      enddo !do nr=0,n_r-1
      call cp1_c16(n_A,Z_q_,M_q_)
      deallocate(C_w_)
c$$$      deallocate(V_r_)
c$$$      deallocate(U_d_)
      deallocate(Z_q_)
      end
!> Doxygen comment: ;\n
!> Applies rotation in ?_c (i.e., cartesian) coordinates. ;\n
!> This uses linear interpolation. ;\n
!> Note that we flank the rotation by a recenter (and decenter) operation. ;\n
!> i.e., our origin is in the middle of the picture. ;\n
!> Assumes that M_c_ is the same size and dimensions as S_c_. ;\n
      subroutine rotate_c_to_c(n_x,max_x_c,n_y,max_y_c,S_c_,gamma
     $     ,M_c_)
c$$$      Assumes that M_c_ is the same size and dimensions as S_c_
c$$$      Rotates around (0,0)
c$$$      Does not periodize boundary
      implicit none
      integer n_x,n_y
      real *8 max_x_c,max_y_c,gamma
      complex *16 S_c_(0:n_x*n_y-1),M_c_(0:n_x*n_y-1)
      complex *16, allocatable :: T_c_(:)
      complex *16, allocatable :: N_c_(:)
      real *8 pi
      integer nx,ny
      real *8 X_c,Y_c,R_c,W_c
      complex *16 C_c
      allocate(T_c_(0:n_x*n_y-1))
      allocate(N_c_(0:n_x*n_y-1))
      call recenter_c16(n_x,n_y,S_c_,T_c_)
      pi = 4.0*atan(1.0)
      do ny=0,n_y-1
         do nx=0,n_x-1
            X_c = 0.0d0 + nx*max_x_c/n_x - max_x_c/2.0
            Y_c = 0.0d0 + ny*max_y_c/n_y - max_y_c/2.0
            R_c = dsqrt(X_c**2 + Y_c**2)
            W_c = atan2(Y_c,X_c) - gamma
            X_c = R_c*cos(W_c)
            Y_c = R_c*sin(W_c)
            X_c = max(0.0d0,min(max_x_c,X_c + max_x_c/2.0))
            Y_c = max(0.0d0,min(max_y_c,Y_c + max_y_c/2.0))
c$$$            call periodize_r8(X_c,0.0d0,max_x_c-d_x_c,X_c)
c$$$            call periodize_r8(Y_c,0.0d0,max_y_c-d_y_c,Y_c)
            call interp2_c16(n_x,0.0d0,max_x_c,n_y,0.0d0,max_y_c,T_c_
     $           ,X_c,Y_c,C_c)
            N_c_(nx+ny*n_x) = C_c
         enddo
      enddo
      call decenter_c16(n_x,n_y,N_c_,M_c_)
      deallocate(N_c_)
      deallocate(T_c_)      
      end
!> Doxygen comment: ;\n
!> Applies rotation in ?_p (i.e., polar) coordinates. ;\n
!> This uses linear interpolation. ;\n
!> Assumes that M_p_ is the same size and dimensions as S_p_. ;\n
      subroutine rotate_p_to_p(n_r,n_w_,n_A,S_p_,gamma,M_p_)
c$$$      Assumes that M_p_ is the same size and dimensions as S_p_
      implicit none
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 gamma
      complex *16 S_p_(0:n_A-1),M_p_(0:n_A-1)
      complex *16, allocatable :: Z_p_(:)
      real *8 pi
      integer nr,ic,icstart,nw,nt_pre,nt_pos
      real *8 W_c,W_pre,W_pos,A,B,alpha,beta
      complex *16 C_p
      allocate(Z_p_(0:n_A-1))
      pi = 4.0*atan(1.0)
      ic=0
      icstart=0
      do nr=0,n_r-1         
         do nw=0,n_w_(nr)-1
            W_c = 0.0 + nw*(2*pi)/(n_w_(nr)) - gamma
            call periodize_r8(W_c,0.0d0,2.0*pi,W_c)
            nt_pre = floor(W_c*n_w_(nr)/(2*pi))
            nt_pos = ceiling(W_c*n_w_(nr)/(2*pi))
            if (nt_pos.ge.n_w_(nr)) then
               nt_pos = nt_pos - n_w_(nr)
            end if
            W_pre = 0.0 + nt_pre*(2*pi)/n_w_(nr)
            W_pos = 0.0 + nt_pos*(2*pi)/n_w_(nr)
            A = dabs(W_c-W_pre)
            B = dabs(W_pos-W_c)
            if (A+B.le.0.0) then
               C_p = S_p_(icstart + nt_pre)
            else
               alpha = A/(A+B)
               beta = B/(A+B)
               C_p = beta*S_p_(icstart + nt_pre) + alpha*S_p_(icstart +
     $              nt_pos)
            end if
            Z_p_(ic) = C_p
            ic = ic + 1
         enddo
         icstart = icstart + n_w_(nr)
      enddo
      call cp1_c16(n_A,Z_p_,M_p_)
      deallocate(Z_p_)
      end
!> Doxygen comment: ;\n
!> Applies rotation in ?_p (i.e., polar) coordinates. ;\n
!> This uses lagrange interpolation with n_q=6 nodes. ;\n
!> Assumes that M_p_ is the same size and dimensions as S_p_. ;\n
      subroutine rotate_p2p_l6(n_r,n_w_,n_A,S_p_,gamma,M_p_)
c$$$      Assumes that M_p_ is the same size and dimensions as S_p_
c$$$      uses n_q==6 nodes.
      implicit none
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 gamma
      complex *16 S_p_(0:n_A-1),M_p_(0:n_A-1)
      complex *16, allocatable :: Z_p_(:)
      real *8 pi,pi2i
      integer nr,ic,icstart,nw,nt_pre,nt_pos
      real *8 W_c,W_pre,W_pos,A,B,alpha,beta
      integer n_q,nq
      parameter(n_q=6)
      integer *4 nt_(0:n_q-1)
      complex *16 F_(0:n_q-1)
      real *8 q_(0:n_q-1)
      real *8 x_(0:n_q-1)
      real *8 d_(0:n_q-1)
      real *8 e_(0:n_q-1)
      real *8 x_tmp
      complex *16 C_p
      allocate(Z_p_(0:n_A-1))
      x_(0) = 0.0d0
      x_(1) = 1.0d0
      x_(2) = 2.0d0
      x_(3) = 3.0d0
      x_(4) = 4.0d0
      x_(5) = 5.0d0
      d_(0) = ((x_(0)-x_(1))*(x_(0)-x_(2)) *(x_(0)-x_(3))*(x_(0)-x_(4))
     $     *(x_(0)-x_(5)))
      d_(1) = ((x_(1)-x_(0))*(x_(1)-x_(2)) *(x_(1)-x_(3))*(x_(1)-x_(4))
     $     *(x_(1)-x_(5)))
      d_(2) = ((x_(2)-x_(0))*(x_(2)-x_(1)) *(x_(2)-x_(3))*(x_(2)-x_(4))
     $     *(x_(2)-x_(5)))
      d_(3) = ((x_(3)-x_(0))*(x_(3)-x_(1)) *(x_(3)-x_(2))*(x_(3)-x_(4))
     $     *(x_(3)-x_(5)))
      d_(4) = ((x_(4)-x_(0))*(x_(4)-x_(1)) *(x_(4)-x_(2))*(x_(4)-x_(3))
     $     *(x_(4)-x_(5)))
      d_(5) = ((x_(5)-x_(0))*(x_(5)-x_(1)) *(x_(5)-x_(2))*(x_(5)-x_(3))
     $     *(x_(5)-x_(4)))
      e_(0) = 1.0d0/d_(0)
      e_(1) = 1.0d0/d_(1)
      e_(2) = 1.0d0/d_(2)
      e_(3) = 1.0d0/d_(3)
      e_(4) = 1.0d0/d_(4)
      e_(5) = 1.0d0/d_(5)
      pi = 4.0*atan(1.0)
      pi2i = 1.0d0/(2.0d0*pi)
      ic=0
      icstart=0
      do nr=0,n_r-1         
         do nw=0,n_w_(nr)-1
            W_c = 0.0 + nw*(2*pi)/(n_w_(nr)) - gamma
            call periodize_r8(W_c,0.0d0,2.0*pi,W_c)
            nt_pre = floor(W_c*n_w_(nr)*pi2i)
            nt_(0) = nt_pre - ceiling(n_q*0.5d0) + 1 + 0
            nt_(1) = nt_pre - ceiling(n_q*0.5d0) + 1 + 1
            nt_(2) = nt_pre - ceiling(n_q*0.5d0) + 1 + 2
            nt_(3) = nt_pre - ceiling(n_q*0.5d0) + 1 + 3
            nt_(4) = nt_pre - ceiling(n_q*0.5d0) + 1 + 4
            nt_(5) = nt_pre - ceiling(n_q*0.5d0) + 1 + 5
            call periodize_i(nt_(0),0,n_w_(nr))
            call periodize_i(nt_(1),0,n_w_(nr))
            call periodize_i(nt_(2),0,n_w_(nr))
            call periodize_i(nt_(3),0,n_w_(nr))
            call periodize_i(nt_(4),0,n_w_(nr))
            call periodize_i(nt_(5),0,n_w_(nr))
            F_(0) = S_p_(icstart + nt_(0))
            F_(1) = S_p_(icstart + nt_(1))
            F_(2) = S_p_(icstart + nt_(2))
            F_(3) = S_p_(icstart + nt_(3))
            F_(4) = S_p_(icstart + nt_(4))
            F_(5) = S_p_(icstart + nt_(5))
            x_tmp = W_c*n_w_(nr)*pi2i - (nt_pre - ceiling(n_q*0.5d0) + 1
     $           + 0)
            q_(0) = ((x_tmp-x_(1))*(x_tmp-x_(2))*(x_tmp-x_(3))*(x_tmp
     $           -x_(4))*(x_tmp-x_(5)))*e_(0)
            q_(1) = ((x_tmp-x_(0))*(x_tmp-x_(2))*(x_tmp-x_(3))*(x_tmp
     $           -x_(4))*(x_tmp-x_(5)))*e_(1)
            q_(2) = ((x_tmp-x_(0))*(x_tmp-x_(1))*(x_tmp-x_(3))*(x_tmp
     $           -x_(4))*(x_tmp-x_(5)))*e_(2)
            q_(3) = ((x_tmp-x_(0))*(x_tmp-x_(1))*(x_tmp-x_(2))*(x_tmp
     $           -x_(4))*(x_tmp-x_(5)))*e_(3)
            q_(4) = ((x_tmp-x_(0))*(x_tmp-x_(1))*(x_tmp-x_(2))*(x_tmp
     $           -x_(3))*(x_tmp-x_(5)))*e_(4)
            q_(5) = ((x_tmp-x_(0))*(x_tmp-x_(1))*(x_tmp-x_(2))*(x_tmp
     $           -x_(3))*(x_tmp-x_(4)))*e_(5)
            Z_p_(ic) = F_(0)*q_(0) + F_(1)*q_(1) + F_(2)*q_(2) + F_(3)
     $           *q_(3) + F_(4)*q_(4) + F_(5)*q_(5)
            ic = ic + 1
         enddo
         icstart = icstart + n_w_(nr)
      enddo
      call cp1_c16(n_A,Z_p_,M_p_)
      deallocate(Z_p_)
      end
!> Doxygen comment: ;\n
!> Applies rotation in ?_p (i.e., polar) coordinates. ;\n
!> This uses fourier interpolation. ;\n
!> Assumes that M_p_ is the same size and dimensions as S_p_. ;\n
      subroutine rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_
     $     ,n_A,fftw_in1_,fftw_out_,S_p_,gamma,M_p_)
c$$$      Assumes that M_p_ is the same size and dimensions as S_p_ ;
c$$$      Also assumes that fftw plans are passed in. ;
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 gamma
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      complex *16 fftw_in1_(0:n_A-1),fftw_out_(0:n_A-1)
      complex *16 S_p_(0:n_A-1),M_p_(0:n_A-1)
      complex *16, allocatable :: C_(:)
      complex *16 C
      real *8 pi;
      integer nr,ic,icstart,nw,n_w_max,nq,q;
      real *8 al2_c16_f
      real *8 l2_pre,l2_pos

      ic = 0
      do nr=0,n_r-1
         ic = ic + n_w_(nr)
      enddo !do nr=0,n_r-1
      if (ic.ne.n_A) then
         write(6,'(2(A,I0))') ' Warning, n_A: ' , n_A , ' ic: ' , ic
      end if !if (ic.ne.n_A) then

      n_w_max = n_w_(n_r-1)
      allocate(C_(0:n_w_max-1));
      do nw=0,n_w_max-1
         q = nw - n_w_max/2
         C = cmplx( +cos(q*gamma) , -sin(q*gamma) )
         C_(nw) = C
      enddo !do nw=0,n_w_max-1

      ic=0
      do nr=0,n_r-1
         if (verbose.gt.0) then
            write(6,'(2(A,I0))') ' nr: ' , nr , ' n_w_(nr): ' , n_w_(nr)
         end if !if (verbose.gt.0) then
         if (n_w_(nr).gt.0) then            
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling cp1_c16: '
            end if !if (verbose.gt.2) then
            call cp1_c16(n_w_(nr),S_p_(ic),fftw_in1_(ic))
            if (verbose.gt.0) then
               write(6,'(A,F16.8)') ' fftw_in1_ l2: ' ,
     $              al2_c16_f(n_w_(nr),fftw_in1_(ic))
            end if !if (verbose.gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; executing fftw_plan: '
            end if !if (verbose.gt.2) then
            call dfftw_execute_(fftw_plan_frwd_(nr))
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling affine_c16: '
            end if !if (verbose.gt.2) then
            call af1_c16(n_w_(nr),1.0d0*cmplx(1.0d0/dsqrt(1.0d0
     $           *n_w_(nr))),1.0d0*cmplx(0.0d0),fftw_out_(ic)
     $           ,fftw_out_(ic))
            if (verbose.gt.0) then
               write(6,'(A,F16.8)') ' fftw_out_ l2: ' ,
     $              al2_c16_f(n_w_(nr),fftw_out_(ic))
            end if !if (verbose.gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; applying rotation: '
            end if !if (verbose.gt.2) then
            do nq=0,n_w_(nr)-1
               q = nq
               if (q.gt.n_w_(nr)/2-1) then 
                  q = q - n_w_(nr)
               end if !if (q.ge.n_w_(nr)/2-1) then 
               C = C_(n_w_max/2 + q)
               fftw_out_(ic + nq) = fftw_out_(ic + nq) * C
            enddo !do nq=0,n_w_(nr)-1
            if (verbose.gt.0) then
               write(6,'(A,F16.8)') ' fftw_out_ l2: ' ,
     $              al2_c16_f(n_w_(nr),fftw_out_(ic))
            end if !if (verbose.gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; executing fftw_plan: '
            end if !if (verbose.gt.2) then
            call dfftw_execute_(fftw_plan_back_(nr))
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling affine_c16: '
            end if !if (verbose.gt.2) then
            call af1_c16(n_w_(nr),1.0d0*cmplx(1.0d0/dsqrt(1.0d0
     $           *n_w_(nr))),1.0d0*cmplx(0.0d0),fftw_in1_(ic)
     $           ,fftw_in1_(ic))
            if (verbose.gt.0) then
               write(6,'(A,F16.8)') ' fftw_in1_ l2: ' ,
     $              al2_c16_f(n_w_(nr),fftw_in1_(ic))
            end if !if (verbose.gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling cp1_c16: '
            end if !if (verbose.gt.2) then
            call cp1_c16(n_w_(nr),fftw_in1_(ic),M_p_(ic))
            if (verbose.gt.2) then
               write(6,*) '% % setting ic ',ic,' to ic ',ic + n_w_(nr)
            end if !if (verbose.gt.2) then
            ic = ic + n_w_(nr)
         end if !if (n_w_(nr).gt.0) then
      enddo !do nr=0,n_r-1
      
      deallocate(C_)

      end

c$$$      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;

      subroutine rotate_p2p_fz(n_r,n_w_,n_A,S_p_,gamma,M_p_)
c$$$      Assumes that M_p_ is the same size and dimensions as S_p_ ;
c$$$      Generates fftw plans internally. ;
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      data verbose / 0 /
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 gamma
      integer *8, allocatable :: fftw_plan_frwd_(:)
      integer *8, allocatable :: fftw_plan_back_(:)
      complex *16, allocatable :: fftw_in1_(:)
      complex *16, allocatable :: fftw_out_(:)
      complex *16 S_p_(0:n_A-1),M_p_(0:n_A-1)
      complex *16, allocatable :: C_(:)
      complex *16 C
      real *8 pi;
      integer na,nr,ic,icstart,nw,n_w_max,nq,q;
      real *8 al2_c16_f
      real *8 l2_pre,l2_pos

      if (verbose.gt.0) then
         write(6,'(A)') ' [entering rotate_p2p_fz] '
      end if !if (verbose.gt.0) then

      na = 0
      do nr=0,n_r-1
         na = na + n_w_(nr)
      enddo !do nr=0,n_r-1
      if (na.ne.n_A) then
         write(6,'(2(A,I0))') ' Warning, n_A: ' , n_A , ' na: ' , na
      end if !if (na.ne.n_A) then

      if (verbose.gt.1) then
         write(6,'(A)') ' Generating fftw_plans for local use'
      end if !if (verbose.gt.1) then
      allocate(fftw_plan_frwd_(0:n_r-1))
      allocate(fftw_plan_back_(0:n_r-1))
      allocate(fftw_in1_(0:n_A-1))
      allocate(fftw_out_(0:n_A-1))
      na = 0
      do nr=0,n_r-1
         call dfftw_plan_dft_1d_(fftw_plan_frwd_(nr),n_w_(nr)
     $        ,fftw_in1_(na),fftw_out_(na),FFTW_FORWARD,FFTW_MEASURE) 
         call dfftw_plan_dft_1d_(fftw_plan_back_(nr),n_w_(nr)
     $        ,fftw_out_(na),fftw_in1_(na),FFTW_BACKWARD,FFTW_MEASURE) 
         na = na + n_w_(nr)
      enddo !do nr=0,n_r-1

      if (verbose.gt.1) then
         write(6,'(A)') ' generating complex exponentials '
      end if !if (verbose.gt.1) then
      n_w_max = n_w_(n_r-1)
      allocate(C_(0:n_w_max-1));
      do nw=0,n_w_max-1
         q = nw - n_w_max/2
         C = cmplx( +cos(q*gamma) , -sin(q*gamma) )
         C_(nw) = C
      enddo !do nw=0,n_w_max-1

      ic=0
      do nr=0,n_r-1
         if (verbose.gt.0) then
            write(6,'(2(A,I0))') ' nr: ' , nr , ' n_w_(nr): ' , n_w_(nr)
         end if !if (verbose.gt.0) then
         if (n_w_(nr).gt.0) then            
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling cp1_c16: '
            end if !if (verbose.gt.2) then
            call cp1_c16(n_w_(nr),S_p_(ic),fftw_in1_(ic))
            if (verbose.gt.0) then
               write(6,'(A,F16.8)') ' fftw_in1_ l2: ' ,
     $              al2_c16_f(n_w_(nr),fftw_in1_(ic))
            end if !if (verbose.gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; executing fftw_plan: '
            end if !if (verbose.gt.2) then
            call dfftw_execute_(fftw_plan_frwd_(nr))
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling affine_c16: '
            end if !if (verbose.gt.2) then
            call af1_c16(n_w_(nr),1.0d0*cmplx(1.0d0/dsqrt(1.0d0
     $           *n_w_(nr))),1.0d0*cmplx(0.0d0),fftw_out_(ic)
     $           ,fftw_out_(ic))
            if (verbose.gt.0) then
               write(6,'(A,F16.8)') ' fftw_out_ l2: ' ,
     $              al2_c16_f(n_w_(nr),fftw_out_(ic))
            end if !if (verbose.gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; applying rotation: '
            end if !if (verbose.gt.2) then
            do nq=0,n_w_(nr)-1
               q = nq
               if (q.gt.n_w_(nr)/2-1) then 
                  q = q - n_w_(nr)
               end if !if (q.ge.n_w_(nr)/2-1) then 
               C = C_(n_w_max/2 + q)
               fftw_out_(ic + nq) = fftw_out_(ic + nq) * C
            enddo !do nq=0,n_w_(nr)-1
            if (verbose.gt.0) then
               write(6,'(A,F16.8)') ' fftw_out_ l2: ' ,
     $              al2_c16_f(n_w_(nr),fftw_out_(ic))
            end if !if (verbose.gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; executing fftw_plan: '
            end if !if (verbose.gt.2) then
            call dfftw_execute_(fftw_plan_back_(nr))
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling affine_c16: '
            end if !if (verbose.gt.2) then
            call af1_c16(n_w_(nr),1.0d0*cmplx(1.0d0/dsqrt(1.0d0
     $           *n_w_(nr))),1.0d0*cmplx(0.0d0),fftw_in1_(ic)
     $           ,fftw_in1_(ic))
            if (verbose.gt.0) then
               write(6,'(A,F16.8)') ' fftw_in1_ l2: ' ,
     $              al2_c16_f(n_w_(nr),fftw_in1_(ic))
            end if !if (verbose.gt.0) then
            if (verbose.gt.2) then
               write(6,*) '% % nr: ',nr,'; calling cp1_c16: '
            end if !if (verbose.gt.2) then
            call cp1_c16(n_w_(nr),fftw_in1_(ic),M_p_(ic))
            if (verbose.gt.2) then
               write(6,*) '% % setting ic ',ic,' to ic ',ic + n_w_(nr)
            end if !if (verbose.gt.2) then
            ic = ic + n_w_(nr)
         end if !if (n_w_(nr).gt.0) then
      enddo !do nr=0,n_r-1
      
      deallocate(C_)

      if (verbose.gt.1) then
         write(6,'(A)') ' Destroying fftw_plans for local use.'
      end if !if (verbose.gt.1) then
      do nr=0,n_r-1
         call dfftw_destroy_plan(fftw_plan_frwd_(nr))
         call dfftw_destroy_plan(fftw_plan_back_(nr))
      enddo !do nr=0,n_r-1
      deallocate(fftw_plan_frwd_)
      deallocate(fftw_plan_back_)
      deallocate(fftw_in1_)
      deallocate(fftw_out_)

      if (verbose.gt.0) then
         write(6,'(A)') ' [finished rotate_p2p_fz] '
      end if !if (verbose.gt.0) then

      end

c$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
c$$$% Notes: test with the following in ti8_dr.f: ;
c$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
c$$$
c$$$      ns=0
c$$$      nS_sample = I_S_sample_(ns)
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$      call cp1_c16(n_A,S_k_p__(nS_sample*n_A),T0_k_p_)
c$$$      MDA_n_d = 1
c$$$      MDA_d_(0) = n_A
c$$$      write(MDA_string,'(A)') './dir_mda/tmp_T0_.mda'
c$$$      call MDA_write_c16(MDA_n_d,MDA_d_,T0_k_p_,MDA_string)
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$      gamma_z = pi/3;
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$      call rotate_p_to_p(n_r,n_w_,n_A,T0_k_p_,+gamma_z,T1_k_p_)
c$$$      MDA_n_d = 1
c$$$      MDA_d_(0) = n_A
c$$$      write(MDA_string,'(A)') './dir_mda/tmp_T1_.mda'
c$$$      call MDA_write_c16(MDA_n_d,MDA_d_,T1_k_p_,MDA_string)
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$      call rotate_p2p_l6(n_r,n_w_,n_A,T0_k_p_,+gamma_z,T2_k_p_)
c$$$      MDA_n_d = 1
c$$$      MDA_d_(0) = n_A
c$$$      write(MDA_string,'(A)') './dir_mda/tmp_T2_.mda'
c$$$      call MDA_write_c16(MDA_n_d,MDA_d_,T2_k_p_,MDA_string)
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$      call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_
c$$$     $     ,n_A,fftw_in1_,fftw_out_,T0_k_p_,+gamma_z,T3_k_p_)
c$$$      MDA_n_d = 1
c$$$      MDA_d_(0) = n_A
c$$$      write(MDA_string,'(A)') './dir_mda/tmp_T3_.mda'
c$$$      call MDA_write_c16(MDA_n_d,MDA_d_,T3_k_p_,MDA_string)
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$      call rotate_p_to_p(n_r,n_w_,n_A,T1_k_p_,-gamma_z,T0_k_p_)
c$$$      MDA_n_d = 1
c$$$      MDA_d_(0) = n_A
c$$$      write(MDA_string,'(A)') './dir_mda/tmp_U1_.mda'
c$$$      call MDA_write_c16(MDA_n_d,MDA_d_,T0_k_p_,MDA_string)
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$      call rotate_p2p_l6(n_r,n_w_,n_A,T2_k_p_,-gamma_z,T0_k_p_)
c$$$      MDA_n_d = 1
c$$$      MDA_d_(0) = n_A
c$$$      write(MDA_string,'(A)') './dir_mda/tmp_U2_.mda'
c$$$      call MDA_write_c16(MDA_n_d,MDA_d_,T0_k_p_,MDA_string)
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$      call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_
c$$$     $     ,n_A,fftw_in1_,fftw_out_,T3_k_p_,-gamma_z,T0_k_p_)
c$$$      MDA_n_d = 1
c$$$      MDA_d_(0) = n_A
c$$$      write(MDA_string,'(A)') './dir_mda/tmp_U3_.mda'
c$$$      call MDA_write_c16(MDA_n_d,MDA_d_,T0_k_p_,MDA_string)
c$$$c$$$      %%%%%%%%%%%%%%%%
c$$$
c$$$      MDA_n_d = 1
c$$$      MDA_d_(0) = n_r
c$$$      write(MDA_string,'(A)') './dir_mda/tmp_n_w_.mda'
c$$$      call MDA_write_i4(MDA_n_d,MDA_d_,n_w_,MDA_string)
c$$$      goto 10

c$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
c$$$% Notes: along with the following matlab code.; 
c$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
c$$$
c$$$n_w_ = MDA_read_i4('dir_mda/tmp_n_w_.mda'); 
c$$$n_r = length(n_w_); grid_p_ = 1:n_r; n_A = sum(n_w_);
c$$$T0_ = MDA_read_c16('dir_mda/tmp_T0_.mda');
c$$$T1_ = MDA_read_c16('dir_mda/tmp_T1_.mda');
c$$$T2_ = MDA_read_c16('dir_mda/tmp_T2_.mda');
c$$$T3_ = MDA_read_c16('dir_mda/tmp_T3_.mda');
c$$$U1_ = MDA_read_c16('dir_mda/tmp_U1_.mda');
c$$$U2_ = MDA_read_c16('dir_mda/tmp_U2_.mda');
c$$$U3_ = MDA_read_c16('dir_mda/tmp_U3_.mda');
c$$$
c$$$disp_flag=0;
c$$$if disp_flag;
c$$$%%%%%%%%%%%%%%%%;
c$$$figure(1);
c$$$pcols = 4;
c$$$np=1;
c$$$%%%%%%%%%%%%%%%%;
c$$$subplot(2,pcols,np+0*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,real(T0_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('real(T0_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$subplot(2,pcols,np+1*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,imag(T0_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('imag(T0_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$np=np+1;
c$$$%%%%%%%%%%%%%%%%;
c$$$subplot(2,pcols,np+0*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,real(T1_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('real(T1_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$subplot(2,pcols,np+1*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,imag(T1_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('imag(T1_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$np=np+1;
c$$$%%%%%%%%%%%%%%%%;
c$$$subplot(2,pcols,np+0*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,real(T2_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('real(T2_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$subplot(2,pcols,np+1*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,imag(T2_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('imag(T2_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$np=np+1;
c$$$%%%%%%%%%%%%%%%%;
c$$$subplot(2,pcols,np+0*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,real(T3_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('real(T3_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$subplot(2,pcols,np+1*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,imag(T3_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('imag(T3_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$np=np+1;
c$$$%%%%%%%%%%%%%%%%;
c$$$end;%if disp_flag;
c$$$
c$$$E1_ = T0_ - U1_;
c$$$E2_ = T0_ - U2_;
c$$$E3_ = T0_ - U3_;
c$$$
c$$$disp_flag=1;
c$$$if disp_flag;
c$$$%%%%%%%%%%%%%%%%;
c$$$figure(1);
c$$$pcols = 3;
c$$$np=1;
c$$$%%%%%%%%%%%%%%%%;
c$$$subplot(2,pcols,np+0*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,real(E1_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('real(E1_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$subplot(2,pcols,np+1*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,imag(E1_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('imag(E1_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$np=np+1;
c$$$%%%%%%%%%%%%%%%%;
c$$$subplot(2,pcols,np+0*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,real(E2_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('real(E2_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$subplot(2,pcols,np+1*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,imag(E2_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('imag(E2_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$np=np+1;
c$$$%%%%%%%%%%%%%%%%;
c$$$subplot(2,pcols,np+0*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,real(E3_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('real(E3_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$subplot(2,pcols,np+1*pcols); clim = imagesc_p(n_r,grid_p_,n_w_,n_A,imag(E3_),[],colormap(colormap_pm(64)));
c$$$xlim(n_r*[-1,1]);ylim(n_r*[-1,1]);
c$$$title(sprintf('imag(E3_) [%0.5f,%0.5f]',min(clim),max(clim)),'Interpreter','none');
c$$$set(gca,'XTick',[],'YTick',[]); axis square;
c$$$np=np+1;
c$$$%%%%%%%%%%%%%%%%;
c$$$end;%if disp_flag;
!> Doxygen comment: ;\n
!> Applies rotation in ?_p (i.e., polar) coordinates. ;\n
!> This uses fourier interpolation. ;\n
!> Assumes that M_p_ is the same size and dimensions as S_p_. ;\n
!> Only applies to a single ring of the image. ;\n
      subroutine rotate_p2p_fx_single(fftw_plan_frwd,fftw_plan_back,n_w
     $     ,fftw_in1_,fftw_out_,S_p_1_,gamma,M_p_1_)
c$$$  Assumes that M_p_1_ is the same size and dimensions as S_p_1_
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_w
      real *8 gamma
      integer *8 fftw_plan_frwd
      integer *8 fftw_plan_back
      complex *16 fftw_in1_(0:n_w-1),fftw_out_(0:n_w-1)
      complex *16 S_p_1_(0:n_w-1),M_p_1_(0:n_w-1)
      complex *16 C
      real *8 pi
      integer ic,nw,nq,q
      real *8 al2_c16_f
      real *8 l2_pre,l2_pos
      pi = 4.0*atan(1.0)

      if (verbose.gt.0) then
         write(6,'(A)') '[entering rotate_p2p_fx_single]'
      end if !if (verbose.gt.0) then

c$$$      We assume that C_ is preallocated as follows: ;
c$$$      allocate(C_(0:n_w_max-1));
c$$$      do nw=0,n_w_max-1
c$$$         q = nw - n_w_max/2
c$$$         C = cmplx( +cos(q*gamma) , -sin(q*gamma) )
c$$$         C_(nw) = C
c$$$      enddo !do nw=0,n_w_max-1
c$$$      This implies that C_(n_w_max/2 + q) = exp(-i*q*gamma)

      ic = 0
      if (n_w.gt.0) then            
         call cp1_c16(n_w,S_p_1_(ic),fftw_in1_(ic))
         if (verbose.gt.0) then
            write(6,'(A,F16.8)') ' fftw_in1_ l2: ' ,
     $           al2_c16_f(n_w,fftw_in1_(ic))
         end if                 !if (verbose.gt.0) then
         call dfftw_execute_(fftw_plan_frwd)
         call af1_c16(n_w,1.0d0*cmplx(1.0d0/dsqrt(1.0d0
     $        *n_w)),1.0d0*cmplx(0.0d0),fftw_out_(ic)
     $        ,fftw_out_(ic))
         if (verbose.gt.0) then
            write(6,'(A,F16.8)') ' fftw_out_ l2: ' ,
     $           al2_c16_f(n_w,fftw_out_(ic))
         end if                 !if (verbose.gt.0) then
         do nq=0,n_w-1
            q = nq
            if (q.gt.n_w/2-1) then 
               q = q - n_w
            end if              !if (q.ge.n_w/2-1) then 
c$$$            C = C_(n_w_max/2 + q)
            C = cmplx( +cos(q*gamma) , -sin(q*gamma) )
            fftw_out_(ic + nq) = fftw_out_(ic + nq) * C
         enddo                  !do nq=0,n_w-1
         if (verbose.gt.0) then
            write(6,'(A,F16.8)') ' fftw_out_ l2: ' ,
     $           al2_c16_f(n_w,fftw_out_(ic))
         end if                 !if (verbose.gt.0) then
         call dfftw_execute_(fftw_plan_back)
         call af1_c16(n_w,1.0d0*cmplx(1.0d0/dsqrt(1.0d0
     $        *n_w)),1.0d0*cmplx(0.0d0),fftw_in1_(ic)
     $        ,fftw_in1_(ic))
         if (verbose.gt.0) then
            write(6,'(A,F16.8)') ' fftw_in1_ l2: ' ,
     $           al2_c16_f(n_w,fftw_in1_(ic))
         end if                 !if (verbose.gt.0) then
         call cp1_c16(n_w,fftw_in1_(ic),M_p_1_(ic))
         if (verbose.gt.2) then
            write(6,*) '% % setting ic ',ic,' to ic ',ic + n_w
         end if                 !if (verbose.gt.2) then
         ic = ic + n_w
      end if                    !if (n_w.gt.0) then

      if (verbose.gt.0) then
         write(6,'(A)') '[finished rotate_p2p_fx_single]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> Applies rotation in ?_q (i.e., bessel) coordinates. ;\n
!> Assumes that M_q_ is the same size and dimensions as S_q_. ;\n
      subroutine rotate_q_to_q_0(n_r,n_w_,n_A,S_q_,gamma,M_q_)
c$$$      Assumes that M_q_ is the same size and dimensions as S_q_
c$$$      Multiplication performed in place
      implicit none
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 gamma
      complex *16 S_q_(0:n_A-1),M_q_(0:n_A-1)
      real *8 pi
      integer nr,ic,n_w_max,nw,nq,q
      complex *16 C
      complex *16, allocatable :: C_(:)
      pi = 4.0*atan(1.0)

      n_w_max = n_w_(n_r-1)
      allocate(C_(0:n_w_max-1))
      do nw=0,n_w_max-1
         q = nw - n_w_max/2
         C = cmplx( +cos(q*gamma) , -sin(q*gamma) )
         C_(nw) = C
      enddo !do nw=0,n_w_max-1

      ic=0
      do nr=0,n_r-1
         do nq=0,n_w_(nr)-1
            q = nq
            if (q.gt.n_w_(nr)/2-1) then 
               q = q - n_w_(nr)
            end if              !if (q.ge.n_w_(nr)/2-1) then 
            C = C_(n_w_max/2 + q)
            M_q_(ic) = S_q_(ic)*C
            ic = ic + 1
         enddo
      enddo
      deallocate(C_)
      end
!> Doxygen comment: ;\n
!> calculates innerproduct in ?_c (i.e., cartesian) coordinates. ;\n
!> assumes that M_c_ is the same size and dimensions as T_c_. ;\n
!> assumes uniform grid and periodic boundary conditions. ;\n
      subroutine innerproduct_c(n_x,grid_x_c_,n_y,grid_y_c_,T_c_,M_c_
     $     ,C_c)
c$$$      assumes that M_c_ is the same size and dimensions as T_c_
c$$$      assumes uniform grid and periodic boundary conditions
      implicit none
      integer n_x,n_y
      real *8 grid_x_c_(0:n_x-1),grid_y_c_(0:n_y-1)
      complex *16 T_c_(0:n_x*n_y-1),M_c_(0:n_x*n_y-1),C_c,C_T,C_M
      integer nx,ny,nc
      real *8 dx,dy
      C_c = cmplx( 0.0 , 0.0 )
c$$$      C_T = cmplx( 0.0 , 0.0 )
c$$$      C_M = cmplx( 0.0 , 0.0 )
      dx = (grid_x_c_(n_x-1)-grid_x_c_(0))/max(1,n_x-1)
      dy = (grid_y_c_(n_y-1)-grid_y_c_(0))/max(1,n_y-1)
      nc = 0
      do ny=0,n_y-1
         do nx=0,n_x-1
c$$$            nc = nx + ny*n_x
            C_c = C_c + conjg(T_c_(nc))*M_c_(nc)
c$$$            C_T = C_T + conjg(T_c_(nc))*T_c_(nc)
c$$$            C_M = C_M + conjg(M_c_(nc))*M_c_(nc)
            nc = nc+1  
         enddo
      enddo
c$$$      write(6,'(A,2F8.3)') 'C_T: ',C_T*dx*dy
c$$$      write(6,'(A,2F8.3)') 'C_M: ',C_M*dx*dy
c$$$      write(6,'(A,2F8.3)') 'C_c: ',C_c*dx*dy
      C_c = C_c*dx*dy
c$$$      C_c = C_c / (zsqrt(C_T) * zsqrt(C_M))
c$$$      write(6,'(A,2F8.3)') 'C_c: ',C_c
      end      
!> Doxygen comment: ;\n
!> calculates innerproduct in ?_p (i.e., polar) coordinates. ;\n
!> assumes that M_p_ is the same size and dimensions as T_p_. ;\n
!> assumes quasi-uniform polar-grid. ;\n
      subroutine innerproduct_p(n_r,grid_p_,n_w_,n_A,T_p_,M_p_,C_p)
c$$$      assumes that M_p_ is the same size and dimensions as T_p_
c$$$      assumes quasi-uniform polar-grid
      implicit none
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_p_(0:n_r-1)
      complex *16 T_p_(0:n_A-1),M_p_(0:n_A-1),C_p,C_tmp
      real *8 pi
      integer ic,nr,nw
      real *8 R_pos,R_pre,dr,dw,dA
      pi = 4.0*atan(1.0)
      C_p = cmplx( 0.0 , 0.0 )
      ic = 0
      do nr=0,n_r-1
         if (nr.gt.0) then
            R_pre = 0.5*(grid_p_(nr-1) + grid_p_(nr))
         else
            R_pre = grid_p_(0)
         end if
         if (nr.lt.n_r-1) then
            R_pos = 0.5*(grid_p_(nr+1) + grid_p_(nr))
         else
            R_pos = grid_p_(n_r-1)
         end if
         dr = R_pos - R_pre
c$$$         We set the zero-mode to zero
         if (grid_p_(nr).le.0.0d0) then
            dr = 0.0d0
         end if
         dw = 2*pi/(1.0d0*max(1,n_w_(nr)))
         dA = (R_pre*dr + (dr**2)/2)*dw
         C_tmp = cmplx( 0.0 , 0.0 )
         do nw=0,n_w_(nr)-1
            C_tmp = C_tmp + conjg(T_p_(ic))*M_p_(ic)
            ic = ic + 1
         enddo
         C_tmp = C_tmp * dA
         C_p = C_p + C_tmp
      enddo
      end
!> Doxygen comment: ;\n
!> Reorganizes an image in k_q_ (i.e., fourier-space bessel) coordinates ;\n
!> to allow for a subsequent multiplication to perform an innerproduct. ;\n
!> Assumes T_q_ corresponds to bessel-coefficients associated ;\n
!> with quasi-uniform polar-grid. ;\n
!> Thus, the (nr,nw) value of T_q_ is stored at: ;\n
!> T_q_(ic) = T_q_(nw + n_w_csum_(nr)). ;\n
!> Depending on flag_conjg, we write T_q_(ic) or conjg(T_q_(ic)) ;\n
!> to the (nr,nw) element of X_q_, stored at: ;\n
!> X_q_(nr + nw*ld_X). ;\n
!> We assume that X_q_ is large enough to hold all the values of T_q_. ;\n
!> This means X_q_ has to be at least size n_r * n_w_max, ;\n
!> with ld_X .ge. n_r. ;\n
!> We store each column of X_q_ in fft ordering (mode 0 , mode 1 , ... , mode -1) ;\n
!> Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;\n
      subroutine innerproduct_q_stretch_0(n_r,grid_p_,n_w_,n_A,T_q_
     $     ,flag_conjg,ld_X,X_q_)
c$$$      Assumes T_q_ corresponds to bessel-coefficients associated ;
c$$$      with quasi-uniform polar-grid. ;
c$$$      Thus, the (nr,nw) value of T_q_ is stored at: ;
c$$$      T_q_(ic) = T_q_(nw + n_w_csum_(nr)). ;
c$$$      Depending on flag_conjg, we write T_q_(ic) or conjg(T_q_(ic)) ;
c$$$      to the (nr,nw) element of X_q_, stored at: ;
c$$$      X_q_(nr + nw*ld_X). ;
c$$$      We assume that X_q_ is large enough to hold all the values of T_q_. ;
c$$$      This means X_q_ has to be at least size n_r * n_w_max, ;
c$$$      with ld_X .ge. n_r. ;
c$$$      We store each column of X_q_ in fft ordering (mode 0 , mode 1 , ... , mode -1) ;
c$$$      Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_p_(0:n_r-1)
      complex *16 T_q_(0:n_A-1)
      logical flag_conjg
      integer ld_X
      complex *16 X_q_(0:0)
      complex *16 C_q
      real *8 pi
      integer n_w_max,ic,nr,nw,nw_fix,nw_C
      real *8 R_pos,R_pre,dr,dw,dA,dAn,dsqrt_dAn
      integer nq,nk
      integer, allocatable :: n_X_(:)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' % [entering innerproduct_q_stretch_0] n_r '
     $        ,n_r
      end if
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' % n_w_max ',n_w_max
      end if
      if (verbose.gt.2) then
         allocate(n_X_(0:n_r*n_w_max-1))
         call cl1_i4(n_r*n_w_max,n_X_)
      end if !if (verbose.gt.2) then
      C_q = cmplx( 0.0 , 0.0 )
      ic = 0
      do nr=0,n_r-1
         if (nr.gt.0) then
            R_pre = 0.5*(grid_p_(nr-1) + grid_p_(nr))
         else
            R_pre = grid_p_(0)
         end if
         if (nr.lt.n_r-1) then
            R_pos = 0.5*(grid_p_(nr+1) + grid_p_(nr))
         else
            R_pos = grid_p_(n_r-1)
         end if
         dr = R_pos - R_pre
c$$$         We set the zero-mode to zero
         if (grid_p_(nr).le.0.0d0) then
            dr = 0.0d0
         end if
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $           ,'; n_w_(nr) ',n_w_(nr),'; R_pre,R_pos,dr: ',R_pre
     $           ,R_pos,dr
         end if
         dw = 2*pi/(1.0d0*max(1,n_w_(nr)))
         dA = (R_pre*dr + (dr**2)/2)*dw
c$$$         We assume that the fourier basis is orthonormal (not merely orthogonal)
         dAn = dA
         dsqrt_dAn = dsqrt(dAn)
         do nw=0,n_w_(nr)-1
            if (nw.gt.n_w_(nr)/2) then
               nw_fix = nw - n_w_(nr) + n_w_max
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,A,I3,A)') ' % % nw ',nw ,'; nw_fix '
     $                 ,nw_fix,'; (full loop)'
               end if
               C_q = T_q_(ic)
               if (flag_conjg) C_q = conjg(C_q)
               nw_C = nw_fix
               if (verbose.gt.2) then
                  n_X_(nr + nw_C*n_r) = n_X_(nr + nw_C*n_r) + 1
               end if !if (verbose.gt.2) then
               X_q_(nr + ld_X*nw_C) = X_q_(nr + ld_X*nw_C) + C_q
     $              *dsqrt_dAn
            else if (nw.eq.n_w_(nr)/2) then
               nw_fix = nw
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,A,I3,A)') ' % % nw ',nw ,'; nw_fix '
     $                 ,nw_fix,'; (first orig)'
               end if
               C_q = dsqrt(0.0d0*0.5d0)*T_q_(ic)
               if (flag_conjg) C_q = conjg(C_q)
               nw_C = nw_fix
               if (verbose.gt.2) then
                  n_X_(nr + nw_C*n_r) = n_X_(nr + nw_C*n_r) + 1
               end if !if (verbose.gt.2) then
               X_q_(nr + ld_X*nw_C) = X_q_(nr + ld_X*nw_C) + C_q
     $              *dsqrt_dAn
               nw_fix = nw - n_w_(nr) + n_w_max
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,A,I3,A)') ' % % nw ',nw ,'; nw_fix '
     $                 ,nw_fix,'; (then loop)'
               end if
               C_q = dsqrt(0.0d0*0.5d0)*T_q_(ic)
               if (flag_conjg) C_q = conjg(C_q)
               nw_C = nw_fix
               if (verbose.gt.2) then
                  n_X_(nr + nw_C*n_r) = n_X_(nr + nw_C*n_r) + 1
               end if !if (verbose.gt.2) then
               X_q_(nr + ld_X*nw_C) = X_q_(nr + ld_X*nw_C) + C_q
     $              *dsqrt_dAn
            else
               nw_fix = nw
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,A,I3,A)') ' % % nw ',nw ,'; nw_fix '
     $                 ,nw_fix,'; (full orig)'
               end if
               C_q = T_q_(ic)
               if (flag_conjg) C_q = conjg(C_q)
               nw_C = nw_fix
               if (verbose.gt.2) then
                  n_X_(nr + nw_C*n_r) = n_X_(nr + nw_C*n_r) + 1
               end if !if (verbose.gt.2) then
               X_q_(nr + ld_X*nw_C) = X_q_(nr + ld_X*nw_C) + C_q
     $              *dsqrt_dAn
            end if
            ic = ic + 1
         enddo
      enddo
      if (verbose.gt.2) then
         call print_all_i4__(n_r,n_w_max,n_X_,'n_X_: ')
         deallocate(n_X_)
      end if !if (verbose.gt.2) then
      if (verbose.gt.0) then
         write(6,'(A)') ' % [finished innerproduct_q_stretch_0]'
      end if
      end
!> Doxygen comment: ;\n
!> Calculates in innerproduct in k_q_ (i.e., fourier-space bessel) coordinates. ;\n
!> Assumes that M_q_ is the same size and dimensions as T_q_. ;\n
!> Assumes quasi-uniform polar-grid. ;\n
!> Assumes that C_q_ is large enough to hold all n_w_(n_r-1) modes ;\n
!> (assuming of course that n_w_(n_r-1) is the largest value within n_w_). ;\n
!> Stores C_q_ in fft ordering (mode 0 , mode 1 , ... , mode -1) ;\n
!> Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;\n
      subroutine innerproduct_q_k_stretch_0(n_r,grid_p_,n_w_,n_A,T_q_
     $     ,M_q_,C_q_)
c$$$      Assumes that M_q_ is the same size and dimensions as T_q_. ;
c$$$      Assumes quasi-uniform polar-grid. ;
c$$$      Assumes that C_q_ is large enough to hold all n_w_(n_r-1) modes ;
c$$$      (assuming of course that n_w_(n_r-1) is the largest value within n_w_). ;
c$$$      Stores C_q_ in fft ordering (mode 0 , mode 1 , ... , mode -1) ;
c$$$      Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;
      implicit none
      integer verbose
      data verbose / 0 /
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_p_(0:n_r-1)
      complex *16 T_q_(0:n_A-1),M_q_(0:n_A-1)
      complex *16 C_q_(0:n_w_(n_r-1)-1)
      complex *16 C_q
      real *8 pi
      integer n_w_max,ic,nr,nw,nw_fix,nw_C
      real *8 R_pos,R_pre,dr,dw,dA,dAn
      if (verbose.gt.0) then
         write(6,'(A,I0)')
     $        ' % [entering innerproduct_q_k_stretch_0] n_r ',n_r
      end if
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' % n_w_max ',n_w_max
      end if
      do nw=0,n_w_max-1
         C_q_(nw) = cmplx( 0.0 , 0.0 )
      enddo
      C_q = cmplx( 0.0 , 0.0 )
      ic = 0
      do nr=0,n_r-1
         if (nr.gt.0) then
            R_pre = 0.5*(grid_p_(nr-1) + grid_p_(nr))
         else
            R_pre = grid_p_(0)
         end if
         if (nr.lt.n_r-1) then
            R_pos = 0.5*(grid_p_(nr+1) + grid_p_(nr))
         else
            R_pos = grid_p_(n_r-1)
         end if
         dr = R_pos - R_pre
c$$$         We set the zero-mode to zero
         if (grid_p_(nr).le.0.0d0) then
            dr = 0.0d0
         end if
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $           ,'; n_w_(nr) ',n_w_(nr),'; R_pre,R_pos,dr: ',R_pre
     $           ,R_pos,dr
         end if
         dw = 2*pi/(1.0d0*max(1,n_w_(nr)))
         dA = (R_pre*dr + (dr**2)/2)*dw
c$$$         We assume that the fourier basis is orthonormal (not merely orthogonal)
         dAn = dA
         do nw=0,n_w_(nr)-1
            if (nw.gt.n_w_(nr)/2) then
               nw_fix = nw - n_w_(nr) + n_w_max
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,A,I3,A)') ' % % nw ',nw ,'; nw_fix '
     $                 ,nw_fix,'; (full loop)'
               end if
               C_q = conjg(T_q_(ic))*M_q_(ic)
               nw_C = nw_fix
               C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
            else if (nw.eq.n_w_(nr)/2) then
               nw_fix = nw
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,A,I3,A)') ' % % nw ',nw ,'; nw_fix '
     $                 ,nw_fix,'; (first orig)'
               end if
               C_q = 0.0d0*0.5d0*conjg(T_q_(ic))*M_q_(ic)
               nw_C = nw_fix
               C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
               nw_fix = nw - n_w_(nr) + n_w_max
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,A,I3,A)') ' % % nw ',nw ,'; nw_fix '
     $                 ,nw_fix,'; (then loop)'
               end if
               C_q = 0.0d0*0.5d0*conjg(T_q_(ic))*M_q_(ic)
               nw_C = nw_fix
               C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
            else
               nw_fix = nw
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,A,I3,A)') ' % % nw ',nw ,'; nw_fix '
     $                 ,nw_fix,'; (full orig)'
               end if
               C_q = conjg(T_q_(ic))*M_q_(ic)
               nw_C = nw_fix
               C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
            end if
            ic = ic + 1
         enddo
      enddo
      if (verbose.gt.0) then
         write(6,'(A)') ' % [finished innerproduct_q_k_stretch_0]'
      end if
      end
!> Doxygen comment: ;\n
!> Sets up an array C_q_ to calculate the 'right side' ;\n
!> (i.e., image-specific component) to the svd-expansion ;\n
!> of the translation operator. ;\n
!> Assumes that M_q_ is the same size and dimensions as T_q_. ;\n
!> Assumes quasi-uniform polar-grid defined via n_r , .. , n_A. ;\n
!> Uses svd-expansion defined via n_svd_r , .. , svd_V_r_. ;\n
!> Assumes that C_q_ is large enough to hold all n_w_max = n_w_(n_r-1)  ;\n
!> modes for each of the n_svd_l terms in the svd-expansion ;\n
!> (assuming of course that n_w_(n_r-1) is the largest value within n_w_). ;\n
!> modes in C_q_ are stored in the order: (mode 0 , mode 1 , ... , mode -1). ;\n
!> The mode-k for term-l is stored in C_q_(l + k*n_svd_l). ;\n
!> The logical flag_S_vs_M determines the sign of the complex exponential. ;\n
!> flag_S_vs_M .eqv. .true. --> transformation applied to S, use +. ;\n
!> flag_S_vs_M .eqv. .false. --> transformation applied to M, use -. ;\n
!> Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;\n
!> Performs polynomial evaluation internally. ;\n
      subroutine innerproduct_q_k_svdr_5(flag_S_vs_M,svd_r_max,n_svd_r
     $     ,svd_r_,n_svd_l,svd_l_,svd_s_,svd_V_r_,n_r,grid_p_,n_w_,n_A
     $     ,T_q_,M_q_,C_q_)
c$$$      Assumes that M_q_ is the same size and dimensions as T_q_. ;
c$$$      Assumes quasi-uniform polar-grid defined via n_r , .. , n_A. ;
c$$$      Uses svd-expansion defined via n_svd_r , .. , svd_V_r_. ;
c$$$      Assumes that C_q_ is large enough to hold all n_w_max = n_w_(n_r-1)  ;
c$$$      modes for each of the n_svd_l terms in the svd-expansion ;
c$$$      (assuming of course that n_w_(n_r-1) is the largest value within n_w_). ;
c$$$      modes in C_q_ are stored in the order: (mode 0 , mode 1 , ... , mode -1). ;
c$$$      The mode-k for term-l is stored in C_q_(l + k*n_svd_l). ;
c$$$      The logical flag_S_vs_M determines the sign of the complex exponential. ;
c$$$      flag_S_vs_M .eqv. .true. --> transformation applied to S, use +. ;
c$$$      flag_S_vs_M .eqv. .false. --> transformation applied to M, use -. ;
c$$$      Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;
      implicit none
      integer verbose
      data verbose / 0 /
      logical warning_flag
      data warning_flag / .true. /
      logical flag_S_vs_M
      integer n_svd_r,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_r_(0:n_svd_r-1),svd_s_(0:n_svd_l-1)
      real *8 svd_V_r_(0:n_svd_r*n_svd_l-1)
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_p_(0:n_r-1)
      complex *16 T_q_(0:n_A-1),M_q_(0:n_A-1)
      complex *16 C_q_(0:n_svd_l*n_w_(n_r-1)-1),C_q
      real *8 pi
      integer n_w_max,ic_store,ic,ict,icr,nr,nw,nwt,nwr,nw_fix,nw_C
      integer n_w_t ! positive threshold for overflow. ;
      integer nwc ! centered nw. ;
      integer nwd ! displaced nw. ;
      logical flag_ic0_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_ict_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_icr_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      real *8 R_q,R_pos,R_pre,dr,dw,dA,dAn
      real *8 svd_r_max,svd_r_m,svd_r_c,svd_r(0:0)
      real *8 D_V_r,D_s
      integer nl,I_l
      real *8, allocatable :: V_r_(:)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' % [entering innerproduct_q_k_svdr_5] n_r '
     $        ,n_r
      end if
      pi = 4.0*atan(1.0)
      allocate(V_r_(0:n_svd_l*n_r-1))
      svd_r_m = svd_r_max / 2.0
      svd_r_c = svd_r_m
      n_w_max = n_w_(n_r-1)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' % n_w_max ',n_w_max
      end if
      do nr=0,n_r-1
         if (grid_p_(nr).gt.svd_r_max .and. warning_flag) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)')
     $           'Warning, grid_p_(nr) ',grid_p_(nr),'>',svd_r_max
     $           ,'; ratio = ',grid_p_(nr)/svd_r_max
     $           ,' in test_innerproduct_8_Z_S_q_4.f'
         end if
         svd_r(0) = (grid_p_(nr) - svd_r_m)/svd_r_c
         do nl=0,n_svd_l-1
            call polyval_r8_reverse_0(n_svd_r,svd_V_r_(0+nl*n_svd_r),1
     $           ,svd_r(0),V_r_(nl+nr*n_svd_l))
         enddo !do nl=0,n_svd_l-1         
      enddo !do nr=0,n_r-1
      do nl=0,n_svd_l-1
         do nw=0,n_w_max-1
            C_q_(nl+nw*n_svd_l) = cmplx( 0.0 , 0.0 )
         enddo
      enddo
      C_q = cmplx( 0.0 , 0.0 )
      ic = 0
      do nr=0,n_r-1
         if (nr.gt.0) then
            R_pre = 0.5*(grid_p_(nr-1) + grid_p_(nr))
         else
            R_pre = grid_p_(0)
         end if
         if (nr.lt.n_r-1) then
            R_pos = 0.5*(grid_p_(nr+1) + grid_p_(nr))
         else
            R_pos = grid_p_(n_r-1)
         end if
         dr = R_pos - R_pre
c$$$         We set the zero-mode to zero
         if (grid_p_(nr).le.0.0d0) then
            dr = 0.0d0
         end if
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $           ,'; n_w_(nr) ',n_w_(nr),'; R_pre,R_pos,dr: ',R_pre
     $           ,R_pos,dr
         end if
         dw = 2*pi/(1.0d0*max(1,n_w_(nr)))
         dA = (R_pre*dr + (dr**2)/2)*dw
c$$$         We assume that the fourier basis is orthonormal (not merely orthogonal)
         dAn = dA
         if (verbose.gt.1) then
            write(6,'(A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $           ,'; dr dw dA: ',dr,dw,dA
         end if
         n_w_t = floor(1.0d0*n_w_(nr)/2.0d0)
         ic_store = ic
         do nl=0,n_svd_l-1
            D_V_r = V_r_(nl+nr*n_svd_l)
            D_s = svd_s_(nl)
            I_l = svd_l_(nl)
            if (verbose.gt.2 .and. nr.lt.5) then
               write(6,'(A,I3,1X,I3,1X,F16.3,1X,F16.3)')
     $              ' % % nl I_l D_V_r D_s: ',nl,I_l,D_V_r,D_s
            end if
            ic = ic_store
            do nw=0,n_w_(nr)-1
               nwc = nw
               if (nwc.ge.n_w_t) then
                  nwc = nwc - n_w_(nr)
               end if !if (nwc.ge.n_w_t) then
               if (abs(nwc).lt.n_w_t) then
                  flag_ic0_overflow = .false.
               else
                  flag_ic0_overflow = .true.
               end if !if (abs(nwc).lt.n_w_t) then
               nwc = nw
               if (nwc.ge.n_w_t) then
                  nwc = nwc - n_w_(nr)
               end if           !if (nwc.ge.n_w_t) then
               flag_ict_overflow = .false.
               nwd = nwc + I_l
               if (abs(nwd).lt.n_w_t) then
                  call periodize_i(nwd,0,n_w_(nr),nwt)
               else
                  nwt = 0
                  flag_ict_overflow = .true.
               end if           !if (abs(nwd).lt.n_w_t) then
               flag_icr_overflow = .false.
               nwd = nwc - I_l
               if (abs(nwd).lt.n_w_t) then
                  call periodize_i(nwd,0,n_w_(nr),nwr)
               else
                  nwr = 0
                  flag_icr_overflow = .true.
               end if           !if (abs(nwd).lt.n_w_t) then
               ict = ic-nw+nwt
               icr = ic-nw+nwr
               if (verbose.gt.3 .and. nr.lt.5) then
                  write(6,'(10(A,I0))') ' % % % nl:' , nl , '; I_l:'
     $                 , I_l , '; ic_store:' , ic_store,
     $                 '; n_w_(nr):' , n_w_(nr) , '; nw:', nw ,
     $                 '; nwt:' ,nwt , '; nwr:' , nwr ,'; ic:' , ic ,
     $                 '; ict:' , ict , '; icr:', icr 
                  write(6,'(2(A,L1))') ' % % % flag_ict: ' ,
     $                 flag_ict_overflow , '; flag_icr: ' ,
     $                 flag_icr_overflow
               end if           !if (verbose.gt.3 .and. nr.lt.5) then
               if ((flag_ic0_overflow.eqv..false.) .and.
     $              (flag_ict_overflow.eqv..false.)) then
               if (nw.gt.n_w_(nr)/2) then
                  nw_fix = nw - n_w_(nr) + n_w_max
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                    ,'; nw_fix ',nw_fix,'; (full loop)'
                  end if
                  if (flag_S_vs_M.eqv..true.) C_q = conjg(D_s*D_V_r
     $                 *T_q_(ict))*M_q_(ic)
                  if (flag_S_vs_M.eqv..false.) C_q = conjg(D_s*D_V_r
     $                 *T_q_(ic))*M_q_(ict)
                  nw_C = nl + nw_fix*n_svd_l
                  C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
               else if (nw.eq.n_w_(nr)/2) then
                  nw_fix = nw
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                    ,'; nw_fix ',nw_fix,'; (first orig)'
                  end if
                  if (flag_S_vs_M.eqv..true.) C_q = 0.0d0*0.5d0
     $                 *conjg(D_s*D_V_r*T_q_(ict))*M_q_(ic)
                  if (flag_S_vs_M.eqv..false.) C_q = 0.0d0*0.5d0
     $                 *conjg(D_s*D_V_r*T_q_(ic))*M_q_(ict)
                  nw_C = nl + nw_fix*n_svd_l
                  C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
                  nw_fix = nw - n_w_(nr) + n_w_max
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                    ,'; nw_fix ',nw_fix,'; (then loop)'
                  end if
                  if (flag_S_vs_M.eqv..true.) C_q = 0.0d0*0.5d0
     $                 *conjg(D_s*D_V_r*T_q_(ict))*M_q_(ic)
                  if (flag_S_vs_M.eqv..false.) C_q = 0.0d0*0.5d0
     $                 *conjg(D_s*D_V_r*T_q_(ic))*M_q_(ict)
                  nw_C = nl + nw_fix*n_svd_l
                  C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
               else
                  nw_fix = nw
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                    ,'; nw_fix ',nw_fix,'; (full orig)'
                  end if
                  if (flag_S_vs_M.eqv..true.) C_q = conjg(D_s*D_V_r
     $                 *T_q_(ict))*M_q_(ic)
                  if (flag_S_vs_M.eqv..false.) C_q = conjg(D_s*D_V_r
     $                 *T_q_(ic))*M_q_(ict)
                  nw_C = nl + nw_fix*n_svd_l
                  C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
               end if !if (nw.gt.n_w_(nr)/2) then
               end if !if ((flag_ic0_overflow.eqv..false.) .and. (flag_ict_overflow.eqv..false.)) then
               ic = ic + 1
            enddo
         enddo         
      enddo
      deallocate(V_r_)
      if (verbose.gt.0) then
         write(6,'(A)') ' % [finished innerproduct_q_k_svdr_5]'
      end if
      end
!> Doxygen comment: ;\n
!> Sets up an array C_q_ to calculate the 'right side' ;\n
!> (i.e., image-specific component) to the svd-expansion ;\n
!> of the translation operator. ;\n
!> Assumes that M_q_ is the same size and dimensions as T_q_. ;\n
!> Assumes quasi-uniform polar-grid defined via n_r , .. , n_A. ;\n
!> Uses svd-expansion defined via n_svd_r , .. , svd_V_r_. ;\n
!> Assumes that C_q_ is large enough to hold all n_w_max = n_w_(n_r-1)  ;\n
!> modes for each of the n_svd_l terms in the svd-expansion ;\n
!> (assuming of course that n_w_(n_r-1) is the largest value within n_w_). ;\n
!> modes in C_q_ are stored in the order: (mode 0 , mode 1 , ... , mode -1). ;\n
!> The mode-k for term-l is stored in C_q_(l + k*n_svd_l). ;\n
!> The logical flag_S_vs_M determines the sign of the complex exponential. ;\n
!> flag_S_vs_M .eqv. .true. --> transformation applied to S, use +. ;\n
!> flag_S_vs_M .eqv. .false. --> transformation applied to M, use -. ;\n
!> Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;\n
!> Assumes that polynomial evaluation has been precomputed. ;\n
      subroutine innerproduct_q_k_svdr_6(flag_S_vs_M,svd_r_max,n_svd_r
     $     ,svd_r_,n_svd_l,svd_l_,svd_s_,svd_V_r_,svd_polyval_V_r_,n_r
     $     ,grid_p_,n_w_,n_A ,T_q_,M_q_,C_q_)
c$$$      Assumes that M_q_ is the same size and dimensions as T_q_. ;
c$$$      Assumes quasi-uniform polar-grid defined via n_r , .. , n_A. ;
c$$$      Uses svd-expansion defined via n_svd_r , .. , svd_V_r_. ;
c$$$      Assumes that C_q_ is large enough to hold all n_w_max = n_w_(n_r-1)  ;
c$$$      modes for each of the n_svd_l terms in the svd-expansion ;
c$$$      (assuming of course that n_w_(n_r-1) is the largest value within n_w_). ;
c$$$      modes in C_q_ are stored in the order: (mode 0 , mode 1 , ... , mode -1). ;
c$$$      The mode-k for term-l is stored in C_q_(l + k*n_svd_l). ;
c$$$      The logical flag_S_vs_M determines the sign of the complex exponential. ;
c$$$      flag_S_vs_M .eqv. .true. --> transformation applied to S, use +. ;
c$$$      flag_S_vs_M .eqv. .false. --> transformation applied to M, use -. ;
c$$$      Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;
      implicit none
      integer verbose
      data verbose / 0 /
      logical warning_flag
      data warning_flag / .true. /
      logical flag_S_vs_M
      integer n_svd_r,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_r_(0:n_svd_r-1),svd_s_(0:n_svd_l-1)
      real *8 svd_V_r_(0:n_svd_r*n_svd_l-1)
      real *8 svd_polyval_V_r_(0:n_svd_l*n_r-1)
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 grid_p_(0:n_r-1)
      complex *16 T_q_(0:n_A-1),M_q_(0:n_A-1)
      complex *16 C_q_(0:n_svd_l*n_w_(n_r-1)-1),C_q
      real *8 pi
      integer n_w_max,ic_store,ic,ict,icr,nr,nw,nwt,nwr,nw_fix,nw_C
      integer n_w_t ! positive threshold for overflow. ;
      integer nwc ! centered nw. ;
      integer nwd ! displaced nw. ;
      logical flag_ic0_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_ict_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_icr_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      real *8 R_q,R_pos,R_pre,dr,dw,dA,dAn
      real *8 svd_r_max,svd_r_m,svd_r_c,svd_r(0:0)
      real *8 D_V_r,D_s
      integer nl,I_l
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' % [entering innerproduct_q_k_svdr_6] n_r '
     $        ,n_r
      end if
      pi = 4.0*atan(1.0)
      svd_r_m = svd_r_max / 2.0
      svd_r_c = svd_r_m
      n_w_max = n_w_(n_r-1)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' % n_w_max ',n_w_max
      end if
      do nr=0,n_r-1
         if (grid_p_(nr).gt.svd_r_max .and. warning_flag) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)')
     $           'Warning, grid_p_(nr) ',grid_p_(nr),'>',svd_r_max
     $           ,'; ratio = ',grid_p_(nr)/svd_r_max
     $           ,' in test_innerproduct_8_Z_S_q_4.f'
         end if
      enddo !do nr=0,n_r-1
      do nl=0,n_svd_l-1
         do nw=0,n_w_max-1
            C_q_(nl+nw*n_svd_l) = cmplx( 0.0 , 0.0 )
         enddo
      enddo
      C_q = cmplx( 0.0 , 0.0 )
      ic = 0
      do nr=0,n_r-1
         if (nr.gt.0) then
            R_pre = 0.5*(grid_p_(nr-1) + grid_p_(nr))
         else
            R_pre = grid_p_(0)
         end if
         if (nr.lt.n_r-1) then
            R_pos = 0.5*(grid_p_(nr+1) + grid_p_(nr))
         else
            R_pos = grid_p_(n_r-1)
         end if
         dr = R_pos - R_pre
c$$$         We set the zero-mode to zero
         if (grid_p_(nr).le.0.0d0) then
            dr = 0.0d0
         end if
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $           ,'; n_w_(nr) ',n_w_(nr),'; R_pre,R_pos,dr: ',R_pre
     $           ,R_pos,dr
         end if
         dw = 2*pi/(1.0d0*max(1,n_w_(nr)))
         dA = (R_pre*dr + (dr**2)/2)*dw
c$$$         We assume that the fourier basis is orthonormal (not merely orthogonal)
         dAn = dA
         if (verbose.gt.1) then
            write(6,'(A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $           ,'; dr dw dA: ',dr,dw,dA
         end if
         n_w_t = floor(1.0d0*n_w_(nr)/2.0d0)
         ic_store = ic
         do nl=0,n_svd_l-1
            D_V_r = svd_polyval_V_r_(nl+nr*n_svd_l)
            D_s = svd_s_(nl)
            I_l = svd_l_(nl)
            if (verbose.gt.2 .and. nr.lt.5) then
               write(6,'(A,I3,1X,I3,1X,F16.3,1X,F16.3)')
     $              ' % % nl I_l D_V_r D_s: ',nl,I_l,D_V_r,D_s
            end if
            ic = ic_store
            do nw=0,n_w_(nr)-1
               nwc = nw
               if (nwc.ge.n_w_t) then
                  nwc = nwc - n_w_(nr)
               end if !if (nwc.ge.n_w_t) then
               if (abs(nwc).lt.n_w_t) then
                  flag_ic0_overflow = .false.
               else
                  flag_ic0_overflow = .true.
               end if !if (abs(nwc).lt.n_w_t) then
               nwc = nw
               if (nwc.ge.n_w_t) then
                  nwc = nwc - n_w_(nr)
               end if           !if (nwc.ge.n_w_t) then
               flag_ict_overflow = .false.
               nwd = nwc + I_l
               if (abs(nwd).lt.n_w_t) then
                  call periodize_i(nwd,0,n_w_(nr),nwt)
               else
                  nwt = 0
                  flag_ict_overflow = .true.
               end if           !if (abs(nwd).lt.n_w_t) then
               flag_icr_overflow = .false.
               nwd = nwc - I_l
               if (abs(nwd).lt.n_w_t) then
                  call periodize_i(nwd,0,n_w_(nr),nwr)
               else
                  nwr = 0
                  flag_icr_overflow = .true.
               end if           !if (abs(nwd).lt.n_w_t) then
               ict = ic-nw+nwt
               icr = ic-nw+nwr
               if (verbose.gt.3 .and. nr.lt.5) then
                  write(6,'(10(A,I0))') ' % % % nl:' , nl , '; I_l:'
     $                 , I_l , '; ic_store:' , ic_store,
     $                 '; n_w_(nr):' , n_w_(nr) , '; nw:', nw ,
     $                 '; nwt:' ,nwt , '; nwr:' , nwr ,'; ic:' , ic ,
     $                 '; ict:' , ict , '; icr:', icr 
                  write(6,'(2(A,L1))') ' % % % flag_ict: ' ,
     $                 flag_ict_overflow , '; flag_icr: ' ,
     $                 flag_icr_overflow
               end if           !if (verbose.gt.3 .and. nr.lt.5) then
               if ((flag_ic0_overflow.eqv..false.) .and.
     $              (flag_ict_overflow.eqv..false.)) then
               if (nw.gt.n_w_(nr)/2) then
                  nw_fix = nw - n_w_(nr) + n_w_max
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                    ,'; nw_fix ',nw_fix,'; (full loop)'
                  end if
                  if (flag_S_vs_M.eqv..true.) C_q = conjg(D_s*D_V_r
     $                 *T_q_(ict))*M_q_(ic)
                  if (flag_S_vs_M.eqv..false.) C_q = conjg(D_s*D_V_r
     $                 *T_q_(ic))*M_q_(ict)
                  nw_C = nl + nw_fix*n_svd_l
                  C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
               else if (nw.eq.n_w_(nr)/2) then
                  nw_fix = nw
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                    ,'; nw_fix ',nw_fix,'; (first orig)'
                  end if
                  if (flag_S_vs_M.eqv..true.) C_q = 0.0d0*0.5d0
     $                 *conjg(D_s*D_V_r*T_q_(ict))*M_q_(ic)
                  if (flag_S_vs_M.eqv..false.) C_q = 0.0d0*0.5d0
     $                 *conjg(D_s*D_V_r*T_q_(ic))*M_q_(ict)
                  nw_C = nl + nw_fix*n_svd_l
                  C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
                  nw_fix = nw - n_w_(nr) + n_w_max
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                    ,'; nw_fix ',nw_fix,'; (then loop)'
                  end if
                  if (flag_S_vs_M.eqv..true.) C_q = 0.0d0*0.5d0
     $                 *conjg(D_s*D_V_r*T_q_(ict))*M_q_(ic)
                  if (flag_S_vs_M.eqv..false.) C_q = 0.0d0*0.5d0
     $                 *conjg(D_s*D_V_r*T_q_(ic))*M_q_(ict)
                  nw_C = nl + nw_fix*n_svd_l
                  C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
               else
                  nw_fix = nw
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                    ,'; nw_fix ',nw_fix,'; (full orig)'
                  end if
                  if (flag_S_vs_M.eqv..true.) C_q = conjg(D_s*D_V_r
     $                 *T_q_(ict))*M_q_(ic)
                  if (flag_S_vs_M.eqv..false.) C_q = conjg(D_s*D_V_r
     $                 *T_q_(ic))*M_q_(ict)
                  nw_C = nl + nw_fix*n_svd_l
                  C_q_(nw_C) = C_q_(nw_C) + C_q*dAn
               end if !if (nw.gt.n_w_(nr)/2) then
               end if !if ((flag_ic0_overflow.eqv..false.) .and. (flag_ict_overflow.eqv..false.)) then
               ic = ic + 1
            enddo
         enddo         
      enddo
      if (verbose.gt.0) then
         write(6,'(A)') ' % [finished innerproduct_q_k_svdr_6]'
      end if
      end
!> Doxygen comment: ;\n
!> Sets up an array C_q_ to calculate the 'left side' ;\n
!> (i.e., translation-specific component) to the svd-expansion ;\n
!> of the translation operator. ;\n
!> Creates a matrix for translations.  \n
!> Uses svd-expansion defined via n_svd_d, .. , svd_U_d_.\n
!> Term-l of Translation-d is stored in \n
!> C_q_(l + ndv*n_svd_l).\n
!> The logical flag_S_vs_M determines the sign of the complex exponential.\n
!> flag_S_vs_M .eqv. .true. --> transformation applied to S, use +.\n
!> flag_S_vs_M .eqv. .false. --> transformation applied to M, use -.\n
!> Performs polynomial evaluation internally. ;\n
      subroutine innerproduct_q_k_svdd_3(flag_S_vs_M,svd_d_max,n_svd_d
     $     ,svd_d_,n_svd_l,svd_l_,svd_U_d_,n_delta_v,delta_x_,delta_y_
     $     ,C_q_)
c$$$      Creates a matrix for translations.  
c$$$      Uses svd-expansion defined via n_svd_d, .. , svd_U_d_.
c$$$      Term-l of Translation-d is stored in 
c$$$      C_q_(l + ndv*n_svd_l).
c$$$      The logical flag_S_vs_M determines the sign of the complex exponential.
c$$$      flag_S_vs_M .eqv. .true. --> transformation applied to S, use +.
c$$$      flag_S_vs_M .eqv. .false. --> transformation applied to M, use -.
      implicit none
      integer verbose
      data verbose / 0 /
      logical warning_flag
      data warning_flag / .true. /
      logical flag_S_vs_M
      real *8 svd_d_max
      integer n_svd_d,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_d_(0:n_svd_d-1)
      real *8 svd_U_d_(0:n_svd_d*n_svd_l-1)
      integer n_delta_v
      real *8 delta_x_(0:n_delta_v-1),delta_x
      real *8 delta_y_(0:n_delta_v-1),delta_y
      complex *16 C_q_(0:n_svd_l*n_delta_v-1)
      real *8 pi
      real *8 svd_d_m,svd_d_c,svd_d(0:0)
      real *16 delta,omega,theta
      integer nl,I_l,ndv,nC,nl_pre
      integer *4 max_i4_f
      integer l_max
c$$$      l_max must equal or exceed order of bessel-function expansion
      complex *16 C_q
      complex *16, allocatable :: C_q_pre_(:)
      real *8, allocatable :: U_d_(:)
      if (verbose.gt.0) then
         write (6,'(A,I0,1X,I0,1X,I0)')
     $        ' % [entering innerproduct_q_k_svdd_3] ',n_svd_d,n_svd_l
     $        ,n_delta_v
      end if
      l_max = max_i4_f(n_svd_l,svd_l_)
      allocate(C_q_pre_(-l_max:+l_max))
      allocate(U_d_(0:n_svd_l-1))
      pi = 4.0*atan(1.0)
      nC = 0
      svd_d_m = svd_d_max / 2.0
      svd_d_c = svd_d_m
      do ndv=0,n_delta_v-1
         delta_x = delta_x_(ndv)
         delta_y = delta_y_(ndv)
         if (verbose.gt.1) then
            write (6,'(A,I0,1X,F6.3,1X,F6.3)')
     $           ' % ndv dx dy : ',ndv,delta_x,delta_y
         end if                 !if (verbose.gt.1) then
         delta = dsqrt(delta_x**2 + delta_y**2)
         if (delta.gt.svd_d_max .and. warning_flag) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)') 'Warning, delta '
     $           ,delta,'>',svd_d_max,'; ratio = ',delta/svd_d_max,
     $           ' in innerproduct_q_k_svdd_3'
         end if
         omega = atan2(delta_y,delta_x)
         if (verbose.gt.1) then
            write (6,'(A,F6.3,1X,F6.3)') ' % delta omega : ',delta
     $           ,omega
         end if
c$$$            here we initialize C_q_pre using omega and l_max
c$$$            The goal is for 
c$$$            C_q_pre_(nl_pre) 
c$$$            to equal:
c$$$            S-type --> cmplx( +cos(theta) , +sin(theta) )
c$$$            M-type --> cmplx( +cos(theta) , -sin(theta) )
c$$$            with
c$$$            theta = nl_pre*(pi/2 - omega).
         C_q_pre_(0) = cmplx( 1.0 , 0.0 )
         if (flag_S_vs_M.eqv..true.) theta = (pi/2 - omega)
         if (flag_S_vs_M.eqv..false.) theta = (pi/2 - omega + pi)
         if (flag_S_vs_M.eqv..true.) C_q = cmplx( +cos(theta) ,
     $        +sin(theta) )
         if (flag_S_vs_M.eqv..false.) C_q = cmplx( +cos(theta) ,
     $        -sin(theta) )
         do nl_pre=1,l_max
            C_q_pre_(+nl_pre) = C_q_pre_(+nl_pre-1)*C_q
         end do
         if (flag_S_vs_M.eqv..true.) C_q = cmplx( +cos(theta) ,
     $        -sin(theta) )
         if (flag_S_vs_M.eqv..false.) C_q = cmplx( +cos(theta) ,
     $        +sin(theta) )
         do nl_pre=1,l_max
            C_q_pre_(-nl_pre) = C_q_pre_(-nl_pre+1)*C_q
         end do
         svd_d(0) = (delta - svd_d_m)/svd_d_c
         do nl=0,n_svd_l-1
            call polyval_r8_reverse_0(n_svd_d,svd_U_d_(0+nl*n_svd_d),1
     $           ,svd_d(0),U_d_(nl))
            if (verbose.gt.1) then
               write (6,'(A,F6.3,A,F6.3,A,I0,A,F8.5)') ' % delta ' ,
     $              delta , ' svd_d ' ,svd_d(0) , ' U_d_(' , nl , ') ',
     $              U_d_(nl)
            end if !if (verbose.gt.1) then
         enddo !do nl=0,n_svd_l-1
         do nl=0,n_svd_l-1
            I_l = svd_l_(nl)
            if (abs(I_l).gt.l_max) then
               write(6,'(A,I0,A)') 'Warning, I_l: ',I_l
     $              ,'>l_max in innerproduct_q_k_svdd_3'
            end if              !if (abs(I_l).gt.l_max) then
            if (verbose.gt.2) then
               write(6,'(A,I3,1X,I3)') ' % % nl I_l: ',nl,I_l
            end if              !if (verbose.gt.2) then
c$$$               theta = I_l*(pi/2 - omega)
c$$$               If transformation were applied to S we would use:
c$$$               C_q = cmplx( +cos(theta) , +sin(theta) )
c$$$               If transformation were applied to M we would use:
c$$$               C_q = cmplx( +cos(theta) , -sin(theta) )
            C_q = C_q_pre_(I_l)
c$$$               nC = nl + ndv*n_svd_l
            C_q_(nC) = U_d_(nl)*C_q
            nC = nC+1
         enddo                  !do nl=0,n_svd_l-1
      enddo                     !do ndv=0,n_delta_v-1
      deallocate(U_d_)
      deallocate(C_q_pre_)
      if (verbose.gt.0) then
         write (6,'(A)') ' % [finished innerproduct_q_k_svdd_3]'
      end if
      end
!> Doxygen comment: ;\n
!> Sets up an array C_q_ to calculate the 'left side' ;\n
!> (i.e., translation-specific component) to the svd-expansion ;\n
!> of the translation operator. ;\n
!> Creates a matrix for translations.  \n
!> Uses svd-expansion defined via n_svd_d, .. , svd_U_d_.\n
!> Term-l of Translation-d is stored in \n
!> C_q_(l + ndv*n_svd_l).\n
!> The logical flag_S_vs_M determines the sign of the complex exponential.\n
!> flag_S_vs_M .eqv. .true. --> transformation applied to S, use +.\n
!> flag_S_vs_M .eqv. .false. --> transformation applied to M, use -.\n
!> Assumes that polynomial evaluation is precomputed. ;\n
      subroutine innerproduct_q_k_svdd_4(flag_S_vs_M,svd_d_max,n_svd_d
     $     ,svd_d_,n_svd_l,svd_l_,svd_U_d_,svd_polyval_U_d_,n_delta_v
     $     ,delta_x_,delta_y_ ,C_q_)
c$$$      Creates a matrix for translations.  
c$$$      Uses svd-expansion defined via n_svd_d, .. , svd_U_d_.
c$$$      Term-l of Translation-d is stored in 
c$$$      C_q_(l + ndv*n_svd_l).
c$$$      The logical flag_S_vs_M determines the sign of the complex exponential.
c$$$      flag_S_vs_M .eqv. .true. --> transformation applied to S, use +.
c$$$      flag_S_vs_M .eqv. .false. --> transformation applied to M, use -.
      implicit none
      integer verbose
      data verbose / 0 /
      logical warning_flag
      data warning_flag / .true. /
      logical flag_S_vs_M
      real *8 svd_d_max
      integer n_svd_d,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_d_(0:n_svd_d-1)
      real *8 svd_U_d_(0:n_svd_d*n_svd_l-1)
      real *8 svd_polyval_U_d_(0:n_svd_l*n_delta_v-1)
      integer n_delta_v
      real *8 delta_x_(0:n_delta_v-1),delta_x
      real *8 delta_y_(0:n_delta_v-1),delta_y
      complex *16 C_q_(0:n_svd_l*n_delta_v-1)
      real *8 pi
      real *8 svd_d_m,svd_d_c,svd_d(0:0)
      real *16 delta,omega,theta
      integer nl,I_l,ndv,nC,nl_pre
      integer *4 max_i4_f
      integer l_max
c$$$      l_max must equal or exceed order of bessel-function expansion
      complex *16 C_q,D_U_d
      complex *16, allocatable :: C_q_pre_(:)
c$$$      real *8, allocatable :: U_d_(:)
      if (verbose.gt.0) then
         write (6,'(A,I0,1X,I0,1X,I0)')
     $        ' % [entering innerproduct_q_k_svdd_4] ',n_svd_d,n_svd_l
     $        ,n_delta_v
      end if
      l_max = max_i4_f(n_svd_l,svd_l_)
      allocate(C_q_pre_(-l_max:+l_max))
c$$$      allocate(U_d_(0:n_svd_l-1))
      pi = 4.0*atan(1.0)
      nC = 0
      svd_d_m = svd_d_max / 2.0
      svd_d_c = svd_d_m
      do ndv=0,n_delta_v-1
         delta_x = delta_x_(ndv)
         delta_y = delta_y_(ndv)
         if (verbose.gt.1) then
            write (6,'(A,I0,1X,F6.3,1X,F6.3)')
     $           ' % ndv dx dy : ',ndv,delta_x,delta_y
         end if                 !if (verbose.gt.1) then
         delta = dsqrt(delta_x**2 + delta_y**2)
         if (delta.gt.svd_d_max .and. warning_flag) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)') 'Warning, delta '
     $           ,delta,'>',svd_d_max,'; ratio = ',delta/svd_d_max,
     $           ' in innerproduct_q_k_svdd_4'
         end if
         omega = atan2(delta_y,delta_x)
         if (verbose.gt.1) then
            write (6,'(A,F6.3,1X,F6.3)') ' % delta omega : ',delta
     $           ,omega
         end if
c$$$            here we initialize C_q_pre using omega and l_max
c$$$            The goal is for 
c$$$            C_q_pre_(nl_pre) 
c$$$            to equal:
c$$$            S-type --> cmplx( +cos(theta) , +sin(theta) )
c$$$            M-type --> cmplx( +cos(theta) , -sin(theta) )
c$$$            with
c$$$            theta = nl_pre*(pi/2 - omega).
         C_q_pre_(0) = cmplx( 1.0 , 0.0 )
         if (flag_S_vs_M.eqv..true.) theta = (pi/2 - omega)
         if (flag_S_vs_M.eqv..false.) theta = (pi/2 - omega + pi)
         if (flag_S_vs_M.eqv..true.) C_q = cmplx( +cos(theta) ,
     $        +sin(theta) )
         if (flag_S_vs_M.eqv..false.) C_q = cmplx( +cos(theta) ,
     $        -sin(theta) )
         do nl_pre=1,l_max
            C_q_pre_(+nl_pre) = C_q_pre_(+nl_pre-1)*C_q
         end do
         if (flag_S_vs_M.eqv..true.) C_q = cmplx( +cos(theta) ,
     $        -sin(theta) )
         if (flag_S_vs_M.eqv..false.) C_q = cmplx( +cos(theta) ,
     $        +sin(theta) )
         do nl_pre=1,l_max
            C_q_pre_(-nl_pre) = C_q_pre_(-nl_pre+1)*C_q
         end do
         do nl=0,n_svd_l-1
            D_U_d = svd_polyval_U_d_(nl+ndv*n_svd_l)
            I_l = svd_l_(nl)
            if (abs(I_l).gt.l_max) then
               write(6,'(A,I0,A)') 'Warning, I_l: ',I_l
     $              ,'>l_max in innerproduct_q_k_svdd_4'
            end if              !if (abs(I_l).gt.l_max) then
            if (verbose.gt.2) then
               write(6,'(A,I3,1X,I3)') ' % % nl I_l: ',nl,I_l
            end if              !if (verbose.gt.2) then
c$$$               theta = I_l*(pi/2 - omega)
c$$$               If transformation were applied to S we would use:
c$$$               C_q = cmplx( +cos(theta) , +sin(theta) )
c$$$               If transformation were applied to M we would use:
c$$$               C_q = cmplx( +cos(theta) , -sin(theta) )
            C_q = C_q_pre_(I_l)
c$$$               nC = nl + ndv*n_svd_l
            C_q_(nC) = D_U_d*C_q
            nC = nC+1
         enddo                  !do nl=0,n_svd_l-1
      enddo                     !do ndv=0,n_delta_v-1
c$$$      deallocate(U_d_)
      deallocate(C_q_pre_)
      if (verbose.gt.0) then
         write (6,'(A)') ' % [finished innerproduct_q_k_svdd_4]'
      end if
      end
!> Doxygen comment: ;\n
!> This function simply applies the rotation ;\n
!> R_{-gamma_z} to the vector delta_pre, ;\n
!> where: ;\n
!> R_{-gamma_z} = [ +cos(gamma_z) , +sin(gamma_z) ] ;\n
!>                [ -sin(gamma_z) , +cos(gamma_z) ] ;\n
!> and\n
!> delta_pre = [ delta_x_pre ; delta_y_pre ]. ;\n
!> ;\n
!> if we define T_{delta} to be translation by delta, ;\n
!> we can see that the above function is used when converting: ;\n
!> R_{gamma2}*T_{delta2}*R_{gamma1}*T_{delta1} ;\n
!> into ;\n
!> R_{gamma2}*R_{gamma1}T_{R_{-gamma1}*delta2}*T_{delta1} ;\n
!> which equals ;\n
!> R_{gamma2 + gamma1}T_{R_{-gamma1}*delta2 + delta1}. ;\n
!> ;\n
!> A conversion of this kind is useful when updating image-parameters.\n
      subroutine get_interchange_delta(delta_x_pre,delta_y_pre
     $     ,gamma_z,delta_x_pos,delta_y_pos)
c$$$      This function simply applies the rotation ;
c$$$      R_{-gamma_z} to the vector delta_pre, ;
c$$$      where: ;
c$$$      R_{-gamma_z} = [ +cos(gamma_z) , +sin(gamma_z) ] ;
c$$$                     [ -sin(gamma_z) , +cos(gamma_z) ] ;
c$$$      and
c$$$      delta_pre = [ delta_x_pre ; delta_y_pre ]. ;
c$$$      ;
c$$$      if we define T_{delta} to be translation by delta, ;
c$$$      we can see that the above function is used when converting: ;
c$$$      R_{gamma2}*T_{delta2}*R_{gamma1}*T_{delta1} ;
c$$$      into ;
c$$$      R_{gamma2}*R_{gamma1}T_{R_{-gamma1}*delta2}*T_{delta1} ;
c$$$      which equals ;
c$$$      R_{gamma2 + gamma1}T_{R_{-gamma1}*delta2 + delta1}. ;
c$$$      ;
c$$$      A conversion of this kind is useful when updating image-parameters.

      implicit none
      real *8 delta_x_pre,delta_y_pre,gamma_z
      real *8 delta_x_pos,delta_y_pos
      real *8 delta_x_tmp,delta_y_tmp
      real *8 dc,ds
      dc = dcos(gamma_z)
      ds = dsin(gamma_z)
      delta_x_tmp = delta_x_pre
      delta_y_tmp = delta_y_pre
      delta_x_pos = +dc*delta_x_tmp +ds*delta_y_tmp
      delta_y_pos = -ds*delta_x_tmp +dc*delta_y_tmp
      end
!> Doxygen comment: ;\n
!> if flag_RTRT_vs_RTRT.eqv..true.: ;\n
!> Updates delta_upd <-- delta_upd + rotate(delta_est,gamma_z_upd), ;\n
!> Updates gamma_z_upd <-- gamma_z_upd + gamma_z_est ;\n
!> if flag_RTRT_vs_RTRT.eqv..false.: ;\n
!> Updates delta_upd <-- rotate(delta_upd+delta_est,gamma_z_upd), ;\n
!> Updates gamma_z_upd <-- gamma_z_upd + gamma_z_est ;\n
!> ;\n
!> These different protocols correspond to different conventions ;\n
!> associated with transforming an image-template pair. ;\n
      subroutine get_interchange_delta_RTRT_vs_RTTR(flag_RTRT_vs_RTTR
     $     ,delta_x_est,delta_y_est,gamma_z_est,delta_x_upd,delta_y_upd
     $     ,gamma_z_upd)
      implicit none
      logical flag_RTRT_vs_RTTR
      real *8 delta_x_est,delta_y_est,gamma_z_est
      real *8 delta_x_upd,delta_y_upd,gamma_z_upd
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      if (flag_RTRT_vs_RTTR.eqv..true.) then
         call get_interchange_delta(delta_x_est,delta_y_est,gamma_z_upd
     $        ,delta_x_tmp ,delta_y_tmp)
         gamma_z_upd = gamma_z_upd + gamma_z_est
         delta_x_upd = delta_x_upd + delta_x_tmp
         delta_y_upd = delta_y_upd + delta_y_tmp
      end if                    !if (flag_RTRT_vs_RTTR.eqv..true.) then
      if (flag_RTRT_vs_RTTR.eqv..false.) then
         delta_x_tmp = delta_x_est + delta_x_upd
         delta_y_tmp = delta_y_est + delta_y_upd
         call get_interchange_delta(delta_x_tmp
     $        ,delta_y_tmp,gamma_z_upd,delta_x_upd
     $        ,delta_y_upd)
         gamma_z_upd = gamma_z_upd + gamma_z_est
      end if                    !if (flag_RTRT_vs_RTTR.eqv..false.) then
      end
!> Doxygen comment: ;\n
!> Assuming that C_S_ is an array defined on an equispaced grid from [0,2*pi), ;\n
!> we shift the array by gamma_z_est, using linear interpolation. ;\n
!> We really should update this to use fourier interpolation. ;\n
      subroutine get_C_S_use_(gamma_z_est,n_gamma_z,C_S_
     $     ,C_S_use_)
      implicit none
      real *8 gamma_z_est
      integer n_gamma_z
      complex *16 C_S_(0:0),C_S_use_(0:0)
      real *8 ngz_est_v,dz_pre,dz_pos,alpha,beta
      integer ngz_est_pre,ngz_est_pos,ngz_pre,ngz_pos
      integer ngz
      real *8 pi
      pi = 4.0*atan(1.0)
      include 'get_C_S_use_excerpt.f'
      do ngz=0,n_gamma_z-1
         ngz_pre = ngz + ngz_est_pre
         call periodize_i(ngz_pre,0,n_gamma_z,ngz_pre)
         ngz_pos = ngz + ngz_est_pos
         call periodize_i(ngz_pos,0,n_gamma_z,ngz_pos)
         C_S_use_(ngz) = beta*C_S_(ngz_pre) + alpha
     $        *C_S_(ngz_pos)
      enddo !do ngz=0,n_gamma_z-1
      end
!> Doxygen comment: ;\n
!> Assuming that CTF_R_S_ is an array defined on an equispaced grid from [0,2*pi), ;\n
!> we shift the array by gamma_z_est, using linear interpolation. ;\n
!> We really should update this to use fourier interpolation. ;\n
      subroutine get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_
     $     ,CTF_R_S_use_)
      implicit none
      real *8 gamma_z_est
      integer n_gamma_z
      complex *16 CTF_R_S_(0:0),CTF_R_S_use_(0:0)
      real *8 ngz_est_v,dz_pre,dz_pos,alpha,beta
      integer ngz_est_pre,ngz_est_pos,ngz_pre,ngz_pos
      integer ngz
      real *8 pi
      pi = 4.0*atan(1.0)
      include 'get_CTF_R_S_use_excerpt.f'
      do ngz=0,n_gamma_z-1
         ngz_pre = ngz + ngz_est_pre
         call periodize_i(ngz_pre,0,n_gamma_z,ngz_pre)
         ngz_pos = ngz + ngz_est_pos
         call periodize_i(ngz_pos,0,n_gamma_z,ngz_pos)
         CTF_R_S_use_(ngz) = beta*CTF_R_S_(ngz_pre) + alpha
     $        *CTF_R_S_(ngz_pos)
      enddo !do ngz=0,n_gamma_z-1
      end
!> Doxygen comment: ;\n
!> Sets up a square grid of displacements. ;\n
!> The displacements range from -T to +T in each direction. ;\n
!> T is equal to N_pixels_in/n_r * half_dimater_x_c. ;\n
!> We should update this to scale by an actual k-value (e.g., grid_k_p_(nr)). ;\n
      subroutine get_delta_0(N_pixels_in,n_r,half_diameter_x_c,n_delta_x
     $     ,delta_x_,n_delta_y,delta_y_)
      implicit none
      integer verbose
      data verbose / 0 /
      real *8 N_pixels_in,half_diameter_x_c
      integer *4 n_r,n_delta_x,n_delta_y
      real *8 delta_x_(0:n_delta_x-1),delta_y_(0:n_delta_y-1)
      integer ndx,ndy
      real *8 delta_x,delta_y
      if (verbose.gt.0) then
         write(6,'(A)') '[entering get_delta_0]'
      end if !if (verbose.gt.0) then
      do ndx=0,n_delta_x-1
         if (n_delta_x.gt.1) then
            delta_x = (-N_pixels_in + ndx*2*N_pixels_in/(n_delta_x-1))
     $           /n_r*half_diameter_x_c
         else
            delta_x = 0.0d0
         end if
         delta_x_(ndx) = delta_x
         do ndy=0,n_delta_y-1
            if (n_delta_y.gt.1) then
               delta_y = (-N_pixels_in + ndy*2*N_pixels_in/(n_delta_y
     $              -1))/n_r*half_diameter_x_c
            else
               delta_y = 0.0d0
            end if
            delta_y_(ndy) = delta_y
         enddo
      enddo      
      if (verbose.gt.0) then
         write(6,'(A)') '[finished get_delta_0]'
      end if !if (verbose.gt.0) then
      end
      
      
!> Doxygen comment: ;\n
!> This function outputs an array of displacements delta_x_, delta_y_ ;\n
!> that are supported on a disc of radius ;\n
!> Rmax = N_pixels*dsqrt(2)*half_diameter_x_c. ;\n
!> This disc circumscribes a square of side-length ;\n
!> N_pixels*half_diameter_x_c*2. ;\n
!> The number of these displacements is stored in n_delta_v. ;\n
!> We assume that delta_x_ and delta_y_ are preallocated. ;\n
!> Note: n_delta_v should be close to ceiling(pi*n_delta_x*n_delta_y). ;\n
!> Note that, right now, the quantity N_pixels_in is scaled to N_pixels_in/n_r * half_dimater_x_c. ;\n
!> We should update this to scale by an actual k-value (e.g., grid_k_p_(nr)). ;\n
      subroutine get_delta_1(N_pixels_in,n_r,half_diameter_x_c,n_delta_x
     $     ,n_delta_y,n_delta_v,delta_x_,delta_y_)
c$$$      This function outputs an array of displacements delta_x_, delta_y_ ;
c$$$      that are supported on a disc of radius ;
c$$$      Rmax = N_pixels*dsqrt(2)*half_diameter_x_c. ;
c$$$      This disc circumscribes a square of side-length ;
c$$$      N_pixels*half_diameter_x_c*2. ;
c$$$      The number of these displacements is stored in n_delta_v. ;
c$$$      We assume that delta_x_ and delta_y_ are preallocated. ;
c$$$      Note: n_delta_v should be close to ceiling(pi*n_delta_x*n_delta_y). ;
      implicit none
      integer verbose
      data verbose / 1 /
      real *8 N_pixels_in,half_diameter_x_c
      integer *4 n_r,n_delta_x,n_delta_y,n_delta_v
      real *8 delta_x_(0:0),delta_y_(0:0)
      integer ndx,ndy,ndv
      real *8 delta_x,delta_y,delta,delta_max
      logical flag_zero ! indicates whether displacement is zero (true) or not (false)
      
      if (verbose.gt.0) then
         write(6,'(A)') '[entering get_delta_1]'
      end if !if (verbose.gt.0) then

      delta_max = N_pixels_in/n_r*half_diameter_x_c*dsqrt(2.0d0)
      if (verbose.gt.0) then
         write(6,'(A,F16.8)') ' N_pixels_in: ' , N_pixels_in
         write(6,'(A,I0)') ' n_r: ' , n_r
         write(6,'(A,F16.8)') ' half_diameter_x_c: ' , half_diameter_x_c
         write(6,'(A,F16.8)') ' delta_max: ' , delta_max
      end if ! if (verbose.gt.0) then

      if ((n_delta_x.le.0) .or. (n_delta_y.le.0)) then
         delta_x_(0) = 0.0d0
         delta_y_(0) = 0.0d0
         n_delta_v = 1
         goto 10
      end if !if ((n_delta_x.le.0) .or. (n_delta_y.le.0)) then

      if ((n_delta_x.le.1) .and. (n_delta_y.le.1)) then
         delta_x_(0) = 0.0d0
         delta_y_(0) = 0.0d0
         n_delta_v = 1
      end if !if ((n_delta_x.le.1) .and. (n_delta_y.le.1)) then

      if ((n_delta_x.le.1) .and. (n_delta_y.gt.1)) then
         ndv=0
         do ndy=0,3*n_delta_y-3
            delta_y = (-3*N_pixels_in + ndy*6*N_pixels_in
     $           /(3*n_delta_y-3))/n_r*half_diameter_x_c
            if (dabs(delta_y).le.delta_max) then
               delta_x_(ndv) = 0.0d0
               delta_y_(ndv) = delta_y
               ndv = ndv+1
            end if !if (dabs(delta_y).le.delta_max) then
         enddo !do ndy=0,3*n_delta_y-1
         n_delta_v = ndv
      end if !if ((n_delta_x.le.1) .and. (n_delta_y.gt.1)) then

      if ((n_delta_x.gt.1) .and. (n_delta_y.le.0)) then
         ndv=0
         do ndx=0,3*n_delta_x-3
            delta_x = (-3*N_pixels_in + ndx*6*N_pixels_in
     $           /(3*n_delta_x-3))/n_r*half_diameter_x_c
            if (dabs(delta_x).le.delta_max) then
               delta_x_(ndv) = delta_x
               delta_y_(ndv) = 0.0d0
               ndv = ndv+1
            end if !if (dabs(delta_x).le.delta_max) then
         enddo !do ndx=0,3*n_delta_x-1
         n_delta_v = ndv
      end if !if ((n_delta_x.gt.1) .and. (n_delta_y.le.0)) then

      if ((n_delta_x.gt.1) .and. (n_delta_y.gt.1)) then
         ndv=0
         flag_zero = .false.
         do ndy=0,3*n_delta_y-3
            delta_y = (-3*N_pixels_in + ndy*6*N_pixels_in
     $           /(3*n_delta_y-3))/n_r*half_diameter_x_c
            do ndx=0,3*n_delta_x-3
               delta_x = (-3*N_pixels_in + ndx*6*N_pixels_in
     $              /(3*n_delta_x-3))/n_r*half_diameter_x_c
               delta = dsqrt(delta_x**2 + delta_y**2)
               if (dabs(delta).le.delta_max) then
                  if (dabs(delta).le.1e-12) then
                     delta_x = 0.0d0
                     delta_y = 0.0d0
                     flag_zero = .true.
                  end if !if (dabs(delta).le.1e-12) then
                  delta_x_(ndv) = delta_x
                  delta_y_(ndv) = delta_y
                  ndv = ndv+1
               end if           !if (dabs(delta_x).le.delta_max) then
            enddo               !do ndx=0,3*n_delta_x-1
         enddo                  !do ndy=0,3*n_delta_y-3
         if (flag_zero.eqv..false.) then
            delta_x_(ndv) = 0.0d0
            delta_y_(ndv) = 0.0d0
            ndv = ndv+1
         end if !if (flag_zero.eqv..false.) then
         n_delta_v = ndv
      end if !if ((n_delta_x.gt.1) .and. (n_delta_y.le.0)) then
      
      if (verbose.gt.1) then
         do ndv=0,n_delta_v-1
            write(6,'(F8.4,1X,F8.4)') delta_x_(ndv) , delta_y_(ndv)
         enddo !do ndv=0,n_delta_v-1
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
      end if !if (verbose.gt.1) then

      if (verbose.gt.0) then
         write(6,'(A)') '[finished get_delta_1]'
      end if !if (verbose.gt.0) then

 10   continue
      end
      
!> Doxygen comment: ;\n
!> get an equispaced grid of gamma-values from [0,2*pi). ;\n
      subroutine get_gamma_0(n_gamma_z,gamma_z_)
      implicit none
      integer verbose
      data verbose / 0 /
      integer *4 n_gamma_z
      real *8 gamma_z_(0:n_gamma_z-1)
      integer ngz
      real *8 gamma_z
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering get_gamma_0]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
      do ngz=0,n_gamma_z-1
         if (n_gamma_z.gt.1) then
            gamma_z = (2*pi*ngz)/n_gamma_z
         else
            gamma_z = 0.0d0
         end if
         gamma_z_(ngz) = gamma_z
      enddo
      if (verbose.gt.0) then
         write(6,'(A)') '[finished get_gamma_0]'
      end if !if (verbose.gt.0) then
      end
      
!> Doxygen comment: ;\n
!> load svd_U_d_ and svd_V_r_ from disc. ;\n
!> takes in certain parameters (e.g., eps_target, n_pixel). ;\n
      subroutine get_svd_2(eps_target,n_svd_r_out,n_svd_d_out
     $     ,n_svd_l_out,svd_r_out_,svd_d_out_,svd_l_out_,svd_U_d_out_
     $     ,svd_s_out_,svd_V_r_out_,svd_unitnumber_out,svd_fname_out
     $     ,grid_p_,n_r,n_delta_v,delta_x_,delta_y_ ,flag_warning,R_max
     $     ,K_max,delta_max ,n_pixel)
      implicit none
      integer verbose
      data verbose / 0 /
      real *8 eps_target
      integer *4 n_svd_r_out,n_svd_d_out,n_svd_l_out
      real *8 svd_r_out_(0:0)
      real *8 svd_d_out_(0:0)
      integer *4 svd_l_out_(0:0)
      real *8 svd_U_d_out_(0:0)
      real *8 svd_s_out_(0:0)
      real *8 svd_V_r_out_(0:0)
      logical, allocatable :: flag_s_(:)
      integer *4 svd_unitnumber_out
      character(len=1024) svd_fname_out
      include './dir_gen_Jsvd_6/gen_Jsvd_svddecl.txt'
      logical flag_warning
      real *8 grid_p_(0:0)
      integer n_r
      integer n_delta_v,ndv
      real *8 delta_x_(0:0),delta_y_(0:0)
      real *8 R_max,K_max,delta,delta_max,n_pixel
      integer nl
      integer *4 sum_l2_f
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering get_svd_2]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
      R_max = 2*pi*grid_p_(n_r-1)
      K_max = grid_p_(n_r-1)
      delta_max = 0.0d0
      do ndv=0,n_delta_v-1
         delta = dsqrt(delta_x_(ndv)**2 + delta_y_(ndv)**2)
         if (delta.gt.delta_max) then
            delta_max = delta
         end if
      enddo !do ndv=0,n_delta_v-1
      n_pixel = delta_max/dsqrt(2.0d0)*2*K_max
      if (verbose.gt.0) then
         write(6,'(A,F8.3,A,F8.3)') 'R_max: ',R_max,'; delta_max: '
     $        ,delta_max
         write(6,'(A,F8.3,A,F8.3)') 'K_max: ',K_max,'; n_pixel: '
     $        ,n_pixel
      end if
      if (n_pixel.gt.5 .and. flag_warning) then
         write(6,'(A,F8.3,A)') 'Warning, n_pixel ',n_pixel
     $        ,' too large in get_svd_2'
      end if
      if (eps_target.lt.1.0d-6 .and. flag_warning) then
         write(6,'(A,F8.5,A)') 'Warning, eps_target ',eps_target
     $        ,' too small in get_svd_2'
      end if
      if (.false.) then ! do nothing and continue to next line ;
      include './dir_gen_Jsvd_6/gen_Jsvd_svdpick.txt'
      end if
      if (verbose.gt.0) then
         write(6,'(A,A)') 'svd_fname: ' , svd_fname
      end if !if (verbose.gt.0) then
      include './dir_gen_Jsvd_6/gen_Jsvd_svdload.txt'
      if (verbose.gt.0) then
         write(6,'(A,I0)') 'n_svd_r: ',n_svd_r
         write(6,'(A,I0)') 'n_svd_d: ',n_svd_d
         write(6,'(A,I0)') 'n_svd_l: ',n_svd_l
         write(6,'(A,I0)') 'svd_unitnumber: ',svd_unitnumber
      end if
      n_svd_r_out = n_svd_r
      n_svd_d_out = n_svd_d
      allocate(flag_s_(0:n_svd_l-1))
      n_svd_l_out = 0
      do nl=0,n_svd_l-1
         flag_s_(nl) = .false.
         if (svd_s_(nl).lt.eps_target) then
            if (verbose.gt.1) then
               write(6,'(A,I0,A,F8.4,A)') ' nl: ' , nl , ' svd_s: ' ,
     $              svd_s_(nl) , ' skipping '
            end if !if (verbose.gt.1) then
         end if !if (svd_s_(nl).lt.eps_target) then
         if (svd_s_(nl).ge.eps_target) then
            flag_s_(nl) = .true.
            if (verbose.gt.1) then
               write(6,'(A,I0,A,F8.4,A,I0)') ' nl: ' , nl , ' svd_s: ' ,
     $              svd_s_(nl) , ' retaining; n_svd_l_out: ' ,
     $              n_svd_l_out
            end if !if (verbose.gt.1) then
            svd_l_out_(n_svd_l_out) = svd_l_(nl)
            call cp1_r8(n_svd_d,svd_U_d_(nl*n_svd_d)
     $           ,svd_U_d_out_(n_svd_l_out*n_svd_d))
            call cp1_r8(1,svd_s_(nl),svd_s_out_(n_svd_l_out))
            call cp1_r8(n_svd_r,svd_V_r_(nl*n_svd_r)
     $           ,svd_V_r_out_(n_svd_l_out*n_svd_r))
            n_svd_l_out = n_svd_l_out + 1
         end if !if (svd_s_(nl).ge.eps_target) then
      enddo !do nl=0,n_svd_l-1
      call cp1_r8(n_svd_r,svd_r_,svd_r_out_)
      call cp1_r8(n_svd_d,svd_d_,svd_d_out_)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' sum(flag_s_) ' , sum_l2_f(n_svd_l,flag_s_)
         if (verbose.gt.1) then
            call print_all_l2(n_svd_l,flag_s_,' flag_s_: ')
         end if                 !if (verbose.gt.1) then
      end if !if (verbose.gt.0) then
      deallocate(flag_s_)
      if (verbose.gt.0) then
         write(6,'(A)') '[finished get_svd_2]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> Evaluates polynomial representation of svd_U_d_. ;\n
!> This is the 'left' side of the displacement operator (involving delta). ;\n
      subroutine get_svd_polyval_U_d_(svd_d_max,n_svd_d,svd_d_,n_svd_l
     $     ,svd_l_,svd_U_d_,n_delta_v,delta_x_,delta_y_
     $     ,svd_polyval_U_d_)
      implicit none
      integer verbose
      data verbose / 0 /
      real *8 svd_d_max,svd_d_m,svd_d_c,svd_d(0:0)
      integer *4 n_svd_d,n_svd_l
      real *8 svd_d_(0:0)
      integer *4 svd_l_(0:0)
      real *8 svd_U_d_(0:0)
      real *8 svd_polyval_U_d_(0:0)
      logical flag_warning
      integer n_delta_v,ndv
      real *8 delta_x_(0:0),delta_y_(0:0)
      real *8 delta_x,delta_y,delta,omega
      integer nl
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering get_svd_polyval_U_d_]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
      svd_d_m = svd_d_max / 2.0d0
      svd_d_c = svd_d_m
      do ndv=0,n_delta_v-1
         delta_x = delta_x_(ndv)
         delta_y = delta_y_(ndv)
         if (verbose.gt.1) then
            write (6,'(A,I0,1X,F6.3,1X,F6.3)')
     $           ' % ndv dx dy : ',ndv,delta_x,delta_y
         end if                 !if (verbose.gt.1) then
         delta = dsqrt(delta_x**2 + delta_y**2)
         if (delta.gt.svd_d_max .and. flag_warning) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)') 'Warning, delta '
     $           ,delta,'>',svd_d_max,'; ratio = ',delta/svd_d_max,
     $           ' in get_svd_polyval_U_d_'
         end if
         omega = atan2(delta_y,delta_x)
         if (verbose.gt.1) then
            write (6,'(A,F6.3,1X,F6.3)') ' % delta omega : ',delta
     $           ,omega
         end if
         svd_d(0) = (delta - svd_d_m)/svd_d_c
         do nl=0,n_svd_l-1
            call polyval_r8_reverse_0(n_svd_d,svd_U_d_(0+nl*n_svd_d),1
     $           ,svd_d(0),svd_polyval_U_d_(nl+ndv*n_svd_l))
            if (verbose.gt.1) then
               write (6,'(A,F6.3,A,F6.3,A,I0,A,F8.5)') ' % delta ' ,
     $              delta , ' svd_d ' ,svd_d(0) , ' U_d_(' , nl , ') ',
     $              svd_polyval_U_d_(nl+ndv*n_svd_l)
            end if !if (verbose.gt.1) then
         enddo !do nl=0,n_svd_l-1
      enddo !do ndv=0,n_delta_v-1
      if (verbose.gt.0) then
         write(6,'(A)') '[finished get_svd_polyval_U_d_]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> Evaluates polynomial representation of svd_V_r_. ;\n
!> This is the 'right' side of the displacement operator (involving k, images and templates). ;\n
      subroutine get_svd_polyval_V_r_(svd_r_max,n_svd_r,svd_r_,n_svd_l
     $     ,svd_l_,svd_V_r_,n_r,grid_p_,svd_polyval_V_r_)
      implicit none
      integer verbose
      data verbose / 0 /
      real *8 svd_r_max,svd_r_m,svd_r_c,svd_r(0:0)
      integer *4 n_svd_r,n_svd_l
      real *8 svd_r_(0:0)
      integer *4 svd_l_(0:0)
      real *8 svd_V_r_(0:0)
      real *8 svd_polyval_V_r_(0:0)
      logical flag_warning
      integer n_r,nr
      real *8 grid_p_(0:0)
      integer nl
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering get_svd_polyval_V_r_]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
      svd_r_m = svd_r_max / 2.0d0
      svd_r_c = svd_r_m
      do nr=0,n_r-1
         if (grid_p_(nr).gt.svd_r_max .and. flag_warning) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)')
     $           'Warning, grid_p_(nr) ',grid_p_(nr),'>',svd_r_max
     $           ,'; ratio = ',grid_p_(nr)/svd_r_max
     $           ,' in get_svd_polyval_V_r_0.f'
         end if
         svd_r(0) = (grid_p_(nr) - svd_r_m)/svd_r_c
         do nl=0,n_svd_l-1
            call polyval_r8_reverse_0(n_svd_r,svd_V_r_(0+nl*n_svd_r),1
     $           ,svd_r(0),svd_polyval_V_r_(nl+nr*n_svd_l))
            if (verbose.gt.1) then
               write (6,'(A,F6.3,A,F6.3,A,I0,A,F8.5)') ' % grid_p ' ,
     $              grid_p_(nr) , ' svd_r ' ,svd_r(0) , ' V_r_(' , nl ,
     $              ') ', svd_polyval_V_r_(nl+nr*n_svd_l)
            end if !if (verbose.gt.1) then
         enddo !do nl=0,n_svd_l-1         
      enddo !do nr=0,n_r-1
      if (verbose.gt.0) then
         write(6,'(A)') '[finished get_svd_polyval_V_r_]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> Used multiple times when calling get_CTF_R_S_use. ;\n
!> Sets up linear interpolation for gamma_z. ;\n
      subroutine get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_
     $     ,gamma_z_est,ngz,CTF_R_S_use)
      implicit none
      integer n_gamma_z,ngz
      real *8 gamma_z_(0:n_gamma_z-1),gamma_z_est
      complex *16 CTF_R_S_(0:0),CTF_R_S_use
      real *8 ngz_est_v,dz_pre,dz_pos,alpha,beta
      integer ngz_est_pre,ngz_est_pos,ngz_pre,ngz_pos
      real *8 pi
      pi = 4.0*atan(1.0)
      include 'get_CTF_R_S_use_excerpt.f'
      ngz_pre = ngz + ngz_est_pre
      call periodize_i(ngz_pre,0,n_gamma_z,ngz_pre)
      ngz_pos = ngz + ngz_est_pos
      call periodize_i(ngz_pos,0,n_gamma_z,ngz_pos)
      CTF_R_S_use = beta*CTF_R_S_(ngz_pre) + alpha*CTF_R_S_(ngz_pos)
      end
!> Doxygen comment: ;\n
!> This subroutine passes blocks of the input array ;\n
!> A_ to the plan stored in fpm_back, which is generated ;\n
!> by fftw_plan_many. ;\n
!> We assume that A_ is stored with ordering ;\n
!> A_(nx + nw*n_X) ;\n
!> with the goal of performing the fft on the nw-dimension ;\n
!> (i.e., the most slowly varying index). ;\n
!> We also assume that the plan fpm_back has been ;\n
!> generated with the ordering ;\n
!> fpm_out_(nw + nx*n_w_max) ;\n
!> where the nw-dimension is the most quickly varying ;\n
!> index. ;\n
!> Due to these assumptions, we rearrange blocks of A_ ;\n
!> when we copy them into fpm_out_, and we rearrange them ;\n
!> once again when we copy them back out from fpm_in1_. ;\n
!>  ;\n
!> timing: ;\n
!> If flag_fftw.eqv..false., then we do not perform the fftw at all, ;\n
!> and instead simply copy the array A_ into and out of ;\n
!> fpm_out_ and fpm_in1_ respectively. ;\n
      subroutine dfftw_block_many_0(verbose,flag_fftw,fpm_howmany
     $     ,n_w_max,fpm_in1_,fpm_out_,fpm_back,n_X,A_)
c$$$      This subroutine passes blocks of the input array ;
c$$$      A_ to the plan stored in fpm_back, which is generated ;
c$$$      by fftw_plan_many. ;
c$$$      We assume that A_ is stored with ordering ;
c$$$      A_(nx + nw*n_X) ;
c$$$      with the goal of performing the fft on the nw-dimension ;
c$$$      (i.e., the most slowly varying index). ;
c$$$      We also assume that the plan fpm_back has been ;
c$$$      generated with the ordering ;
c$$$      fpm_out_(nw + nx*n_w_max) ;
c$$$      where the nw-dimension is the most quickly varying ;
c$$$      index. ;
c$$$      Due to these assumptions, we rearrange blocks of A_ ;
c$$$      when we copy them into fpm_out_, and we rearrange them ;
c$$$      once again when we copy them back out from fpm_in1_. ;
c$$$       ;
c$$$      timing: ;
c$$$      If flag_fftw.eqv..false., then we do not perform the fftw at all, ;
c$$$      and instead simply copy the array A_ into and out of ;
c$$$      fpm_out_ and fpm_in1_ respectively. ;
      
      implicit none
      integer verbose
      logical flag_fftw
      integer fpm_howmany,n_w_max,n_X
      complex *16 fpm_in1_(0:0),fpm_out_(0:0)
      integer *8 fpm_back
      complex *16 A_(0:0)
      integer n_block,nblock,nx_bgn,nx_end,nx_tot
      integer nx,nw,na,nf
      if (verbose.gt.0) then
         write(6,'(A)') '[entering dfftw_block_many_0]'
      end if !if (verbose.gt.0) then
      n_block = n_X/fpm_howmany
      if (mod(n_X,fpm_howmany).gt.0) then
         n_block = n_block + 1
      end if !if (mod(n_X,fpm_howmany).gt.0) then
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' fpm_howmany: ' , fpm_howmany
         write(6,'(A,I0)') ' n_w_max: ' , n_w_max
         write(6,'(A,I0)') ' n_X: ' , n_X
         write(6,'(A,I0)') ' n_block: ' , n_block
      end if !if (verbose.gt.1) then
      do nblock=0,n_block-1
         nx_bgn = nblock*fpm_howmany
         nx_end = min(n_X,(nblock+1)*fpm_howmany)
         nx_tot = nx_end-nx_bgn
         if (verbose.gt.2) then
            write(6,'(A,I0)') ' nblock: ' , nblock
            write(6,'(A,I0)') ' nx_bgn: ' , nx_bgn
            write(6,'(A,I0)') ' nx_end: ' , nx_end
            write(6,'(A,I0)') ' nx_tot: ' , nx_tot
         end if !if (verbose.gt.2) then
         if (nx_tot.gt.0) then
            nf = 0;
            do nx=nx_bgn,nx_end-1
               na = nx
               do nw=0,n_w_max-1
c$$$                  nf = nw + nx*n_w_max
c$$$                  na = nx + nw*n_X
                  fpm_out_(nf) = A_(na)
                  nf = nf + 1
                  na = na + n_X
               enddo !do nw=0,n_w_max-1
            enddo !do nx=nx_bgn,nx_end-1
            if (flag_fftw.eqv..true.) then
               call dfftw_execute_dft(fpm_back,fpm_out_,fpm_in1_)
            end if ! if (flag_fftw.eqv..true.) then
            if (flag_fftw.eqv..false.) then
               call cp1_c16(n_w_max*nx_tot,fpm_out_,fpm_in1_)
            end if ! if (flag_fftw.eqv..false.) then
            nf = 0;
            do nx=nx_bgn,nx_end-1
               na = nx
               do nw=0,n_w_max-1
c$$$                  nf = nw + nx*n_w_max
c$$$                  na = nx + nw*n_X
                  A_(na) = fpm_in1_(nf)
                  nf = nf + 1
                  na = na + n_X
               enddo !do nw=0,n_w_max-1
            enddo !do nx=nx_bgn,nx_end-1            
         end if !if (nx_tot.gt.0) then
      enddo !do nblock=0,n_block-1      
      if (verbose.gt.0) then
         write(6,'(A)') '[finished dfftw_block_many_0]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> This subroutine passes blocks of the input array ;\n
!> A_ to the plan stored in fpm_back, which is generated ;\n
!> by fftw_plan_many. ;\n
!> We assume that A_ is stored with ordering ;\n
!> A_(nx + nw*n_X_tot) ;\n
!> with the goal of performing the fft on the nw-dimension ;\n
!> (i.e., the most slowly varying index). ;\n
!> We also assume that the plan fpm_back has been ;\n
!> generated with the ordering ;\n
!> fpm_out_(nw + nx*n_w_max) ;\n
!> where the nw-dimension is the most quickly varying ;\n
!> index. ;\n
!> Due to these assumptions, we rearrange blocks of A_ ;\n
!> when we copy them into fpm_out_, and we rearrange them ;\n
!> once again when we copy them back out from fpm_in1_. ;\n
!>  ;\n
!> Note: this function is structured so that we operate only \n
!> on the entries nx ranging from 0 to n_X_sub-1.\n
!> (recall, each of these entries corresponds to a\n
!> different 'row' of A_, each of which will be copied\n
!> into a different column of fpm_out_ and operated on with\n
!> the fourier transform).\n
!>  ;\n
!> timing: ;\n
!> If flag_fftw.eqv..false., then we do not perform the fftw at all, ;\n
!> and instead simply copy the array A_ into and out of ;\n
!> fpm_out_ and fpm_in1_ respectively. ;\n
      subroutine dfftw_block_many_1(verbose,flag_fftw,fpm_howmany
     $     ,n_w_max,fpm_in1_,fpm_out_,fpm_back,n_X_sub,n_X_tot,A_)
c$$$      This subroutine passes blocks of the input array ;
c$$$      A_ to the plan stored in fpm_back, which is generated ;
c$$$      by fftw_plan_many. ;
c$$$      We assume that A_ is stored with ordering ;
c$$$      A_(nx + nw*n_X_tot) ;
c$$$      with the goal of performing the fft on the nw-dimension ;
c$$$      (i.e., the most slowly varying index). ;
c$$$      We also assume that the plan fpm_back has been ;
c$$$      generated with the ordering ;
c$$$      fpm_out_(nw + nx*n_w_max) ;
c$$$      where the nw-dimension is the most quickly varying ;
c$$$      index. ;
c$$$      Due to these assumptions, we rearrange blocks of A_ ;
c$$$      when we copy them into fpm_out_, and we rearrange them ;
c$$$      once again when we copy them back out from fpm_in1_. ;
c$$$       ;
c$$$      Note: this function is structured so that we operate only 
c$$$      on the entries nx ranging from 0 to n_X_sub-1.
c$$$      (recall, each of these entries corresponds to a
c$$$      different 'row' of A_, each of which will be copied
c$$$      into a different column of fpm_out_ and operated on with
c$$$      the fourier transform).
c$$$       ;
c$$$      timing: ;
c$$$      If flag_fftw.eqv..false., then we do not perform the fftw at all, ;
c$$$      and instead simply copy the array A_ into and out of ;
c$$$      fpm_out_ and fpm_in1_ respectively. ;
      
      implicit none
      integer verbose
      logical flag_fftw
      integer fpm_howmany,n_w_max,n_X_sub,n_X_tot
      complex *16 fpm_in1_(0:0),fpm_out_(0:0)
      integer *8 fpm_back
      complex *16 A_(0:0)
      integer n_block,nblock,nx_bgn,nx_end,nx_tot
      integer nx,nw,na,nf
      if (verbose.gt.0) then
         write(6,'(A)') '[entering dfftw_block_many_1]'
      end if !if (verbose.gt.0) then
      n_block = n_X_sub/fpm_howmany
      if (mod(n_X_sub,fpm_howmany).gt.0) then
         n_block = n_block + 1
      end if !if (mod(n_X_sub,fpm_howmany).gt.0) then
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' fpm_howmany: ' , fpm_howmany
         write(6,'(A,I0)') ' n_w_max: ' , n_w_max
         write(6,'(A,I0)') ' n_X_sub: ' , n_X_sub
         write(6,'(A,I0)') ' n_X_tot: ' , n_X_tot
         write(6,'(A,I0)') ' n_block: ' , n_block
      end if !if (verbose.gt.1) then
      do nblock=0,n_block-1
         nx_bgn = nblock*fpm_howmany
         nx_end = min(n_X_sub,(nblock+1)*fpm_howmany)
         nx_tot = nx_end-nx_bgn
         if (verbose.gt.2) then
            write(6,'(A,I0)') ' nblock: ' , nblock
            write(6,'(A,I0)') ' nx_bgn: ' , nx_bgn
            write(6,'(A,I0)') ' nx_end: ' , nx_end
            write(6,'(A,I0)') ' nx_tot: ' , nx_tot
         end if !if (verbose.gt.2) then
         if (nx_tot.gt.0) then
            nf = 0;
            do nx=nx_bgn,nx_end-1
               na = nx
               do nw=0,n_w_max-1
c$$$                  nf = nw + nx*n_w_max
c$$$                  na = nx + nw*n_X_tot
                  fpm_out_(nf) = A_(na)
                  nf = nf + 1
                  na = na + n_X_tot
               enddo !do nw=0,n_w_max-1
            enddo !do nx=nx_bgn,nx_end-1
            if (flag_fftw.eqv..true.) then
               call dfftw_execute_dft(fpm_back,fpm_out_,fpm_in1_)
            end if ! if (flag_fftw.eqv..true.) then
            if (flag_fftw.eqv..false.) then
               call cp1_c16(n_w_max*nx_tot,fpm_out_,fpm_in1_)
            end if ! if (flag_fftw.eqv..false.) then
            nf = 0;
            do nx=nx_bgn,nx_end-1
               na = nx
               do nw=0,n_w_max-1
c$$$                  nf = nw + nx*n_w_max
c$$$                  na = nx + nw*n_X_tot
                  A_(na) = fpm_in1_(nf)
                  nf = nf + 1
                  na = na + n_X_tot
               enddo !do nw=0,n_w_max-1
            enddo !do nx=nx_bgn,nx_end-1            
         end if !if (nx_tot.gt.0) then
      enddo !do nblock=0,n_block-1      
      if (verbose.gt.0) then
         write(6,'(A)') '[finished dfftw_block_many_1]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> Maintains a stack of n_SM .le. n_SM_max image parameters called alpha_SM_. ;\n
!> Each time a new set of image parameters (alpha__in) is about to be added, ;\n
!> we check the 'best' element of alpha_SM_ (ranked by label C_Z_opt) ;\n
!> to decide whether or not to actually add the new set of image parameters. ;\n
!> In this way we can ensure that the stack never references more than n_SM_max images. ;\n
      subroutine alpha_SM_update_1(n_SM_max,n_SM,alpha_SM_,alpha__in)
      implicit none
      integer verbose
      data verbose / 0 /
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM ! the actual number of templates stored for this particular image. ;
      real *8 alpha_SM_(0:0) ! array of size n_alpha*n_SM_max storing the image-parameters for each stored template-image pair for this particular image. ;
      integer nSM,nSM_sub
      logical flag_continue
      real *8, allocatable :: alpha_tmp_(:)
      real *8, allocatable :: C_Z_opt_(:)
      integer *4, allocatable :: I_permute_(:)
      external quicksort_c16
      include 'nalpha_define.f'
      real *8 alpha__in(0:n_alpha-1)
      character(len=1024) format_string

      if (verbose.gt.1) then
         write(6,'(A)') '[entering alpha_SM_update_1]'
      end if !if (verbose.gt.1) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         write(6,'(A,I0)') ' n_SM: ' , n_SM
         write(6,'(A,I0)') ' n_alpha: ' , n_alpha
         call print_sub_r8(n_alpha*n_SM_max,alpha_SM_
     $        ,' alpha_SM_: ')
         call print_all_r8(n_alpha,alpha__in
     $        ,' alpha__in_: ')
      end if !if (verbose.gt.1) then

      if (n_SM.lt.n_SM_max) then
         if (verbose.gt.1) then
            write(6,'(A,I0)') ' adding at n_SM: ' , n_SM
         end if !if (verbose.gt.1) then
         call cp1_r8(n_alpha,alpha__in,alpha_SM_(n_alpha*n_SM))
         n_SM = n_SM+1
         if (n_SM.eq.n_SM_max) then
         if (verbose.gt.1) then
            write(6,'(A,I0,A)') ' n_SM: ' , n_SM , '; sorting. '
         end if !if (verbose.gt.1) then
         call alpha_SM_sort_0(n_SM_max,n_SM,alpha_SM_)
         end if !if (n_SM.eq.n_SM_max-1) then
         goto 10
      end if !if (n_SM.lt.n_SM_max) then
      if (n_SM.eq.n_SM_max) then
         if (verbose.gt.1) then
            write(6,'(A,I0)') ' alpha_SM full; n_SM: ' , n_SM
         end if !if (verbose.gt.1) then
         flag_continue=.true.
         nSM=0
         do while (flag_continue)
            if (alpha__in(nalpha_C_Z_opt).lt.alpha_SM_(nalpha_C_Z_opt +
     $           nSM*n_alpha)) then
               flag_continue = .false.
            else
               nSM = nSM+1
               flag_continue = .true.
               if (nSM.ge.n_SM_max) then
                  flag_continue = .false.
               end if !if (nSM.ge.n_SM_max-1) then
            end if !if (alpha__in(nalpha_C_Z_opt).lt.alpha_SM_(nalpha_C_Z_opt + nSM*n_alpha)) then
         enddo !do while (flag_continue)
         if (verbose.gt.1) then
            write(6,'(A,I0)') ' alpha_SM full; insert at nSM-1 : ' , nSM
     $           -1
         end if !if (verbose.gt.1) then
         if (nSM.gt.0) then
            do nSM_sub=0,nSM-2
               if (verbose.gt.1) then
                  write(6,'(A,I0,A,I0)') ' replacing nSM ' , nSM_sub ,
     $                 ' with ' , nSM_sub+1
               end if !if (verbose.gt.1) then
               call cp1_r8(n_alpha,alpha_SM_(n_alpha*(nSM_sub+1))
     $              ,alpha_SM_(n_alpha*(nSM_sub)))
            enddo !do nSM_sub=0,nSM-2
            if (verbose.gt.1) then
               write(6,'(A,I0,A)') ' replacing nSM ' , nSM-1 ,
     $              ' with new data '
            end if !if (verbose.gt.1) then
            call cp1_r8(n_alpha,alpha__in,alpha_SM_(n_alpha*(nSM-1)))
         end if !if (nSM.gt.0) then         
         if (verbose.gt.2) then
            call alpha_SM_write_0(n_SM_max,n_SM ,alpha_SM_,13
     $           ,' alpha_SM_:  ')
         end if !if (verbose.gt.2) then
         goto 10
      end if !if (n_SM.eq.n_SM_max) then

 10   continue

      if (verbose.gt.1) then
         write(6,'(A)') '[finished alpha_SM_update_1]'
      end if !if (verbose.gt.1) then
      end
!> Doxygen comment: ;\n
!> Extracts sub-stack of n_SM image parameters from the full stack alpha_SM_, ;\n
!> Then sorts the stack by them by label C_Z_opt and puts them back in. ;\n
      subroutine alpha_SM_sort_0(n_SM_max,n_SM,alpha_SM_)
      implicit none
      integer verbose
      data verbose / 0 /
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM ! the actual number of templates stored for this particular image. ;
      real *8 alpha_SM_(0:0) ! array of size n_alpha*n_SM_max storing the image-parameters for each stored template-image pair for this particular image. ;
      integer nSM,nSM_sub
      logical flag_continue
      real *8, allocatable :: alpha_tmp_(:)
      real *8, allocatable :: C_Z_opt_(:)
      integer *4, allocatable :: I_permute_(:)
      external quicksort_c16
      include 'nalpha_define.f'
      real *8 alpha__in(0:n_alpha-1)
      character(len=1024) format_string

      if (verbose.gt.1) then
         write(6,'(A,I0,A)') ' n_SM: ' , n_SM , '; sorting. '
      end if                    !if (verbose.gt.1) then

      if (verbose.gt.2) then
         call alpha_SM_write_0(n_SM_max,n_SM,alpha_SM_,16
     $        ,' alpha_SM_ pre: ')
      end if                    !if (verbose.gt.2) then

      allocate(alpha_tmp_(0:n_alpha*n_SM_max-1))
      allocate(C_Z_opt_(0:n_SM_max-1))
      allocate(I_permute_(0:n_SM_max-1))

      do nSM=0,n_SM_max-1
         C_Z_opt_(nSM) = alpha_SM_(nalpha_C_Z_opt + nSM*n_alpha)
         I_permute_(nSM) = nSM
      enddo                     !do nSM=0,n_SM_max-1

      do nSM=0,n_SM-1
         I_permute_(nSM) = nSM
      enddo                     !do nSM=0,n_SM-1

      call quicksort_r8(0,n_SM-1,C_Z_opt_,1,I_permute_,1
     $     ,quicksort_r8)

      do nSM=0,n_SM-1
         call cp1_r8(n_alpha,alpha_SM_(n_alpha*I_permute_(nSM))
     $        ,alpha_tmp_(n_alpha*nSM))
      enddo                     !do nSM=0,n_SM-1

      call cp1_r8(n_alpha*n_SM,alpha_tmp_,alpha_SM_)

      deallocate(alpha_tmp_)
      deallocate(C_Z_opt_)
      deallocate(I_permute_)

      if (verbose.gt.2) then
         call alpha_SM_write_0(n_SM_max,n_SM,alpha_SM_,16
     $        ,' alpha_SM_ pos: ')
      end if                    !if (verbose.gt.2) then

      end
!> Doxygen comment: ;\n
!> Helper routine to display some aspects of image-parameter stack alpha_SM. ;\n
      subroutine alpha_SM_write_0(n_SM_max,n_SM,alpha_SM_,n_p
     $     ,prefix_string)
      implicit none
      integer verbose
      data verbose / 0 /
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM ! the actual number of templates stored for this particular image. ;
      real *8 alpha_SM_(0:0) ! array of size n_alpha*n_SM_max storing the image-parameters for each stored template-image pair for this particular image. ;
      integer *4 n_p
      character(len=n_p) prefix_string
      integer nSM,nSM_sub
      include 'nalpha_define.f'
      character(len=1024) format_string

      write(format_string,'(A,I0,A)') '(A,A,I2,A,' , n_alpha ,
     $     '(F10.5,1X))'
      do nSM=0,n_SM-1
         write(6,format_string) prefix_string , 'nSM ' , nSM , ': ' ,
     $           (alpha_SM_(nSM_sub),nSM_sub=n_alpha*nSM,n_alpha*nSM
     $           +n_alpha-1)
      enddo                     !do nSM=0,n_SM_max-1

      end
!> Doxygen comment: ;\n
!> This program calculates innerproducts via brute force. ;\n
      subroutine test_innerproduct_bruteforce_1(verbose ,n_r ,grid_p_
     $     ,n_w_ ,half_diameter_x_c ,S_p__in_,M_p__in_ ,CTF_p__in_
     $     ,delta_x_est ,delta_y_est ,gamma_z_est ,n_delta_v ,delta_x_
     $     ,delta_y_ ,n_gamma_z ,gamma_z_)
c$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
      implicit none
      include '/usr/include/fftw3.f'
      include 'omp_lib.h'
      integer verbose
      integer *4 n_r,n_w_(0:n_r-1)
      real *8 grid_p_(0:n_r-1),half_diameter_x_c
      complex *16 S_p__in_(0:0)
      complex *16 M_p__in_(0:0)
      complex *16 CTF_p__in_(0:0)
c$$$      array of displacements and rotations to measure
      real *8 delta_x_est,delta_y_est,gamma_z_est
      integer n_delta_v,n_gamma_z
      real *8 delta_x_(0:0)
      real *8 delta_y_(0:0)
      real *8 gamma_z_(0:0)
c$$$      fftw for local use
      integer *8, allocatable :: fftw_plan_frwd_(:)
      integer *8, allocatable :: fftw_plan_back_(:)
      complex *16, allocatable :: fftw_in1_(:)
      complex *16, allocatable :: fftw_out_(:)
      pointer (p_fftw_plan_frwd_last,fftw_plan_frwd_last)
      pointer (p_fftw_plan_back_last,fftw_plan_back_last)
      pointer (p_fftw_in1_last_,fftw_in1_last_)
      pointer (p_fftw_out_last_,fftw_out_last_)
      integer *8 fftw_plan_frwd_last,fftw_plan_back_last
      complex *16 fftw_in1_last_(*),fftw_out_last_(*)
c$$$      temporary arrays for templates and images
      complex *16, allocatable :: S_p_(:)
      complex *16, allocatable :: M_p_(:)
      complex *16, allocatable :: CTF_p_(:)
      complex *16, allocatable :: T_p_(:)
      complex *16, allocatable :: S_q_(:)
      complex *16, allocatable :: M_q_(:)
      complex *16, allocatable :: CTF_q_(:)
      complex *16, allocatable :: T_q_(:)
c$$$      temporary arrays for innerproducts
      integer *4, allocatable :: I_S_sample_(:)
      integer *4, allocatable :: I_M_sample_(:)
      complex *16, allocatable :: CTF_R_S_xx_(:)
      complex *16, allocatable :: CTF_R_S_bf_(:)
      complex *16, allocatable :: S_T_R_T_R_M_xx_(:)
      complex *16, allocatable :: S_T_R_T_R_M_bf_(:)
      complex *16, allocatable :: Z_tmp_(:)
      complex *16 C_p,C_q
      real *8 costheta_c16_f
c$$$      indices
      integer n_S,n_M,n_CTF,ld_S,ld_M,ld_CTF,nr,n_w_max,n_A,na,nC
      integer ndv,ngz,ndv_optimal,ngz_optimal,n_X
      real *8 delta_x,delta_y,gamma_z
      character(len=64) format_string
c$$$      pi
      real *8 pi
c$$$      parameters for timing
      real *8 timing_tic,timing_toc,timing_tmp,timing_tot

      if (verbose.gt.0) then
         write(6,'(A)') '[entering test_innerproduct_bruteforce_1]'
      end if      

      if (verbose.gt.1) then
         write(6,'(A)') ' Generating indices'
         write(6,'(A)') ' '
      end if
      pi = 4.0*atan(1.0)
      n_A = 0
      do nr=0,n_r-1
         n_A = n_A + n_w_(nr)
      enddo
      n_w_max = n_w_(n_r-1)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0)') 'n_A: ',n_A,'; n_w_max: ',n_w_max
         call print_all_i4(n_r,n_w_,' n_w_: ')
      end if
      ld_S = n_A
      ld_M = n_A
      ld_CTF = n_A
      n_S = 1
      n_M = 1
      n_CTF = 1

      if (verbose.gt.1) then
         write(6,'(A,F8.4)') ' delta_x_est: ' , delta_x_est
         write(6,'(A,F8.4)') ' delta_y_est: ' , delta_y_est
         write(6,'(A,F8.4)') ' gamma_z_est: ' , gamma_z_est
         call print_sub_c16(n_A,S_p__in_,' S_p__in_: ')
         call print_sub_c16(n_A,M_p__in_,' M_p__in_: ')
         call print_sub_c16(n_A,CTF_p__in_,' CTF_p__in_: ')
      end if !if (verbose.gt.1) then

      if (verbose.gt.1) then
         write(6,'(A)') 'Generating fftw_plans for local use'
         write(6,'(A)') ' '
      end if
      allocate(fftw_plan_frwd_(0:n_r-1))
      allocate(fftw_plan_back_(0:n_r-1))
      allocate(fftw_in1_(0:n_A-1))
      allocate(fftw_out_(0:n_A-1))
      timing_tic = omp_get_wtime()
      na = 0
      do nr=0,n_r-1
         call dfftw_plan_dft_1d_(fftw_plan_frwd_(nr),n_w_(nr)
     $        ,fftw_in1_(na),fftw_out_(na),FFTW_FORWARD,FFTW_MEASURE) 
         call dfftw_plan_dft_1d_(fftw_plan_back_(nr),n_w_(nr)
     $        ,fftw_out_(na),fftw_in1_(na),FFTW_BACKWARD,FFTW_MEASURE) 
         na = na + n_w_(nr)
      enddo
      timing_toc = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A,A,F8.3)') ' fftw_plan_1d:'
     $        ,' total_time ',timing_toc-timing_tic
      end if !if (verbose.gt.0) then
      p_fftw_plan_frwd_last = loc(fftw_plan_frwd_(n_r-1))
      p_fftw_plan_back_last = loc(fftw_plan_back_(n_r-1))
      p_fftw_in1_last_ = loc(fftw_in1_(n_A-n_w_max))
      p_fftw_out_last_ = loc(fftw_out_(n_A-n_w_max))

      allocate(S_p_(0:n_A-1))
      allocate(M_p_(0:n_A-1))
      allocate(CTF_p_(0:n_A-1))
      allocate(T_p_(0:n_A-1))
      allocate(S_q_(0:n_A-1))
      allocate(M_q_(0:n_A-1))
      allocate(CTF_q_(0:n_A-1))
      allocate(T_q_(0:n_A-1))
      allocate(I_S_sample_(0:0))
      I_S_sample_(0)=0
      allocate(I_M_sample_(0:0))
      I_M_sample_(0)=0

      if (verbose.gt.1) then
         write(6,'(A)') ' Allocating array CTF_R_S_xx_ to hold'
         write(6,'(A)') ' innerproducts for each CTF-S pair.'
         write(6,'(A)') ' '
      end if
      allocate(CTF_R_S_xx_(0:n_gamma_z))
      call cl1_c16(n_gamma_z,CTF_R_S_xx_)
      if (verbose.gt.1) then
         write(6,'(A)') ' Calculate CTF_R_S_xx_.'
         write(6,'(A)') ' CTF_R_S = || CTF .* R(S) ||.'
         write(6,'(A)') ' More specifically, the value: '
         write(6,'(A)') ' CTF_R_S_xx_(ngz) '
         write(6,'(A)') ' is equal to the l2_norm (not squared)'
         write(6,'(A)') ' of the pointwise product of CTF and R(S),'
         write(6,'(A)') ' where CTF is the ctf-function, '
         write(6,'(A)') ' R is rotation by +gamma_z_(ngz).'
         write(6,'(A)') ' and S is the template, '
         write(6,'(A)') ' '
      end if
      timing_tic = omp_get_wtime()
      call test_innerproduct_bruteforce_CTF_R_S_1(verbose-1,n_gamma_z
     $     ,gamma_z_,fftw_plan_frwd_,fftw_in1_,fftw_out_
     $     ,fftw_plan_back_last,fftw_in1_last_,fftw_out_last_,n_r
     $     ,grid_p_,n_w_,n_A,S_p_,S_q_,n_S,I_S_sample_,ld_S ,S_p__in_
     $     ,CTF_p_ ,CTF_q_ ,n_CTF,ld_CTF ,CTF_p__in_ ,CTF_R_S_xx_)
      timing_toc = omp_get_wtime()
      timing_tot = timing_toc - timing_tic
      if (verbose.gt.0) then
         write(6,'(A,F8.5)')
     $        ' finished calculating CTF_R_S_xx_ for each ctf-S pair. '
     $        ,timing_tot
         timing_tmp = (n_A*1.0d0)*(n_S*1.0d0)*(n_CTF*1.0d0)/timing_tot
     $        /1e9
         write(6,'(A,F8.4)') ' CTF_R_S_xx_ total Gnumps: ' , timing_tmp
         write(6,'(A)') ' '
      end if ! if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A)') ' Allocating array CTF_R_S_bf_ to hold'
         write(6,'(A)') ' innerproducts for each CTF-S pair.'
         write(6,'(A)') ' '
      end if
      allocate(CTF_R_S_bf_(0:n_gamma_z))
      call cl1_c16(n_gamma_z,CTF_R_S_bf_)
      timing_tic = omp_get_wtime()
      do ngz=0,n_gamma_z
         gamma_z = gamma_z_(ngz)
         call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,S_p__in_,+gamma_z,S_p_)
         call xx1_c16(n_A,S_p_,CTF_p__in_,S_p_)
         call innerproduct_p(n_r,grid_p_,n_w_,n_A,S_p_,S_p_,C_p)
         CTF_R_S_bf_(ngz) = zsqrt(C_p)/n_r**2
      enddo !do ngz=0,n_gamma_z
      timing_toc = omp_get_wtime()
      timing_tot = timing_toc - timing_tic
      if (verbose.gt.0) then
         write(6,'(A,F8.5)')
     $        ' finished calculating CTF_R_S_bf_ for each ctf-S pair. '
     $        ,timing_tot
         timing_tmp = (n_A*1.0d0)*(n_S*1.0d0)*(n_CTF*1.0d0)/timing_tot
     $        /1e9
         write(6,'(A,F8.4)') ' CTF_R_S_bf_ total Gnumps: ' , timing_tmp
         write(6,'(A)') ' '
      end if ! if (verbose.gt.0) then

      if (verbose.gt.1) then
         call print_all_c16(n_gamma_z,CTF_R_S_xx_,' CTF_R_S_xx_: ')
         call print_all_c16(n_gamma_z,CTF_R_S_bf_,' CTF_R_S_bf_: ')
         write(6,'(A,F8.4)') ' costheta: ' , costheta_c16_f(n_gamma_z
     $        ,CTF_R_S_xx_,CTF_R_S_bf_)
      end if !if (verbose.gt.1) then

      allocate(Z_tmp_(0:n_w_max-1))
      call cl1_c16(n_w_max,Z_tmp_)

      if (verbose.gt.1) then
         write(6,'(A)') ' Allocating array S_T_R_T_R_M_xx_ to hold'
         write(6,'(A)') ' innerproducts for each S-M pair.'
         write(6,'(A)') ' '
      end if
      allocate(S_T_R_T_R_M_xx_(0:n_delta_v*n_gamma_z))
      call cl1_c16(n_delta_v*n_gamma_z,S_T_R_T_R_M_xx_)
      if (verbose.gt.1) then
         write(6,'(A)') ' Calculate S_T_R_T_R_M_xx_.'
         write(6,'(A)') ' More specifically, the value: '
         write(6,'(A)')
     $        ' S_T_R_T_R_M_xx_(ngz + n_gamma_z*ndv) '
         write(6,'(A)') ' is equal to the innerproduct between '
         write(6,'(A)') ' R_{est}T_{est}R_{upd}T_{upd}(S) and'
         write(6,'(A)') ' conjg(CTF).*M, where CTF is the ctf-function '
         write(6,'(A)') ' R is rotation by +gamma_z_(ngz).'
         write(6,'(A)') ' and S is the template, '
         write(6,'(A)') ' '
      end if
      timing_tic = omp_get_wtime()
      call xc1_c16(n_A,M_p__in_,CTF_p__in_,M_p_)
      call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $     ,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
      call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est,
     $     -delta_y_est,M_p_)
c$$$      call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x,
c$$$     $     -delta_y,M_p_)
      call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $     ,fftw_in1_,fftw_out_,M_p_,M_q_)
      do ndv=0,n_delta_v-1
         delta_x = delta_x_(ndv)
         delta_y = delta_y_(ndv)
         call cp1_c16(n_A,S_p__in_,S_p_)
         call transf_p_to_p(n_r,grid_p_,n_w_,n_A,S_p_,delta_x,delta_y
     $        ,S_p_)
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,S_p_,S_q_)
         call innerproduct_q_k_stretch_0(n_r,grid_p_,n_w_
     $        ,n_A,S_q_,M_q_,Z_tmp_)
         call cp1_c16(n_w_max,Z_tmp_,fftw_out_last_)
         call dfftw_execute_(fftw_plan_back_last)
         call cp1_c16(n_w_max,fftw_in1_last_,Z_tmp_)
         if (verbose.gt.1) then
            write(6,'(A,I0)') ' ndv ' , ndv
            call print_sub_c16(n_w_max,Z_tmp_,' Z_tmp: ')
         end if !if (verbose.gt.1) then
         do ngz=0,n_gamma_z-1
            gamma_z = gamma_z_(ngz)
            call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $           ,C_q)
            nC = ngz + n_gamma_z*ndv
            S_T_R_T_R_M_xx_(nC) = C_q/(n_r**4)
            enddo !do ngz=0,n_gamma_z-1
      enddo !do ndv=0,n_delta_v-1
      timing_toc = omp_get_wtime()
      timing_tot = timing_toc - timing_tic
      if (verbose.gt.0) then
         write(6,'(A,A,F8.5)') ' finished calculating S_T_R_T_R_M_xx_ '
     $        , ' for each S-M pair. ' ,timing_tot
         timing_tmp = (n_A*1.0d0)*(n_S*1.0d0)*(n_M*1.0d0)/timing_tot
     $        /1e9
         write(6,'(A,F8.4)') ' S_T_R_T_R_M_xx total Gnumps: ' ,
     $        timing_tmp
         write(6,'(A)') ' '
      end if ! if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A)') ' Allocating array S_T_R_T_R_M_bf_ to hold'
         write(6,'(A)') ' innerproducts for each S-M pair.'
         write(6,'(A)') ' '
      end if
      allocate(S_T_R_T_R_M_bf_(0:n_delta_v*n_gamma_z))
      call cl1_c16(n_delta_v*n_gamma_z,S_T_R_T_R_M_bf_)
      timing_tic = omp_get_wtime()
      call xc1_c16(n_A,M_p__in_,CTF_p__in_,M_p_)
      call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $     ,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
      call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est,
     $     -delta_y_est,M_p_)
      do ndv=0,n_delta_v-1
         delta_x = delta_x_(ndv)
         delta_y = delta_y_(ndv)
         do ngz=0,n_gamma_z-1
            gamma_z = gamma_z_(ngz)
            call cp1_c16(n_A,S_p__in_,S_p_)
            call transf_p_to_p(n_r,grid_p_,n_w_,n_A,S_p_,delta_x
     $           ,delta_y,S_p_)
            call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,S_p_,gamma_z,S_p_)
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,S_p_,M_p_,C_p)
            nC = ngz + n_gamma_z*ndv
            S_T_R_T_R_M_bf_(nC) = C_p/(n_r**4)
         enddo                  !do ngz=0,n_gamma_z-1
      enddo !do ndv=0,n_delta_v-1
      timing_toc = omp_get_wtime()
      timing_tot = timing_toc - timing_tic
      if (verbose.gt.0) then
         write(6,'(A,A,F8.5)') ' finished calculating S_T_R_T_R_M_bf_ '
     $        , ' for each S-M pair. ' ,timing_tot
         timing_tmp = (n_A*1.0d0)*(n_S*1.0d0)*(n_M*1.0d0)/timing_tot
     $        /1e9
         write(6,'(A,F8.4)') ' S_T_R_T_R_M_bf total Gnumps: ' ,
     $        timing_tmp
         write(6,'(A)') ' '
      end if ! if (verbose.gt.0) then

      if (verbose.gt.0) then
         do ndv=0,n_delta_v-1
            delta_x = delta_x_(ndv)
            delta_y = delta_y_(ndv)
            write(6,'(A,I0)') ' ndv ' , ndv
            n_X = n_gamma_z*ndv
            call print_sub_c16(n_gamma_z ,S_T_R_T_R_M_xx_(n_X)
     $           ,' S_T_R_T_R_M_xx_: ')
            call print_sub_c16(n_gamma_z ,S_T_R_T_R_M_bf_(n_X)
     $           ,' S_T_R_T_R_M_bf_: ')
            write(6,'(A,F8.4)') ' costheta: ' ,
     $           costheta_c16_f(n_gamma_z,S_T_R_T_R_M_xx_(n_X)
     $           ,S_T_R_T_R_M_bf_(n_X))
         enddo                  !do ndv=0,n_delta_v-1
      end if                    !if (verbose.gt.0) then

      deallocate(S_p_)
      deallocate(M_p_)
      deallocate(CTF_p_)
      deallocate(T_p_)
      deallocate(S_q_)
      deallocate(M_q_)
      deallocate(CTF_q_)
      deallocate(T_q_)
      if (verbose.gt.1) then
         write(6,'(A)') ' Destroying fftw_plans for local use.'
      end if
      do nr=0,n_r-1
         call dfftw_destroy_plan(fftw_plan_frwd_(nr))
         call dfftw_destroy_plan(fftw_plan_back_(nr))
      enddo !do nr=0,n_r-1
      deallocate(fftw_plan_frwd_)
      deallocate(fftw_plan_back_)
      deallocate(fftw_in1_)
      deallocate(fftw_out_)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished test_innerproduct_bruteforce_1]'
      end if      

      end
!> Doxygen comment: ;\n
!> This is used to calculate innerproducts via brute force. ;\n
!> Calculates :  ;\n
!> CTF_R_S_(ngz + n_gamma_z*(ns + n_S*(nctf))) = Z_q_(ngz), ;\n
!> where: ;\n
!> Z_q_(ngz) = \| CTF_p_(nctf) .* R(ngz) ( S_p__(ns*ld_S) ) \|_{L^{2}} ,  ;\n
!> where: ;\n
!> ".*" is a pointwise product,  ;\n
!> CTF_p_ is a CTF-function given on nonuniform polar grid, ;\n
!> S_p_ is a template given on a nonuniform polar grid, ;\n
!> and R is rotation by +gamma_z_(ngz). ;\n
!> (see test_innerproduct_timing_dr.f for examples). ;\n
!> This calculation is carried out by considering ;\n
!> the bessel-function expansions of:  ;\n
!> conjg(CTF_p_).*(CTF_p_) ;\n
!> and ;\n
!> conjg(S_p_).*(S_p_), ;\n
!> and appealing to the fft. ;\n
      subroutine test_innerproduct_bruteforce_CTF_R_S_1(verbose
     $     ,n_gamma_z,gamma_z_,fftw_plan_frwd_,fftw_in1_,fftw_out_
     $     ,fftw_plan_back_last,fftw_in1_last_,fftw_out_last_,n_r
     $     ,grid_p_,n_w_,n_A,S_p_,S_q_,n_S,I_S_sample_,ld_S,S_p__,CTF_p_
     $     ,CTF_q_ ,n_CTF ,ld_CTF ,CTF_p__,CTF_R_S_)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      Calculates : 
c$$$      CTF_R_S_(ngz + n_gamma_z*(ns + n_S*(nctf))) = Z_q_(ngz),
c$$$      where:
c$$$      Z_q_(ngz) = \| CTF_p_(nctf) .* R(ngz) ( S_p__(ns*ld_S) ) \|_{L^{2}} , 
c$$$      where:
c$$$      ".*" is a pointwise product, 
c$$$      CTF_p_ is a CTF-function given on nonuniform polar grid,
c$$$      S_p_ is a template given on a nonuniform polar grid,
c$$$      and R is rotation by +gamma_z_(ngz).
c$$$      (see test_innerproduct_timing_dr.f for examples).
c$$$      This calculation is carried out by considering
c$$$      the bessel-function expansions of: 
c$$$      conjg(CTF_p_).*(CTF_p_)
c$$$      and
c$$$      conjg(S_p_).*(S_p_),
c$$$      and appealing to the fft.
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_gamma_z
      integer n_r,n_w_(0:n_r-1),n_A,n_S,I_S_sample_(0:n_S-1),ld_S,n_CTF
     $     ,ld_CTF
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1),fftw_plan_back_last
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 fftw_in1_last_(0:0),fftw_out_last_(0:0)
      complex *16 Z_q
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 CTF_R_S_(0:0)
      complex *16, allocatable :: Z_tmp_(:)
      complex *16 Z_tmp
      integer n_w_max,nr,ngz,nw,ns,nctf
      real *8 gamma_z
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[entering test_innerproduct_bruteforce_CTF_R_S_1]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)
      allocate(Z_tmp_(0:n_w_max-1))
      call cl1_c16(n_w_max,Z_tmp_)
      do ns=0,n_S-1
         call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
         if (verbose.gt.2) then
            call innerproduct_p(n_r,grid_p_,n_w_,n_A
     $           ,S_p__(I_S_sample_(ns)*ld_S),S_p__(I_S_sample_(ns)
     $           *ld_S),Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,I0,A,F8.4,1X,F8.4)') '|S_p__(',ns,'*ld_S)|: ' ,
     $           Z_tmp
         end if                 !if (verbose.gt.2) then
         do nctf=0,n_CTF-1
            call cp1_c16(n_A,CTF_p__(nctf*ld_CTF),CTF_p_)
            call xc1_c16(n_A,S_p_,S_p_,S_q_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,S_q_,S_q_)
            call xc1_c16(n_A,CTF_p_,CTF_p_,CTF_q_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,CTF_q_,CTF_q_)
            call innerproduct_q_k_stretch_0(n_r,grid_p_,n_w_
     $           ,n_A,S_q_,CTF_q_,Z_tmp_)
            call cp1_c16(n_w_max,Z_tmp_,fftw_out_last_)
            call dfftw_execute_(fftw_plan_back_last)
            call cp1_c16(n_w_max,fftw_in1_last_,Z_tmp_)
            do ngz=0,n_gamma_z-1
               gamma_z = gamma_z_(ngz)
               call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $              ,Z_q)
               CTF_R_S_(ngz + ns*n_gamma_z + nctf*n_gamma_z*n_S) =
     $              zsqrt(Z_q)/(n_r**2)
            enddo !do ngz=0,n_gamma_z-1
            if (verbose.gt.2) then
               call print_sub_c16(n_gamma_z,CTF_R_S_(0+ns*n_gamma_z+nctf
     $              *n_gamma_z*n_S),'CTF_R_S_: ')
            end if !if (verbose.gt.2) then
         enddo !do nctf=0,n_CTF-1
      enddo !do ns=0,n_S-1
      deallocate(Z_tmp_)
      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[finished test_innerproduct_bruteforce_CTF_R_S_1]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> This program actually calculates the innerproducts ;\n
!> across n_S templates and n_M images: ;\n
!> ;\n
!> Global search proceeds as follows: ;\n
!> For each 0-level S-block: ;\n
!>     For each 0-level M-block: ;\n
!>         Define 1-level S-blocking. ;\n
!>         Define 1-level M-blocking. ;\n
!>         For each 1-level S-block: ;\n
!>             For each 1-level M-block: ;\n
!>                 Calculate innerproducts using omp. ;\n
!>                 (i.e., using 9-level S- and M-blocks). ;\n
!>             end 1-level M-block. ;\n
!>         end 1-level S-block. ;\n
!>     end 0-level M-block. ;\n
!> end 0-level S-block. ;\n
!> ;\n
!> Local search proceeds as follows: ;\n
!> For each 0-level S-block: ;\n
!>     Define 9-level M-blocking. ;\n
!>     Use omp to parallelize across 9-level M-blocks. ;\n
!>     For each 9-level M-block: ;\n
!>         For each image in M-block: ;\n
!>             Search tesselation tree for appropriate templates. ;\n
!>             Calculate innerproducts across those templates. ;\n
!>             Here we use nS_1_per_max as an upper bound for the ;\n
!>             number of templates processed at a single time. ;\n
!>         end image. ;\n
!>     end 9-level M-block. ;\n
!> end 0-level S-block. ;\n
      subroutine test_innerproduct_8(
      include 'ti8_list_var_external_0.f'
     $     )
      include 'ti8_define_var_allocation__on_0.f'
      include 'ti8_entering_0.f'
      include 'ti8_allocate_variable_0.f'
      include 'ti8_define_svdd_3.f'
      include 'ti8_define_fftw_local_0.f'
      include 'ti8_define_fftw_omp_0.f'
      include 'ti8_define_fftw_fpm_0.f'
      include 'ti8_checkset_variable_0.f'
      do nS_0_sub=0,n_S_0_sub_use-1
         nS_0_per = n_S_0_per_(nS_0_sub)
         nS_0_sum = n_S_0_sum_(nS_0_sub)
         n_S_9_sub_use = min(n_omp_sub__in,nS_0_per)
      include 'ti8_checkset_variable_0.f'
         call block_0(verbose-2,n_S_9_sub_use,nS_0_per,n_S_9_per_
     $        ,n_S_9_sum_,n_S_9_sub_use,nS_9_per_min,nS_9_per_max)
      include 'ti8_checkset_variable_0.f'
         include 'ti8_define_CTF_R_S_0.f'
      include 'ti8_checkset_variable_0.f'
         include 'ti8_define_O_S_q_0.f'
      include 'ti8_checkset_variable_0.f'
         include 'ti8_define_T_S_q_0.f'
      include 'ti8_checkset_variable_0.f'
         include 'ti8_define_Z_S_q_0.f'
      include 'ti8_checkset_variable_0.f'
         if (tesselation_distance_req.ge.2.0d0) then
            call ti8_global_0(
            include 'ti8_list_var_external_0.f'
            include 'ti8_list_var_internal_0.f'
     $           )
         else !if (tesselation_distance_req.ge.2.0d0) then
            include 'ti8_define_tesselation_0.f'
            call ti8_local_0(
            include 'ti8_list_var_external_0.f'
            include 'ti8_list_var_internal_0.f'
     $           )
         end if !if (tesselation_distance_req.ge.2.0d0) then
      include 'ti8_checkset_variable_0.f'
      enddo !do nS_0_sub=0,n_S_0_sub_use-1
      include 'ti8_checkset_variable_0.f'
      include 'ti8_deallocate_0.f'
      include 'ti8_finished_1.f'
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Calculates :  ;\n
!> CTF_R_S__(ngz + n_gamma_z*(nctf + n_CTF*ns)) = Z_q_(ngz), ;\n
!> where: ;\n
!> Z_q_(ngz) = \| CTF_p_(nctf) .* R(ngz) ( S_p__(ns*ld_S) ) \|_{L^{2}} ,  ;\n
!> where: ;\n
!> ".*" is a pointwise product,  ;\n
!> CTF_p_ is a CTF-function given on nonuniform polar grid, ;\n
!> S_p_ is a template given on a nonuniform polar grid, ;\n
!> and R is rotation by +gamma_z_(ngz). ;\n
!> (see test_innerproduct_timing_dr.f for examples). ;\n
!> This calculation is carried out by considering ;\n
!> the bessel-function expansions of:  ;\n
!> conjg(CTF_p_).*(CTF_p_) ;\n
!> and ;\n
!> conjg(S_p_).*(S_p_), ;\n
!> and appealing to the fft. ;\n
      subroutine ti8_build_CTF_R_S_3(verbose,n_gamma_z
     $     ,gamma_z_,fftw_plan_frwd_,fftw_plan_back_,fftw_in1_,fftw_out_
     $     ,n_r,grid_p_,n_w_,n_A ,S_p_,S_q_,n_S,I_S_sample_,ld_S,S_p__
     $     ,CTF_p_ ,CTF_q_ ,n_CTF ,ld_CTF ,CTF_p__,CTF_R_S__,Z_q_)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      Calculates : 
c$$$      CTF_R_S__(ngz + n_gamma_z*(nctf + n_CTF*ns)) = Z_q_(ngz),
c$$$      where:
c$$$      Z_q_(ngz) = \| CTF_p_(nctf) .* R(ngz) ( S_p__(ns*ld_S) ) \|_{L^{2}} , 
c$$$      where:
c$$$      ".*" is a pointwise product, 
c$$$      CTF_p_ is a CTF-function given on nonuniform polar grid,
c$$$      S_p_ is a template given on a nonuniform polar grid,
c$$$      and R is rotation by +gamma_z_(ngz).
c$$$      (see test_innerproduct_timing_dr.f for examples).
c$$$      This calculation is carried out by considering
c$$$      the bessel-function expansions of: 
c$$$      conjg(CTF_p_).*(CTF_p_)
c$$$      and
c$$$      conjg(S_p_).*(S_p_),
c$$$      and appealing to the fft.
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_gamma_z
      integer n_r,n_w_(0:n_r-1),n_A,n_S,I_S_sample_(0:n_S-1),ld_S,n_CTF
     $     ,ld_CTF
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      pointer (p_fftw_plan_back_last,fftw_plan_back_last)
      pointer (p_fftw_in1_last_,fftw_in1_last_)
      pointer (p_fftw_out_last_,fftw_out_last_)
      integer *8 fftw_plan_back_last
      complex *16 fftw_in1_last_(0:0),fftw_out_last_(0:0)
      complex *16 Z_q_(0:0)
      complex *16 Z_q
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 CTF_R_S__(0:0)
      integer n_w_max,nr,ngz,nw,ns,nctf
      real *8 gamma_z
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_build_CTF_R_S_3]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         call print_sub_c16(n_A,fftw_in1_,' fftw_in1_: ')
         call print_sub_c16(n_A,fftw_out_,' fftw_out_: ')
         write(6,'(A,I0)') ' n_r: ' , n_r
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         call print_sub_c16(n_A,S_p_,' S_p_: ')
         call print_sub_c16(n_A,S_q_,' S_q_: ')
         write(6,'(A,I0)') ' n_S: ' , n_S
         call print_sub_i4(n_S,I_S_sample_,' I_S_sample_: ')
         write(6,'(A,I0)') ' ld_S: ' , ld_S
         call print_sub_c16(I_S_sample_(n_S-1)*ld_S,S_p__,' S_p__: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         write(6,'(A,I0)') ' ld_CTF: ' , ld_CTF
         call print_sub_c16(n_CTF*ld_CTF,CTF_p__,' CTF_p__: ')
         call print_sub_c16(n_gamma_z*n_CTF*n_S,CTF_R_S__,'CTF_R_S__: ')
         call print_sub_c16(n_A,Z_q_,' Z_q_: ')
      end if !if (verbose.gt.1) then

      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)
      if (verbose.gt.1) then
         write(6,'(A,I0)') ' n_w_max: ' , n_w_max
         write(6,'(A)') ' linking fftw_plan_back_last, etc. '
      end if !if (verbose.gt.1) then      
      p_fftw_plan_back_last = loc(fftw_plan_back_(n_r-1))
      p_fftw_in1_last_ = loc(fftw_in1_(n_A-n_w_max))
      p_fftw_out_last_ = loc(fftw_out_(n_A-n_w_max))
      if (verbose.gt.1) then
         write(6,'(A)') ' clearing Z_q_. '
      end if !if (verbose.gt.1) then      
      call cl1_c16(n_w_max,Z_q_)
      do ns=0,n_S-1
         if (verbose.gt.2) then
            write(6,'(A,I0)') ' ns: ' , ns
         end if !if (verbose.gt.2) then      
         call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
         if (verbose.gt.2) then
            call innerproduct_p(n_r,grid_p_,n_w_,n_A
     $           ,S_p__(I_S_sample_(ns)*ld_S),S_p__(I_S_sample_(ns)
     $           *ld_S),Z_q)
            Z_q = zsqrt(Z_q)/(n_r*n_r)
            write(6,'(A,I0,A,F8.4,1X,F8.4)') ' |S_p__(',ns,'*ld_S)|: ' ,
     $           Z_q
         end if                 !if (verbose.gt.2) then
         do nctf=0,n_CTF-1
            if (verbose.gt.2) then
               write(6,'(A,I0)') ' nctf: ' , nctf
            end if !if (verbose.gt.2) then      
            call cp1_c16(n_A,CTF_p__(nctf*ld_CTF),CTF_p_)
            call xc1_c16(n_A,S_p_,S_p_,S_q_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,S_q_,S_q_)
            call xc1_c16(n_A,CTF_p_,CTF_p_,CTF_q_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,CTF_q_,CTF_q_)
            call innerproduct_q_k_stretch_0(n_r,grid_p_,n_w_
     $           ,n_A,S_q_,CTF_q_,Z_q_)
            call cp1_c16(n_w_max,Z_q_,fftw_out_last_)
            call dfftw_execute_(fftw_plan_back_last)
            call cp1_c16(n_w_max,fftw_in1_last_,Z_q_)
            do ngz=0,n_gamma_z-1
               gamma_z = gamma_z_(ngz)
               call interp1_c16(n_w_max,0.0d0,2*pi,Z_q_,+gamma_z
     $              ,Z_q)
               CTF_R_S__(ngz + n_gamma_z*(nctf + n_CTF*ns)) = zsqrt(Z_q)
     $              /(n_r**2)
            enddo !do ngz=0,n_gamma_z-1
            if (verbose.gt.2) then
               call print_sub_c16(n_gamma_z,CTF_R_S__(0+n_gamma_z*(nctf
     $              + n_CTF*ns)),' CTF_R_S__: ')
            end if !if (verbose.gt.2) then
         enddo !do nctf=0,n_CTF-1
      enddo !do ns=0,n_S-1
      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_build_CTF_R_S_3]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Calculate bessel coefficients of S. ;\n
!> S = template in k-space polar coord. ;\n
!> O_S_q__(nr + n_r*(ns + n_S_tot*nw)) ;\n
!> is equal to the bessel-coefficients ;\n
!> conjg(S_q_(ic)) ;\n
!> for ic = nw + n_w_csum_(nr), ;\n
!> where S_q_ = S, with ;\n
!> S <-- S_p__(ns*ld_S). ;\n
      subroutine ti8_build_O_S_q_1(verbose,fftw_plan_frwd_
     $     ,fftw_in1_,fftw_out_ ,n_r,grid_p_,n_w_,n_A,S_p_,S_q_,n_S_sub
     $     ,I_S_sample_,ld_S,S_p__ ,n_S_tot ,O_S_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      Calculate bessel coefficients of S.
c$$$      S = template in k-space polar coord.
c$$$      O_S_q__(nr + n_r*(ns + n_S_tot*nw))
c$$$      is equal to the bessel-coefficients
c$$$      conjg(S_q_(ic))
c$$$      for ic = nw + n_w_csum_(nr),
c$$$      where S_q_ = S, with
c$$$      S <-- S_p__(ns*ld_S).
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_r,n_w_(0:n_r-1),n_A,n_S_sub,I_S_sample_(0:0)
     $     ,n_S_tot,ld_S
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 Z_q
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 O_S_q__(0:0)
      complex *16 Z_tmp
      integer n_w_max,nr,nw,ns
      integer nx,ld_X
      logical flag_conjg
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_build_O_S_q_1]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      do ns=0,n_S_sub-1
         if (verbose.gt.2) then
            call innerproduct_p(n_r,grid_p_,n_w_,n_A
     $           ,S_p__(I_S_sample_(ns)*ld_S)
     $           ,S_p__(I_S_sample_(ns)*ld_S),Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,I0,A,F8.4,1X,F8.4)') '|S_p_(',ns,')|: ' , Z_tmp
            call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $           ,fftw_in1_,fftw_out_,S_p_,S_q_)
            call print_sub_c16(n_A,S_q_,'S_q_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,S_q_,S_q_,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,I0,A,F8.4,1X,F8.4)') '|S_q_(',ns,')|: ' , Z_tmp
         end if !if (verbose.gt.2) then
         call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_
     $        ,n_A,fftw_in1_,fftw_out_,S_p_,S_q_)
         flag_conjg = .true.
         nx = 0 + n_r*ns
         ld_X = n_r*n_S_tot
         call innerproduct_q_stretch_0(n_r,grid_p_,n_w_,n_A,S_q_
     $        ,flag_conjg,ld_X,O_S_q__(nx))
         if (verbose.gt.2) then
            write(6,'(A,I0)') ' ns: ' , ns 
            call print_sub_c16(n_A,S_q_,'S_q_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,S_q_,S_q_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|S_q_|: ' , Z_tmp
         end if ! if (verbose.gt.2) then
      enddo ! do ns=0,n_S_sub-1

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_build_O_S_q_1]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Calculate bessel coefficients of T(S). ;\n
!> T = translation by delta_x,delta_y. ;\n
!> S = template in k-space polar coord. ;\n
!> T_S_q__(nr + n_r*(ndv + n_delta_v*(ns + n_S_tot*nw))) ;\n
!> is equal to the bessel-coefficients ;\n
!> conjg(S_q_(ic)) ;\n
!> for ic = nw + n_w_csum_(nr), ;\n
!> where S_q_ = T(S), with ;\n
!> T <-- delta_x_(ndv) and delta_y_(ndv) ;\n
!> and S <-- S_p__(ns*ld_S). ;\n
      subroutine ti8_build_T_S_q_4(verbose,n_delta_v
     $     ,delta_x_,delta_y_,fftw_plan_frwd_,fftw_in1_
     $     ,fftw_out_ ,n_r,grid_p_,n_w_,n_A,S_p_,S_q_,n_S_sub
     $     ,I_S_sample_,ld_S,S_p__ ,n_S_tot ,T_S_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      Calculate bessel coefficients of T(S).
c$$$      T = translation by delta_x,delta_y.
c$$$      S = template in k-space polar coord.
c$$$      T_S_q__(nr + n_r*(ndv + n_delta_v*(ns + n_S_tot*nw)))
c$$$      is equal to the bessel-coefficients
c$$$      conjg(S_q_(ic))
c$$$      for ic = nw + n_w_csum_(nr),
c$$$      where S_q_ = T(S), with
c$$$      T <-- delta_x_(ndv) and delta_y_(ndv)
c$$$      and S <-- S_p__(ns*ld_S).
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_delta_v
      integer n_r,n_w_(0:n_r-1),n_A,n_S_sub,I_S_sample_(0:0)
     $     ,n_S_tot,ld_S
      real *8 delta_x_(0:n_delta_v-1)
      real *8 delta_y_(0:n_delta_v-1)
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 Z_q
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 T_S_q__(0:0)
      complex *16 Z_tmp
      integer n_w_max,nr,nw,ns
      integer ndv,nx,ld_X
      logical flag_conjg
      real *8 delta_x,delta_y
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_build_T_S_q_4]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      do ns=0,n_S_sub-1
         if (verbose.gt.2) then
            call innerproduct_p(n_r,grid_p_,n_w_,n_A
     $           ,S_p__(I_S_sample_(ns)*ld_S)
     $           ,S_p__(I_S_sample_(ns)*ld_S),Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,I0,A,F8.4,1X,F8.4)') '|S_p_(',ns,')|: ' , Z_tmp
            call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $           ,fftw_in1_,fftw_out_,S_p_,S_q_)
            call print_sub_c16(n_A,S_q_,'S_q_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,S_q_,S_q_,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,I0,A,F8.4,1X,F8.4)') '|S_q_(',ns,')|: ' , Z_tmp
         end if                 !if (verbose.gt.2) then
         do ndv=0,n_delta_v-1
            delta_x = delta_x_(ndv)
            delta_y = delta_y_(ndv)
            call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
            call transf_p_to_p(n_r,grid_p_,n_w_
     $           ,n_A,S_p_,+delta_x,+delta_y,S_p_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,S_p_,S_q_)
            flag_conjg = .true.
            nx = 0 + n_r*(ndv + n_delta_v*ns)
            ld_X = n_r*n_delta_v*n_S_tot
            call innerproduct_q_stretch_0(n_r,grid_p_,n_w_,n_A,S_q_
     $           ,flag_conjg,ld_X,T_S_q__(nx))
            if (verbose.gt.2) then
               write(6,'(A,I0,A,I0)') ' ns: ' , ns , ' ndv: ' , ndv
               call print_sub_c16(n_A,S_q_,'S_q_: ')
               call innerproduct_p(n_r,grid_p_,n_w_,n_A,S_q_,S_q_
     $              ,Z_tmp)
               Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
               write(6,'(A,F8.4,1X,F8.4)') '|S_q_|: ' , Z_tmp
            end if              ! if (verbose.gt.2) then
         enddo                  !do ndv=0,n_delta_v-1
      enddo                     ! do ns=0,n_S_sub-1

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_build_T_S_q_4]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Calculate bessel coefficients of Z(S). ; ;\n
!> Z = svd of translation operator.  ; ;\n
!> S = template in k-space polar coord. ; ;\n
!> Z_S_q__(nr + n_r*(nl + n_svd_l*(ns + n_S_tot*nw)))  ; ;\n
!> is equal to the bessel-coefficients ; ;\n
!> conjg(S_q_(ic))  ; ;\n
!> for ic = nw + n_w_csum_(nr), ; ;\n
!> where S_q_ = Z(S), with  ; ;\n
!> Z representing the left-hand factor  ; ;\n
!> of the translation-operator ; ;\n
!> associated with delta, ; ;\n
!> and S <-- S_p__(ns*ld_S). ; ;\n
!> Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ; ;\n
      subroutine ti8_build_Z_S_q_5(verbose,svd_r_max,n_svd_r
     $     ,svd_r_,n_svd_l,svd_l_,svd_s_,svd_V_r_,svd_polyval_V_r_
     $     ,fftw_plan_frwd_ ,fftw_in1_,fftw_out_ ,n_r,grid_p_,n_w_,n_A
     $     ,S_p_,S_q_,n_S_sub ,I_S_sample_,ld_S,S_p__ ,n_S_tot,Z_S_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      Calculate bessel coefficients of Z(S). ;
c$$$      Z = svd of translation operator.  ;
c$$$      S = template in k-space polar coord. ;
c$$$      Z_S_q__(nr + n_r*(nl + n_svd_l*(ns + n_S_tot*nw)))  ;
c$$$      is equal to the bessel-coefficients ;
c$$$      conjg(S_q_(ic))  ;
c$$$      for ic = nw + n_w_csum_(nr), ;
c$$$      where S_q_ = Z(S), with  ;
c$$$      Z representing the left-hand factor  ;
c$$$      of the translation-operator ;
c$$$      associated with delta, ;
c$$$      and S <-- S_p__(ns*ld_S). ;
c$$$      Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical warning_flag
      data warning_flag / .true. /
      integer n_svd_r,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_r_(0:n_svd_r-1),svd_s_(0:n_svd_l-1)
      real *8 svd_V_r_(0:n_svd_r*n_svd_l-1)
      real *8 svd_polyval_V_r_(0:n_svd_l*n_r-1)
      integer n_r,n_w_(0:n_r-1),n_A,n_S_sub,I_S_sample_(0:0)
     $     ,n_S_tot,ld_S
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 Z_q
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 Z_S_q__(0:0)
      complex *16 Z_tmp,C_q
      integer n_w_max,ic_store,ic,ict,icr,nr,nw,nwt,nwr,nw_fix,nw_C,ns
      integer n_w_t ! positive threshold for overflow. ;
      integer nwc ! centered nw. ;
      integer nwd ! displaced nw. ;
      logical flag_ic0_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_ict_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_icr_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      integer nx,ld_X
      real *8 R_q,R_pos,R_pre,dr,dw,dA,dAn,dsqrt_dAn
      real *8 svd_r_max,svd_r_m,svd_r_c,svd_r(0:0)
      real *8 D_V_r,D_s
      integer nl,I_l
      real *8 pi
      integer, allocatable :: n_X_(:)
c$$$      real *8, allocatable :: V_r_(:)
      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_build_Z_S_q_5]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
c$$$      allocate(V_r_(0:n_svd_l*n_r-1))
      svd_r_m = svd_r_max / 2.0
      svd_r_c = svd_r_m
      n_w_max = n_w_(n_r-1)
      if (verbose.gt.1) then
         write(6,'(A,I0)') ' % n_w_max ',n_w_max
      end if
      if (verbose.gt.2) then
         allocate(n_X_(0:n_r*n_svd_l*n_w_max-1))
         call cl1_i4(n_r*n_svd_l*n_w_max,n_X_)
      end if !if (verbose.gt.2) then
      do nr=0,n_r-1
         if (grid_p_(nr).gt.svd_r_max .and. warning_flag) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)')
     $           'Warning, grid_p_(nr) ',grid_p_(nr),'>',svd_r_max
     $           ,'; ratio = ',grid_p_(nr)/svd_r_max
     $           ,' in ti8_build_Z_S_q_5.f'
         end if
         svd_r(0) = (grid_p_(nr) - svd_r_m)/svd_r_c
c$$$         do nl=0,n_svd_l-1
c$$$            call polyval_r8_reverse_0(n_svd_r,svd_V_r_(0+nl*n_svd_r),1
c$$$     $           ,svd_r(0),V_r_(nl+nr*n_svd_l))
c$$$         enddo !do nl=0,n_svd_l-1         
      enddo !do nr=0,n_r-1
      ld_X = n_r*n_svd_l*n_S_tot
      do ns=0,n_S_sub-1
         if (verbose.gt.2) then
            call innerproduct_p(n_r,grid_p_,n_w_,n_A
     $           ,S_p__(I_S_sample_(ns)*ld_S)
     $           ,S_p__(I_S_sample_(ns)*ld_S),Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,I0,A,F8.4,1X,F8.4)') '|S_p_(',ns,')|: ' , Z_tmp
            call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $           ,fftw_in1_,fftw_out_,S_p_,S_q_)
            call print_sub_c16(n_A,S_q_,'S_q_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,S_q_,S_q_,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,I0,A,F8.4,1X,F8.4)') '|S_q_(',ns,')|: ' , Z_tmp
         end if                 !if (verbose.gt.2) then
         call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_) 
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $        ,fftw_in1_,fftw_out_,S_p_,S_q_)         
         if (verbose.gt.2) then
            call cl1_i4(n_r*n_svd_l*n_w_max,n_X_)
         end if !if (verbose.gt.2) then
         ic = 0
         do nr=0,n_r-1
            if (nr.gt.0) then
               R_pre = 0.5*(grid_p_(nr-1) + grid_p_(nr))
            else
               R_pre = grid_p_(0)
            end if !if (nr.gt.0) then
            if (nr.lt.n_r-1) then
               R_pos = 0.5*(grid_p_(nr+1) + grid_p_(nr))
            else 
               R_pos = grid_p_(n_r-1)
            end if !if (nr.lt.n_r-1) then
            dr = R_pos - R_pre
c$$$  We set the zero-mode to zero
            if (grid_p_(nr).le.0.0d0) then
               dr = 0.0d0
            end if !if (grid_p_(nr).le.0.0d0) then
            if (verbose.gt.1) then
               write(6,'(A,I0,A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $              ,'; n_w_(nr) ',n_w_(nr),'; R_pre,R_pos,dr: ',R_pre
     $              ,R_pos,dr
            end if !if (verbose.gt.1) then
            dw = 2*pi/(1.0d0*max(1,n_w_(nr)))
            dA = (R_pre*dr + (dr**2)/2)*dw
c$$$  We assume that the fourier basis is orthonormal (not merely orthogonal)
            dAn = dA
            dsqrt_dAn = dsqrt(dAn)
            if (verbose.gt.1) then
               write(6,'(A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $              ,'; dr dw dA: ',dr,dw,dA
            end if !if (verbose.gt.1) then
            n_w_t = floor(1.0d0*n_w_(nr)/2.0d0)
            ic_store = ic
            do nl=0,n_svd_l-1
               D_V_r = svd_polyval_V_r_(nl+nr*n_svd_l)
               D_s = svd_s_(nl)
               I_l = svd_l_(nl)
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(A,I3,1X,I3,1X,F16.3,1X,F16.3)')
     $                 ' % % l I_l D_V_r D_s: ',nl,I_l,D_V_r,D_s
               end if !if (verbose.gt.2 .and. nr.lt.5) then
               nx = 0 + n_r*(nl + n_svd_l*ns);
               ic = ic_store
               do nw=0,n_w_(nr)-1
                  nwc = nw
                  if (nwc.ge.n_w_t) then
                     nwc = nwc - n_w_(nr)
                  end if !if (nwc.ge.n_w_t) then
                  if (abs(nwc).lt.n_w_t) then
                     flag_ic0_overflow = .false.
                  else
                     flag_ic0_overflow = .true.
                  end if !if (abs(nwc).lt.n_w_t) then
                  nwc = nw
                  if (nwc.ge.n_w_t) then
                     nwc = nwc - n_w_(nr)
                  end if !if (nwc.ge.n_w_t) then
                  flag_ict_overflow = .false.
                  nwd = nwc + I_l
                  if (abs(nwd).lt.n_w_t) then
                     call periodize_i(nwd,0,n_w_(nr),nwt)
                  else
                     nwt = 0
                     flag_ict_overflow = .true.
                  end if !if (abs(nwd).lt.n_w_t) then
                  flag_icr_overflow = .false.
                  nwd = nwc - I_l
                  if (abs(nwd).lt.n_w_t) then
                     call periodize_i(nwd,0,n_w_(nr),nwr)
                  else
                     nwr = 0
                     flag_icr_overflow = .true.
                  end if !if (abs(nwd).lt.n_w_t) then
                  ict = ic-nw+nwt
                  icr = ic-nw+nwr
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(10(A,I0))') ' % % % nl:' , nl , '; I_l:'
     $                    , I_l , '; ic_store:' , ic_store,
     $                    '; n_w_(nr):' , n_w_(nr) , '; nw:', nw ,
     $                    '; nwt:' ,nwt , '; nwr:' , nwr ,'; ic:' , ic ,
     $                    '; ict:' , ict , '; icr:', icr 
                     write(6,'(2(A,L1))') ' % % % flag_ict: ' ,
     $                    flag_ict_overflow , '; flag_icr: ' ,
     $                    flag_icr_overflow
                  end if !if (verbose.gt.3 .and. nr.lt.5) then
                  if ((flag_ic0_overflow.eqv..false.) .and.
     $                 (flag_ict_overflow.eqv..false.)) then
                  if (nw.gt.n_w_(nr)/2) then
                     nw_fix = nw - n_w_(nr) + n_w_max
                     if (verbose.gt.3 .and. nr.lt.5) then
                        write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                       ,'; nw_fix ',nw_fix,'; (full loop)'
                     end if
                     C_q = conjg(D_s*D_V_r*S_q_(ict))
                     nw_C = nw_fix
                     if (verbose.gt.2) then
                        n_X_(nr + n_r*(nl + n_svd_l*nw_fix)) = n_X_(nr +
     $                       n_r*(nl + n_svd_l*nw_fix)) + 1
                     end if     !if (verbose.gt.2) then
                     Z_S_q__(nx + nr + ld_X*nw_C) = Z_S_q__(nx + nr +
     $                    ld_X*nw_C) +C_q*dsqrt_dAn
                  else if (nw.eq.n_w_(nr)/2) then
                     nw_fix = nw
                     if (verbose.gt.3 .and. nr.lt.5) then
                        write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                       ,'; nw_fix ',nw_fix,'; (first orig)'
                     end if
                     C_q = dsqrt(0.0d0*0.5d0)*conjg(D_s*D_V_r*S_q_(ict))
                     nw_C = nw_fix
                     if (verbose.gt.2) then
                        n_X_(nr + n_r*(nl + n_svd_l*nw_fix)) = n_X_(nr +
     $                       n_r*(nl + n_svd_l*nw_fix)) + 1
                     end if     !if (verbose.gt.2) then
                     Z_S_q__(nx + nr + ld_X*nw_C) = Z_S_q__(nx + nr +
     $                    ld_X*nw_C) +C_q*dsqrt_dAn
                     nw_fix = nw - n_w_(nr) + n_w_max
                     if (verbose.gt.3 .and. nr.lt.5) then
                        write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                       ,'; nw_fix ',nw_fix,'; (then loop)'
                     end if
                     C_q = dsqrt(0.0d0*0.5d0)*conjg(D_s*D_V_r*S_q_(ict))
                     nw_C = nw_fix
                     if (verbose.gt.2) then
                        n_X_(nr + n_r*(nl + n_svd_l*nw_fix)) = n_X_(nr +
     $                       n_r*(nl + n_svd_l*nw_fix)) + 1
                     end if     !if (verbose.gt.2) then
                     Z_S_q__(nx + nr + ld_X*nw_C) = Z_S_q__(nx + nr +
     $                    ld_X*nw_C) +C_q*dsqrt_dAn
                  else
                     nw_fix = nw
                     if (verbose.gt.3 .and. nr.lt.5) then
                        write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                       ,'; nw_fix ',nw_fix,'; (full orig)'
                     end if
                     C_q = conjg(D_s*D_V_r*S_q_(ict))
                     nw_C = nw_fix
                     if (verbose.gt.2) then
                        n_X_(nr + n_r*(nl + n_svd_l*nw_fix)) = n_X_(nr +
     $                       n_r*(nl + n_svd_l*nw_fix)) + 1
                     end if     !if (verbose.gt.2) then
                     Z_S_q__(nx + nr + ld_X*nw_C) = Z_S_q__(nx + nr +
     $                    ld_X*nw_C) +C_q*dsqrt_dAn
                  end if !if nw
                  end if !if ((flag_ic0_overflow.eqv..false.) .and. (flag_ict_overflow.eqv..false.)) then
                  ic = ic + 1
               enddo !do nw=0,n_w_(nr)-1
            enddo !do nl=0,n_svd_l-1
         enddo !do nr=0,n_r-1
         if (verbose.gt.2) then
            write(6,'(A,I0)') ' ns: ' , ns
            call print_all_i4__(n_r,n_svd_l*n_w_max,n_X_,'n_X_: ')
         end if !if (verbose.gt.2) then
      enddo !do ns=0,n_S_sub-1
c$$$      deallocate(V_r_);
      if (verbose.gt.2) then
         deallocate(n_X_)
      end if !if (verbose.gt.2) then
      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_build_Z_S_q_5]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Global search proceeds as follows: ;\n
!> For each 0-level S-block: ;\n
!>     For each 0-level M-block: ;\n
!>         Define 1-level S-blocking. ;\n
!>         Define 1-level M-blocking. ;\n
!>         For each 1-level S-block: ;\n
!>             For each 1-level M-block: ;\n
!>                 Calculate innerproducts using omp. ;\n
!>                 (i.e., using 9-level S- and M-blocks). ;\n
!>             end 1-level M-block. ;\n
!>         end 1-level S-block. ;\n
!>     end 0-level M-block. ;\n
!> end 0-level S-block. ;\n
      subroutine ti8_global_0(
      include 'ti8_list_var_external_0.f'
      include 'ti8_list_var_internal_0.f'
     $ )
      include 'ti8_define_var_allocation_off_0.f'
      do nM_0_sub=0,n_M_0_sub_use-1
         nM_0_per = n_M_0_per_(nM_0_sub)
         nM_0_sum = n_M_0_sum_(nM_0_sub)
         n_M_9_sub_use = min(n_omp_sub__in,nM_0_per)
         call block_0(verbose-2,n_M_9_sub_use,nM_0_per,n_M_9_per_
     $        ,n_M_9_sum_,n_M_9_sub_use,nM_9_per_min,nM_9_per_max)
         if (verbose.gt.1) then
            write(6,'(5(A,I0))') ' n_M_9_sub_use ' , n_M_9_sub_use ,
     $           ' nM_0_per ' , nM_0_per , ' n_M_9_sub_use ' ,
     $           n_M_9_sub_use , ' nM_9_per_min ' , nM_9_per_min ,
     $           ' nM_9_per_max ' , nM_9_per_max
            call print_all_i4(n_M_9_sub_use,n_M_9_per_
     $           ,' n_M_9_per_: ')
            call print_all_i4(n_M_9_sub_use,n_M_9_sum_
     $           ,' n_M_9_sum_: ')
         end if !if (verbose.gt.1) then
      include 'ti8_checkset_variable_0.f'
         include 'ti8_extract_alpha_sub_0.f'
      include 'ti8_checkset_variable_0.f'
         include 'ti8_define_O_T_R_CTF_M_q_0.f'
      include 'ti8_checkset_variable_0.f'
         include 'ti8_define_T_T_R_CTF_M_q_0.f'
      include 'ti8_checkset_variable_0.f'
         include 'ti8_define_Z_T_R_CTF_M_q_0.f'
      include 'ti8_checkset_variable_0.f'
         n_S_1_sub_use = min(n_S_1_sub__in,nS_0_per)
         call block_0(verbose-2,n_S_1_sub_use,nS_0_per,n_S_1_per_
     $        ,n_S_1_sum_,n_S_1_sub_use,nS_1_per_min,nS_1_per_max)
         if (verbose.gt.1) then
            write(6,'(5(A,I0))') ' n_S_1_sub_use ' , n_S_1_sub_use ,
     $           ' nS_0_per ' , nS_0_per , ' n_S_1_sub_use ' ,
     $           n_S_1_sub_use , ' nS_1_per_min ' , nS_1_per_min ,
     $           ' nS_1_per_max ' , nS_1_per_max
            call print_all_i4(n_S_1_sub_use,n_S_1_per_
     $           ,' n_S_1_per_: ')
            call print_all_i4(n_S_1_sub_use,n_S_1_sum_
     $           ,' n_S_1_sum_: ')
         end if !if (verbose.gt.1) then
         n_M_1_sub_use = min(n_M_1_sub__in,nM_0_per)
         call block_0(verbose-2,n_M_1_sub_use,nM_0_per,n_M_1_per_
     $        ,n_M_1_sum_,n_M_1_sub_use,nM_1_per_min,nM_1_per_max)
         if (verbose.gt.1) then
            write(6,'(5(A,I0))') ' n_M_1_sub_use ' , n_M_1_sub_use ,
     $           ' nM_0_per ' , nM_0_per , ' n_M_1_sub_use ' ,
     $           n_M_1_sub_use , ' nM_1_per_min ' , nM_1_per_min ,
     $           ' nM_1_per_max ' , nM_1_per_max
            call print_all_i4(n_M_1_sub_use,n_M_1_per_
     $           ,' n_M_1_per_: ')
            call print_all_i4(n_M_1_sub_use,n_M_1_sum_
     $           ,' n_M_1_sum_: ')
         end if !if (verbose.gt.1) then
         do nS_1_sub=0,n_S_1_sub_use-1
            nS_1_per = n_S_1_per_(nS_1_sub)
            nS_1_sum = n_S_1_sum_(nS_1_sub)
            n_S_9_sub_use = min(n_omp_sub__in,nS_1_per)
            call block_0(verbose-2,n_S_9_sub_use,nS_1_per,n_S_9_per_
     $           ,n_S_9_sum_,n_S_9_sub_use,nS_9_per_min,nS_9_per_max)
            do nM_1_sub=0,n_M_1_sub_use-1
               nM_1_per = n_M_1_per_(nM_1_sub)
               nM_1_sum = n_M_1_sum_(nM_1_sub)
               n_M_9_sub_use = min(n_omp_sub__in,nM_1_per)
               call block_0(verbose-2,n_M_9_sub_use,nM_1_per
     $              ,n_M_9_per_,n_M_9_sum_,n_M_9_sub_use,nM_9_per_min
     $              ,nM_9_per_max)
               include 'ti8_block_display_0.f'
      include 'ti8_checkset_variable_0.f'
               include 'ti8_STxTRM_0.f'
      include 'ti8_checkset_variable_0.f'
               include 'ti8_SxTTRM_0.f'
      include 'ti8_checkset_variable_0.f'
               include 'ti8_SZxTRM_0.f'
      include 'ti8_checkset_variable_0.f'
               include 'ti8_SxZTRM_0.f'
      include 'ti8_checkset_variable_0.f'
               n_S_use_sum = n_S_use_sum + nM_1_per*nS_1_per
               if (flag_time_Zstore) then
                  include 'ti8_Zstore_0a.f'
                  include 'ti8_Zstore_0b.f'
                  include 'ti8_Zstore_0c.f'
                  include 'ti8_Zstore_0x.f'
                  include 'ti8_Zstore_0d.f'
                  include 'ti8_Zstore_0e.f'
               end if           !if (flag_time_Zstore) then
               include 'ti8_Zstore_1.f'
            enddo               !do nM_1_sub=0,n_M_1_sub_use-1
         enddo                  !do nS_1_sub=0,n_S_1_sub_use-1
      enddo                     !do nM_0_sub=0,n_M_0_sub_use-1
      end



!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Local search proceeds as follows: ;\n
!> For each 0-level S-block: ;\n
!>     Define 9-level M-blocking. ;\n
!>     Use omp to parallelize across 9-level M-blocks. ;\n
!>     For each 9-level M-block: ;\n
!>         For each image in M-block: ;\n
!>             Search tesselation tree for appropriate templates. ;\n
!>             Calculate innerproducts across those templates. ;\n
!>             Here we use nS_1_per_max as an upper bound for the ;\n
!>             number of templates processed at a single time. ;\n
!>         end image. ;\n
!>     end 9-level M-block. ;\n
!> end 0-level S-block. ;\n
      subroutine ti8_local_0(
      include 'ti8_list_var_external_0.f'
      include 'ti8_list_var_internal_0.f'
     $ )
      include 'ti8_define_var_allocation_off_0.f'
      include 'ti8_extract_alpha_all_0.f'
      n_M_9_sub_use = min(n_omp_sub__in,n_M)
      call block_0(verbose-2,n_M_9_sub_use,n_M,n_M_9_per_
     $     ,n_M_9_sum_,n_M_9_sub_use,nM_9_per_min,nM_9_per_max)

      if (verbose.gt.2) then
         write(6,'(A,I0)') ' n_M_9_sub_use: ' , n_M_9_sub_use      
         write(6,'(A,I0)') ' n_M_9_sum_(0): ' , n_M_9_sum_(0)
         call print_sub_c16(n_A,S_k_p__,' S_k_p__: ')
         call print_sub_c16(n_A,M_k_p__,' M_k_p__: ')
         call print_sub_c16(n_A,CTF_k_p__,' CTF_k_p__: ')
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_x_,' delta_x_: ');
         call print_sub_r8(n_delta_v,delta_y_,' delta_y_: ');
         write(6,'(A,I0)') ' n_r: ' , n_r
         call print_sub_r8(n_r,grid_k_p_,' grid_k_p_: ');
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,F8.4)') ' delta_x_est_(0): ' ,
     $        delta_x_est_(0)
         write(6,'(A,F8.4)') ' delta_y_est_(0): ' ,
     $        delta_y_est_(0)
         write(6,'(A,F8.4)') ' gamma_z_est_(0): ' ,
     $        gamma_z_est_(0)
         write(6,'(A,F8.4)') ' ctf_ind_est_(0): ' ,
     $        ctf_ind_est_(0)
         call print_sub_c16(n_A,Z_p_omp__,' Z_p_omp__: ')
         call print_sub_c16(n_A,M_p_omp__,' M_p_omp__: ')
         call print_sub_c16(n_A,Z_q_omp__,' Z_q_omp__: ')
         call print_sub_c16(n_A,M_q_omp__,' M_q_omp__: ')
      end if                    ! if (verbose.gt.2) then

c$OMP PARALLEL PRIVATE(nM_9_per,nM_9_sum,
      include 'ti8l_private_0.f'
c$OMP&)
c$OMP DO
      do nM_9_sub=0,n_M_9_sub_use-1
         nM_9_per = n_M_9_per_(nM_9_sub)
         nM_9_sum = n_M_9_sum_(nM_9_sub)
         include 'ti8l_define_sub_0.f'
         do nm=0,nM_9_per-1
            include 'ti8l_define_O_T_R_CTF_M_q_0.f'
            include 'ti8l_define_T_T_R_CTF_M_q_0.f'
            include 'ti8l_define_Z_T_R_CTF_M_q_0.f'
            include 'ti8l_search_tesselation_1.f'
         enddo !do nm=0,nM_9_per-1
      enddo !do nM_9_sub=0,n_M_9_sub_use-1
c$OMP END DO
c$OMP END PARALLEL
      n_S_use_sum = sum_i4_f(n_M_9_sub_use,n_S_use_sum_)
      end     

!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Calculate bessel coefficients of T(R(CTF.*M)). ;\n
!> T = translation by -delta_x_est,-delta_y_est.  ;\n
!> R = rotation by -gamma_est. ;\n
!> CTF = conjg(CTF) in k-space polar coord. ;\n
!> M = template in k-space polar coord. ;\n
!> O_T_R_CTF_M_q__(nr + n_r*(nm + n_M_tot*nw))  ;\n
!> is equal to the bessel-coefficients ;\n
!> M_q_(ic))  ;\n
!> for ic = nw + n_w_csum_(nr), ;\n
!> where M_q_ = T(R(CTF.*M)), with  ;\n
!> T <-- -delta_est ;\n
!> R <-- -gamma_est ;\n
!> and CTF <-- conjg(CTF_(nctf)) ;\n
!> and M <-- M_p__(nm*ld_M). ;\n
      subroutine ti8_build_O_T_R_CTF_M_q_3(verbose
     $     ,delta_x_est_,delta_y_est_,gamma_z_est_,ctf_ind_est_
     $     ,fftw_plan_frwd_ ,fftw_plan_back_ ,fftw_in1_,fftw_out_,n_r
     $     ,grid_p_,n_w_,n_A ,M_p_ ,M_q_,n_M_sub,I_M_sample_,ld_M ,M_p__
     $     ,CTF_p_ ,n_CTF,ld_CTF,CTF_p__ ,C_M_ ,n_M_tot,O_T_R_CTF_M_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      Calculate bessel coefficients of T(R(CTF.*M)).
c$$$      T = translation by -delta_x_est,-delta_y_est. 
c$$$      R = rotation by -gamma_est.
c$$$      CTF = conjg(CTF) in k-space polar coord.
c$$$      M = template in k-space polar coord.
c$$$      O_T_R_CTF_M_q__(nr + n_r*(nm + n_M_tot*nw)) 
c$$$      is equal to the bessel-coefficients
c$$$      M_q_(ic)) 
c$$$      for ic = nw + n_w_csum_(nr),
c$$$      where M_q_ = T(R(CTF.*M)), with 
c$$$      T <-- -delta_est
c$$$      R <-- -gamma_est
c$$$      and CTF <-- conjg(CTF_(nctf))
c$$$      and M <-- M_p__(nm*ld_M).
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_r,n_w_(0:n_r-1),n_A,n_M_sub,I_M_sample_(0:0)
     $     ,n_M_tot,ld_M,n_CTF,ld_CTF
      real *8 delta_x_est_(0:0)
      real *8 delta_y_est_(0:0)
      real *8 gamma_z_est_(0:0)
      real *8 ctf_ind_est_(0:0)
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 M_p_(0:0),M_q_(0:0),M_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 C_M_(0:0)
      complex *16 O_T_R_CTF_M_q__(0:0)
      complex *16 C_M
      complex *16 Z_tmp
      integer n_w_max,nr,nw,nm,nctf
      integer ndx,ndy,nx,ld_X
      logical flag_conjg
      real *8 delta_x_est,delta_y_est,gamma_z_est
      real *8 pi

      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[entering ti8_build_O_T_R_CTF_M_q_3]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         write(6,'(A,I0)') ' n_r: ' , n_r
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         call print_sub_c16(n_A,M_p_,' M_p_: ')
         call print_sub_c16(n_A,M_q_,' M_q_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_all_i4(n_M_sub,I_M_sample_,' I_M_sample_: ')
         write(6,'(A,I0)') ' ld_M: ' , ld_M
         call print_sub_c16(n_A,M_p__(I_M_sample_(0)*ld_M)
     $        ,' M_p__(0): ')
         call print_sub_c16(n_A,M_p__(I_M_sample_(n_M_sub-1)*ld_M)
     $        ,' M_p__(end): ')
         call print_sub_c16(n_A,CTF_p_,' CTF_p_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         write(6,'(A,I0)') ' ld_CTF: ' , ld_CTF
         call print_sub_c16(n_A*n_CTF,CTF_p__,' CTF_p__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
      end if !if (verbose.gt.1) then

      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      do nm=0,n_M_sub-1
         delta_x_est = +delta_x_est_(nm)
         delta_y_est = +delta_y_est_(nm)
         gamma_z_est = +gamma_z_est_(nm)
         nctf = nint(ctf_ind_est_(nm))
         if (0+verbose.gt.1) then
            write(6,'(A,I0,A,I0,A,I0,A,I0)') 'Processing image ',nm,'/'
     $           ,n_M_sub,' associated with ctf ',nctf,'/',n_CTF
            write(6,'(A)') ' First we calculate l2_norm C_M.'
         end if
         call innerproduct_p(n_r,grid_p_,n_w_,n_A
     $        ,M_p__(I_M_sample_(nm)*ld_M)
     $        ,M_p__(I_M_sample_(nm)*ld_M),C_M)
         C_M = zsqrt(C_M)/(n_r*n_r)
         C_M_(nm) = C_M
         if (verbose.gt.2) then
            write(6,'(A,I0,A,2F16.3)') ' nm: ',nm,'; C_M: ',C_M
         end if
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply ctf-star to M_p_ '
         end if
         call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_p_,'original M_p_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|original M_p_|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_p_,'  CTF *  M_p_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|  CTF *  M_p_|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply R_{-gamma_est} to M_p_ '
         end if
         call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_p_,'  R(CTF*M_p_): ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|  R(CTF*M_p_)|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply T_{-delta_est} to M_p_ '
         end if
         call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est,
     $        -delta_y_est,M_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_p_,'T(R(CTF*M_p_)):')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|T(R(CTF*M_p_))|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we convert M_p_ to M_q_ '
         end if
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A,fftw_in1_
     $        ,fftw_out_,M_p_,M_q_)
         flag_conjg = .false.
         nx = 0 + n_r*nm
         ld_X = n_r*n_M_tot
         call innerproduct_q_stretch_0(n_r,grid_p_,n_w_,n_A,M_q_
     $        ,flag_conjg,ld_X,O_T_R_CTF_M_q__(nx))
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'M_q_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_q_,M_q_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|M_q_|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
      enddo ! do nm=0,n_M_sub-1

      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[finished ti8_build_O_T_R_CTF_M_q_3]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Calculate bessel coefficients of T(T_est(R(CTF.*M))). ;\n
!> T = translation by -delta_x,-delta_y.  ;\n
!> T_est = translation by -delta_x_est,-delta_y_est.  ;\n
!> R = rotation by -gamma_est. ;\n
!> CTF = conjg(CTF) in k-space polar coord. ;\n
!> M = template in k-space polar coord. ;\n
!> T_T_R_CTF_M_q__(nr + n_r*(ndv + n_delta_v*(nm + n_M_tot*nw)))  ;\n
!> is equal to the bessel-coefficients ;\n
!> M_q_(ic))  ;\n
!> for ic = nw + n_w_csum_(nr), ;\n
!> where M_q_ = T(T_est(R(CTF.*M))), with  ;\n
!> T <-- -delta (i.e., a local small translation) ;\n
!> T_est <-- -delta_est ;\n
!> R <-- -gamma_est ;\n
!> and CTF <-- conjg(CTF_(nctf)) ;\n
!> and M <-- M_p__(nm*ld_M). ;\n
      subroutine ti8_build_T_T_R_CTF_M_q_2(verbose ,n_delta_v
     $     ,delta_x_,delta_y_,delta_x_est_ ,delta_y_est_,gamma_z_est_
     $     ,ctf_ind_est_,fftw_plan_frwd_,fftw_plan_back_ ,fftw_in1_
     $     ,fftw_out_,n_r,grid_p_,n_w_,n_A,Z_p_,M_p_ ,M_q_ ,n_M_sub
     $     ,I_M_sample_,ld_M ,M_p__,CTF_p_,n_CTF,ld_CTF ,CTF_p__ ,C_M_
     $     ,n_M_tot,T_T_R_CTF_M_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      Calculate bessel coefficients of T(T_est(R(CTF.*M))).
c$$$      T = translation by -delta_x,-delta_y. 
c$$$      T_est = translation by -delta_x_est,-delta_y_est. 
c$$$      R = rotation by -gamma_est.
c$$$      CTF = conjg(CTF) in k-space polar coord.
c$$$      M = template in k-space polar coord.
c$$$      T_T_R_CTF_M_q__(nr + n_r*(ndv + n_delta_v*(nm + n_M_tot*nw))) 
c$$$      is equal to the bessel-coefficients
c$$$      M_q_(ic)) 
c$$$      for ic = nw + n_w_csum_(nr),
c$$$      where M_q_ = T(T_est(R(CTF.*M))), with 
c$$$      T <-- -delta (i.e., a local small translation)
c$$$      T_est <-- -delta_est
c$$$      R <-- -gamma_est
c$$$      and CTF <-- conjg(CTF_(nctf))
c$$$      and M <-- M_p__(nm*ld_M).
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_delta_v
      integer n_r,n_w_(0:n_r-1),n_A,n_M_sub,I_M_sample_(0:0)
     $     ,n_M_tot,ld_M,n_CTF,ld_CTF
      real *8 delta_x_(0:n_delta_v-1)
      real *8 delta_y_(0:n_delta_v-1)
      real *8 delta_x_est_(0:0)
      real *8 delta_y_est_(0:0)
      real *8 gamma_z_est_(0:0)
      real *8 ctf_ind_est_(0:0)
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 Z_p_(0:0),M_p_(0:0),M_q_(0:0),M_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 C_M_(0:0)
      complex *16 T_T_R_CTF_M_q__(0:0)
      complex *16 C_M
      complex *16 Z_tmp
      integer n_w_max,nr,nw,nm,nctf
      integer ndv,nx,ld_X
      logical flag_conjg
      real *8 delta_x_est,delta_y_est,gamma_z_est
      real *8 delta_x,delta_y
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[entering ti8_build_T_T_R_CTF_M_q_2]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      do nm=0,n_M_sub-1
         delta_x_est = +delta_x_est_(nm)
         delta_y_est = +delta_y_est_(nm)
         gamma_z_est = +gamma_z_est_(nm)
         nctf = nint(ctf_ind_est_(nm))
         if (0+verbose.gt.1) then
            write(6,'(A,I0,A,I0,A,I0,A,I0)') 'Processing image ',nm,'/'
     $           ,n_M_sub,' associated with ctf ',nctf,'/',n_CTF
            write(6,'(A)') ' First we calculate l2_norm C_M.'
         end if
         call innerproduct_p(n_r,grid_p_,n_w_,n_A
     $        ,M_p__(I_M_sample_(nm)*ld_M)
     $        ,M_p__(I_M_sample_(nm)*ld_M),C_M)
         C_M = zsqrt(C_M)/(n_r*n_r)
         C_M_(nm) = C_M
         if (verbose.gt.2) then
            write(6,'(A,I0,A,2F16.3)') ' nm: ',nm,'; C_M: ',C_M
         end if
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply ctf-star to M_p_ '
         end if
         call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),Z_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'original Z_p_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,Z_p_,Z_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|original Z_p_|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         call xc1_c16(n_A,Z_p_,CTF_p__(nctf*ld_CTF),Z_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'  CTF *  Z_p_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,Z_p_,Z_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|  CTF *  Z_p_|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply R_{-gamma_est} to Z_p_ '
         end if
         call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,Z_p_,-gamma_z_est,Z_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'  R(CTF*Z_p_): ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,Z_p_,Z_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|  R(CTF*Z_p_)|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply T_{-delta_est} to Z_p_ '
         end if
         call transf_p_to_p(n_r,grid_p_,n_w_,n_A,Z_p_,-delta_x_est,
     $        -delta_y_est,Z_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'T_est(R(CTF*Z_p_)):')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,Z_p_,Z_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|T_est(R(CTF*Z_p_))|: ' ,
     $           Z_tmp
         end if                 ! if (verbose.gt.2) then
         do ndv=0,n_delta_v-1
            delta_x = +delta_x_(ndv)
            delta_y = +delta_y_(ndv)
            if (verbose.gt.2) then
               write(6,'(A)') ' Now we apply T_{-delta} to Z_p_ '
            end if
            call transf_p_to_p(n_r,grid_p_,n_w_,n_A,Z_p_,-delta_x
     $           ,-delta_y,M_p_)
            if (verbose.gt.2) then
               write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
               call print_sub_c16(n_A,M_q_
     $              ,'T(T_est(R(CTF*M_p_))):')
               call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $              ,Z_tmp)
               Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
               write(6,'(A,F8.4,1X,F8.4)')
     $              '|T(T_est(R(CTF*M_p_)))|: ' ,Z_tmp
            end if              ! if (verbose.gt.2) then
            if (verbose.gt.2) then
               write(6,'(A)') ' Now we convert M_p_ to M_q_ '
            end if
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $           ,fftw_in1_,fftw_out_,M_p_,M_q_)
            flag_conjg = .false.
            nx = 0 + n_r*(ndv + n_delta_v*nm)
            ld_X = n_r*n_delta_v*n_M_tot
            call innerproduct_q_stretch_0(n_r,grid_p_,n_w_,n_A,M_q_
     $           ,flag_conjg,ld_X,T_T_R_CTF_M_q__(nx))
            if (verbose.gt.2) then
               write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
               call print_sub_c16(n_A,M_q_,'M_q_: ')
               call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_q_,M_q_
     $              ,Z_tmp)
               Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
               write(6,'(A,F8.4,1X,F8.4)') '|M_q_|: ' , Z_tmp
            end if              ! if (verbose.gt.2) then               
         enddo                  !do ndv=0,n_delta_v-1
      enddo                     ! do nm=0,n_M_sub-1

      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[finished ti8_build_T_T_R_CTF_M_q_2]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Calculate bessel coefficients of Z(T(R(CTF.*M))). ; ;\n
!> Z = svd of translation operator.  ; ;\n
!> T = translation by -delta_x_est,-delta_y_est.  ; ;\n
!> R = rotation by -gamma_est. ; ;\n
!> CTF = conjg(CTF) in k-space polar coord. ; ;\n
!> M = template in k-space polar coord. ; ;\n
!> Z_T_R_CTF_M_q__(nr + n_r*(nl + n_svd_l*(nm + n_M_tot*nw)))  ; ;\n
!> is equal to the bessel-coefficients ; ;\n
!> M_q_(ic))  ; ;\n
!> for ic = nw + n_w_csum_(nr), ; ;\n
!> where M_q_ = Z(T(R(CTF.*M))), with  ; ;\n
!> Z representing the left-hand factor  ; ;\n
!> of the translation-operator ; ;\n
!> associated with delta, ; ;\n
!> T <-- -delta_est ; ;\n
!> R <-- -gamma_est ; ;\n
!> and CTF <-- conjg(CTF_(nctf)) ; ;\n
!> and M <-- M_p__(nm*ld_M). ; ;\n
!> Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ; ;\n
      subroutine ti8_build_Z_T_R_CTF_M_q_2(verbose,svd_r_max
     $     ,n_svd_r,svd_r_,n_svd_l,svd_l_,svd_s_,svd_V_r_
     $     ,svd_polyval_V_r_,delta_x_est_ ,delta_y_est_,gamma_z_est_
     $     ,ctf_ind_est_ ,fftw_plan_frwd_ ,fftw_plan_back_ ,fftw_in1_
     $     ,fftw_out_,n_r,grid_p_,n_w_,n_A ,M_p_ ,M_q_,n_M_sub
     $     ,I_M_sample_,ld_M ,M_p__,CTF_p_ ,n_CTF ,ld_CTF,CTF_p__ ,C_M_
     $     ,n_M_tot,Z_T_R_CTF_M_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      Calculate bessel coefficients of Z(T(R(CTF.*M))). ;
c$$$      Z = svd of translation operator.  ;
c$$$      T = translation by -delta_x_est,-delta_y_est.  ;
c$$$      R = rotation by -gamma_est. ;
c$$$      CTF = conjg(CTF) in k-space polar coord. ;
c$$$      M = template in k-space polar coord. ;
c$$$      Z_T_R_CTF_M_q__(nr + n_r*(nl + n_svd_l*(nm + n_M_tot*nw)))  ;
c$$$      is equal to the bessel-coefficients ;
c$$$      M_q_(ic))  ;
c$$$      for ic = nw + n_w_csum_(nr), ;
c$$$      where M_q_ = Z(T(R(CTF.*M))), with  ;
c$$$      Z representing the left-hand factor  ;
c$$$      of the translation-operator ;
c$$$      associated with delta, ;
c$$$      T <-- -delta_est ;
c$$$      R <-- -gamma_est ;
c$$$      and CTF <-- conjg(CTF_(nctf)) ;
c$$$      and M <-- M_p__(nm*ld_M). ;
c$$$      Upgraded to ignore frequencies of magnitude n_w_(nr)/2 or larger. ;
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical warning_flag
      data warning_flag / .true. /
      integer n_svd_r,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_r_(0:n_svd_r-1),svd_s_(0:n_svd_l-1)
      real *8 svd_V_r_(0:n_svd_r*n_svd_l-1)
      real *8 svd_polyval_V_r_(0:n_svd_l*n_r-1)
      integer n_r,n_w_(0:n_r-1),n_A,n_M_sub,I_M_sample_(0:0)
     $     ,n_M_tot,ld_M,n_CTF,ld_CTF
      real *8 delta_x_est_(0:0)
      real *8 delta_y_est_(0:0)
      real *8 gamma_z_est_(0:0)
      real *8 ctf_ind_est_(0:0)
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 Z_q
      complex *16 M_p_(0:0),M_q_(0:0),M_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 C_M_(0:0)
      complex *16 Z_T_R_CTF_M_q__(0:0)
      complex *16 C_M
      complex *16 Z_tmp,C_q
      integer n_w_max,ic_store,ic,ict,icr,nr,nw,nwt,nwr,nw_fix,nw_C
      integer n_w_t ! positive threshold for overflow. ;
      integer nwc ! centered nw. ;
      integer nwd ! displaced nw. ;
      logical flag_ic0_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_ict_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      logical flag_icr_overflow ! notes whether or not M_q_ coefficient should be set to 0. ;
      integer nm,nctf
      integer nx,ld_X
      real *8 R_q,R_pos,R_pre,dr,dw,dA,dAn,dsqrt_dAn
      real *8 svd_r_max,svd_r_m,svd_r_c,svd_r(0:0)
      real *8 D_V_r,D_s
      integer nl,I_l
      real *8 delta_x_est,delta_y_est,gamma_z_est
      real *8 pi
      integer, allocatable :: n_X_(:)
c$$$      real *8, allocatable :: V_r_(:)
      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[entering ti8_build_Z_T_R_CTF_M_q_2]'
      end if !if (verbose.gt.0) then
      pi = 4.0*atan(1.0)
c$$$      allocate(V_r_(0:n_svd_l*n_r-1))
      svd_r_m = svd_r_max / 2.0
      svd_r_c = svd_r_m
      n_w_max = n_w_(n_r-1)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' % n_w_max ',n_w_max
      end if
      if (verbose.gt.2) then
         allocate(n_X_(0:n_r*n_svd_l*n_w_max-1))
         call cl1_i4(n_r*n_svd_l*n_w_max,n_X_)
      end if !if (verbose.gt.2) then
      do nr=0,n_r-1
         if (grid_p_(nr).gt.svd_r_max .and. warning_flag) then
            write(6,'(A,F6.3,A,F6.3,A,F6.3,A)')
     $           'Warning, grid_p_(nr) ',grid_p_(nr),'>',svd_r_max
     $           ,'; ratio = ',grid_p_(nr)/svd_r_max
     $           ,' in test_innerproduct_8_Z_S_q_4'
         end if
         svd_r(0) = (grid_p_(nr) - svd_r_m)/svd_r_c
c$$$         do nl=0,n_svd_l-1
c$$$            call polyval_r8_reverse_0(n_svd_r,svd_V_r_(0+nl*n_svd_r),1
c$$$     $           ,svd_r(0),V_r_(nl+nr*n_svd_l))
c$$$         enddo !do nl=0,n_svd_l-1         
      enddo !do nr=0,n_r-1
      ld_X = n_r*n_svd_l*n_M_tot
      do nm=0,n_M_sub-1
         delta_x_est = +delta_x_est_(nm)
         delta_y_est = +delta_y_est_(nm)
         gamma_z_est = +gamma_z_est_(nm)
         nctf = nint(ctf_ind_est_(nm))
         if (0+verbose.gt.1) then
            write(6,'(A,I0,A,I0,A,I0,A,I0)') 'Processing image ',nm,'/'
     $           ,n_M_sub,' associated with ctf ',nctf,'/',n_CTF
            write(6,'(A)') ' First we calculate l2_norm C_M.'
         end if
         call innerproduct_p(n_r,grid_p_,n_w_,n_A
     $        ,M_p__(I_M_sample_(nm)*ld_M)
     $        ,M_p__(I_M_sample_(nm)*ld_M),C_M)
         C_M = zsqrt(C_M)/(n_r*n_r)
         C_M_(nm) = C_M
         if (verbose.gt.2) then
            write(6,'(A,I0,A,2F16.3)') ' nm: ',nm,'; C_M: ',C_M
         end if
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply ctf-star to M_p_ '
         end if
         call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'original M_p_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|original M_p_|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'  CTF *  M_p_: ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|  CTF *  M_p_|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply R_{-gamma_est} to M_p_ '
         end if
         call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'  R(CTF*M_p_): ')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|  R(CTF*M_p_)|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we apply T_{-delta_est} to M_p_ '
         end if
         call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est,
     $        -delta_y_est,M_p_)
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') ' nm: ' , nm 
            call print_sub_c16(n_A,M_q_,'T(R(CTF*M_p_)):')
            call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_
     $           ,Z_tmp)
            Z_tmp = zsqrt(Z_tmp)/(n_r*n_r)
            write(6,'(A,F8.4,1X,F8.4)') '|T(R(CTF*M_p_))|: ' , Z_tmp
         end if                 ! if (verbose.gt.2) then
         if (verbose.gt.2) then
            write(6,'(A)') ' Now we convert M_p_ to M_q_ '
         end if
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A,fftw_in1_
     $        ,fftw_out_,M_p_,M_q_)
         if (verbose.gt.2) then
            call cl1_i4(n_r*n_svd_l*n_w_max,n_X_)
         end if !if (verbose.gt.2) then
         ic = 0
         do nr=0,n_r-1
            if (nr.gt.0) then
               R_pre = 0.5*(grid_p_(nr-1) + grid_p_(nr))
            else
               R_pre = grid_p_(0)
            end if !if (nr.gt.0) then
            if (nr.lt.n_r-1) then
               R_pos = 0.5*(grid_p_(nr+1) + grid_p_(nr))
            else 
               R_pos = grid_p_(n_r-1)
            end if !if (nr.lt.n_r-1) then
            dr = R_pos - R_pre
c$$$  We set the zero-mode to zero
            if (grid_p_(nr).le.0.0d0) then
               dr = 0.0d0
            end if !if (grid_p_(nr).le.0.0d0) then
            if (verbose.gt.1) then
               write(6,'(A,I0,A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $              ,'; n_w_(nr) ',n_w_(nr),'; R_pre,R_pos,dr: ',R_pre
     $              ,R_pos,dr
            end if !if (verbose.gt.1) then
            dw = 2*pi/(1.0d0*max(1,n_w_(nr)))
            dA = (R_pre*dr + (dr**2)/2)*dw
c$$$  We assume that the fourier basis is orthonormal (not merely orthogonal)
            dAn = dA
            dsqrt_dAn = dsqrt(dAn)
            if (verbose.gt.1) then
               write(6,'(A,I0,A,F6.3,1X,F6.3,1X,F6.3)') ' % nr ',nr
     $              ,'; dr dw dA: ',dr,dw,dA
            end if !if (verbose.gt.1) then
            n_w_t = floor(1.0d0*n_w_(nr)/2.0d0)
            ic_store = ic
            do nl=0,n_svd_l-1
               D_V_r = svd_polyval_V_r_(nl+nr*n_svd_l)
               D_s = svd_s_(nl)
               I_l = svd_l_(nl)
               if (verbose.gt.2 .and. nr.lt.5) then
                  write(6,'(2(A,I3),1X,2(A,F16.3))') ' % % nl:' , nl ,
     $                 '; I_l:' , I_l , '; D_V_r:' , D_V_r , '; D_s:' ,
     $                 D_s
               end if !if (verbose.gt.2 .and. nr.lt.5) then
               nx = 0 + n_r*(nl + n_svd_l*nm)
               ic = ic_store
               do nw=0,n_w_(nr)-1
                  nwc = nw
                  if (nwc.ge.n_w_t) then
                     nwc = nwc - n_w_(nr)
                  end if !if (nwc.ge.n_w_t) then
                  if (abs(nwc).lt.n_w_t) then
                     flag_ic0_overflow = .false.
                  else
                     flag_ic0_overflow = .true.
                  end if !if (abs(nwc).lt.n_w_t) then
                  nwc = nw
                  if (nwc.ge.n_w_t) then
                     nwc = nwc - n_w_(nr)
                  end if !if (nwc.ge.n_w_t) then
                  flag_ict_overflow = .false.
                  nwd = nwc + I_l
                  if (abs(nwd).lt.n_w_t) then
                     call periodize_i(nwd,0,n_w_(nr),nwt)
                  else
                     nwt = 0
                     flag_ict_overflow = .true.
                  end if !if (abs(nwd).lt.n_w_t) then
                  flag_icr_overflow = .false.
                  nwd = nwc - I_l
                  if (abs(nwd).lt.n_w_t) then
                     call periodize_i(nwd,0,n_w_(nr),nwr)
                  else
                     nwr = 0
                     flag_icr_overflow = .true.
                  end if !if (abs(nwd).lt.n_w_t) then
                  ict = ic-nw+nwt
                  icr = ic-nw+nwr
                  if (verbose.gt.3 .and. nr.lt.5) then
                     write(6,'(10(A,I0))') ' % % % nl:' , nl , '; I_l:'
     $                    , I_l , '; ic_store:' , ic_store,
     $                    '; n_w_(nr):' , n_w_(nr) , '; nw:', nw ,
     $                    '; nwt:' ,nwt , '; nwr:' , nwr ,'; ic:' , ic ,
     $                    '; ict:' , ict , '; icr:', icr 
                     write(6,'(2(A,L1))') ' % % % flag_ict: ' ,
     $                    flag_ict_overflow , '; flag_icr: ' ,
     $                    flag_icr_overflow
                  end if !if (verbose.gt.3 .and. nr.lt.5) then
                  if ((flag_ic0_overflow.eqv..false.) .and.
     $                 (flag_ict_overflow.eqv..false.)) then
                  if (nw.gt.n_w_(nr)/2) then
                     nw_fix = nw - n_w_(nr) + n_w_max
                     if (verbose.gt.4 .and. nr.lt.5) then
                        write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                       ,'; nw_fix ',nw_fix,'; (full loop)'
                     end if
c$$$                     no conjugate, since we are acting on M and not S
                     C_q = (D_s*D_V_r*M_q_(ict))
                     nw_C = nw_fix
                     if (verbose.gt.2) then
                        n_X_(nr + n_r*(nl + n_svd_l*nw_fix)) = n_X_(nr +
     $                       n_r*(nl + n_svd_l*nw_fix)) + 1
                     end if     !if (verbose.gt.2) then
                     Z_T_R_CTF_M_q__(nx + nr + ld_X*nw_C) =
     $                    Z_T_R_CTF_M_q__(nx + nr +ld_X*nw_C) +C_q
     $                    *dsqrt_dAn
                  else if (nw.eq.n_w_(nr)/2) then
                     nw_fix = nw
                     if (verbose.gt.4 .and. nr.lt.5) then
                        write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                       ,'; nw_fix ',nw_fix,'; (half orig)'
                     end if
c$$$                     no conjugate, since we are acting on M and not S
                     C_q = dsqrt(0.0d0*0.5d0)*(D_s*D_V_r*M_q_(ict))
                     nw_C = nw_fix
                     if (verbose.gt.2) then
                        n_X_(nr + n_r*(nl + n_svd_l*nw_fix)) = n_X_(nr +
     $                       n_r*(nl + n_svd_l*nw_fix)) + 1
                     end if     !if (verbose.gt.2) then
                     Z_T_R_CTF_M_q__(nx + nr + ld_X*nw_C) =
     $                    Z_T_R_CTF_M_q__(nx + nr +ld_X*nw_C) +C_q
     $                    *dsqrt_dAn
                     nw_fix = nw - n_w_(nr) + n_w_max
                     if (verbose.gt.4 .and. nr.lt.5) then
                        write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                       ,'; nw_fix ',nw_fix,'; (half loop)'
                     end if
c$$$                     no conjugate, since we are acting on M and not S
                     C_q = dsqrt(0.0d0*0.5d0)*(D_s*D_V_r*M_q_(ict))
                     nw_C = nw_fix
                     if (verbose.gt.2) then
                        n_X_(nr + n_r*(nl + n_svd_l*nw_fix)) = n_X_(nr +
     $                       n_r*(nl + n_svd_l*nw_fix)) + 1
                     end if     !if (verbose.gt.2) then
                     Z_T_R_CTF_M_q__(nx + nr + ld_X*nw_C) =
     $                    Z_T_R_CTF_M_q__(nx + nr +ld_X*nw_C) +C_q
     $                    *dsqrt_dAn
                  else
                     nw_fix = nw
                     if (verbose.gt.4 .and. nr.lt.5) then
                        write(6,'(A,I3,A,I3,A)') ' % % % nw ',nw
     $                       ,'; nw_fix ',nw_fix,'; (full orig)'
                     end if
c$$$                     no conjugate, since we are acting on M and not S
                     C_q = (D_s*D_V_r*M_q_(ict))
                     nw_C = nw_fix
                     if (verbose.gt.2) then
                        n_X_(nr + n_r*(nl + n_svd_l*nw_fix)) = n_X_(nr +
     $                       n_r*(nl + n_svd_l*nw_fix)) + 1
                     end if     !if (verbose.gt.2) then
                     Z_T_R_CTF_M_q__(nx + nr + ld_X*nw_C) =
     $                    Z_T_R_CTF_M_q__(nx + nr +ld_X*nw_C) +C_q
     $                    *dsqrt_dAn
                  end if !if nw
                  end if !if ((flag_ic0_overflow.eqv..false.) .and. (flag_ict_overflow.eqv..false.)) then
                  ic = ic + 1
               enddo !do nw=0,n_w_(nr)-1
            enddo !do nl=0,n_svd_l-1
         enddo !do nr=0,n_r-1
         if (verbose.gt.2) then
            write(6,'(A,I0)') ' nm: ' , nm
            call print_all_i4__(n_r,n_svd_l*n_w_max,n_X_,'n_X_: ')
         end if !if (verbose.gt.2) then
      enddo ! do nm=0,n_M_sub-1
c$$$      deallocate(V_r_)
      if (verbose.gt.2) then
         deallocate(n_X_)
      end if !if (verbose.gt.2) then

      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[finished ti8_build_Z_T_R_CTF_M_q_2]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Tests S_T_T_R_CTF_M_q_ calculation directly. ;\n
      subroutine ti8_check_STxTRM_3(verbose,n_delta_v
     $     ,delta_x_,delta_y_,n_gamma_z,gamma_z_,delta_x_est_
     $     ,delta_y_est_ ,gamma_z_est_,ctf_ind_est_,fftw_plan_frwd_
     $     ,fftw_plan_back_ ,fftw_in1_ ,fftw_out_,fftw_plan_back_last
     $     ,fftw_in1_last_ ,fftw_out_last_ ,n_r,grid_p_,n_w_,n_A,S_p_
     $     ,S_q_,n_S ,I_S_sample_,ld_S ,S_p__,M_p_,M_q_,n_M ,I_M_sample_
     $     ,ld_M ,M_p__,CTF_p_ ,n_CTF ,ld_CTF ,CTF_p__,CTF_R_S_
     $     ,S_T_T_R_CTF_M_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      test S_T_T_R_CTF_M_q_.
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_delta_v,n_gamma_z
      integer n_r,n_w_(0:n_r-1),n_A
      integer n_S,I_S_sample_(0:n_S-1),ld_S
      integer n_M,I_M_sample_(0:n_M-1),ld_M
      integer n_CTF,ld_CTF
      real *8 delta_x_(0:0)
      real *8 delta_y_(0:0)
      real *8 gamma_z_(0:0)
      real *8 delta_x_est_(0:0)
      real *8 delta_y_est_(0:0)
      real *8 gamma_z_est_(0:0)
      real *8 ctf_ind_est_(0:0)
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      integer *8 fftw_plan_back_last
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 fftw_in1_last_(0:0),fftw_out_last_(0:0)
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 M_p_(0:0),M_q_(0:0),M_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 CTF_R_S_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16, allocatable :: CTF_R_S_use_(:)
      complex *16, allocatable :: C_q_(:)
      complex *16, allocatable :: Z_tmp_(:)
      complex *16, allocatable :: ZZ1_(:)
      complex *16, allocatable :: ZZ2_(:)
      complex *16 C_tmp,Z_tmp,CTF_R_S_use,C_Z_use,C_M
      integer n_w_max,nr,nw,ns,nm,nctf,nC
      integer ndv,ngz,nx,ld_X,nx1,nx2,nx3
      real *8 delta_x,delta_y,gamma_z
      real *8 delta_x_est,delta_y_est,gamma_z_est
      real *8 pi
      complex *16 maxr_c16_f
      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_check_STxTRM_3]'
      end if !if (verbose.gt.0) then

      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      allocate(CTF_R_S_use_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      allocate(ZZ1_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,ZZ1_)
      allocate(ZZ2_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,ZZ2_)

      allocate(C_q_(0:n_w_max-1))
      call cl1_c16(n_w_max,C_q_)
      allocate(Z_tmp_(0:n_w_max-1))
      call cl1_c16(n_w_max,Z_tmp_)
      do nx1=0,n_delta_v*n_S*n_M-1
         nx = nx1
         ndv = mod(nx,n_delta_v)
         nx = (nx - ndv)/n_delta_v
         ns = mod(nx,n_S)
         nx = (nx - ns)/n_S
         nm = mod(nx,n_M)
         nx = (nx - nm)/n_M
         if (nx.ne.0) then
            write(6,'(A,I0)') 'Warning, incorrectly unpacked nx1: '
     $           , nx1
         end if                 ! if (nx.ne.0) then
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0,A,I0)') , ' nx1: '
     $           , nx1 ,' ndv: ' , ndv , ' ns: ' ,
     $           ns ,' nm: ' , nm 
         end if                 !if (verbose.gt.2) then
         delta_x = delta_x_(ndv)
         delta_y = delta_y_(ndv)
         call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
         call transf_p_to_p(n_r,grid_p_,n_w_ ,n_A,S_p_,+delta_x,
     $        +delta_y,S_p_)
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $        ,fftw_in1_,fftw_out_,S_p_,S_q_)
         delta_x_est = +delta_x_est_(nm)
         delta_y_est = +delta_y_est_(nm)
         gamma_z_est = +gamma_z_est_(nm)
         nctf = nint(ctf_ind_est_(nm))
         call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
     $        n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
         call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
         call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
         call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
         call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est,
     $        -delta_y_est,M_p_)
         call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_,C_M)
         C_M = zsqrt(C_M)/n_r**2
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,M_q_)
         call innerproduct_q_k_stretch_0(n_r,grid_p_,n_w_,n_A,S_q_,M_q_
     $        ,C_q_)
         call cp1_c16(n_w_max,C_q_,fftw_out_last_)
         call dfftw_execute_(fftw_plan_back_last)
         call cp1_c16(n_w_max,fftw_in1_last_,C_q_)
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         C_tmp = (0.0d0,0.0d0)
         Z_tmp = (0.0d0,0.0d0)
         do nw=0,n_w_max-1
            C_tmp = C_tmp + zabs(C_q_(nw))**2
            nx2 = ndv + n_delta_v*(ns + n_S*nm)
            nx3 = nw*n_delta_v*n_S*n_M
            Z_tmp = Z_tmp + zabs(C_q_(nw) - S_T_T_R_CTF_M_q__(nx2 +
     $           nx3))**2
         enddo                  !do nw=0,n_w_max-1
         C_tmp = zsqrt(C_tmp)
         Z_tmp = zsqrt(Z_tmp)
         if (verbose.gt.-2) then
            write(6,'(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A,F16.8)') ,
     $           ' C_q_ vs S_T_T_R_CTF_M_q__: ' ,
     $           ' nx1: ' , nx1 ,' ndv: ' , ndv ,
     $           ' ns: ' , ns ,' nm: ' , nm , ' absolute error: ' ,
     $           real(zabs(Z_tmp)) , ' relative error: ' ,
     $           real(zabs(Z_tmp)/zabs(C_tmp))
         end if                 !if (verbose.gt.2) then            
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         call cp1_c16(n_w_max,C_q_,Z_tmp_)
         do ngz=0,n_gamma_z-1
            CTF_R_S_use = CTF_R_S_use_(ngz)
            gamma_z = gamma_z_(ngz)
            call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $           ,Z_tmp)
c$$$            nC = ndv + n_delta_v*ngz
            nC = ngz
            if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
               C_Z_use = 1.0d0
            else
               C_Z_use = C_M*CTF_R_S_use
            end if
            ZZ1_(nC) = Z_tmp/(n_r**4)/C_Z_use
         enddo !do ngz=0,n_gamma_z-1
c$$$         call print_sub_c16(n_gamma_z,ZZ1_,'ZZ1_: ')
         do nw=0,n_w_max-1
            nx2 = ndv + n_delta_v*(ns + n_S*nm)
            nx3 = nw*n_delta_v*n_S*n_M
            Z_tmp_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
         enddo !do nw=0,n_w_max-1
         do ngz=0,n_gamma_z-1
            CTF_R_S_use = CTF_R_S_use_(ngz)
            gamma_z = gamma_z_(ngz)
            call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $           ,Z_tmp)
c$$$            nC = ndv + n_delta_v*ngz
            nC = ngz
            if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
               C_Z_use = 1.0d0
            else
               C_Z_use = C_M*CTF_R_S_use
            end if
            ZZ2_(nC) = Z_tmp/(n_r**4)/C_Z_use
         enddo !do ngz=0,n_gamma_z-1
c$$$         call print_sub_c16(n_gamma_z,ZZ2_,'ZZ2_: ')
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         C_tmp = (0.0d0,0.0d0)
         Z_tmp = (0.0d0,0.0d0)
         do ngz=0,n_gamma_z-1
            C_tmp = C_tmp + zabs(ZZ1_(ngz))**2
            Z_tmp = Z_tmp + zabs(ZZ1_(ngz) - ZZ2_(ngz))**2
         enddo                  !do ngz=0,n_gamma_z-1
         C_tmp = zsqrt(C_tmp)
         Z_tmp = zsqrt(Z_tmp)
         if (verbose.gt.-2) then
            write(6, '(A,A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A,F16.8)')
     $           ' Correlations(C_q_) vs'
     $           ,' Correlations(S_T_T_R_CTF_M_q__): ' , ' nx1: ' , nx1
     $           ,' ndv: ' , ndv , ' ns: ' , ns
     $           ,' nm: ' , nm , ' absolute error: ' , real(zabs(Z_tmp))
     $           , ' relative error: ' , real(zabs(Z_tmp)/zabs(C_tmp))
            write(6,'(2(A,F8.4,1X,F8.4))') ' ZZ1_ maxr: ' ,
     $           maxr_c16_f(n_gamma_z,ZZ1_) , ' ZZ2_ maxr: ' ,
     $           maxr_c16_f(n_gamma_z,ZZ2_)
         end if                 !if (verbose.gt.2) then
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         
         
      enddo                     !do nx1=0,n_delta_v*n_S*n_M-1
      
      deallocate(CTF_R_S_use_)
      deallocate(ZZ1_)
      deallocate(ZZ2_)
      deallocate(C_q_)
      deallocate(Z_tmp_)

      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[finished ti8_check_STxTRM_3]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Tests S_T_T_R_CTF_M_q_ calculation directly. ;\n
      subroutine ti8_check_SZxTRM_4(verbose,svd_d_max,n_svd_d,svd_d_
     $     ,svd_r_max,n_svd_r,svd_r_,n_svd_l,svd_l_,svd_U_d_,svd_s_
     $     ,svd_V_r_ ,Z_S_svdd_,n_delta_v,delta_x_ ,delta_y_ ,n_gamma_z
     $     ,gamma_z_ ,delta_x_est_,delta_y_est_ ,gamma_z_est_
     $     ,ctf_ind_est_ ,fftw_plan_frwd_,fftw_plan_back_ ,fftw_in1_
     $     ,fftw_out_,fftw_plan_back_last,fftw_in1_last_ ,fftw_out_last_
     $     ,n_r,grid_p_,n_w_,n_A,S_p_,S_q_,n_S ,I_S_sample_,ld_S ,S_p__
     $     ,M_p_,M_q_,n_M ,I_M_sample_,ld_M ,M_p__,CTF_p_ ,n_CTF ,ld_CTF
     $     ,CTF_p__,C_M_,CTF_R_S_ ,S_Z_T_R_CTF_M_q__ ,S_T_T_R_CTF_M_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      test S_T_T_R_CTF_M_q_.
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_svd_d,n_svd_r,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_d_(0:n_svd_d-1),svd_r_(0:n_svd_r-1)
      real *8 svd_U_d_(0:n_svd_d*n_svd_l-1)
      real *8 svd_s_(0:n_svd_l-1)
      real *8 svd_V_r_(0:n_svd_r*n_svd_l-1)
      complex *16 Z_S_svdd_(0:0)
      integer n_delta_v,n_gamma_z
      integer n_r,n_w_(0:n_r-1),n_A
      integer n_S,I_S_sample_(0:n_S-1),ld_S
      integer n_M,I_M_sample_(0:n_M-1),ld_M
      integer n_CTF,ld_CTF
      real *8 delta_x_(0:0)
      real *8 delta_y_(0:0)
      real *8 gamma_z_(0:0)
      real *8 delta_x_est_(0:0)
      real *8 delta_y_est_(0:0)
      real *8 gamma_z_est_(0:0)
      real *8 ctf_ind_est_(0:0)
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      integer *8 fftw_plan_back_last
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 fftw_in1_last_(0:0),fftw_out_last_(0:0)
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 M_p_(0:0),M_q_(0:0),M_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 S_Z_T_R_CTF_M_q__(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16, allocatable :: CTF_R_S_use_(:)
      complex *16, allocatable :: ZZ1_(:)
      complex *16, allocatable :: ZZ2_(:)
      complex *16, allocatable :: Z_svdr_(:)
      complex *16, allocatable :: C_q0_(:)
      complex *16, allocatable :: C_q1_(:)
      complex *16, allocatable :: C_q2_(:)
      complex *16, allocatable :: C_q3_(:)
      complex *16, allocatable :: Z_tmp_(:)
      complex *16 C_tmp,Z_tmp,C_Z_use,CTF_R_S_use
      real *8 svd_d_max,svd_r_max
      integer n_w_max,nr,nw,ns,nm,nctf,nC
      integer ndv,ngz,nx,ld_X,nx1,nx2,nx3
      real *8 delta_x,delta_y,gamma_z
      real *8 delta_x_est,delta_y_est,gamma_z_est
      integer nsvd_l,nC1,nC2,nC3,nC4
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_check_SZxTRM_4]'
      end if !if (verbose.gt.0) then

      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      allocate(Z_svdr_(0:n_svd_l*n_w_max - 1))
      call cl1_c16(n_svd_l*n_w_max,Z_svdr_)
      allocate(C_q0_(0:n_w_max*n_delta_v-1))
      call cl1_c16(n_w_max*n_delta_v,C_q0_)
      allocate(C_q1_(0:n_w_max*n_delta_v-1))
      call cl1_c16(n_w_max*n_delta_v,C_q1_)
      allocate(C_q2_(0:n_w_max*n_delta_v-1))
      call cl1_c16(n_w_max*n_delta_v,C_q2_)
      allocate(C_q3_(0:n_w_max*n_delta_v-1))
      call cl1_c16(n_w_max*n_delta_v,C_q3_)

      allocate(CTF_R_S_use_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      allocate(ZZ1_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,ZZ1_)
      allocate(ZZ2_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,ZZ2_)
      allocate(Z_tmp_(0:n_w_max-1))
      call cl1_c16(n_w_max,Z_tmp_)
      do nx1=0,n_S*n_M-1
         nx = nx1
         ns = mod(nx,n_S)
         nx = (nx-ns)/n_S
         nm = mod(nx,n_M)
         nx = (nx-nm)/n_M
         if (nx.ne.0) then
            write(6,'(A,I0)') 'Warning, incorrectly unpacked nx1: '
     $           , nx1
         end if                 ! if (nx.ne.0) then
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') , ' nx1: ' , nx1 , ' ns: ' , ns
     $           ,' nm: ' , nm 
         end if                 !if (verbose.gt.2) then
c$$$         Define CTF_R_S_use_
         gamma_z_est = +gamma_z_est_(nm)
         nctf = nint(ctf_ind_est_(nm))
         call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 + ns
     $        *n_gamma_z + nctf*n_gamma_z*n_S),CTF_R_S_use_)
c$$$         Define C_q0_
         do ndv=0,n_delta_v-1
            delta_x = delta_x_(ndv)
            delta_y = delta_y_(ndv)
            call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
            call transf_p_to_p(n_r,grid_p_,n_w_ ,n_A,S_p_,+delta_x,
     $           +delta_y,S_p_)
            delta_x_est = +delta_x_est_(nm)
            delta_y_est = +delta_y_est_(nm)
            gamma_z_est = +gamma_z_est_(nm)
            nctf = nint(ctf_ind_est_(nm))
            call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
            call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
            call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
            call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est
     $           ,-delta_y_est,M_p_)
            do nw=0,n_w_max-1
               gamma_z = (2.0d0*pi*nw)/(1.0d0*n_w_max)
               call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_
     $              ,n_w_,n_A,fftw_in1_,fftw_out_,S_p_,+gamma_z,S_q_)
               call innerproduct_p(n_r,grid_p_,n_w_,n_A,S_q_,M_p_
     $              ,C_q0_(nw + n_w_max*ndv))
            enddo               !do nw=0,n_w_max-1
         enddo                  !do ndv=0,n_delta_v-1
c$$$         Define C_q1_
         do ndv=0,n_delta_v-1
            delta_x = delta_x_(ndv)
            delta_y = delta_y_(ndv)
            call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
            call transf_p_to_p(n_r,grid_p_,n_w_ ,n_A,S_p_,+delta_x,
     $           +delta_y,S_p_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $           ,fftw_in1_,fftw_out_,S_p_,S_q_)
            delta_x_est = +delta_x_est_(nm)
            delta_y_est = +delta_y_est_(nm)
            gamma_z_est = +gamma_z_est_(nm)
            nctf = nint(ctf_ind_est_(nm))
            call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
            call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
            call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
            call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est
     $           ,-delta_y_est,M_p_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $           ,fftw_in1_,fftw_out_,M_p_,M_q_)
            call innerproduct_q_k_stretch_0(n_r,grid_p_,n_w_,n_A,S_q_
     $           ,M_q_,C_q1_(n_w_max*ndv))
            call cp1_c16(n_w_max,C_q1_(n_w_max*ndv),fftw_out_last_)
            call dfftw_execute_(fftw_plan_back_last)
            call cp1_c16(n_w_max,fftw_in1_last_,C_q1_(n_w_max*ndv))
         enddo                  !do ndv=0,n_delta_v-1
c$$$         Define C_q2_
         do ndv=0,n_delta_v-1
            delta_x = delta_x_(ndv)
            delta_y = delta_y_(ndv)
            call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $           ,fftw_in1_,fftw_out_,S_p_,S_q_)
            call transf_svd_q_to_q_5(svd_r_max,n_svd_r,svd_r_
     $           ,svd_d_max,n_svd_d,svd_d_,n_svd_l,svd_l_,svd_U_d_
     $           ,svd_s_,svd_V_r_,n_r,grid_p_,n_w_,n_A,S_q_,delta_x
     $           ,delta_y,S_q_)
            delta_x_est = +delta_x_est_(nm)
            delta_y_est = +delta_y_est_(nm)
            gamma_z_est = +gamma_z_est_(nm)
            nctf = nint(ctf_ind_est_(nm))
            call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
            call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
            call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_
     $           ,n_A,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
            call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est
     $           ,-delta_y_est,M_p_)
            call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $           ,fftw_in1_,fftw_out_,M_p_,M_q_)
            call innerproduct_q_k_stretch_0(n_r,grid_p_,n_w_,n_A,S_q_
     $           ,M_q_,C_q2_(n_w_max*ndv))
            call cp1_c16(n_w_max,C_q2_(n_w_max*ndv),fftw_out_last_)
            call dfftw_execute_(fftw_plan_back_last)
            call cp1_c16(n_w_max,fftw_in1_last_,C_q2_(n_w_max*ndv))
         enddo                  !do ndv=0,n_delta_v-1
c$$$         Define S_q
         call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $        ,fftw_in1_,fftw_out_,S_p_,S_q_)
         delta_x_est = +delta_x_est_(nm)
         delta_y_est = +delta_y_est_(nm)
         gamma_z_est = +gamma_z_est_(nm)
c$$$         Define M_q
         nctf = nint(ctf_ind_est_(nm))
         call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
         call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
         call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
         call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est,
     $        -delta_y_est,M_p_)
         call innerproduct_p(n_r,grid_p_,n_w_,n_A,M_p_,M_p_,C_M)
         C_M = zsqrt(C_M)/n_r**2
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,M_q_)
c$$$         Combine S_q and M_q into Z_svdr_
         call innerproduct_q_k_svdr_5(.true.,svd_r_max,n_svd_r,svd_r_
     $        ,n_svd_l,svd_l_,svd_s_,svd_V_r_,n_r,grid_p_,n_w_,n_A,S_q_
     $        ,M_q_,Z_svdr_)
c$$$         fftw each term in Z_svdr_
         do nsvd_l=0,n_svd_l-1
            call cps_c16(n_w_max,Z_svdr_(nsvd_l),n_svd_l ,fftw_out_last_
     $           ,1)
            call dfftw_execute_(fftw_plan_back_last)
            call cps_c16(n_w_max,fftw_in1_last_,1,Z_svdr_(nsvd_l)
     $           ,n_svd_l)
         enddo                  !do svd_l=0,n_svd_l-1
         do nsvd_l=0,n_svd_l-1
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do nw=0,n_w_max-1
               C_tmp = C_tmp + zabs(Z_svdr_(nsvd_l + nw*n_svd_l))**2
               nx2 = nsvd_l + n_svd_l*(ns + n_S*nm)
               nx3 = nw*n_svd_l*n_S*n_M
               Z_tmp = Z_tmp + zabs(Z_svdr_(nsvd_l + nw*n_svd_l) -
     $              S_Z_T_R_CTF_M_q__(nx2+nx3))**2
            enddo               !do nw=0,n_w_max-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6 ,'(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' Z_svdr_ vs S_Z_T_R_CTF_M_q__: ' ,' nx1: ' , nx1
     $              ,' nsvd_l: ' , nsvd_l , ' ns: ' , ns ,' nm: ' , nm ,
     $              ' absolute error: ' ,real(zabs(Z_tmp)) ,
     $              ' relative error: ' ,real(zabs(Z_tmp) /zabs(C_tmp))
            end if              !if (verbose.gt.2) then               
         enddo                  !do nsvd_l=0,n_svd_l-1
c$$$         Combining terms to recover delta_x and delta_y, ;
c$$$         but not yet interpolating gamma. ;
         nC1 = 0
         do ndv=0,n_delta_v-1
            do nw=0,n_w_max-1
c$$$  nC1 = nw + ndv*n_w_max
               C_q3_(nC1) = cmplx( 0.0 , 0.0 )
               nC2 = ndv*n_svd_l
               nC3 = nw*n_svd_l
               do nsvd_l=0,n_svd_l-1
                  C_q3_(nC1) = C_q3_(nC1) + Z_S_svdd_(nC2)
     $                 *Z_svdr_(nC3)
                  nC2 = nC2 + 1
                  nC3 = nC3 + 1
               enddo            !do nsvd_l=0,n_svd_l-1
               nC1 = nC1 + 1
            enddo               !do nw=0,n_w_max-1
         enddo                  !ndv=0,n_delta_v-1
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         do ndv=0,n_delta_v-1
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do nw=0,n_w_max-1
               nC4 = nw + n_w_max*ndv
               C_tmp = C_tmp + zabs(C_q1_(nC4))**2
               Z_tmp = Z_tmp + zabs(C_q1_(nC4) - C_q0_(nC4))**2
            enddo               !do nw=0,n_w_max-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_q1_ vs C_q0__: ' 
     $              ,' ndv: ' , ndv , ' ns: ' , ns
     $              ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_tmp)) , ' relative error: '
     $              ,real(zabs(Z_tmp) /zabs(C_tmp))
            end if              !if (verbose.gt.2) then
         enddo !do ndv=0,n_delta_v-1
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         do ndv=0,n_delta_v-1
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do nw=0,n_w_max-1
               nC4 = nw + n_w_max*ndv
               C_tmp = C_tmp + zabs(C_q1_(nC4))**2
               Z_tmp = Z_tmp + zabs(C_q1_(nC4) - C_q2_(nC4))**2
            enddo               !do nw=0,n_w_max-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_q1_ vs C_q2__: ' 
     $              ,' ndv: ' , ndv , ' ns: ' , ns
     $              ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_tmp)) , ' relative error: '
     $              ,real(zabs(Z_tmp) /zabs(C_tmp))
            end if              !if (verbose.gt.2) then
         enddo !do ndv=0,n_delta_v-1
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         do ndv=0,n_delta_v-1
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do nw=0,n_w_max-1
               nC4 = nw + n_w_max*ndv
               C_tmp = C_tmp + zabs(C_q1_(nC4))**2
               Z_tmp = Z_tmp + zabs(C_q1_(nC4) - C_q3_(nC4))**2
            enddo               !do nw=0,n_w_max-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_q1_ vs C_q3__: ' 
     $              ,' ndv: ' , ndv ,' ns: ' , ns
     $              ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_tmp)) , ' relative error: '
     $              ,real(zabs(Z_tmp) /zabs(C_tmp))
            end if              !if (verbose.gt.2) then               
         enddo                  !do ndv=0,n_delta_v-1
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         do ndv=0,n_delta_v-1
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do nw=0,n_w_max-1
               nC4 = nw + n_w_max*ndv
               C_tmp = C_tmp + zabs(C_q3_(nC4))**2
               Z_tmp = Z_tmp + zabs(C_q3_(nC4) - C_q0_(nC4))**2
            enddo               !do nw=0,n_w_max-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_q3_ vs C_q0__: ' 
     $              ,' ndv: ' , ndv ,' ns: ' , ns
     $              ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_tmp)) , ' relative error: '
     $              ,real(zabs(Z_tmp) /zabs(C_tmp))
            end if              !if (verbose.gt.2) then               
         enddo                  !do ndv=0,n_delta_v-1
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         do ndv=0,n_delta_v-1
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do nw=0,n_w_max-1
               nC4 = nw + n_w_max*ndv
               C_tmp = C_tmp + zabs(C_q3_(nC4))**2
               Z_tmp = Z_tmp + zabs(C_q3_(nC4) - C_q2_(nC4))**2
            enddo               !do nw=0,n_w_max-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_q3_ vs C_q2__: ' 
     $              ,' ndv: ' , ndv ,' ns: ' , ns
     $              ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_tmp)) , ' relative error: '
     $              ,real(zabs(Z_tmp) /zabs(C_tmp))
            end if              !if (verbose.gt.2) then               
         enddo                  !do ndv=0,n_delta_v-1
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         do ndv=0,n_delta_v-1
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do nw=0,n_w_max-1
               nC4 = nw + n_w_max*ndv
               C_tmp = C_tmp + zabs(C_q3_(nC4))**2
               nx2 = ndv + n_delta_v*(ns + n_S*nm)
               nx3 = nw*n_delta_v*n_S*n_M
               Z_tmp = Z_tmp + zabs(C_q3_(nC4) -
     $              S_T_T_R_CTF_M_q__(nx2+nx3))**2
            enddo               !do nw=0,n_w_max-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_q3_ vs S_T_T_R_CTF_M_Q__: ' ,' nx1: ' , nx1
     $              ,' ndv: ' , ndv ,' ns: ' , ns
     $              ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_tmp)) , ' relative error: '
     $              ,real(zabs(Z_tmp) /zabs(C_tmp))
            end if              !if (verbose.gt.2) then               
         enddo                  !do ndv=0,n_delta_v-1
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         do ndv=0,n_delta_v-1
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call cp1_c16(n_w_max,C_q3_(0+n_w_max*ndv),Z_tmp_)
            do ngz=0,n_gamma_z-1
               CTF_R_S_use = CTF_R_S_use_(ngz)
               gamma_z = gamma_z_(ngz)
               call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $              ,Z_tmp)
c$$$  nC = ndv + n_delta_v*ngz
               nC = ngz
               if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
                  C_Z_use = 1.0d0
               else
                  C_Z_use = C_M*CTF_R_S_use
               end if
               ZZ1_(nC) = Z_tmp/(n_r**4)/C_Z_use
            enddo               !do ngz=0,n_gamma_z-1
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            do nw=0,n_w_max-1
               nx2 = ndv + n_delta_v*(ns + n_S*nm)
               nx3 = nw*n_delta_v*n_S*n_M
               Z_tmp_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
            enddo               !do nw=0,n_w_max-1
            do ngz=0,n_gamma_z-1
               CTF_R_S_use = CTF_R_S_use_(ngz)
               gamma_z = gamma_z_(ngz)
               call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $              ,Z_tmp)
               nC = ngz
               if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
                  C_Z_use = 1.0d0
               else
                  C_Z_use = C_M*CTF_R_S_use
               end if
               ZZ2_(nC) = Z_tmp/(n_r**4)/C_Z_use
            enddo               !do ngz=0,n_gamma_z-1
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do ngz=0,n_gamma_z-1
               C_tmp = C_tmp + zabs(ZZ1_(ngz))**2
               Z_tmp = Z_tmp + zabs(ZZ1_(ngz) - ZZ2_(ngz))**2
            enddo               !do ngz=0,n_gamma_z-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6 ,
     $              '(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A,F16.8)'
     $              )' ZZ1 vs ZZ2: ' ,' nx1: ' , nx1 ,' ndv: ' , ndv
     $              , ' ns: ' , ns ,' nm: ' , nm ,
     $              ' absolute error: ' ,real(zabs(Z_tmp)) ,
     $              ' relative error: ' ,real(zabs(Z_tmp)
     $              /zabs(C_tmp))
            end if              !if (verbose.gt.2) then            
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%               
         enddo                  !do ndv=0,n_delta_v-1

      enddo ! do nx1=0,n_S*n_M-1

      deallocate(Z_svdr_)
      deallocate(C_q3_)
      deallocate(C_q2_)
      deallocate(C_q1_)
      deallocate(C_q0_)
      deallocate(CTF_R_S_use_)
      deallocate(ZZ1_)
      deallocate(ZZ2_)
      deallocate(Z_tmp_)

      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[finished ti8_check_SZxTRM_4]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Tests S_T_T_R_CTF_M_q_ calculation directly. ;\n
      subroutine ti8_check_SxTTRM_3(verbose,n_delta_v
     $     ,delta_x_,delta_y_,n_gamma_z,gamma_z_,delta_x_est_
     $     ,delta_y_est_ ,gamma_z_est_,ctf_ind_est_,fftw_plan_frwd_
     $     ,fftw_plan_back_ ,fftw_in1_ ,fftw_out_,fftw_plan_back_last
     $     ,fftw_in1_last_ ,fftw_out_last_ ,n_r,grid_p_,n_w_,n_A,S_p_
     $     ,S_q_,n_S ,I_S_sample_,ld_S ,S_p__,M_p_,M_q_,n_M ,I_M_sample_
     $     ,ld_M ,M_p__,CTF_p_ ,n_CTF ,ld_CTF ,CTF_p__,C_M_,CTF_R_S_
     $     ,S_T_T_R_CTF_M_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      test S_T_T_R_CTF_M_q_.
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_delta_v,n_gamma_z
      integer n_r,n_w_(0:n_r-1),n_A
      integer n_S,I_S_sample_(0:n_S-1),ld_S
      integer n_M,I_M_sample_(0:n_M-1),ld_M
      integer n_CTF,ld_CTF
      real *8 delta_x_(0:0)
      real *8 delta_y_(0:0)
      real *8 gamma_z_(0:0)
      real *8 delta_x_est_(0:0)
      real *8 delta_y_est_(0:0)
      real *8 gamma_z_est_(0:0)
      real *8 ctf_ind_est_(0:0)
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      integer *8 fftw_plan_back_last
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 fftw_in1_last_(0:0),fftw_out_last_(0:0)
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 M_p_(0:0),M_q_(0:0),M_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16, allocatable :: CTF_R_S_use_(:)
      complex *16, allocatable :: C_q_(:)
      complex *16, allocatable :: Z_tmp_(:)
      complex *16, allocatable :: ZZ1_(:)
      complex *16, allocatable :: ZZ2_(:)
      complex *16 C_tmp,Z_tmp,CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,ns,nm,nctf,nC
      integer ndv,ngz,nx,ld_X,nx1,nx2,nx3
      real *8 delta_x,delta_y,gamma_z
      real *8 delta_x_est,delta_y_est,gamma_z_est
      real *8 pi
      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_check_SxTTRM_3]'
      end if !if (verbose.gt.0) then

      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      if (verbose.gt.-1) then
         write(6,'(A)') 'calling test_innerproduct_bruteforce: '
         ns=0
         nm=0
         nctf = nint(ctf_ind_est_(nm))
         write(6,'(A,F8.4)') ' delta_x_est: ' , delta_x_est_(nm)
         write(6,'(A,F8.4)') ' delta_y_est: ' , delta_y_est_(nm)
         write(6,'(A,F8.4)') ' gamma_z_est: ' , gamma_z_est_(nm)
         call print_sub_c16(n_A,S_p__(ld_S*ns),' S_p__in_: ')
         call print_sub_c16(n_A,M_p__(ld_M*nm),' M_p__in_: ')
         call print_sub_c16(n_A,CTF_p__(ld_CTF*nctf),' CTF_p__in_: ')
      end if                    !if (verbose.gt.1) then
      call test_innerproduct_bruteforce_1(2,n_r ,grid_p_ ,n_w_
     $     ,0.5d0 ,S_p__(ld_S*ns),M_p__(ld_M*nm)
     $     ,CTF_p__(ld_CTF*nctf) ,delta_x_est_(nm) ,delta_y_est_(nm)
     $     ,gamma_z_est_(nm) ,n_delta_v ,delta_x_ ,delta_y_
     $     ,n_gamma_z ,gamma_z_)

      allocate(CTF_R_S_use_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      allocate(ZZ1_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,ZZ1_)
      allocate(ZZ2_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,ZZ2_)

      allocate(C_q_(0:n_w_max-1))
      call cl1_c16(n_w_max,C_q_)
      allocate(Z_tmp_(0:n_w_max-1))
      call cl1_c16(n_w_max,Z_tmp_)
      do nx1=0,n_delta_v*n_S*n_M-1
         nx = nx1
         ndv = mod(nx,n_delta_v)
         nx = (nx - ndv)/n_delta_v
         ns = mod(nx,n_S)
         nx = (nx - ns)/n_S
         nm = mod(nx,n_M)
         nx = (nx - nm)/n_M
         if (nx.ne.0) then
            write(6,'(A,I0)') 'Warning, incorrectly unpacked nx1: '
     $           , nx1
         end if                 ! if (nx.ne.0) then
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0,A,I0)') , ' nx1: '
     $           , nx1 ,' ndv: ' , ndv , ' ns: ' ,
     $           ns ,' nm: ' , nm 
         end if                 !if (verbose.gt.2) then
         delta_x = delta_x_(ndv)
         delta_y = delta_y_(ndv)
         call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
c$$$         call print_sub_c16(n_A,S_p_,' S_p_: ')
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $        ,fftw_in1_,fftw_out_,S_p_,S_q_)
         delta_x_est = +delta_x_est_(nm)
         delta_y_est = +delta_y_est_(nm)
         gamma_z_est = +gamma_z_est_(nm)
         nctf = nint(ctf_ind_est_(nm))
         call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 + ns
     $        *n_gamma_z + nctf*n_gamma_z*n_S),CTF_R_S_use_)
         call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
c$$$         call print_sub_c16(n_A,M_p_,' M_p_: ')
c$$$         call print_sub_c16(n_A,CTF_p__(nctf*ld_CTF),' CTF_p_: ')
         call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
         call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
         call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est,
     $        -delta_y_est,M_p_)
         call transf_p_to_p(n_r,grid_p_,n_w_ ,n_A,M_p_,-delta_x,
     $        -delta_y,M_p_)
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,M_q_)
         call innerproduct_q_k_stretch_0(n_r,grid_p_,n_w_,n_A,S_q_,M_q_
     $        ,C_q_)
         call cp1_c16(n_w_max,C_q_,fftw_out_last_)
         call dfftw_execute_(fftw_plan_back_last)
         call cp1_c16(n_w_max,fftw_in1_last_,C_q_)
c$$$         write(6,'(1(A,I0))') ' ndv ' , ndv
c$$$         call print_sub_c16(n_w_max,C_q_,' C_q: ')
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         C_tmp = (0.0d0,0.0d0)
         Z_tmp = (0.0d0,0.0d0)
         do nw=0,n_w_max-1
            C_tmp = C_tmp + zabs(C_q_(nw))**2
            nx2 = ndv + n_delta_v*(ns + n_S*nm)
            nx3 = nw*n_delta_v*n_S*n_M
            Z_tmp = Z_tmp + zabs(C_q_(nw) - S_T_T_R_CTF_M_q__(nx2 +
     $           nx3))**2
         enddo                  !do nw=0,n_w_max-1
         C_tmp = zsqrt(C_tmp)
         Z_tmp = zsqrt(Z_tmp)
         if (verbose.gt.-2) then
            write(6,'(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A,F16.8)') ,
     $           ' C_q_ vs S_T_T_R_CTF_M_q__: ' ,
     $           ' nx1: ' , nx1 ,' ndv: ' , ndv ,
     $           ' ns: ' , ns ,' nm: ' , nm , ' absolute error: ' ,
     $           real(zabs(Z_tmp)) , ' relative error: ' ,
     $           real(zabs(Z_tmp)/zabs(C_tmp))
         end if                 !if (verbose.gt.2) then            
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         call cp1_c16(n_w_max,C_q_,Z_tmp_)
         do ngz=0,n_gamma_z-1
            CTF_R_S_use = CTF_R_S_use_(ngz)
            gamma_z = gamma_z_(ngz)
            call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $           ,Z_tmp)
c$$$            nC = ndv + n_delta_v*ngz
            nC = ngz
            if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
               C_Z_use = 1.0d0
            else
               C_Z_use = C_M*CTF_R_S_use
            end if
            ZZ1_(nC) = Z_tmp/(n_r**4)/C_Z_use
         enddo !do ngz=0,n_gamma_z-1
c$$$         call print_sub_c16(n_gamma_z,ZZ1_,'ZZ1_: ')
         do nw=0,n_w_max-1
            nx2 = ndv + n_delta_v*(ns + n_S*nm)
            nx3 = nw*n_delta_v*n_S*n_M
            Z_tmp_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
         enddo !do nw=0,n_w_max-1
         do ngz=0,n_gamma_z-1
            CTF_R_S_use = CTF_R_S_use_(ngz)
            gamma_z = gamma_z_(ngz)
            call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $           ,Z_tmp)
c$$$            nC = ndv + n_delta_v*ngz
            nC = ngz
            if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
               C_Z_use = 1.0d0
            else
               C_Z_use = C_M*CTF_R_S_use
            end if
            ZZ2_(nC) = Z_tmp/(n_r**4)/C_Z_use
         enddo !do ngz=0,n_gamma_z-1
c$$$         call print_sub_c16(n_gamma_z,ZZ2_,'ZZ2_: ')
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         C_tmp = (0.0d0,0.0d0)
         Z_tmp = (0.0d0,0.0d0)
         do ngz=0,n_gamma_z-1
            C_tmp = C_tmp + zabs(ZZ1_(ngz))**2
            Z_tmp = Z_tmp + zabs(ZZ1_(ngz) - ZZ2_(ngz))**2
         enddo                  !do ngz=0,n_gamma_z-1
         C_tmp = zsqrt(C_tmp)
         Z_tmp = zsqrt(Z_tmp)
         if (verbose.gt.-2) then
            write(6, '(A,A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A,F16.8)')
     $           ' Correlations(C_q_) vs'
     $           ,' Correlations(S_T_T_R_CTF_M_q__): ' , ' nx1: ' , nx1
     $           ,' ndv: ' , ndv , ' ns: ' , ns
     $           ,' nm: ' , nm , ' absolute error: ' , real(zabs(Z_tmp))
     $           , ' relative error: ' , real(zabs(Z_tmp)/zabs(C_tmp))
         end if                 !if (verbose.gt.2) then
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$         write(6,'(1(A,I0))') ' ndv ' , ndv 
c$$$         call print_all_c16(n_gamma_z ,ZZ1_,' ZZ1_: ')
c$$$         call print_all_c16(n_gamma_z ,ZZ2_,' ZZ2_: ')         
      enddo                     !do nx1=0,n_delta_v*n_S*n_M-1
      
      deallocate(CTF_R_S_use_)
      deallocate(ZZ1_)
      deallocate(ZZ2_)
      deallocate(C_q_)
      deallocate(Z_tmp_)

      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[finished ti8_check_SxTTRM_3]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Tests S_T_T_R_CTF_M_q_ calculation directly. ;\n
      subroutine ti8_check_SxZTRM_4(verbose,svd_d_max,n_svd_d,svd_d_
     $     ,svd_r_max,n_svd_r,svd_r_,n_svd_l,svd_l_,svd_U_d_,svd_s_
     $     ,svd_V_r_ ,Z_M_svdd_,n_delta_v,delta_x_ ,delta_y_ ,n_gamma_z
     $     ,gamma_z_ ,delta_x_est_,delta_y_est_ ,gamma_z_est_
     $     ,ctf_ind_est_ ,fftw_plan_frwd_,fftw_plan_back_,fftw_in1_
     $     ,fftw_out_ ,fftw_plan_back_last,fftw_in1_last_,fftw_out_last_
     $     ,n_r ,grid_p_,n_w_,n_A,S_p_,S_q_,n_S,I_S_sample_,ld_S ,S_p__
     $     ,M_p_ ,M_q_,n_M ,I_M_sample_,ld_M,M_p__,CTF_p_ ,n_CTF ,ld_CTF
     $     ,CTF_p__,C_M_,CTF_R_S_,S_Z_T_R_CTF_M_q__ ,S_T_T_R_CTF_M_q__)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
c$$$      test S_T_T_R_CTF_M_q_.
c$$$      %%%%%%%%%%%%%%%%%%%%%%%
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      integer n_svd_d,n_svd_r,n_svd_l,svd_l_(0:n_svd_l-1)
      real *8 svd_d_(0:n_svd_d-1),svd_r_(0:n_svd_r-1)
      real *8 svd_U_d_(0:n_svd_d*n_svd_l-1)
      real *8 svd_s_(0:n_svd_l-1)
      real *8 svd_V_r_(0:n_svd_r*n_svd_l-1)
      complex *16, allocatable :: Z_S_svdd_(:)
      complex *16 Z_M_svdd_(0:0)
      integer n_delta_v,n_gamma_z
      integer n_r,n_w_(0:n_r-1),n_A
      integer n_S,I_S_sample_(0:n_S-1),ld_S
      integer n_M,I_M_sample_(0:n_M-1),ld_M
      integer n_CTF,ld_CTF
      real *8 delta_x_(0:0)
      real *8 delta_y_(0:0)
      real *8 gamma_z_(0:0)
      real *8 delta_x_est_(0:0)
      real *8 delta_y_est_(0:0)
      real *8 gamma_z_est_(0:0)
      real *8 ctf_ind_est_(0:0)
      real *8 grid_p_(0:n_r-1)
      integer *8 fftw_plan_frwd_(0:n_r-1)
      integer *8 fftw_plan_back_(0:n_r-1)
      integer *8 fftw_plan_back_last
      complex *16 fftw_in1_(0:0),fftw_out_(0:0)
      complex *16 fftw_in1_last_(0:0),fftw_out_last_(0:0)
      complex *16 S_p_(0:0),S_q_(0:0),S_p__(0:0)
      complex *16 M_p_(0:0),M_q_(0:0),M_p__(0:0)
      complex *16 CTF_p_(0:0),CTF_q_(0:0),CTF_p__(0:0)
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 S_Z_T_R_CTF_M_q__(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      real *8 svd_d_max,svd_r_max
      complex *16, allocatable :: CTF_R_S_use_(:)
      complex *16, allocatable :: ZZ1_(:)
      complex *16, allocatable :: ZZ2_(:)
      complex *16, allocatable :: Z_S_svdr_(:)
      complex *16, allocatable :: Z_M_svdr_(:)
      complex *16, allocatable :: C_S_q_(:)
      complex *16, allocatable :: C_M_q_(:)
      complex *16, allocatable :: S_R_T_x_T_R_CTF_M_q__(:)
      complex *16, allocatable :: S_T_R_x_T_R_CTF_M_q__(:)
      complex *16, allocatable :: T_p_(:)
      complex *16, allocatable :: T_q_(:)
      complex *16, allocatable :: Z_tmp_(:)
      complex *16 C_tmp,Z_tmp,C_Z_use,CTF_R_S_use
      complex *16 C_S_tmp,C_M_tmp,Z_S_tmp,Z_M_tmp,Z_X_tmp
      complex *16 costheta_c16_f
      integer n_w_max,nr,nw,ns,nm,nctf,nC
      integer ndv,ngz,nx,ld_X,nx1,nx2,nx3
      real *8 delta_x,delta_y,gamma_z
      real *8 delta_x_est,delta_y_est,gamma_z_est
      integer nsvd_l,nC1,nC2,nC3,nC4
      real *8 pi
      integer *4 MDA_n_d,MDA_d_(0:127)
      character(len=1024) MDA_string
      integer max_i4_f
      integer ns_dump
      integer nm_dump
      integer ndelta_dump
      integer ngamma_dump
      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_check_SxZTRM_4]'
      end if !if (verbose.gt.0) then

      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)
      
c$$$      dump output to dir_tmp. ;
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/svd_d_max.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,svd_d_max,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_svd_d.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_svd_d,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/svd_r_max.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,svd_r_max,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_svd_r.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_svd_r,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_svd_l.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_svd_l,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_svd_l
      write(MDA_string,'(A)') './dir_tmp/svd_l_.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,svd_l_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_svd_d
      write(MDA_string,'(A)') './dir_tmp/svd_d_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,svd_d_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_svd_r
      write(MDA_string,'(A)') './dir_tmp/svd_r_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,svd_r_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_svd_d*n_svd_l
      write(MDA_string,'(A)') './dir_tmp/svd_U_d_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,svd_U_d_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_svd_l
      write(MDA_string,'(A)') './dir_tmp/svd_s_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,svd_s_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_svd_r*n_svd_l
      write(MDA_string,'(A)') './dir_tmp/svd_V_r_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,svd_V_r_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_delta_v.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_delta_v,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_gamma_z.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_gamma_z,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_r.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_r,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_r
      write(MDA_string,'(A)') './dir_tmp/n_w_.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_w_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_A.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_A,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_S.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_S,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_S
      write(MDA_string,'(A)') './dir_tmp/I_S_sample_.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,I_S_sample_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/ld_S.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,ld_S,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_M.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_M,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_M
      write(MDA_string,'(A)') './dir_tmp/I_M_sample_.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,I_M_sample_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/ld_M.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,ld_M,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/n_CTF.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,n_CTF,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/ld_CTF.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,ld_CTF,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_delta_v
      write(MDA_string,'(A)') './dir_tmp/delta_x_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,delta_x_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_delta_v
      write(MDA_string,'(A)') './dir_tmp/delta_y_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,delta_y_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_gamma_z
      write(MDA_string,'(A)') './dir_tmp/gamma_z_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,gamma_z_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_M
      write(MDA_string,'(A)') './dir_tmp/delta_x_est_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,delta_x_est_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_M
      write(MDA_string,'(A)') './dir_tmp/delta_y_est_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,delta_y_est_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_M
      write(MDA_string,'(A)') './dir_tmp/gamma_z_est_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,gamma_z_est_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_M
      write(MDA_string,'(A)') './dir_tmp/ctf_ind_est_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,ctf_ind_est_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_r
      write(MDA_string,'(A)') './dir_tmp/grid_p_.mda'
      call MDA_write_r8(MDA_n_d,MDA_d_,grid_p_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = ld_S*(1+max_i4_f(n_S,I_S_sample_))
      write(MDA_string,'(A)') './dir_tmp/S_p__.mda'
      call MDA_write_c16(MDA_n_d,MDA_d_,S_p__,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = ld_M*(1+max_i4_f(n_M,I_M_sample_))
      write(MDA_string,'(A)') './dir_tmp/M_p__.mda'
      call MDA_write_c16(MDA_n_d,MDA_d_,M_p__,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = ld_CTF*n_CTF
      write(MDA_string,'(A)') './dir_tmp/CTF_p__.mda'
      call MDA_write_c16(MDA_n_d,MDA_d_,CTF_p__,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_w_max*n_svd_l*n_S*n_M
      write(MDA_string,'(A)') './dir_tmp/S_Z_T_R_CTF_M_q__.mda'
      call MDA_write_c16(MDA_n_d,MDA_d_,S_Z_T_R_CTF_M_q__,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_w_max*n_delta_v*n_S*n_M
      write(MDA_string,'(A)') './dir_tmp/S_T_T_R_CTF_M_q__.mda'
      call MDA_write_c16(MDA_n_d,MDA_d_,S_T_T_R_CTF_M_q__,MDA_string)
c$$$      %%%%%%%% ;
      ns_dump = 0
      nm_dump = 0
      ndelta_dump = 0
      ngamma_dump = 0
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/ns_dump.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,ns_dump,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/nm_dump.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,nm_dump,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/ndelta_dump.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,ndelta_dump,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = 1
      write(MDA_string,'(A)') './dir_tmp/ngamma_dump.mda'
      call MDA_write_i4(MDA_n_d,MDA_d_,ngamma_dump,MDA_string)
c$$$      %%%%%%%% ;

      allocate(Z_S_svdd_(0:n_svd_l*n_delta_v - 1))
      call innerproduct_q_k_svdd_3(.true.,svd_d_max,n_svd_d,svd_d_
     $     ,n_svd_l,svd_l_,svd_U_d_,n_delta_v,delta_x_,delta_y_
     $     ,Z_S_svdd_)

c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_svd_l*n_delta_v
      write(MDA_string,'(A)') './dir_tmp/Z_S_svdd_.mda'
      call MDA_write_c16(MDA_n_d,MDA_d_,Z_S_svdd_,MDA_string)
c$$$      %%%%%%%% ;
      MDA_n_d = 1
      MDA_d_(0) = n_svd_l*n_delta_v
      write(MDA_string,'(A)') './dir_tmp/Z_M_svdd_.mda'
      call MDA_write_c16(MDA_n_d,MDA_d_,Z_M_svdd_,MDA_string)
c$$$      %%%%%%%% ;

      allocate(Z_S_svdr_(0:n_svd_l*n_w_max - 1))
      call cl1_c16(n_svd_l*n_w_max,Z_S_svdr_)
      allocate(Z_M_svdr_(0:n_svd_l*n_w_max - 1))
      call cl1_c16(n_svd_l*n_w_max,Z_M_svdr_)
      allocate(C_S_q_(0:n_w_max*n_delta_v-1))
      call cl1_c16(n_w_max*n_delta_v,C_S_q_)
      allocate(C_M_q_(0:n_w_max*n_delta_v-1))
      call cl1_c16(n_w_max*n_delta_v,C_M_q_)
      allocate(S_R_T_x_T_R_CTF_M_q__(0:n_w_max-1))
      call cl1_c16(n_w_max,S_R_T_x_T_R_CTF_M_q__)
      allocate(S_T_R_x_T_R_CTF_M_q__(0:n_w_max-1))
      call cl1_c16(n_w_max,S_T_R_x_T_R_CTF_M_q__)
      allocate(T_p_(0:n_A-1))
      call cl1_c16(n_A,T_p_)
      allocate(T_q_(0:n_A-1))
      call cl1_c16(n_A,T_q_)

      allocate(CTF_R_S_use_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      allocate(ZZ1_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,ZZ1_)
      allocate(ZZ2_(0:n_gamma_z-1))
      call cl1_c16(n_gamma_z,ZZ2_)
      allocate(Z_tmp_(0:n_w_max-1))
      call cl1_c16(n_w_max,Z_tmp_)
      do nx1=0,n_S*n_M-1
         nx = nx1
         ns = mod(nx,n_S)
         nx = (nx-ns)/n_S
         nm = mod(nx,n_M)
         nx = (nx-nm)/n_M
         if (nx.ne.0) then
            write(6,'(A,I0)') 'Warning, incorrectly unpacked nx1: '
     $           , nx1
         end if                 ! if (nx.ne.0) then
         if (verbose.gt.2) then
            write(6,'(A,I0,A,I0,A,I0)') , ' nx1: ' , nx1 , ' ns: ' , ns
     $           ,' nm: ' , nm 
         end if                 !if (verbose.gt.2) then
c$$$         Define CTF_R_S_use_
         gamma_z_est = +gamma_z_est_(nm)
         nctf = nint(ctf_ind_est_(nm))
         call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 + ns
     $        *n_gamma_z + nctf*n_gamma_z*n_S),CTF_R_S_use_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_gamma_z
            write(MDA_string,'(A)') './dir_tmp/CTF_R_S_use_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,CTF_R_S_use_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
c$$$         Define S_q
         call cp1_c16(n_A,S_p__(I_S_sample_(ns)*ld_S),S_p_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_A
            write(MDA_string,'(A)') './dir_tmp/S_p_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,S_p_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_ ,n_A
     $        ,fftw_in1_,fftw_out_,S_p_,S_q_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_A
            write(MDA_string,'(A)') './dir_tmp/S_q_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,S_q_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         delta_x_est = +delta_x_est_(nm)
         delta_y_est = +delta_y_est_(nm)
         gamma_z_est = +gamma_z_est_(nm)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = 1
            write(MDA_string,'(A)') './dir_tmp/delta_x_est.mda'
            call MDA_write_r8(MDA_n_d,MDA_d_,delta_x_est,MDA_string)            
            write(MDA_string,'(A)') './dir_tmp/delta_y_est.mda'
            call MDA_write_r8(MDA_n_d,MDA_d_,delta_y_est,MDA_string)            
            write(MDA_string,'(A)') './dir_tmp/gamma_z_est.mda'
            call MDA_write_r8(MDA_n_d,MDA_d_,gamma_z_est,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
c$$$         Define M_q
         nctf = nint(ctf_ind_est_(nm))
         call cp1_c16(n_A,M_p__(I_M_sample_(nm)*ld_M),M_p_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_A
            write(MDA_string,'(A)') './dir_tmp/M_p_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,M_p_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         call xc1_c16(n_A,M_p_,CTF_p__(nctf*ld_CTF),M_p_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_A
            write(MDA_string,'(A)') './dir_tmp/M_p_1_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,M_p_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         call rotate_p2p_fx(n_r,fftw_plan_frwd_,fftw_plan_back_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,-gamma_z_est,M_p_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_A
            write(MDA_string,'(A)') './dir_tmp/M_p_2_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,M_p_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         call transf_p_to_p(n_r,grid_p_,n_w_,n_A,M_p_,-delta_x_est,
     $        -delta_y_est,M_p_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_A
            write(MDA_string,'(A)') './dir_tmp/M_p_3_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,M_p_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         call interp_p_to_q_fftw(n_r,fftw_plan_frwd_,n_w_,n_A
     $        ,fftw_in1_,fftw_out_,M_p_,M_q_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_A
            write(MDA_string,'(A)') './dir_tmp/M_q_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,M_q_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
c$$$         Combine S_q and M_q into Z_S_svdr_
         call innerproduct_q_k_svdr_5(.true.,svd_r_max,n_svd_r,svd_r_
     $        ,n_svd_l,svd_l_,svd_s_,svd_V_r_,n_r,grid_p_,n_w_,n_A,S_q_
     $        ,M_q_,Z_S_svdr_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_svd_l*n_w_max
            write(MDA_string,'(A)') './dir_tmp/Z_S_svdr_0_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,Z_S_svdr_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
c$$$         fftw each term in Z_S_svdr_
         do nsvd_l=0,n_svd_l-1
            call cps_c16(n_w_max,Z_S_svdr_(nsvd_l),n_svd_l
     $           ,fftw_out_last_,1)
            call dfftw_execute_(fftw_plan_back_last)
            call cps_c16(n_w_max,fftw_in1_last_,1,Z_S_svdr_(nsvd_l)
     $           ,n_svd_l)
         enddo                  !do svd_l=0,n_svd_l-1
c$$$         Combine S_q and M_q into Z_M_svdr_
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_svd_l*n_w_max
            write(MDA_string,'(A)') './dir_tmp/Z_S_svdr_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,Z_S_svdr_,MDA_string)
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         call innerproduct_q_k_svdr_5(.false.,svd_r_max,n_svd_r,svd_r_
     $        ,n_svd_l,svd_l_,svd_s_,svd_V_r_,n_r,grid_p_,n_w_,n_A,S_q_
     $        ,M_q_,Z_M_svdr_)
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_svd_l*n_w_max
            write(MDA_string,'(A)') './dir_tmp/Z_M_svdr_0_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,Z_M_svdr_,MDA_string)            
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
c$$$         fftw each term in Z_M_svdr_
         do nsvd_l=0,n_svd_l-1
            call cps_c16(n_w_max,Z_M_svdr_(nsvd_l),n_svd_l
     $           ,fftw_out_last_,1)
            call dfftw_execute_(fftw_plan_back_last)
            call cps_c16(n_w_max,fftw_in1_last_,1,Z_M_svdr_(nsvd_l)
     $           ,n_svd_l)
         enddo                  !do svd_l=0,n_svd_l-1
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_svd_l*n_w_max
            write(MDA_string,'(A)') './dir_tmp/Z_M_svdr_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,Z_M_svdr_,MDA_string)
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         do nsvd_l=0,n_svd_l-1
            C_M_tmp = (0.0d0,0.0d0)
            Z_M_tmp = (0.0d0,0.0d0)
            do nw=0,n_w_max-1
               C_M_tmp = C_M_tmp + zabs(Z_M_svdr_(nsvd_l + nw*n_svd_l))
     $              **2
               nx2 = nsvd_l + n_svd_l*(ns + n_S*nm)
               nx3 = nw*n_svd_l*n_S*n_M
               Z_M_tmp = Z_M_tmp + zabs(Z_M_svdr_(nsvd_l + nw*n_svd_l) -
     $              S_Z_T_R_CTF_M_q__(nx2+nx3))**2
            enddo               !do nw=0,n_w_max-1
            C_M_tmp = zsqrt(C_M_tmp)
            Z_M_tmp = zsqrt(Z_M_tmp)
            if (verbose.gt.-2) then
               write(6 ,'(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' Z_M_svdr_ vs S_Z_T_R_CTF_M_q__: ' ,' nx1: ' , nx1
     $              ,' nsvd_l: ' , nsvd_l , ' ns: ' , ns ,' nm: ' , nm ,
     $              ' absolute error: ' ,real(zabs(Z_M_tmp)) ,
     $              ' relative error: ' ,real(zabs(Z_M_tmp)
     $              /zabs(C_M_tmp))
            end if              !if (verbose.gt.2) then               
         enddo                  !do nsvd_l=0,n_svd_l-1
c$$$         Combining terms to recover delta_x and delta_y, ;
c$$$         but not yet interpolating gamma. ;
         nC1 = 0
         do ndv=0,n_delta_v-1
            do nw=0,n_w_max-1
c$$$  nC1 = nw + ndv*n_w_max
               C_S_q_(nC1) = cmplx( 0.0 , 0.0 )
               C_M_q_(nC1) = cmplx( 0.0 , 0.0 )
               nC2 = ndv*n_svd_l
               nC3 = nw*n_svd_l
               do nsvd_l=0,n_svd_l-1
                  C_S_q_(nC1) = C_S_q_(nC1) + Z_S_svdd_(nC2)
     $                 *Z_S_svdr_(nC3)
                  C_M_q_(nC1) = C_M_q_(nC1) + Z_M_svdd_(nC2)
     $                 *Z_M_svdr_(nC3)
                  nC2 = nC2 + 1
                  nC3 = nC3 + 1
               enddo            !do nsvd_l=0,n_svd_l-1
               nC1 = nC1 + 1
            enddo               !do nw=0,n_w_max-1
         enddo                  !do ndv=0,n_delta_v-1
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         if (verbose.gt.3) then
         do ndv=0,n_delta_v-1
            write(6,'(A,I0)') ' ndv:' , ndv 
            call print_sub_c16(n_w_max,C_S_q_(n_w_max*ndv),' C_S_q_: ')
            call print_sub_c16(n_w_max,C_M_q_(n_w_max*ndv),' C_M_q_: ')
         enddo !do ndv=0,n_delta_v-1
         end if !if (verbose.gt.3) then
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_w_max*n_delta_v
            write(MDA_string,'(A)') './dir_tmp/C_S_q_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,C_S_q_,MDA_string)
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
c$$$         %%%%%%%%
         if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_w_max*n_delta_v
            write(MDA_string,'(A)') './dir_tmp/C_M_q_.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,C_M_q_,MDA_string)
         end if !if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump)) then
c$$$         %%%%%%%%
         do ndv=0,n_delta_v-1
            delta_x = delta_x_(ndv)
            delta_y = delta_y_(ndv)
            C_S_tmp = (0.0d0,0.0d0)
            Z_S_tmp = (0.0d0,0.0d0)
            C_M_tmp = (0.0d0,0.0d0)
            Z_M_tmp = (0.0d0,0.0d0)
            Z_X_tmp = (0.0d0,0.0d0)
            call cl1_c16(n_w_max,S_R_T_x_T_R_CTF_M_q__)
            call cl1_c16(n_w_max,S_T_R_x_T_R_CTF_M_q__)
            do nw=0,n_w_max-1
               gamma_z = (2.0d0*pi*nw)/(1.0d0*n_w_max)
               call cp1_c16(n_A,S_q_,T_q_)
               call transf_svd_q_to_q_5(svd_r_max,n_svd_r,svd_r_
     $              ,svd_d_max,n_svd_d,svd_d_,n_svd_l,svd_l_,svd_U_d_
     $              ,svd_s_,svd_V_r_,n_r,grid_p_,n_w_,n_A,T_q_,delta_x
     $              ,delta_y,T_q_)
               call rotate_q_to_q_0(n_r,n_w_,n_A,T_q_,gamma_z,T_q_)
               call innerproduct_p(n_r,grid_p_,n_w_,n_A,T_q_,M_q_
     $              ,S_T_R_x_T_R_CTF_M_q__(nw))
               call cp1_c16(n_A,S_q_,T_q_)
               call rotate_q_to_q_0(n_r,n_w_,n_A,T_q_,gamma_z,T_q_)
               call transf_svd_q_to_q_5(svd_r_max,n_svd_r,svd_r_
     $              ,svd_d_max,n_svd_d,svd_d_,n_svd_l,svd_l_,svd_U_d_
     $              ,svd_s_,svd_V_r_,n_r,grid_p_,n_w_,n_A,T_q_,delta_x
     $              ,delta_y,T_q_)
               call innerproduct_p(n_r,grid_p_,n_w_,n_A,T_q_,M_q_
     $              ,S_R_T_x_T_R_CTF_M_q__(nw))
               nC4 = nw + n_w_max*ndv
c$$$  C_S_tmp = C_S_tmp + zabs(C_S_q_(nC4))**2
c$$$  C_M_tmp = C_M_tmp + zabs(C_M_q_(nC4))**2
               C_S_tmp = C_S_tmp + zabs(S_T_R_x_T_R_CTF_M_q__(nw))**2
               C_M_tmp = C_M_tmp + zabs(S_R_T_x_T_R_CTF_M_q__(nw))**2
               nx2 = ndv + n_delta_v*(ns + n_S*nm)
               nx3 = nw*n_delta_v*n_S*n_M
               Z_S_tmp = Z_S_tmp + zabs(C_S_q_(nC4) -
     $              S_T_R_x_T_R_CTF_M_q__(nw))**2
               Z_M_tmp = Z_M_tmp + zabs(C_M_q_(nC4) -
     $              S_R_T_x_T_R_CTF_M_q__(nw))**2
               Z_X_tmp = Z_X_tmp + zabs(C_M_q_(nC4) -
     $              S_T_T_R_CTF_M_q__(nx2+nx3))**2
            enddo               !do nw=0,n_w_max-1
c$$$         %%%%%%%%
            if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump) .and.
     $           (ndv.eq.ndelta_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_w_max
            write(MDA_string,'(A)')
     $           './dir_tmp/S_R_T_x_T_R_CTF_M_q__.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,S_R_T_x_T_R_CTF_M_q__
     $           ,MDA_string)
         end if !if dump
c$$$         %%%%%%%%
c$$$         %%%%%%%%
            if ((ns.eq.ns_dump) .and. (nm.eq.nm_dump) .and.
     $           (ndv.eq.ndelta_dump)) then
            MDA_n_d = 1
            MDA_d_(0) = n_w_max
            write(MDA_string,'(A)')
     $           './dir_tmp/S_T_R_x_T_R_CTF_M_q__.mda'
            call MDA_write_c16(MDA_n_d,MDA_d_,S_T_R_x_T_R_CTF_M_q__
     $           ,MDA_string)
         end if !if dump
c$$$         %%%%%%%%

            C_S_tmp = zsqrt(C_S_tmp)
            Z_S_tmp = zsqrt(Z_S_tmp)
            C_M_tmp = zsqrt(C_M_tmp)
            Z_M_tmp = zsqrt(Z_M_tmp)
            Z_X_tmp = zsqrt(Z_X_tmp)
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_S_q_ vs S_T_R_x_T_R_CTF_M_q__: ' ,' nx1: ' ,
     $              nx1 ,' ndv: ' , ndv , ' ns: ' ,
     $              ns ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_S_tmp)) , ' relative error: '
     $              ,real(zabs(Z_S_tmp) /zabs(C_S_tmp))
            end if              !if (verbose.gt.2) then               
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_M_q_ vs S_R_T_x_T_R_CTF_M_q__: ' ,' nx1: ' ,
     $              nx1 ,' ndv: ' , ndv ,' ns: ' ,
     $              ns ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_M_tmp)) , ' relative error: '
     $              ,real(zabs(Z_M_tmp) /zabs(C_M_tmp))
            end if              !if (verbose.gt.2) then               
            if (verbose.gt.-2) then
               write(6
     $              ,'(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A ,F16.8)')
     $              ,' C_M_q_ vs S_T_T_R_CTF_M_q__: ' ,' nx1: ' , nx1
     $              ,' ndv: ' , ndv ,' ns: ' , ns
     $              ,' nm: ' , nm , ' absolute error: '
     $              ,real(zabs(Z_X_tmp)) , ' relative error: '
     $              ,real(zabs(Z_X_tmp) /zabs(C_M_tmp))
            end if              !if (verbose.gt.2) then               
         enddo !do ndv=0,n_delta_v-1
c$$$         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         do ndv=0,n_delta_v-1
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call cp1_c16(n_w_max,C_M_q_(0+n_w_max*ndv),Z_tmp_)
            do ngz=0,n_gamma_z-1
               CTF_R_S_use = CTF_R_S_use_(ngz)
               gamma_z = gamma_z_(ngz)
               call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $              ,Z_tmp)
c$$$  nC = ndv + n_delta_v*ngz
               nC = ngz
               if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
                  C_Z_use = 1.0d0
               else
                  C_Z_use = C_M*CTF_R_S_use
               end if
               ZZ1_(nC) = Z_tmp/(n_r**4)/C_Z_use
            enddo               !do ngz=0,n_gamma_z-1
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            do nw=0,n_w_max-1
               nx2 = ndv + n_delta_v*(ns + n_S*nm)
               nx3 = nw*n_delta_v*n_S*n_M
               Z_tmp_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
            enddo               !do nw=0,n_w_max-1
            do ngz=0,n_gamma_z-1
               CTF_R_S_use = CTF_R_S_use_(ngz)
               gamma_z = gamma_z_(ngz)
               call interp1_c16(n_w_max,0.0d0,2*pi,Z_tmp_,+gamma_z
     $              ,Z_tmp)
               nC = ngz
               if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
                  C_Z_use = 1.0d0
               else
                  C_Z_use = C_M*CTF_R_S_use
               end if
               ZZ2_(nC) = Z_tmp/(n_r**4)/C_Z_use
            enddo               !do ngz=0,n_gamma_z-1
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            C_tmp = (0.0d0,0.0d0)
            Z_tmp = (0.0d0,0.0d0)
            do ngz=0,n_gamma_z-1
               C_tmp = C_tmp + zabs(ZZ1_(ngz))**2
               Z_tmp = Z_tmp + zabs(ZZ1_(ngz) - ZZ2_(ngz))**2
            enddo               !do ngz=0,n_gamma_z-1
            C_tmp = zsqrt(C_tmp)
            Z_tmp = zsqrt(Z_tmp)
            if (verbose.gt.-2) then
               write(6 ,
     $              '(A,A,I0,A,I0,A,I0,A,I0,A,F16.8,A,F16.8)'
     $              )' ZZ1 vs ZZ2: ' ,' nx1: ' , nx1 ,' ndv: ' , ndv
     $              , ' ns: ' , ns ,' nm: ' , nm ,
     $              ' absolute error: ' ,real(zabs(Z_tmp)) ,
     $              ' relative error: ' ,real(zabs(Z_tmp)
     $              /zabs(C_tmp))
            end if              !if (verbose.gt.2) then            
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         enddo                  !do ndv=0,n_delta_v-1

      enddo ! do nx1=0,n_S*n_M-1

      deallocate(S_R_T_x_T_R_CTF_M_q__)
      deallocate(S_T_R_x_T_R_CTF_M_q__)
      deallocate(T_p_)
      deallocate(T_q_)
      deallocate(Z_S_svdr_)
      deallocate(Z_M_svdr_)
      deallocate(C_S_q_)
      deallocate(C_M_q_)
      deallocate(CTF_R_S_use_)
      deallocate(ZZ1_)
      deallocate(ZZ2_)
      deallocate(Z_tmp_)
      deallocate(Z_S_svdd_)

      if (verbose.gt.0) then
         write(6,'(A)')
     $        '[finished ti8_check_SxZTRM_4]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Performs part of the search-and-store routine. ;\n
      subroutine ti8_Zstore_3a(
     $     verbose
     $     ,rseed
     $     ,flag_RTRT_vs_RTTR
     $     ,n_delta_v
     $     ,delta_x_
     $     ,delta_y_
     $     ,n_gamma_z
     $     ,gamma_z_
     $     ,n_r 
     $     ,grid_p_
     $     ,n_w_
     $     ,n_A
     $     ,n_S_sub
     $     ,n_S_sum
     $     ,S_alpha_S_index_
     $     ,S_alpha_polar_a_
     $     ,S_alpha_azimu_b_
     $     ,n_M_sub
     $     ,polar_a_est_
     $     ,azimu_b_est_
     $     ,gamma_z_est_ 
     $     ,delta_x_est_
     $     ,delta_y_est_
     $     ,l2_norm_est_
     $     ,ctf_ind_est_ 
     $     ,S_index_est_
     $     ,M_index_est_
     $     ,alpha__in_
     $     ,alpha_update_f
     $     ,displacement_max
     $     ,flag_MS_vs_SM
     $     ,n_SM_max
     $     ,n_SM_
     $     ,alpha_SM__
     $     ,n_MS_max
     $     ,n_MS_
     $     ,alpha_MS__
     $     ,C_M_
     $     ,n_CTF
     $     ,CTF_R_S_ 
     $     ,CTF_R_S_use_ 
     $     ,n_M_tot
     $     ,S_T_T_R_CTF_M_q__ 
     $     ,ZZ_
     $     ,ZZ_sub_
     $     )
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      integer *4 rseed !random seed. ;
      real *8 adi_rand_f
      integer n_delta_v,n_gamma_z,n_CTF
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 S_alpha_S_index_(0:0)
      real *8 S_alpha_polar_a_(0:0)
      real *8 S_alpha_azimu_b_(0:0)
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      real *8 polar_a_est_(0:n_M_sub-1),azimu_b_est_(0:n_M_sub-1)
     $     ,gamma_z_est_(0:n_M_sub-1)
      real *8 delta_x_est_(0:n_M_sub-1),delta_y_est_(0:n_M_sub-1)
     $     ,l2_norm_est_(0:n_M_sub-1)
      real *8 ctf_ind_est_(0:n_M_sub-1)
      real *8 S_index_est_(0:n_M_sub-1)
      real *8 M_index_est_(0:n_M_sub-1)
      real *8 displacement_max
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM_(0:0) ! array of size n_M indicating the actual number of templates stored per image. ;
      real *8 alpha_SM__(0:0) ! array of size n_alpha*n_SM_max*n_M storing the image-parameters for each stored template-image pair. ;
c$$$      MS storage
      integer *4 n_MS_max ! total (maximum) number of images to store per template. ;
      integer *4 n_MS_(0:0) ! array of size n_S indicating the actual number of images stored per template. ;
      real *8 alpha_MS__(0:0) ! array of size n_alpha*n_MS_max*n_S storing the image-parameters for each stored iamge-template pair. ;
      real *8 alpha_update_f
      include 'nalpha_define.f'
      real *8 alpha__in_(0:n_alpha-1)
      integer n_S_sub,n_S_sum,n_M_sub,n_M_tot
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 CTF_R_S_use_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16 ZZ_(0:0)
      complex *16 ZZ_sub_(0:0)
      complex *16 ZZ
      complex *16 CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,nC,nC_stride
      integer ndv,ngz
      integer ns,nm,nctf,ns_use,nr_use
      integer nx2,nx3,nx3_stride
      real *8 delta_x,delta_y,gamma_z,gamma_z_est
      integer ndv_optimal,ngz_optimal
      real *8 delta_x_optimal,delta_y_optimal,gamma_z_optimal
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      complex *16 C_Z_optimal,CTF_R_S_optimal,l2_norm_optimal
      real *8 pi
      character(len=1024) format_string

      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_Zstore_3a]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_x_,' delta_x_: ')
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_y_,' delta_y_: ')
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         write(6,'(A,I0)') ' n_r : ' , n_r 
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,I0)') ' n_S_sub: ' , n_S_sub
         call print_sub_r8(n_S_sub,S_alpha_S_index_
     $        ,' S_alpha_S_index_: ')
         call print_sub_r8(n_S_sub,S_alpha_polar_a_
     $        ,' S_alpha_polar_a_: ')
         call print_sub_r8(n_S_sub,S_alpha_azimu_b_
     $        ,' S_alpha_azimu_b_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_sub_r8(n_M_sub,polar_a_est_,' polar_a_est_: ')
         call print_sub_r8(n_M_sub,azimu_b_est_,' azimu_b_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,l2_norm_est_,' l2_norm_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         call print_sub_r8(n_M_sub,S_index_est_,' S_index_est_: ')
         call print_sub_r8(n_M_sub,M_index_est_,' M_index_est_: ')
         write(6,'(A,F8.4)') ' alpha_update_f: ' , alpha_update_f
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
         write(6,'(A,L1)') ' flag_MS_vs_SM: ' , flag_MS_vs_SM
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         call print_sub_i4(n_M_sub,n_SM_,' n_SM_: ')
         call print_sub_r8(n_alpha*n_SM_max*n_M_sub,alpha_SM__
     $        ,' alpha_SM__: ')
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S_sub,n_MS_,' n_MS_: ')
         call print_sub_r8(n_alpha*n_MS_max*n_S_sub,alpha_MS__
     $        ,' alpha_MS__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         call print_sub_c16(n_gamma_z*n_CTF*n_S_sub,
     $        CTF_R_S_,' CTF_R_S_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
         call print_sub_c16(n_delta_v*n_S_sub*n_M_sub
     $        ,S_T_T_R_CTF_M_q__,' S_T_T_R_CTF_M_q__: ')
         call print_sub_c16(n_delta_v*n_gamma_z
     $        ,ZZ_,' ZZ_: ')
      end if !if (verbose.gt.1) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      call cl1_r8(n_alpha,alpha__in_)
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      call cl1_c16(n_w_max,ZZ_sub_)

c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      do nm=0,n_M_sub-1
         C_M = C_M_(nm)
         nctf = nint(ctf_ind_est_(nm))
         gamma_z_est = gamma_z_est_(nm)
         do ns=0,n_S_sub-1
            call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
     $           n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
            do ngz=0,n_gamma_z-1
               if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then
                  CTF_R_S_use_(ngz) = 1.0d0
               else
                  CTF_R_S_use_(ngz) = 1.0d0/(C_M*CTF_R_S_use_(ngz)*n_r
     $                 **4)
               end if !if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then               
            enddo !do ngz=0,n_gamma_z-1
c$$$            call cl1_c16(n_delta_v*n_gamma_z,ZZ_)
c$$$            if (n_gamma_z.eq.n_w_max) then
c$$$            nx2 = n_delta_v*(ns + n_S_sub*nm)
c$$$            nx3_stride = n_delta_v*n_S_sub*n_M_tot
c$$$            nC_stride = n_delta_v
c$$$            do ndv=0,n_delta_v-1
c$$$               nx3 = 0
c$$$               nC = ndv
c$$$               do nw=0,n_w_max-1
c$$$                  ngz = nw
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  ZZ_(nC) = S_T_T_R_CTF_M_q__(nx2 + nx3)*CTF_R_S_use
c$$$                  nx3 = nx3 + nx3_stride
c$$$                  nC = nC + nC_stride
c$$$               enddo            !do nw
c$$$               nx2 = nx2 + 1
c$$$            enddo ! do ndv
c$$$            else
c$$$            do ndv=0,n_delta_v-1
c$$$               delta_y = delta_y_(ndv)
c$$$               delta_x = delta_x_(ndv)
c$$$               call cl1_c16(n_w_max,ZZ_sub_)
c$$$               do nw=0,n_w_max-1
c$$$                  nx2 = ndv + n_delta_v*(ns + n_S_sub*nm)
c$$$                  nx3 = nw*n_delta_v*n_S_sub*n_M_tot
c$$$                  ZZ_sub_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
c$$$               enddo            !do nw
c$$$               do ngz=0,n_gamma_z-1
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  gamma_z = gamma_z_(ngz)
c$$$                  call interp1_c16(n_w_max,0.0d0,2*pi,ZZ_sub_,
c$$$     $                 +gamma_z,ZZ)
c$$$                  nC = ndv + n_delta_v*ngz
c$$$                  ZZ_(nC) = ZZ*CTF_R_S_use
c$$$               enddo            !do ngz
c$$$            enddo ! do ndv
c$$$            end if !if (n_gamma_z.eq.n_w_max) then
c$$$c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call ti8_ZZ_scan_4(flag_RTRT_vs_RTTR
c$$$     $           ,delta_x_est_(nm),delta_y_est_(nm),gamma_z_est_(nm)
c$$$     $           ,displacement_max,n_delta_v ,delta_x_ ,delta_y_
c$$$     $           ,n_gamma_z,gamma_z_,ZZ_ ,ndv_optimal ,ngz_optimal
c$$$     $           ,C_Z_optimal)
c$$$            delta_x_optimal = delta_x_(ndv_optimal)
c$$$            delta_y_optimal = delta_y_(ndv_optimal)
c$$$            gamma_z_optimal = gamma_z_(ngz_optimal)
c$$$c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_(0
c$$$     $           +ns*n_gamma_z + nctf*n_gamma_z*n_S_sub),
c$$$     $           +gamma_z_est_(nm) ,ngz_optimal,CTF_R_S_optimal)
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A,I0,A,I0,A,I2,1X,I2,A,2F8.3,A,2F8.3)')
c$$$     $              ' Match between M_q_(' , nm , ') and S_q_(',ns
c$$$     $              ,') at ndv_optimal,ngz_optimal: '
c$$$     $              ,ndv_optimal ,ngz_optimal
c$$$     $              ,'; CTF_R_S_optimal: ',CTF_R_S_optimal ,
c$$$     $              '; C_Z_optimal: ' ,C_Z_optimal
c$$$            end if !verbose            
c$$$            if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$               l2_norm_optimal = 1.0d0
c$$$            else 
c$$$               l2_norm_optimal = zabs(C_M_(nm)) *zabs(C_Z_optimal)
c$$$     $              /zabs(CTF_R_S_optimal)
c$$$            end if ! if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$            call cl1_r8(n_alpha,alpha__in_)
c$$$            alpha__in_(nalpha_polar_a) = S_alpha_polar_a_(ns)
c$$$            alpha__in_(nalpha_azimu_b) = S_alpha_azimu_b_(ns)
c$$$            alpha__in_(nalpha_gamma_z) = gamma_z_optimal
c$$$            alpha__in_(nalpha_delta_x) = delta_x_optimal
c$$$            alpha__in_(nalpha_delta_y) = delta_y_optimal
c$$$            alpha__in_(nalpha_l2_norm) = l2_norm_optimal
c$$$            alpha__in_(nalpha_ctf_ind) = nctf
c$$$            alpha__in_(nalpha_S_index) = S_alpha_S_index_(ns)
c$$$            alpha__in_(nalpha_M_index) = M_index_est_(nm)
c$$$            alpha__in_(nalpha_CTF_R_S) = CTF_R_S_optimal
c$$$            alpha__in_(nalpha_C_Z_opt) = C_Z_optimal
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A)') ' calling alpha_SM_update_1 with '
c$$$               write(6,'(5(A,I0))') ' n_alpha ' , n_alpha , ' n_SM_max '
c$$$     $              , n_SM_max , ' nm ' , nm ,' nm*n_alpha*n_SM_max ' ,
c$$$     $              nm*n_alpha*n_SM_max , ' n_SM_(nm) ' , n_SM_(nm) 
c$$$               write(6,'(A,I0)') ' calling alpha_SM_update_1 with '
c$$$               call print_all_r8(n_alpha,alpha__in_
c$$$     $              ,' alpha__in_: ')
c$$$            end if !if (verbose.gt.2) then
c$$$            if (flag_MS_vs_SM.eqv..true.) then
c$$$c$$$        Note: we use alpha_SM_update to update MS as well.
c$$$            call alpha_SM_update_1(n_MS_max,n_MS_(ns)
c$$$     $           ,alpha_MS__(ns*n_alpha*n_MS_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..true.) then
c$$$            if (flag_MS_vs_SM.eqv..false.) then
c$$$            call alpha_SM_update_1(n_SM_max,n_SM_(nm)
c$$$     $           ,alpha_SM__(nm*n_alpha*n_SM_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..false.) then
         enddo !do ns=0,n_S_sub-1
      enddo !do nm=0,n_M_sub-1
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_Zstore_3a]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Performs part of the search-and-store routine. ;\n
      subroutine ti8_Zstore_3b(
     $     verbose
     $     ,rseed
     $     ,flag_RTRT_vs_RTTR
     $     ,n_delta_v
     $     ,delta_x_
     $     ,delta_y_
     $     ,n_gamma_z
     $     ,gamma_z_
     $     ,n_r 
     $     ,grid_p_
     $     ,n_w_
     $     ,n_A
     $     ,n_S_sub
     $     ,n_S_sum
     $     ,S_alpha_S_index_
     $     ,S_alpha_polar_a_
     $     ,S_alpha_azimu_b_
     $     ,n_M_sub
     $     ,polar_a_est_
     $     ,azimu_b_est_
     $     ,gamma_z_est_ 
     $     ,delta_x_est_
     $     ,delta_y_est_
     $     ,l2_norm_est_
     $     ,ctf_ind_est_ 
     $     ,S_index_est_
     $     ,M_index_est_
     $     ,alpha__in_
     $     ,alpha_update_f
     $     ,displacement_max
     $     ,flag_MS_vs_SM
     $     ,n_SM_max
     $     ,n_SM_
     $     ,alpha_SM__
     $     ,n_MS_max
     $     ,n_MS_
     $     ,alpha_MS__
     $     ,C_M_
     $     ,n_CTF
     $     ,CTF_R_S_ 
     $     ,CTF_R_S_use_ 
     $     ,n_M_tot
     $     ,S_T_T_R_CTF_M_q__ 
     $     ,ZZ_
     $     ,ZZ_sub_
     $     )
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      integer *4 rseed !random seed. ;
      real *8 adi_rand_f
      integer n_delta_v,n_gamma_z,n_CTF
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 S_alpha_S_index_(0:0)
      real *8 S_alpha_polar_a_(0:0)
      real *8 S_alpha_azimu_b_(0:0)
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      real *8 polar_a_est_(0:n_M_sub-1),azimu_b_est_(0:n_M_sub-1)
     $     ,gamma_z_est_(0:n_M_sub-1)
      real *8 delta_x_est_(0:n_M_sub-1),delta_y_est_(0:n_M_sub-1)
     $     ,l2_norm_est_(0:n_M_sub-1)
      real *8 ctf_ind_est_(0:n_M_sub-1)
      real *8 S_index_est_(0:n_M_sub-1)
      real *8 M_index_est_(0:n_M_sub-1)
      real *8 displacement_max
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM_(0:0) ! array of size n_M indicating the actual number of templates stored per image. ;
      real *8 alpha_SM__(0:0) ! array of size n_alpha*n_SM_max*n_M storing the image-parameters for each stored template-image pair. ;
c$$$      MS storage
      integer *4 n_MS_max ! total (maximum) number of images to store per template. ;
      integer *4 n_MS_(0:0) ! array of size n_S indicating the actual number of images stored per template. ;
      real *8 alpha_MS__(0:0) ! array of size n_alpha*n_MS_max*n_S storing the image-parameters for each stored iamge-template pair. ;
      real *8 alpha_update_f
      include 'nalpha_define.f'
      real *8 alpha__in_(0:n_alpha-1)
      integer n_S_sub,n_S_sum,n_M_sub,n_M_tot
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 CTF_R_S_use_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16 ZZ_(0:0)
      complex *16 ZZ_sub_(0:0)
      complex *16 ZZ
      complex *16 CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,nC,nC_stride
      integer ndv,ngz
      integer ns,nm,nctf,ns_use,nr_use
      integer nx2,nx3,nx3_stride
      real *8 delta_x,delta_y,gamma_z,gamma_z_est
      integer ndv_optimal,ngz_optimal
      real *8 delta_x_optimal,delta_y_optimal,gamma_z_optimal
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      complex *16 C_Z_optimal,CTF_R_S_optimal,l2_norm_optimal
      real *8 pi
      character(len=1024) format_string

      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_Zstore_3b]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_x_,' delta_x_: ')
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_y_,' delta_y_: ')
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         write(6,'(A,I0)') ' n_r : ' , n_r 
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,I0)') ' n_S_sub: ' , n_S_sub
         call print_sub_r8(n_S_sub,S_alpha_S_index_
     $        ,' S_alpha_S_index_: ')
         call print_sub_r8(n_S_sub,S_alpha_polar_a_
     $        ,' S_alpha_polar_a_: ')
         call print_sub_r8(n_S_sub,S_alpha_azimu_b_
     $        ,' S_alpha_azimu_b_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_sub_r8(n_M_sub,polar_a_est_,' polar_a_est_: ')
         call print_sub_r8(n_M_sub,azimu_b_est_,' azimu_b_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,l2_norm_est_,' l2_norm_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         call print_sub_r8(n_M_sub,S_index_est_,' S_index_est_: ')
         call print_sub_r8(n_M_sub,M_index_est_,' M_index_est_: ')
         write(6,'(A,F8.4)') ' alpha_update_f: ' , alpha_update_f
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
         write(6,'(A,L1)') ' flag_MS_vs_SM: ' , flag_MS_vs_SM
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         call print_sub_i4(n_M_sub,n_SM_,' n_SM_: ')
         call print_sub_r8(n_alpha*n_SM_max*n_M_sub,alpha_SM__
     $        ,' alpha_SM__: ')
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S_sub,n_MS_,' n_MS_: ')
         call print_sub_r8(n_alpha*n_MS_max*n_S_sub,alpha_MS__
     $        ,' alpha_MS__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         call print_sub_c16(n_gamma_z*n_CTF*n_S_sub,
     $        CTF_R_S_,' CTF_R_S_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
         call print_sub_c16(n_delta_v*n_S_sub*n_M_sub
     $        ,S_T_T_R_CTF_M_q__,' S_T_T_R_CTF_M_q__: ')
         call print_sub_c16(n_delta_v*n_gamma_z
     $        ,ZZ_,' ZZ_: ')
      end if !if (verbose.gt.1) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      call cl1_r8(n_alpha,alpha__in_)
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      call cl1_c16(n_w_max,ZZ_sub_)

c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      do nm=0,n_M_sub-1
         C_M = C_M_(nm)
         nctf = nint(ctf_ind_est_(nm))
         gamma_z_est = gamma_z_est_(nm)
         do ns=0,n_S_sub-1
c$$$            call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
c$$$     $           n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
            do ngz=0,n_gamma_z-1
               if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then
                  CTF_R_S_use_(ngz) = 1.0d0
               else
                  CTF_R_S_use_(ngz) = 1.0d0/(C_M*CTF_R_S_use_(ngz)*n_r
     $                 **4)
               end if !if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then               
            enddo !do ngz=0,n_gamma_z-1
            call cl1_c16(n_delta_v*n_gamma_z,ZZ_)
            if (n_gamma_z.eq.n_w_max) then
            nx2 = n_delta_v*(ns + n_S_sub*nm)
            nx3_stride = n_delta_v*n_S_sub*n_M_tot
            nC_stride = n_delta_v
            do ndv=0,n_delta_v-1
               nx3 = 0
               nC = ndv
               do nw=0,n_w_max-1
                  ngz = nw
                  CTF_R_S_use = CTF_R_S_use_(ngz)
                  ZZ_(nC) = S_T_T_R_CTF_M_q__(nx2 + nx3)*CTF_R_S_use
                  nx3 = nx3 + nx3_stride
                  nC = nC + nC_stride
               enddo            !do nw
               nx2 = nx2 + 1
            enddo ! do ndv
            else
            do ndv=0,n_delta_v-1
               delta_y = delta_y_(ndv)
               delta_x = delta_x_(ndv)
               call cl1_c16(n_w_max,ZZ_sub_)
               do nw=0,n_w_max-1
                  nx2 = ndv + n_delta_v*(ns + n_S_sub*nm)
                  nx3 = nw*n_delta_v*n_S_sub*n_M_tot
                  ZZ_sub_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
               enddo            !do nw
               do ngz=0,n_gamma_z-1
                  CTF_R_S_use = CTF_R_S_use_(ngz)
                  gamma_z = gamma_z_(ngz)
                  call interp1_c16(n_w_max,0.0d0,2*pi,ZZ_sub_,
     $                 +gamma_z,ZZ)
                  nC = ndv + n_delta_v*ngz
                  ZZ_(nC) = ZZ*CTF_R_S_use
               enddo            !do ngz
            enddo ! do ndv
            end if !if (n_gamma_z.eq.n_w_max) then
c$$$c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call ti8_ZZ_scan_4(flag_RTRT_vs_RTTR
c$$$     $           ,delta_x_est_(nm),delta_y_est_(nm),gamma_z_est_(nm)
c$$$     $           ,displacement_max,n_delta_v ,delta_x_ ,delta_y_
c$$$     $           ,n_gamma_z,gamma_z_,ZZ_ ,ndv_optimal ,ngz_optimal
c$$$     $           ,C_Z_optimal)
c$$$            delta_x_optimal = delta_x_(ndv_optimal)
c$$$            delta_y_optimal = delta_y_(ndv_optimal)
c$$$            gamma_z_optimal = gamma_z_(ngz_optimal)
c$$$c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_(0
c$$$     $           +ns*n_gamma_z + nctf*n_gamma_z*n_S_sub),
c$$$     $           +gamma_z_est_(nm) ,ngz_optimal,CTF_R_S_optimal)
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A,I0,A,I0,A,I2,1X,I2,A,2F8.3,A,2F8.3)')
c$$$     $              ' Match between M_q_(' , nm , ') and S_q_(',ns
c$$$     $              ,') at ndv_optimal,ngz_optimal: '
c$$$     $              ,ndv_optimal ,ngz_optimal
c$$$     $              ,'; CTF_R_S_optimal: ',CTF_R_S_optimal ,
c$$$     $              '; C_Z_optimal: ' ,C_Z_optimal
c$$$            end if !verbose            
c$$$            if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$               l2_norm_optimal = 1.0d0
c$$$            else 
c$$$               l2_norm_optimal = zabs(C_M_(nm)) *zabs(C_Z_optimal)
c$$$     $              /zabs(CTF_R_S_optimal)
c$$$            end if ! if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$            call cl1_r8(n_alpha,alpha__in_)
c$$$            alpha__in_(nalpha_polar_a) = S_alpha_polar_a_(ns)
c$$$            alpha__in_(nalpha_azimu_b) = S_alpha_azimu_b_(ns)
c$$$            alpha__in_(nalpha_gamma_z) = gamma_z_optimal
c$$$            alpha__in_(nalpha_delta_x) = delta_x_optimal
c$$$            alpha__in_(nalpha_delta_y) = delta_y_optimal
c$$$            alpha__in_(nalpha_l2_norm) = l2_norm_optimal
c$$$            alpha__in_(nalpha_ctf_ind) = nctf
c$$$            alpha__in_(nalpha_S_index) = S_alpha_S_index_(ns)
c$$$            alpha__in_(nalpha_M_index) = M_index_est_(nm)
c$$$            alpha__in_(nalpha_CTF_R_S) = CTF_R_S_optimal
c$$$            alpha__in_(nalpha_C_Z_opt) = C_Z_optimal
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A)') ' calling alpha_SM_update_1 with '
c$$$               write(6,'(5(A,I0))') ' n_alpha ' , n_alpha , ' n_SM_max '
c$$$     $              , n_SM_max , ' nm ' , nm ,' nm*n_alpha*n_SM_max ' ,
c$$$     $              nm*n_alpha*n_SM_max , ' n_SM_(nm) ' , n_SM_(nm) 
c$$$               write(6,'(A,I0)') ' calling alpha_SM_update_1 with '
c$$$               call print_all_r8(n_alpha,alpha__in_
c$$$     $              ,' alpha__in_: ')
c$$$            end if !if (verbose.gt.2) then
c$$$            if (flag_MS_vs_SM.eqv..true.) then
c$$$c$$$        Note: we use alpha_SM_update to update MS as well.
c$$$            call alpha_SM_update_1(n_MS_max,n_MS_(ns)
c$$$     $           ,alpha_MS__(ns*n_alpha*n_MS_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..true.) then
c$$$            if (flag_MS_vs_SM.eqv..false.) then
c$$$            call alpha_SM_update_1(n_SM_max,n_SM_(nm)
c$$$     $           ,alpha_SM__(nm*n_alpha*n_SM_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..false.) then
         enddo !do ns=0,n_S_sub-1
      enddo !do nm=0,n_M_sub-1
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_Zstore_3b]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Performs part of the search-and-store routine. ;\n
      subroutine ti8_Zstore_3c(
     $     verbose
     $     ,rseed
     $     ,flag_RTRT_vs_RTTR
     $     ,n_delta_v
     $     ,delta_x_
     $     ,delta_y_
     $     ,n_gamma_z
     $     ,gamma_z_
     $     ,n_r 
     $     ,grid_p_
     $     ,n_w_
     $     ,n_A
     $     ,n_S_sub
     $     ,n_S_sum
     $     ,S_alpha_S_index_
     $     ,S_alpha_polar_a_
     $     ,S_alpha_azimu_b_
     $     ,n_M_sub
     $     ,polar_a_est_
     $     ,azimu_b_est_
     $     ,gamma_z_est_ 
     $     ,delta_x_est_
     $     ,delta_y_est_
     $     ,l2_norm_est_
     $     ,ctf_ind_est_ 
     $     ,S_index_est_
     $     ,M_index_est_
     $     ,alpha__in_
     $     ,alpha_update_f
     $     ,displacement_max
     $     ,flag_MS_vs_SM
     $     ,n_SM_max
     $     ,n_SM_
     $     ,alpha_SM__
     $     ,n_MS_max
     $     ,n_MS_
     $     ,alpha_MS__
     $     ,C_M_
     $     ,n_CTF
     $     ,CTF_R_S_ 
     $     ,CTF_R_S_use_ 
     $     ,n_M_tot
     $     ,S_T_T_R_CTF_M_q__ 
     $     ,ZZ_
     $     ,ZZ_sub_
     $     )
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      integer *4 rseed !random seed. ;
      real *8 adi_rand_f
      integer n_delta_v,n_gamma_z,n_CTF
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 S_alpha_S_index_(0:0)
      real *8 S_alpha_polar_a_(0:0)
      real *8 S_alpha_azimu_b_(0:0)
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      real *8 polar_a_est_(0:n_M_sub-1),azimu_b_est_(0:n_M_sub-1)
     $     ,gamma_z_est_(0:n_M_sub-1)
      real *8 delta_x_est_(0:n_M_sub-1),delta_y_est_(0:n_M_sub-1)
     $     ,l2_norm_est_(0:n_M_sub-1)
      real *8 ctf_ind_est_(0:n_M_sub-1)
      real *8 S_index_est_(0:n_M_sub-1)
      real *8 M_index_est_(0:n_M_sub-1)
      real *8 displacement_max
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM_(0:0) ! array of size n_M indicating the actual number of templates stored per image. ;
      real *8 alpha_SM__(0:0) ! array of size n_alpha*n_SM_max*n_M storing the image-parameters for each stored template-image pair. ;
c$$$      MS storage
      integer *4 n_MS_max ! total (maximum) number of images to store per template. ;
      integer *4 n_MS_(0:0) ! array of size n_S indicating the actual number of images stored per template. ;
      real *8 alpha_MS__(0:0) ! array of size n_alpha*n_MS_max*n_S storing the image-parameters for each stored iamge-template pair. ;
      real *8 alpha_update_f
      include 'nalpha_define.f'
      real *8 alpha__in_(0:n_alpha-1)
      integer n_S_sub,n_S_sum,n_M_sub,n_M_tot
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 CTF_R_S_use_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16 ZZ_(0:0)
      complex *16 ZZ_sub_(0:0)
      complex *16 ZZ
      complex *16 CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,nC,nC_stride
      integer ndv,ngz
      integer ns,nm,nctf,ns_use,nr_use
      integer nx2,nx3,nx3_stride
      real *8 delta_x,delta_y,gamma_z,gamma_z_est
      integer ndv_optimal,ngz_optimal
      real *8 delta_x_optimal,delta_y_optimal,gamma_z_optimal
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      complex *16 C_Z_optimal,CTF_R_S_optimal,l2_norm_optimal
      real *8 pi
      character(len=1024) format_string

      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_Zstore_3c]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_x_,' delta_x_: ')
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_y_,' delta_y_: ')
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         write(6,'(A,I0)') ' n_r : ' , n_r 
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,I0)') ' n_S_sub: ' , n_S_sub
         call print_sub_r8(n_S_sub,S_alpha_S_index_
     $        ,' S_alpha_S_index_: ')
         call print_sub_r8(n_S_sub,S_alpha_polar_a_
     $        ,' S_alpha_polar_a_: ')
         call print_sub_r8(n_S_sub,S_alpha_azimu_b_
     $        ,' S_alpha_azimu_b_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_sub_r8(n_M_sub,polar_a_est_,' polar_a_est_: ')
         call print_sub_r8(n_M_sub,azimu_b_est_,' azimu_b_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,l2_norm_est_,' l2_norm_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         call print_sub_r8(n_M_sub,S_index_est_,' S_index_est_: ')
         call print_sub_r8(n_M_sub,M_index_est_,' M_index_est_: ')
         write(6,'(A,F8.4)') ' alpha_update_f: ' , alpha_update_f
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
         write(6,'(A,L1)') ' flag_MS_vs_SM: ' , flag_MS_vs_SM
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         call print_sub_i4(n_M_sub,n_SM_,' n_SM_: ')
         call print_sub_r8(n_alpha*n_SM_max*n_M_sub,alpha_SM__
     $        ,' alpha_SM__: ')
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S_sub,n_MS_,' n_MS_: ')
         call print_sub_r8(n_alpha*n_MS_max*n_S_sub,alpha_MS__
     $        ,' alpha_MS__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         call print_sub_c16(n_gamma_z*n_CTF*n_S_sub,
     $        CTF_R_S_,' CTF_R_S_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
         call print_sub_c16(n_delta_v*n_S_sub*n_M_sub
     $        ,S_T_T_R_CTF_M_q__,' S_T_T_R_CTF_M_q__: ')
         call print_sub_c16(n_delta_v*n_gamma_z
     $        ,ZZ_,' ZZ_: ')
      end if !if (verbose.gt.1) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      call cl1_r8(n_alpha,alpha__in_)
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      call cl1_c16(n_w_max,ZZ_sub_)

c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      do nm=0,n_M_sub-1
         C_M = C_M_(nm)
         nctf = nint(ctf_ind_est_(nm))
         gamma_z_est = gamma_z_est_(nm)
         do ns=0,n_S_sub-1
c$$$            call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
c$$$     $           n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
c$$$            do ngz=0,n_gamma_z-1
c$$$               if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then
c$$$                  CTF_R_S_use_(ngz) = 1.0d0
c$$$               else
c$$$                  CTF_R_S_use_(ngz) = 1.0d0/(C_M*CTF_R_S_use_(ngz)*n_r
c$$$     $                 **4)
c$$$               end if !if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then               
c$$$            enddo !do ngz=0,n_gamma_z-1
c$$$            call cl1_c16(n_delta_v*n_gamma_z,ZZ_)
c$$$            if (n_gamma_z.eq.n_w_max) then
c$$$            nx2 = n_delta_v*(ns + n_S_sub*nm)
c$$$            nx3_stride = n_delta_v*n_S_sub*n_M_tot
c$$$            nC_stride = n_delta_v
c$$$            do ndv=0,n_delta_v-1
c$$$               nx3 = 0
c$$$               nC = ndv
c$$$               do nw=0,n_w_max-1
c$$$                  ngz = nw
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  ZZ_(nC) = S_T_T_R_CTF_M_q__(nx2 + nx3)*CTF_R_S_use
c$$$                  nx3 = nx3 + nx3_stride
c$$$                  nC = nC + nC_stride
c$$$               enddo            !do nw
c$$$               nx2 = nx2 + 1
c$$$            enddo ! do ndv
c$$$            else
c$$$            do ndv=0,n_delta_v-1
c$$$               delta_y = delta_y_(ndv)
c$$$               delta_x = delta_x_(ndv)
c$$$               call cl1_c16(n_w_max,ZZ_sub_)
c$$$               do nw=0,n_w_max-1
c$$$                  nx2 = ndv + n_delta_v*(ns + n_S_sub*nm)
c$$$                  nx3 = nw*n_delta_v*n_S_sub*n_M_tot
c$$$                  ZZ_sub_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
c$$$               enddo            !do nw
c$$$               do ngz=0,n_gamma_z-1
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  gamma_z = gamma_z_(ngz)
c$$$                  call interp1_c16(n_w_max,0.0d0,2*pi,ZZ_sub_,
c$$$     $                 +gamma_z,ZZ)
c$$$                  nC = ndv + n_delta_v*ngz
c$$$                  ZZ_(nC) = ZZ*CTF_R_S_use
c$$$               enddo            !do ngz
c$$$            enddo ! do ndv
c$$$            end if !if (n_gamma_z.eq.n_w_max) then
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call ti8_ZZ_scan_4(flag_RTRT_vs_RTTR
     $           ,delta_x_est_(nm),delta_y_est_(nm),gamma_z_est_(nm)
     $           ,displacement_max,n_delta_v ,delta_x_ ,delta_y_
     $           ,n_gamma_z,gamma_z_,ZZ_ ,ndv_optimal ,ngz_optimal
     $           ,C_Z_optimal)
            delta_x_optimal = delta_x_(ndv_optimal)
            delta_y_optimal = delta_y_(ndv_optimal)
            gamma_z_optimal = gamma_z_(ngz_optimal)
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_(0
c$$$     $           +ns*n_gamma_z + nctf*n_gamma_z*n_S_sub),
c$$$     $           +gamma_z_est_(nm) ,ngz_optimal,CTF_R_S_optimal)
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A,I0,A,I0,A,I2,1X,I2,A,2F8.3,A,2F8.3)')
c$$$     $              ' Match between M_q_(' , nm , ') and S_q_(',ns
c$$$     $              ,') at ndv_optimal,ngz_optimal: '
c$$$     $              ,ndv_optimal ,ngz_optimal
c$$$     $              ,'; CTF_R_S_optimal: ',CTF_R_S_optimal ,
c$$$     $              '; C_Z_optimal: ' ,C_Z_optimal
c$$$            end if !verbose            
c$$$            if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$               l2_norm_optimal = 1.0d0
c$$$            else 
c$$$               l2_norm_optimal = zabs(C_M_(nm)) *zabs(C_Z_optimal)
c$$$     $              /zabs(CTF_R_S_optimal)
c$$$            end if ! if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$            call cl1_r8(n_alpha,alpha__in_)
c$$$            alpha__in_(nalpha_polar_a) = S_alpha_polar_a_(ns)
c$$$            alpha__in_(nalpha_azimu_b) = S_alpha_azimu_b_(ns)
c$$$            alpha__in_(nalpha_gamma_z) = gamma_z_optimal
c$$$            alpha__in_(nalpha_delta_x) = delta_x_optimal
c$$$            alpha__in_(nalpha_delta_y) = delta_y_optimal
c$$$            alpha__in_(nalpha_l2_norm) = l2_norm_optimal
c$$$            alpha__in_(nalpha_ctf_ind) = nctf
c$$$            alpha__in_(nalpha_S_index) = S_alpha_S_index_(ns)
c$$$            alpha__in_(nalpha_M_index) = M_index_est_(nm)
c$$$            alpha__in_(nalpha_CTF_R_S) = CTF_R_S_optimal
c$$$            alpha__in_(nalpha_C_Z_opt) = C_Z_optimal
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A)') ' calling alpha_SM_update_1 with '
c$$$               write(6,'(5(A,I0))') ' n_alpha ' , n_alpha , ' n_SM_max '
c$$$     $              , n_SM_max , ' nm ' , nm ,' nm*n_alpha*n_SM_max ' ,
c$$$     $              nm*n_alpha*n_SM_max , ' n_SM_(nm) ' , n_SM_(nm) 
c$$$               write(6,'(A,I0)') ' calling alpha_SM_update_1 with '
c$$$               call print_all_r8(n_alpha,alpha__in_
c$$$     $              ,' alpha__in_: ')
c$$$            end if !if (verbose.gt.2) then
c$$$            if (flag_MS_vs_SM.eqv..true.) then
c$$$c$$$        Note: we use alpha_SM_update to update MS as well.
c$$$            call alpha_SM_update_1(n_MS_max,n_MS_(ns)
c$$$     $           ,alpha_MS__(ns*n_alpha*n_MS_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..true.) then
c$$$            if (flag_MS_vs_SM.eqv..false.) then
c$$$            call alpha_SM_update_1(n_SM_max,n_SM_(nm)
c$$$     $           ,alpha_SM__(nm*n_alpha*n_SM_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..false.) then
         enddo !do ns=0,n_S_sub-1
      enddo !do nm=0,n_M_sub-1
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_Zstore_3c]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Performs part of the search-and-store routine. ;\n
      subroutine ti8_Zstore_3d(
     $     verbose
     $     ,rseed
     $     ,flag_RTRT_vs_RTTR
     $     ,n_delta_v
     $     ,delta_x_
     $     ,delta_y_
     $     ,n_gamma_z
     $     ,gamma_z_
     $     ,n_r 
     $     ,grid_p_
     $     ,n_w_
     $     ,n_A
     $     ,n_S_sub
     $     ,n_S_sum
     $     ,S_alpha_S_index_
     $     ,S_alpha_polar_a_
     $     ,S_alpha_azimu_b_
     $     ,n_M_sub
     $     ,polar_a_est_
     $     ,azimu_b_est_
     $     ,gamma_z_est_ 
     $     ,delta_x_est_
     $     ,delta_y_est_
     $     ,l2_norm_est_
     $     ,ctf_ind_est_ 
     $     ,S_index_est_
     $     ,M_index_est_
     $     ,alpha__in_
     $     ,alpha_update_f
     $     ,displacement_max
     $     ,flag_MS_vs_SM
     $     ,n_SM_max
     $     ,n_SM_
     $     ,alpha_SM__
     $     ,n_MS_max
     $     ,n_MS_
     $     ,alpha_MS__
     $     ,C_M_
     $     ,n_CTF
     $     ,CTF_R_S_ 
     $     ,CTF_R_S_use_ 
     $     ,n_M_tot
     $     ,S_T_T_R_CTF_M_q__ 
     $     ,ZZ_
     $     ,ZZ_sub_
     $     )
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      integer *4 rseed !random seed. ;
      real *8 adi_rand_f
      integer n_delta_v,n_gamma_z,n_CTF
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 S_alpha_S_index_(0:0)
      real *8 S_alpha_polar_a_(0:0)
      real *8 S_alpha_azimu_b_(0:0)
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      real *8 polar_a_est_(0:n_M_sub-1),azimu_b_est_(0:n_M_sub-1)
     $     ,gamma_z_est_(0:n_M_sub-1)
      real *8 delta_x_est_(0:n_M_sub-1),delta_y_est_(0:n_M_sub-1)
     $     ,l2_norm_est_(0:n_M_sub-1)
      real *8 ctf_ind_est_(0:n_M_sub-1)
      real *8 S_index_est_(0:n_M_sub-1)
      real *8 M_index_est_(0:n_M_sub-1)
      real *8 displacement_max
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM_(0:0) ! array of size n_M indicating the actual number of templates stored per image. ;
      real *8 alpha_SM__(0:0) ! array of size n_alpha*n_SM_max*n_M storing the image-parameters for each stored template-image pair. ;
c$$$      MS storage
      integer *4 n_MS_max ! total (maximum) number of images to store per template. ;
      integer *4 n_MS_(0:0) ! array of size n_S indicating the actual number of images stored per template. ;
      real *8 alpha_MS__(0:0) ! array of size n_alpha*n_MS_max*n_S storing the image-parameters for each stored iamge-template pair. ;
      real *8 alpha_update_f
      include 'nalpha_define.f'
      real *8 alpha__in_(0:n_alpha-1)
      integer n_S_sub,n_S_sum,n_M_sub,n_M_tot
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 CTF_R_S_use_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16 ZZ_(0:0)
      complex *16 ZZ_sub_(0:0)
      complex *16 ZZ
      complex *16 CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,nC,nC_stride
      integer ndv,ngz
      integer ns,nm,nctf,ns_use,nr_use
      integer nx2,nx3,nx3_stride
      real *8 delta_x,delta_y,gamma_z,gamma_z_est
      integer ndv_optimal,ngz_optimal
      real *8 delta_x_optimal,delta_y_optimal,gamma_z_optimal
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      complex *16 C_Z_optimal,CTF_R_S_optimal,l2_norm_optimal
      real *8 pi
      character(len=1024) format_string

      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_Zstore_3d]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_x_,' delta_x_: ')
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_y_,' delta_y_: ')
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         write(6,'(A,I0)') ' n_r : ' , n_r 
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,I0)') ' n_S_sub: ' , n_S_sub
         call print_sub_r8(n_S_sub,S_alpha_S_index_
     $        ,' S_alpha_S_index_: ')
         call print_sub_r8(n_S_sub,S_alpha_polar_a_
     $        ,' S_alpha_polar_a_: ')
         call print_sub_r8(n_S_sub,S_alpha_azimu_b_
     $        ,' S_alpha_azimu_b_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_sub_r8(n_M_sub,polar_a_est_,' polar_a_est_: ')
         call print_sub_r8(n_M_sub,azimu_b_est_,' azimu_b_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,l2_norm_est_,' l2_norm_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         call print_sub_r8(n_M_sub,S_index_est_,' S_index_est_: ')
         call print_sub_r8(n_M_sub,M_index_est_,' M_index_est_: ')
         write(6,'(A,F8.4)') ' alpha_update_f: ' , alpha_update_f
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
         write(6,'(A,L1)') ' flag_MS_vs_SM: ' , flag_MS_vs_SM
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         call print_sub_i4(n_M_sub,n_SM_,' n_SM_: ')
         call print_sub_r8(n_alpha*n_SM_max*n_M_sub,alpha_SM__
     $        ,' alpha_SM__: ')
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S_sub,n_MS_,' n_MS_: ')
         call print_sub_r8(n_alpha*n_MS_max*n_S_sub,alpha_MS__
     $        ,' alpha_MS__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         call print_sub_c16(n_gamma_z*n_CTF*n_S_sub,
     $        CTF_R_S_,' CTF_R_S_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
         call print_sub_c16(n_delta_v*n_S_sub*n_M_sub
     $        ,S_T_T_R_CTF_M_q__,' S_T_T_R_CTF_M_q__: ')
         call print_sub_c16(n_delta_v*n_gamma_z
     $        ,ZZ_,' ZZ_: ')
      end if !if (verbose.gt.1) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      call cl1_r8(n_alpha,alpha__in_)
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      call cl1_c16(n_w_max,ZZ_sub_)

c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      do nm=0,n_M_sub-1
         C_M = C_M_(nm)
         nctf = nint(ctf_ind_est_(nm))
         gamma_z_est = gamma_z_est_(nm)
         do ns=0,n_S_sub-1
c$$$            call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
c$$$     $           n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
c$$$            do ngz=0,n_gamma_z-1
c$$$               if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then
c$$$                  CTF_R_S_use_(ngz) = 1.0d0
c$$$               else
c$$$                  CTF_R_S_use_(ngz) = 1.0d0/(C_M*CTF_R_S_use_(ngz)*n_r
c$$$     $                 **4)
c$$$               end if !if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then               
c$$$            enddo !do ngz=0,n_gamma_z-1
c$$$            call cl1_c16(n_delta_v*n_gamma_z,ZZ_)
c$$$            if (n_gamma_z.eq.n_w_max) then
c$$$            nx2 = n_delta_v*(ns + n_S_sub*nm)
c$$$            nx3_stride = n_delta_v*n_S_sub*n_M_tot
c$$$            nC_stride = n_delta_v
c$$$            do ndv=0,n_delta_v-1
c$$$               nx3 = 0
c$$$               nC = ndv
c$$$               do nw=0,n_w_max-1
c$$$                  ngz = nw
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  ZZ_(nC) = S_T_T_R_CTF_M_q__(nx2 + nx3)*CTF_R_S_use
c$$$                  nx3 = nx3 + nx3_stride
c$$$                  nC = nC + nC_stride
c$$$               enddo            !do nw
c$$$               nx2 = nx2 + 1
c$$$            enddo ! do ndv
c$$$            else
c$$$            do ndv=0,n_delta_v-1
c$$$               delta_y = delta_y_(ndv)
c$$$               delta_x = delta_x_(ndv)
c$$$               call cl1_c16(n_w_max,ZZ_sub_)
c$$$               do nw=0,n_w_max-1
c$$$                  nx2 = ndv + n_delta_v*(ns + n_S_sub*nm)
c$$$                  nx3 = nw*n_delta_v*n_S_sub*n_M_tot
c$$$                  ZZ_sub_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
c$$$               enddo            !do nw
c$$$               do ngz=0,n_gamma_z-1
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  gamma_z = gamma_z_(ngz)
c$$$                  call interp1_c16(n_w_max,0.0d0,2*pi,ZZ_sub_,
c$$$     $                 +gamma_z,ZZ)
c$$$                  nC = ndv + n_delta_v*ngz
c$$$                  ZZ_(nC) = ZZ*CTF_R_S_use
c$$$               enddo            !do ngz
c$$$            enddo ! do ndv
c$$$            end if !if (n_gamma_z.eq.n_w_max) then
c$$$c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call ti8_ZZ_scan_4(flag_RTRT_vs_RTTR
c$$$     $           ,delta_x_est_(nm),delta_y_est_(nm),gamma_z_est_(nm)
c$$$     $           ,displacement_max,n_delta_v ,delta_x_ ,delta_y_
c$$$     $           ,n_gamma_z,gamma_z_,ZZ_ ,ndv_optimal ,ngz_optimal
c$$$     $           ,C_Z_optimal)
c$$$            delta_x_optimal = delta_x_(ndv_optimal)
c$$$            delta_y_optimal = delta_y_(ndv_optimal)
c$$$            gamma_z_optimal = gamma_z_(ngz_optimal)
c$$$c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_(0
     $           +ns*n_gamma_z + nctf*n_gamma_z*n_S_sub),
     $           +gamma_z_est_(nm) ,ngz_optimal,CTF_R_S_optimal)
            if (verbose.gt.2) then
               write(6,'(A,I0,A,I0,A,I2,1X,I2,A,2F8.3,A,2F8.3)')
     $              ' Match between M_q_(' , nm , ') and S_q_(',ns
     $              ,') at ndv_optimal,ngz_optimal: '
     $              ,ndv_optimal ,ngz_optimal
     $              ,'; CTF_R_S_optimal: ',CTF_R_S_optimal ,
     $              '; C_Z_optimal: ' ,C_Z_optimal
            end if !verbose            
            if (zabs(CTF_R_S_optimal).le.1.0d-15) then
               l2_norm_optimal = 1.0d0
            else 
               l2_norm_optimal = zabs(C_M_(nm)) *zabs(C_Z_optimal)
     $              /zabs(CTF_R_S_optimal)
            end if ! if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$            call cl1_r8(n_alpha,alpha__in_)
c$$$            alpha__in_(nalpha_polar_a) = S_alpha_polar_a_(ns)
c$$$            alpha__in_(nalpha_azimu_b) = S_alpha_azimu_b_(ns)
c$$$            alpha__in_(nalpha_gamma_z) = gamma_z_optimal
c$$$            alpha__in_(nalpha_delta_x) = delta_x_optimal
c$$$            alpha__in_(nalpha_delta_y) = delta_y_optimal
c$$$            alpha__in_(nalpha_l2_norm) = l2_norm_optimal
c$$$            alpha__in_(nalpha_ctf_ind) = nctf
c$$$            alpha__in_(nalpha_S_index) = S_alpha_S_index_(ns)
c$$$            alpha__in_(nalpha_M_index) = M_index_est_(nm)
c$$$            alpha__in_(nalpha_CTF_R_S) = CTF_R_S_optimal
c$$$            alpha__in_(nalpha_C_Z_opt) = C_Z_optimal
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A)') ' calling alpha_SM_update_1 with '
c$$$               write(6,'(5(A,I0))') ' n_alpha ' , n_alpha , ' n_SM_max '
c$$$     $              , n_SM_max , ' nm ' , nm ,' nm*n_alpha*n_SM_max ' ,
c$$$     $              nm*n_alpha*n_SM_max , ' n_SM_(nm) ' , n_SM_(nm) 
c$$$               write(6,'(A,I0)') ' calling alpha_SM_update_1 with '
c$$$               call print_all_r8(n_alpha,alpha__in_
c$$$     $              ,' alpha__in_: ')
c$$$            end if !if (verbose.gt.2) then
c$$$            if (flag_MS_vs_SM.eqv..true.) then
c$$$c$$$        Note: we use alpha_SM_update to update MS as well.
c$$$            call alpha_SM_update_1(n_MS_max,n_MS_(ns)
c$$$     $           ,alpha_MS__(ns*n_alpha*n_MS_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..true.) then
c$$$            if (flag_MS_vs_SM.eqv..false.) then
c$$$            call alpha_SM_update_1(n_SM_max,n_SM_(nm)
c$$$     $           ,alpha_SM__(nm*n_alpha*n_SM_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..false.) then
         enddo !do ns=0,n_S_sub-1
      enddo !do nm=0,n_M_sub-1
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_Zstore_3d]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Performs part of the search-and-store routine. ;\n
      subroutine ti8_Zstore_3e(
     $     verbose
     $     ,rseed
     $     ,flag_RTRT_vs_RTTR
     $     ,n_delta_v
     $     ,delta_x_
     $     ,delta_y_
     $     ,n_gamma_z
     $     ,gamma_z_
     $     ,n_r 
     $     ,grid_p_
     $     ,n_w_
     $     ,n_A
     $     ,n_S_sub
     $     ,n_S_sum
     $     ,S_alpha_S_index_
     $     ,S_alpha_polar_a_
     $     ,S_alpha_azimu_b_
     $     ,n_M_sub
     $     ,polar_a_est_
     $     ,azimu_b_est_
     $     ,gamma_z_est_ 
     $     ,delta_x_est_
     $     ,delta_y_est_
     $     ,l2_norm_est_
     $     ,ctf_ind_est_ 
     $     ,S_index_est_
     $     ,M_index_est_
     $     ,alpha__in_
     $     ,alpha_update_f
     $     ,displacement_max
     $     ,flag_MS_vs_SM
     $     ,n_SM_max
     $     ,n_SM_
     $     ,alpha_SM__
     $     ,n_MS_max
     $     ,n_MS_
     $     ,alpha_MS__
     $     ,C_M_
     $     ,n_CTF
     $     ,CTF_R_S_ 
     $     ,CTF_R_S_use_ 
     $     ,n_M_tot
     $     ,S_T_T_R_CTF_M_q__ 
     $     ,ZZ_
     $     ,ZZ_sub_
     $     )
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      integer *4 rseed !random seed. ;
      real *8 adi_rand_f
      integer n_delta_v,n_gamma_z,n_CTF
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 S_alpha_S_index_(0:0)
      real *8 S_alpha_polar_a_(0:0)
      real *8 S_alpha_azimu_b_(0:0)
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      real *8 polar_a_est_(0:n_M_sub-1),azimu_b_est_(0:n_M_sub-1)
     $     ,gamma_z_est_(0:n_M_sub-1)
      real *8 delta_x_est_(0:n_M_sub-1),delta_y_est_(0:n_M_sub-1)
     $     ,l2_norm_est_(0:n_M_sub-1)
      real *8 ctf_ind_est_(0:n_M_sub-1)
      real *8 S_index_est_(0:n_M_sub-1)
      real *8 M_index_est_(0:n_M_sub-1)
      real *8 displacement_max
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM_(0:0) ! array of size n_M indicating the actual number of templates stored per image. ;
      real *8 alpha_SM__(0:0) ! array of size n_alpha*n_SM_max*n_M storing the image-parameters for each stored template-image pair. ;
c$$$      MS storage
      integer *4 n_MS_max ! total (maximum) number of images to store per template. ;
      integer *4 n_MS_(0:0) ! array of size n_S indicating the actual number of images stored per template. ;
      real *8 alpha_MS__(0:0) ! array of size n_alpha*n_MS_max*n_S storing the image-parameters for each stored iamge-template pair. ;
      real *8 alpha_update_f
      include 'nalpha_define.f'
      real *8 alpha__in_(0:n_alpha-1)
      integer n_S_sub,n_S_sum,n_M_sub,n_M_tot
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 CTF_R_S_use_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16 ZZ_(0:0)
      complex *16 ZZ_sub_(0:0)
      complex *16 ZZ
      complex *16 CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,nC,nC_stride
      integer ndv,ngz
      integer ns,nm,nctf,ns_use,nr_use
      integer nx2,nx3,nx3_stride
      real *8 delta_x,delta_y,gamma_z,gamma_z_est
      integer ndv_optimal,ngz_optimal
      real *8 delta_x_optimal,delta_y_optimal,gamma_z_optimal
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      complex *16 C_Z_optimal,CTF_R_S_optimal,l2_norm_optimal
      real *8 pi
      character(len=1024) format_string

      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_Zstore_3e]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_x_,' delta_x_: ')
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_y_,' delta_y_: ')
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         write(6,'(A,I0)') ' n_r : ' , n_r 
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,I0)') ' n_S_sub: ' , n_S_sub
         call print_sub_r8(n_S_sub,S_alpha_S_index_
     $        ,' S_alpha_S_index_: ')
         call print_sub_r8(n_S_sub,S_alpha_polar_a_
     $        ,' S_alpha_polar_a_: ')
         call print_sub_r8(n_S_sub,S_alpha_azimu_b_
     $        ,' S_alpha_azimu_b_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_sub_r8(n_M_sub,polar_a_est_,' polar_a_est_: ')
         call print_sub_r8(n_M_sub,azimu_b_est_,' azimu_b_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,l2_norm_est_,' l2_norm_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         call print_sub_r8(n_M_sub,S_index_est_,' S_index_est_: ')
         call print_sub_r8(n_M_sub,M_index_est_,' M_index_est_: ')
         write(6,'(A,F8.4)') ' alpha_update_f: ' , alpha_update_f
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
         write(6,'(A,L1)') ' flag_MS_vs_SM: ' , flag_MS_vs_SM
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         call print_sub_i4(n_M_sub,n_SM_,' n_SM_: ')
         call print_sub_r8(n_alpha*n_SM_max*n_M_sub,alpha_SM__
     $        ,' alpha_SM__: ')
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S_sub,n_MS_,' n_MS_: ')
         call print_sub_r8(n_alpha*n_MS_max*n_S_sub,alpha_MS__
     $        ,' alpha_MS__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         call print_sub_c16(n_gamma_z*n_CTF*n_S_sub,
     $        CTF_R_S_,' CTF_R_S_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
         call print_sub_c16(n_delta_v*n_S_sub*n_M_sub
     $        ,S_T_T_R_CTF_M_q__,' S_T_T_R_CTF_M_q__: ')
         call print_sub_c16(n_delta_v*n_gamma_z
     $        ,ZZ_,' ZZ_: ')
      end if !if (verbose.gt.1) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      call cl1_r8(n_alpha,alpha__in_)
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      call cl1_c16(n_w_max,ZZ_sub_)

c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      do nm=0,n_M_sub-1
         C_M = C_M_(nm)
         nctf = nint(ctf_ind_est_(nm))
         gamma_z_est = gamma_z_est_(nm)
         do ns=0,n_S_sub-1
c$$$            call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
c$$$     $           n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
c$$$            do ngz=0,n_gamma_z-1
c$$$               if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then
c$$$                  CTF_R_S_use_(ngz) = 1.0d0
c$$$               else
c$$$                  CTF_R_S_use_(ngz) = 1.0d0/(C_M*CTF_R_S_use_(ngz)*n_r
c$$$     $                 **4)
c$$$               end if !if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then               
c$$$            enddo !do ngz=0,n_gamma_z-1
c$$$            call cl1_c16(n_delta_v*n_gamma_z,ZZ_)
c$$$            if (n_gamma_z.eq.n_w_max) then
c$$$            nx2 = n_delta_v*(ns + n_S_sub*nm)
c$$$            nx3_stride = n_delta_v*n_S_sub*n_M_tot
c$$$            nC_stride = n_delta_v
c$$$            do ndv=0,n_delta_v-1
c$$$               nx3 = 0
c$$$               nC = ndv
c$$$               do nw=0,n_w_max-1
c$$$                  ngz = nw
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  ZZ_(nC) = S_T_T_R_CTF_M_q__(nx2 + nx3)*CTF_R_S_use
c$$$                  nx3 = nx3 + nx3_stride
c$$$                  nC = nC + nC_stride
c$$$               enddo            !do nw
c$$$               nx2 = nx2 + 1
c$$$            enddo ! do ndv
c$$$            else
c$$$            do ndv=0,n_delta_v-1
c$$$               delta_y = delta_y_(ndv)
c$$$               delta_x = delta_x_(ndv)
c$$$               call cl1_c16(n_w_max,ZZ_sub_)
c$$$               do nw=0,n_w_max-1
c$$$                  nx2 = ndv + n_delta_v*(ns + n_S_sub*nm)
c$$$                  nx3 = nw*n_delta_v*n_S_sub*n_M_tot
c$$$                  ZZ_sub_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
c$$$               enddo            !do nw
c$$$               do ngz=0,n_gamma_z-1
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  gamma_z = gamma_z_(ngz)
c$$$                  call interp1_c16(n_w_max,0.0d0,2*pi,ZZ_sub_,
c$$$     $                 +gamma_z,ZZ)
c$$$                  nC = ndv + n_delta_v*ngz
c$$$                  ZZ_(nC) = ZZ*CTF_R_S_use
c$$$               enddo            !do ngz
c$$$            enddo ! do ndv
c$$$            end if !if (n_gamma_z.eq.n_w_max) then
c$$$c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call ti8_ZZ_scan_4(flag_RTRT_vs_RTTR
c$$$     $           ,delta_x_est_(nm),delta_y_est_(nm),gamma_z_est_(nm)
c$$$     $           ,displacement_max,n_delta_v ,delta_x_ ,delta_y_
c$$$     $           ,n_gamma_z,gamma_z_,ZZ_ ,ndv_optimal ,ngz_optimal
c$$$     $           ,C_Z_optimal)
c$$$            delta_x_optimal = delta_x_(ndv_optimal)
c$$$            delta_y_optimal = delta_y_(ndv_optimal)
c$$$            gamma_z_optimal = gamma_z_(ngz_optimal)
c$$$c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_(0
c$$$     $           +ns*n_gamma_z + nctf*n_gamma_z*n_S_sub),
c$$$     $           +gamma_z_est_(nm) ,ngz_optimal,CTF_R_S_optimal)
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A,I0,A,I0,A,I2,1X,I2,A,2F8.3,A,2F8.3)')
c$$$     $              ' Match between M_q_(' , nm , ') and S_q_(',ns
c$$$     $              ,') at ndv_optimal,ngz_optimal: '
c$$$     $              ,ndv_optimal ,ngz_optimal
c$$$     $              ,'; CTF_R_S_optimal: ',CTF_R_S_optimal ,
c$$$     $              '; C_Z_optimal: ' ,C_Z_optimal
c$$$            end if !verbose            
c$$$            if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$               l2_norm_optimal = 1.0d0
c$$$            else 
c$$$               l2_norm_optimal = zabs(C_M_(nm)) *zabs(C_Z_optimal)
c$$$     $              /zabs(CTF_R_S_optimal)
c$$$            end if ! if (zabs(CTF_R_S_optimal).le.1.0d-15) then
            call cl1_r8(n_alpha,alpha__in_)
            alpha__in_(nalpha_polar_a) = S_alpha_polar_a_(ns)
            alpha__in_(nalpha_azimu_b) = S_alpha_azimu_b_(ns)
            alpha__in_(nalpha_gamma_z) = gamma_z_optimal
            alpha__in_(nalpha_delta_x) = delta_x_optimal
            alpha__in_(nalpha_delta_y) = delta_y_optimal
            alpha__in_(nalpha_l2_norm) = l2_norm_optimal
            alpha__in_(nalpha_ctf_ind) = nctf
            alpha__in_(nalpha_S_index) = S_alpha_S_index_(ns)
            alpha__in_(nalpha_M_index) = M_index_est_(nm)
            alpha__in_(nalpha_CTF_R_S) = CTF_R_S_optimal
            alpha__in_(nalpha_C_Z_opt) = C_Z_optimal
            if (verbose.gt.2) then
               write(6,'(A)') ' calling alpha_SM_update_1 with '
               write(6,'(5(A,I0))') ' n_alpha ' , n_alpha , ' n_SM_max '
     $              , n_SM_max , ' nm ' , nm ,' nm*n_alpha*n_SM_max ' ,
     $              nm*n_alpha*n_SM_max , ' n_SM_(nm) ' , n_SM_(nm) 
               write(6,'(A,I0)') ' calling alpha_SM_update_1 with '
               call print_all_r8(n_alpha,alpha__in_
     $              ,' alpha__in_: ')
            end if !if (verbose.gt.2) then
            if (flag_MS_vs_SM.eqv..true.) then
c$$$        Note: we use alpha_SM_update to update MS as well.
            call alpha_SM_update_1(n_MS_max,n_MS_(ns)
     $           ,alpha_MS__(ns*n_alpha*n_MS_max),alpha__in_)
            end if !if (flag_MS_vs_SM.eqv..true.) then
            if (flag_MS_vs_SM.eqv..false.) then
            call alpha_SM_update_1(n_SM_max,n_SM_(nm)
     $           ,alpha_SM__(nm*n_alpha*n_SM_max),alpha__in_)
            end if !if (flag_MS_vs_SM.eqv..false.) then
         enddo !do ns=0,n_S_sub-1
      enddo !do nm=0,n_M_sub-1
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_Zstore_3e]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Performs part of the search-and-store routine. ;\n
      subroutine ti8_Zstore_3x(
     $     verbose
     $     ,rseed
     $     ,flag_RTRT_vs_RTTR
     $     ,n_delta_v
     $     ,delta_x_
     $     ,delta_y_
     $     ,n_gamma_z
     $     ,gamma_z_
     $     ,n_r 
     $     ,grid_p_
     $     ,n_w_
     $     ,n_A
     $     ,n_S_sub
     $     ,n_S_sum
     $     ,S_alpha_S_index_
     $     ,S_alpha_polar_a_
     $     ,S_alpha_azimu_b_
     $     ,n_M_sub
     $     ,polar_a_est_
     $     ,azimu_b_est_
     $     ,gamma_z_est_ 
     $     ,delta_x_est_
     $     ,delta_y_est_
     $     ,l2_norm_est_
     $     ,ctf_ind_est_ 
     $     ,S_index_est_
     $     ,M_index_est_
     $     ,alpha__in_
     $     ,alpha_update_f
     $     ,displacement_max
     $     ,flag_MS_vs_SM
     $     ,n_SM_max
     $     ,n_SM_
     $     ,alpha_SM__
     $     ,n_MS_max
     $     ,n_MS_
     $     ,alpha_MS__
     $     ,C_M_
     $     ,n_CTF
     $     ,CTF_R_S_ 
     $     ,CTF_R_S_use_ 
     $     ,n_M_tot
     $     ,S_T_T_R_CTF_M_q__ 
     $     ,ZZ_
     $     ,ZZ_sub_
     $     )
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      integer *4 rseed !random seed. ;
      real *8 adi_rand_f
      integer n_delta_v,n_gamma_z,n_CTF
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 S_alpha_S_index_(0:0)
      real *8 S_alpha_polar_a_(0:0)
      real *8 S_alpha_azimu_b_(0:0)
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      real *8 polar_a_est_(0:n_M_sub-1),azimu_b_est_(0:n_M_sub-1)
     $     ,gamma_z_est_(0:n_M_sub-1)
      real *8 delta_x_est_(0:n_M_sub-1),delta_y_est_(0:n_M_sub-1)
     $     ,l2_norm_est_(0:n_M_sub-1)
      real *8 ctf_ind_est_(0:n_M_sub-1)
      real *8 S_index_est_(0:n_M_sub-1)
      real *8 M_index_est_(0:n_M_sub-1)
      real *8 displacement_max
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM_(0:0) ! array of size n_M indicating the actual number of templates stored per image. ;
      real *8 alpha_SM__(0:0) ! array of size n_alpha*n_SM_max*n_M storing the image-parameters for each stored template-image pair. ;
c$$$      MS storage
      integer *4 n_MS_max ! total (maximum) number of images to store per template. ;
      integer *4 n_MS_(0:0) ! array of size n_S indicating the actual number of images stored per template. ;
      real *8 alpha_MS__(0:0) ! array of size n_alpha*n_MS_max*n_S storing the image-parameters for each stored iamge-template pair. ;
      real *8 alpha_update_f
      include 'nalpha_define.f'
      real *8 alpha__in_(0:n_alpha-1)
      integer n_S_sub,n_S_sum,n_M_sub,n_M_tot
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 CTF_R_S_use_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16 ZZ_(0:0)
      complex *16 ZZ_sub_(0:0)
      complex *16 ZZ
      complex *16 CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,nC,nC_stride
      integer ndv,ngz
      integer ns,nm,nctf,ns_use,nr_use
      integer nx2,nx3,nx3_stride
      real *8 delta_x,delta_y,gamma_z,gamma_z_est
      integer ndv_optimal,ngz_optimal
      real *8 delta_x_optimal,delta_y_optimal,gamma_z_optimal
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      complex *16 C_Z_optimal,CTF_R_S_optimal,l2_norm_optimal
      real *8 pi
      character(len=1024) format_string

      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_Zstore_3x]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_x_,' delta_x_: ')
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_y_,' delta_y_: ')
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         write(6,'(A,I0)') ' n_r : ' , n_r 
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,I0)') ' n_S_sub: ' , n_S_sub
         call print_sub_r8(n_S_sub,S_alpha_S_index_
     $        ,' S_alpha_S_index_: ')
         call print_sub_r8(n_S_sub,S_alpha_polar_a_
     $        ,' S_alpha_polar_a_: ')
         call print_sub_r8(n_S_sub,S_alpha_azimu_b_
     $        ,' S_alpha_azimu_b_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_sub_r8(n_M_sub,polar_a_est_,' polar_a_est_: ')
         call print_sub_r8(n_M_sub,azimu_b_est_,' azimu_b_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,l2_norm_est_,' l2_norm_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         call print_sub_r8(n_M_sub,S_index_est_,' S_index_est_: ')
         call print_sub_r8(n_M_sub,M_index_est_,' M_index_est_: ')
         write(6,'(A,F8.4)') ' alpha_update_f: ' , alpha_update_f
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
         write(6,'(A,L1)') ' flag_MS_vs_SM: ' , flag_MS_vs_SM
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         call print_sub_i4(n_M_sub,n_SM_,' n_SM_: ')
         call print_sub_r8(n_alpha*n_SM_max*n_M_sub,alpha_SM__
     $        ,' alpha_SM__: ')
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S_sub,n_MS_,' n_MS_: ')
         call print_sub_r8(n_alpha*n_MS_max*n_S_sub,alpha_MS__
     $        ,' alpha_MS__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         call print_sub_c16(n_gamma_z*n_CTF*n_S_sub,
     $        CTF_R_S_,' CTF_R_S_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
         call print_sub_c16(n_delta_v*n_S_sub*n_M_sub
     $        ,S_T_T_R_CTF_M_q__,' S_T_T_R_CTF_M_q__: ')
         call print_sub_c16(n_delta_v*n_gamma_z
     $        ,ZZ_,' ZZ_: ')
      end if !if (verbose.gt.1) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      call cl1_r8(n_alpha,alpha__in_)
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      call cl1_c16(n_w_max,ZZ_sub_)

c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      do nm=0,n_M_sub-1
         C_M = C_M_(nm)
         nctf = nint(ctf_ind_est_(nm))
         gamma_z_est = gamma_z_est_(nm)
         do ns=0,n_S_sub-1
c$$$            call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
c$$$     $           n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
c$$$            do ngz=0,n_gamma_z-1
c$$$               if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then
c$$$                  CTF_R_S_use_(ngz) = 1.0d0
c$$$               else
c$$$                  CTF_R_S_use_(ngz) = 1.0d0/(C_M*CTF_R_S_use_(ngz)*n_r
c$$$     $                 **4)
c$$$               end if !if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then               
c$$$            enddo !do ngz=0,n_gamma_z-1
c$$$            call cl1_c16(n_delta_v*n_gamma_z,ZZ_)
c$$$            if (n_gamma_z.eq.n_w_max) then
c$$$            nx2 = n_delta_v*(ns + n_S_sub*nm)
c$$$            nx3_stride = n_delta_v*n_S_sub*n_M_tot
c$$$            nC_stride = n_delta_v
c$$$            do ndv=0,n_delta_v-1
c$$$               nx3 = 0
c$$$               nC = ndv
c$$$               do nw=0,n_w_max-1
c$$$                  ngz = nw
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  ZZ_(nC) = S_T_T_R_CTF_M_q__(nx2 + nx3)*CTF_R_S_use
c$$$                  nx3 = nx3 + nx3_stride
c$$$                  nC = nC + nC_stride
c$$$               enddo            !do nw
c$$$               nx2 = nx2 + 1
c$$$            enddo ! do ndv
c$$$            else
c$$$            do ndv=0,n_delta_v-1
c$$$               delta_y = delta_y_(ndv)
c$$$               delta_x = delta_x_(ndv)
c$$$               call cl1_c16(n_w_max,ZZ_sub_)
c$$$               do nw=0,n_w_max-1
c$$$                  nx2 = ndv + n_delta_v*(ns + n_S_sub*nm)
c$$$                  nx3 = nw*n_delta_v*n_S_sub*n_M_tot
c$$$                  ZZ_sub_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
c$$$               enddo            !do nw
c$$$               do ngz=0,n_gamma_z-1
c$$$                  CTF_R_S_use = CTF_R_S_use_(ngz)
c$$$                  gamma_z = gamma_z_(ngz)
c$$$                  call interp1_c16(n_w_max,0.0d0,2*pi,ZZ_sub_,
c$$$     $                 +gamma_z,ZZ)
c$$$                  nC = ndv + n_delta_v*ngz
c$$$                  ZZ_(nC) = ZZ*CTF_R_S_use
c$$$               enddo            !do ngz
c$$$            enddo ! do ndv
c$$$            end if !if (n_gamma_z.eq.n_w_max) then
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call ti8_ZZ_scan_4x(flag_RTRT_vs_RTTR
     $           ,delta_x_est_(nm),delta_y_est_(nm),gamma_z_est_(nm)
     $           ,displacement_max,n_delta_v ,delta_x_ ,delta_y_
     $           ,n_gamma_z,gamma_z_,ZZ_ ,ndv_optimal ,ngz_optimal
     $           ,C_Z_optimal)
            delta_x_optimal = delta_x_(ndv_optimal)
            delta_y_optimal = delta_y_(ndv_optimal)
            gamma_z_optimal = gamma_z_(ngz_optimal)
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$            call get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_(0
c$$$     $           +ns*n_gamma_z + nctf*n_gamma_z*n_S_sub),
c$$$     $           +gamma_z_est_(nm) ,ngz_optimal,CTF_R_S_optimal)
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A,I0,A,I0,A,I2,1X,I2,A,2F8.3,A,2F8.3)')
c$$$     $              ' Match between M_q_(' , nm , ') and S_q_(',ns
c$$$     $              ,') at ndv_optimal,ngz_optimal: '
c$$$     $              ,ndv_optimal ,ngz_optimal
c$$$     $              ,'; CTF_R_S_optimal: ',CTF_R_S_optimal ,
c$$$     $              '; C_Z_optimal: ' ,C_Z_optimal
c$$$            end if !verbose            
c$$$            if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$               l2_norm_optimal = 1.0d0
c$$$            else 
c$$$               l2_norm_optimal = zabs(C_M_(nm)) *zabs(C_Z_optimal)
c$$$     $              /zabs(CTF_R_S_optimal)
c$$$            end if ! if (zabs(CTF_R_S_optimal).le.1.0d-15) then
c$$$            call cl1_r8(n_alpha,alpha__in_)
c$$$            alpha__in_(nalpha_polar_a) = S_alpha_polar_a_(ns)
c$$$            alpha__in_(nalpha_azimu_b) = S_alpha_azimu_b_(ns)
c$$$            alpha__in_(nalpha_gamma_z) = gamma_z_optimal
c$$$            alpha__in_(nalpha_delta_x) = delta_x_optimal
c$$$            alpha__in_(nalpha_delta_y) = delta_y_optimal
c$$$            alpha__in_(nalpha_l2_norm) = l2_norm_optimal
c$$$            alpha__in_(nalpha_ctf_ind) = nctf
c$$$            alpha__in_(nalpha_S_index) = S_alpha_S_index_(ns)
c$$$            alpha__in_(nalpha_M_index) = M_index_est_(nm)
c$$$            alpha__in_(nalpha_CTF_R_S) = CTF_R_S_optimal
c$$$            alpha__in_(nalpha_C_Z_opt) = C_Z_optimal
c$$$            if (verbose.gt.2) then
c$$$               write(6,'(A)') ' calling alpha_SM_update_1 with '
c$$$               write(6,'(5(A,I0))') ' n_alpha ' , n_alpha , ' n_SM_max '
c$$$     $              , n_SM_max , ' nm ' , nm ,' nm*n_alpha*n_SM_max ' ,
c$$$     $              nm*n_alpha*n_SM_max , ' n_SM_(nm) ' , n_SM_(nm) 
c$$$               write(6,'(A,I0)') ' calling alpha_SM_update_1 with '
c$$$               call print_all_r8(n_alpha,alpha__in_
c$$$     $              ,' alpha__in_: ')
c$$$            end if !if (verbose.gt.2) then
c$$$            if (flag_MS_vs_SM.eqv..true.) then
c$$$c$$$        Note: we use alpha_SM_update to update MS as well.
c$$$            call alpha_SM_update_1(n_MS_max,n_MS_(ns)
c$$$     $           ,alpha_MS__(ns*n_alpha*n_MS_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..true.) then
c$$$            if (flag_MS_vs_SM.eqv..false.) then
c$$$            call alpha_SM_update_1(n_SM_max,n_SM_(nm)
c$$$     $           ,alpha_SM__(nm*n_alpha*n_SM_max),alpha__in_)
c$$$            end if !if (flag_MS_vs_SM.eqv..false.) then
         enddo !do ns=0,n_S_sub-1
      enddo !do nm=0,n_M_sub-1
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_Zstore_3x]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Performs search-and-store routine. ;\n
      subroutine ti8_Zstore_3y(
     $     verbose
     $     ,rseed
     $     ,flag_RTRT_vs_RTTR
     $     ,n_delta_x
     $     ,delta_x_
     $     ,n_delta_y
     $     ,delta_y_
     $     ,n_gamma_z
     $     ,gamma_z_
     $     ,n_r 
     $     ,grid_p_
     $     ,n_w_
     $     ,n_A
     $     ,n_S_sub
     $     ,n_S_tot
     $     ,S_alpha_polar_a_
     $     ,S_alpha_azimu_b_
     $     ,n_M_sub
     $     ,polar_a_est_
     $     ,azimu_b_est_
     $     ,gamma_z_est_ 
     $     ,delta_x_est_
     $     ,delta_y_est_
     $     ,l2_norm_est_
     $     ,ctf_ind_est_ 
     $     ,S_index_est_
     $     ,M_index_est_
     $     ,alpha__in_
     $     ,alpha_update_f
     $     ,displacement_max
     $     ,flag_MS_vs_SM
     $     ,n_SM_max
     $     ,n_SM_
     $     ,alpha_SM__
     $     ,n_MS_max
     $     ,n_MS_
     $     ,alpha_MS__
     $     ,C_M_
     $     ,n_CTF
     $     ,CTF_R_S_ 
     $     ,CTF_R_S_use_ 
     $     ,n_M_tot
     $     ,S_T_T_R_CTF_M_q__ 
     $     ,ZZ_
     $     ,ZZ_sub_
     $     )
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      integer *4 rseed !random seed. ;
      real *8 adi_rand_f
      integer n_delta_x,n_delta_y,n_gamma_z,n_CTF
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 S_alpha_polar_a_(0:0),S_alpha_azimu_b_(0:0)
      real *8 delta_x_(0:n_delta_x-1),delta_y_(0:n_delta_y-1)
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      real *8 polar_a_est_(0:n_M_sub-1),azimu_b_est_(0:n_M_sub-1)
     $     ,gamma_z_est_(0:n_M_sub-1)
      real *8 delta_x_est_(0:n_M_sub-1),delta_y_est_(0:n_M_sub-1)
     $     ,l2_norm_est_(0:n_M_sub-1)
      real *8 ctf_ind_est_(0:n_M_sub-1)
      real *8 S_index_est_(0:n_M_sub-1)
      real *8 M_index_est_(0:n_M_sub-1)
      real *8 displacement_max
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM_(0:0) ! array of size n_M indicating the actual number of templates stored per image. ;
      real *8 alpha_SM__(0:0) ! array of size n_alpha*n_SM_max*n_M storing the image-parameters for each stored template-image pair. ;
c$$$      MS storage
      integer *4 n_MS_max ! total (maximum) number of images to store per template. ;
      integer *4 n_MS_(0:0) ! array of size n_S indicating the actual number of images stored per template. ;
      real *8 alpha_MS__(0:0) ! array of size n_alpha*n_MS_max*n_S storing the image-parameters for each stored iamge-template pair. ;
      real *8 alpha_update_f
      include 'nalpha_define.f'
      real *8 alpha__in_(0:n_alpha-1)
      integer n_S_sub,n_S_tot,n_M_sub,n_M_tot
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 CTF_R_S_use_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16 ZZ_(0:0)
      complex *16 ZZ_sub_(0:0)
      complex *16 ZZ
      complex *16 CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,nC
      integer ndx,ndy,ngz
      integer ns,nm,nctf,ns_use,nr_use
      integer nx2,nx3
      real *8 delta_x,delta_y,gamma_z,gamma_z_est
      integer ndx_optimal,ndy_optimal,ngz_optimal
      real *8 delta_x_optimal,delta_y_optimal,gamma_z_optimal
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      complex *16 C_Z_optimal,CTF_R_S_optimal,l2_norm_optimal
      real *8 pi
      character(len=1024) format_string

      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_Zstore_3y]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         write(6,'(A,I0)') ' n_delta_x: ' , n_delta_x
         call print_sub_r8(n_delta_x,delta_x_,' delta_x_: ')
         write(6,'(A,I0)') ' n_delta_y: ' , n_delta_y
         call print_sub_r8(n_delta_x,delta_y_,' delta_y_: ')
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         write(6,'(A,I0)') ' n_r : ' , n_r 
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,I0)') ' n_S_sub: ' , n_S_sub
         call print_sub_r8(n_S_sub,S_alpha_polar_a_
     $        ,' S_alpha_polar_a_: ')
         call print_sub_r8(n_S_sub,S_alpha_azimu_b_
     $        ,' S_alpha_azimu_b_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_sub_r8(n_M_sub,polar_a_est_,' polar_a_est_: ')
         call print_sub_r8(n_M_sub,azimu_b_est_,' azimu_b_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,l2_norm_est_,' l2_norm_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         call print_sub_r8(n_M_sub,S_index_est_,' S_index_est_: ')
         call print_sub_r8(n_M_sub,M_index_est_,' M_index_est_: ')
         write(6,'(A,F8.4)') ' alpha_update_f: ' , alpha_update_f
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
         write(6,'(A,L1)') ' flag_MS_vs_SM: ' , flag_MS_vs_SM
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         call print_sub_i4(n_M_sub,n_SM_,' n_SM_: ')
         call print_sub_r8(n_alpha*n_SM_max*n_M_sub,alpha_SM__
     $        ,' alpha_SM__: ')
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S_sub,n_MS_,' n_MS_: ')
         call print_sub_r8(n_alpha*n_MS_max*n_S_sub,alpha_MS__
     $        ,' alpha_MS__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         call print_sub_c16(n_gamma_z*n_CTF*n_S_sub,
     $        CTF_R_S_,' CTF_R_S_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
         call print_sub_c16(n_delta_x*n_delta_y*n_S_sub*n_M_sub
     $        ,S_T_T_R_CTF_M_q__,' S_T_T_R_CTF_M_q__: ')
         call print_sub_c16(n_delta_x*n_delta_y*n_gamma_z
     $        ,ZZ_,' ZZ_: ')
      end if !if (verbose.gt.1) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      call cl1_r8(n_alpha,alpha__in_)
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      call cl1_c16(n_w_max,ZZ_sub_)

c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      do nm=0,n_M_sub-1
         C_M = C_M_(nm)
         nctf = nint(ctf_ind_est_(nm))
         gamma_z_est = gamma_z_est_(nm)
         do ns=0,n_S_sub-1
            call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
     $           n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
            call cl1_c16(n_delta_x*n_delta_y*n_gamma_z,ZZ_)
            do ndy=0,n_delta_y-1
               delta_y = delta_y_(ndy)
               do ndx=0,n_delta_x-1
                  delta_x = delta_x_(ndx)
                  call cl1_c16(n_w_max,ZZ_sub_)
                  do nw=0,n_w_max-1
                     nx2 = ndx + n_delta_x*(ndy + n_delta_y*(ns +
     $                    n_S_sub*nm))
                     nx3 = nw*n_delta_x*n_delta_y*n_S_sub*n_M_tot
                     ZZ_sub_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
                  enddo !do nw
                  do ngz=0,n_gamma_z-1
                     CTF_R_S_use = CTF_R_S_use_(ngz)
                     gamma_z = gamma_z_(ngz)
                     call interp1_c16(n_w_max,0.0d0,2*pi,ZZ_sub_,
     $                    +gamma_z,ZZ)
                     nC = ndx + ndy*n_delta_x + ngz*n_delta_x*n_delta_y
                     if (zabs(C_M*CTF_R_S_use).le.1.0d-15) then
                        C_Z_use = 1.0d0
                     else
                        C_Z_use = C_M*CTF_R_S_use
                     end if
                     ZZ_(nC) = ZZ/(n_r**4)/C_Z_use
                  enddo !do ngz
               enddo !do ndx
            enddo ! do ndy
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call ti8_ZZ_scan_2(flag_RTRT_vs_RTTR
     $           ,delta_x_est_(nm),delta_y_est_(nm),gamma_z_est_(nm)
     $           ,displacement_max,n_delta_x ,delta_x_ ,n_delta_y
     $           ,delta_y_,n_gamma_z,gamma_z_,ZZ_ ,ndx_optimal
     $           ,ndy_optimal ,ngz_optimal,C_Z_optimal)
            delta_x_optimal = delta_x_(ndx_optimal)
            delta_y_optimal = delta_y_(ndy_optimal)
            gamma_z_optimal = gamma_z_(ngz_optimal)
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_(0
     $           +ns*n_gamma_z + nctf*n_gamma_z*n_S_sub),
     $           +gamma_z_est_(nm) ,ngz_optimal,CTF_R_S_optimal)
            if (verbose.gt.2) then
               write(6,'(A,I0,A,I0,A,I2,1X,I2,1X,I2,A,2F8.3,A,2F8.3)')
     $              ' Match between M_q_(' , nm , ') and S_q_(',ns
     $              ,') at ndx_optimal,ndy_optimal,ngz_optimal: '
     $              ,ndx_optimal ,ndy_optimal ,ngz_optimal
     $              ,'; CTF_R_S_optimal: ',CTF_R_S_optimal ,
     $              '; C_Z_optimal: ' ,C_Z_optimal
            end if !verbose            
            if (zabs(CTF_R_S_optimal).le.1.0d-15) then
               l2_norm_optimal = 1.0d0
            else 
               l2_norm_optimal = zabs(C_M_(nm)) *zabs(C_Z_optimal)
     $              /zabs(CTF_R_S_optimal)
            end if ! if (zabs(CTF_R_S_optimal).le.1.0d-15) then
            call cl1_r8(n_alpha,alpha__in_)
            alpha__in_(nalpha_polar_a) = S_alpha_polar_a_(ns)
            alpha__in_(nalpha_azimu_b) = S_alpha_azimu_b_(ns)
            alpha__in_(nalpha_gamma_z) = gamma_z_optimal
            alpha__in_(nalpha_delta_x) = delta_x_optimal
            alpha__in_(nalpha_delta_y) = delta_y_optimal
            alpha__in_(nalpha_l2_norm) = l2_norm_optimal
            alpha__in_(nalpha_ctf_ind) = nctf
            alpha__in_(nalpha_S_index) = ns + n_S_tot
            alpha__in_(nalpha_M_index) = M_index_est_(nm)
            alpha__in_(nalpha_CTF_R_S) = CTF_R_S_optimal
            alpha__in_(nalpha_C_Z_opt) = C_Z_optimal
            if (verbose.gt.2) then
               write(6,'(A)') ' calling alpha_SM_update_1 with '
               write(6,'(5(A,I0))') ' n_alpha ' , n_alpha , ' n_SM_max '
     $              , n_SM_max , ' nm ' , nm ,' nm*n_alpha*n_SM_max ' ,
     $              nm*n_alpha*n_SM_max , ' n_SM_(nm) ' , n_SM_(nm) 
               write(6,'(A,I0)') ' calling alpha_SM_update_1 with '
               call print_all_r8(n_alpha,alpha__in_
     $              ,' alpha__in_: ')
            end if !if (verbose.gt.2) then
            if (flag_MS_vs_SM.eqv..true.) then
c$$$        Note: we use alpha_SM_update to update MS as well.
            call alpha_SM_update_1(n_MS_max,n_MS_(ns)
     $           ,alpha_MS__(ns*n_alpha*n_MS_max),alpha__in_)
            end if !if (flag_MS_vs_SM.eqv..true.) then
            if (flag_MS_vs_SM.eqv..false.) then
            call alpha_SM_update_1(n_SM_max,n_SM_(nm)
     $           ,alpha_SM__(nm*n_alpha*n_SM_max),alpha__in_)
            end if !if (flag_MS_vs_SM.eqv..false.) then
         enddo !do ns=0,n_S_sub-1
      enddo !do nm=0,n_M_sub-1
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_Zstore_3y]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Performs search-and-store routine. ;\n
      subroutine ti8_Zstore_4(
     $     verbose
     $     ,rseed
     $     ,flag_RTRT_vs_RTTR
     $     ,n_delta_v
     $     ,delta_x_
     $     ,delta_y_
     $     ,n_gamma_z
     $     ,gamma_z_
     $     ,n_r 
     $     ,grid_p_
     $     ,n_w_
     $     ,n_A
     $     ,n_S_sub
     $     ,n_S_sum
     $     ,n_S_tmp
     $     ,S_alpha_S_index_
     $     ,S_alpha_polar_a_
     $     ,S_alpha_azimu_b_
     $     ,n_M_sub
     $     ,polar_a_est_
     $     ,azimu_b_est_
     $     ,gamma_z_est_ 
     $     ,delta_x_est_
     $     ,delta_y_est_
     $     ,l2_norm_est_
     $     ,ctf_ind_est_ 
     $     ,S_index_est_
     $     ,M_index_est_
     $     ,alpha__in_
     $     ,alpha_update_f
     $     ,displacement_max
     $     ,flag_MS_vs_SM
     $     ,n_SM_max
     $     ,n_SM_
     $     ,alpha_SM__
     $     ,n_MS_max
     $     ,n_MS_
     $     ,alpha_MS__
     $     ,C_M_
     $     ,n_CTF
     $     ,CTF_R_S_ 
     $     ,CTF_R_S_use_ 
     $     ,n_M_tot
     $     ,S_T_T_R_CTF_M_q__ 
     $     ,ZZ_
     $     ,ZZ_sub_
     $     )
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      integer *4 rseed !random seed. ;
      real *8 adi_rand_f
      integer n_delta_v,n_gamma_z,n_CTF
      integer n_r,n_w_(0:n_r-1),n_A
      real *8 S_alpha_S_index_(0:0)
      real *8 S_alpha_polar_a_(0:0)
      real *8 S_alpha_azimu_b_(0:0)
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1),grid_p_(0:n_r-1)
      real *8 polar_a_est_(0:n_M_sub-1),azimu_b_est_(0:n_M_sub-1)
     $     ,gamma_z_est_(0:n_M_sub-1)
      real *8 delta_x_est_(0:n_M_sub-1),delta_y_est_(0:n_M_sub-1)
     $     ,l2_norm_est_(0:n_M_sub-1)
      real *8 ctf_ind_est_(0:n_M_sub-1)
      real *8 S_index_est_(0:n_M_sub-1)
      real *8 M_index_est_(0:n_M_sub-1)
      real *8 displacement_max
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
c$$$      SM storage
      integer *4 n_SM_max ! total (maximum) number of templates to store per image. ;
      integer *4 n_SM_(0:0) ! array of size n_M indicating the actual number of templates stored per image. ;
      real *8 alpha_SM__(0:0) ! array of size n_alpha*n_SM_max*n_M storing the image-parameters for each stored template-image pair. ;
c$$$      MS storage
      integer *4 n_MS_max ! total (maximum) number of images to store per template. ;
      integer *4 n_MS_(0:0) ! array of size n_S indicating the actual number of images stored per template. ;
      real *8 alpha_MS__(0:0) ! array of size n_alpha*n_MS_max*n_S storing the image-parameters for each stored iamge-template pair. ;
      real *8 alpha_update_f
      include 'nalpha_define.f'
      real *8 alpha__in_(0:n_alpha-1)
      integer n_S_sub,n_S_sum,n_S_tmp,n_M_sub,n_M_tot
      complex *16 C_M_(0:0),C_M
      complex *16 CTF_R_S_(0:0)
      complex *16 CTF_R_S_use_(0:0)
      complex *16 S_T_T_R_CTF_M_q__(0:0)
      complex *16 ZZ_(0:0)
      complex *16 ZZ_sub_(0:0)
      complex *16 ZZ
      complex *16 CTF_R_S_use,C_Z_use
      integer n_w_max,nr,nw,nC,nC_stride
      integer ndv,ngz
      integer ns,nm,nctf,ns_use,nr_use
      integer nx2,nx3,nx3_stride
      real *8 delta_x,delta_y,gamma_z,gamma_z_est
      integer ndv_optimal,ngz_optimal
      real *8 delta_x_optimal,delta_y_optimal,gamma_z_optimal
      real *8 delta_x_tmp,delta_y_tmp,gamma_z_tmp
      complex *16 C_Z_optimal,CTF_R_S_optimal,l2_norm_optimal
      real *8 pi
      character(len=1024) format_string

      if (verbose.gt.0) then
         write(6,'(A)') '[entering ti8_Zstore_4]'
      end if !if (verbose.gt.0) then

      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_x_,' delta_x_: ')
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         call print_sub_r8(n_delta_v,delta_y_,' delta_y_: ')
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         call print_sub_r8(n_gamma_z,gamma_z_,' gamma_z_: ')
         write(6,'(A,I0)') ' n_r : ' , n_r 
         call print_sub_r8(n_r,grid_p_,' grid_p_: ')
         call print_sub_i4(n_r,n_w_,' n_w_: ')
         write(6,'(A,I0)') ' n_A: ' , n_A
         write(6,'(A,I0)') ' n_S_sub: ' , n_S_sub
         write(6,'(A,I0)') ' n_S_sum: ' , n_S_sum
         write(6,'(A,I0)') ' n_S_tmp: ' , n_S_tmp
         call print_sub_r8(n_S_sub,S_alpha_S_index_
     $        ,' S_alpha_S_index_: ')
         call print_sub_r8(n_S_sub,S_alpha_polar_a_
     $        ,' S_alpha_polar_a_: ')
         call print_sub_r8(n_S_sub,S_alpha_azimu_b_
     $        ,' S_alpha_azimu_b_: ')
         write(6,'(A,I0)') ' n_M_sub: ' , n_M_sub
         call print_sub_r8(n_M_sub,polar_a_est_,' polar_a_est_: ')
         call print_sub_r8(n_M_sub,azimu_b_est_,' azimu_b_est_: ')
         call print_sub_r8(n_M_sub,gamma_z_est_,' gamma_z_est_: ')
         call print_sub_r8(n_M_sub,delta_x_est_,' delta_x_est_: ')
         call print_sub_r8(n_M_sub,delta_y_est_,' delta_y_est_: ')
         call print_sub_r8(n_M_sub,l2_norm_est_,' l2_norm_est_: ')
         call print_sub_r8(n_M_sub,ctf_ind_est_,' ctf_ind_est_: ')
         call print_sub_r8(n_M_sub,S_index_est_,' S_index_est_: ')
         call print_sub_r8(n_M_sub,M_index_est_,' M_index_est_: ')
         write(6,'(A,F8.4)') ' alpha_update_f: ' , alpha_update_f
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
         write(6,'(A,L1)') ' flag_MS_vs_SM: ' , flag_MS_vs_SM
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         call print_sub_i4(n_M_sub,n_SM_,' n_SM_: ')
         call print_sub_r8(n_alpha*n_SM_max*n_M_sub,alpha_SM__
     $        ,' alpha_SM__: ')
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S_sub,n_MS_,' n_MS_: ')
         call print_sub_r8(n_alpha*n_MS_max*n_S_sub,alpha_MS__
     $        ,' alpha_MS__: ')
         call print_sub_c16(n_M_sub,C_M_,' C_M_: ')
         write(6,'(A,I0)') ' n_CTF: ' , n_CTF
         call print_sub_c16(n_gamma_z*n_CTF*n_S_sub,
     $        CTF_R_S_,' CTF_R_S_: ')
         write(6,'(A,I0)') ' n_M_tot: ' , n_M_tot
         call print_sub_c16(n_delta_v*n_S_sub*n_M_sub
     $        ,S_T_T_R_CTF_M_q__,' S_T_T_R_CTF_M_q__: ')
         call print_sub_c16(n_delta_v*n_gamma_z
     $        ,ZZ_,' ZZ_: ')
      end if !if (verbose.gt.1) then
      pi = 4.0*atan(1.0)
      n_w_max = n_w_(n_r-1)

      call cl1_r8(n_alpha,alpha__in_)
      call cl1_c16(n_gamma_z,CTF_R_S_use_)
      call cl1_c16(n_w_max,ZZ_sub_)

c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      do nm=0,n_M_sub-1
         C_M = C_M_(nm)
         nctf = nint(ctf_ind_est_(nm))
         gamma_z_est = gamma_z_est_(nm)
         do ns=0,n_S_sum-1
            call get_CTF_R_S_use_(gamma_z_est,n_gamma_z,CTF_R_S_(0 +
     $           n_gamma_z*(nctf + n_CTF*ns)),CTF_R_S_use_)
            do ngz=0,n_gamma_z-1
               if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then
                  CTF_R_S_use_(ngz) = 1.0d0
               else
                  CTF_R_S_use_(ngz) = 1.0d0/(C_M*CTF_R_S_use_(ngz)*n_r
     $                 **4)
               end if !if (zabs(C_M*CTF_R_S_use_(ngz)).le.1.0d-15) then               
            enddo !do ngz=0,n_gamma_z-1
            call cl1_c16(n_delta_v*n_gamma_z,ZZ_)
            if (n_gamma_z.eq.n_w_max) then
            nx2 = n_delta_v*(ns + n_S_sub*nm)
            nx3_stride = n_delta_v*n_S_sub*n_M_tot
            nC_stride = n_delta_v
            do ndv=0,n_delta_v-1
               nx3 = 0
               nC = ndv
               do nw=0,n_w_max-1
                  ngz = nw
                  CTF_R_S_use = CTF_R_S_use_(ngz)
                  ZZ_(nC) = S_T_T_R_CTF_M_q__(nx2 + nx3)*CTF_R_S_use
                  nx3 = nx3 + nx3_stride
                  nC = nC + nC_stride
               enddo            !do nw
               nx2 = nx2 + 1
            enddo ! do ndv
            else
            do ndv=0,n_delta_v-1
               delta_y = delta_y_(ndv)
               delta_x = delta_x_(ndv)
               call cl1_c16(n_w_max,ZZ_sub_)
               do nw=0,n_w_max-1
                  nx2 = ndv + n_delta_v*(ns + n_S_sub*nm)
                  nx3 = nw*n_delta_v*n_S_sub*n_M_tot
                  ZZ_sub_(nw) = S_T_T_R_CTF_M_q__(nx2 + nx3)
               enddo            !do nw
               do ngz=0,n_gamma_z-1
                  CTF_R_S_use = CTF_R_S_use_(ngz)
                  gamma_z = gamma_z_(ngz)
                  call interp1_c16(n_w_max,0.0d0,2*pi,ZZ_sub_,
     $                 +gamma_z,ZZ)
                  nC = ndv + n_delta_v*ngz
                  ZZ_(nC) = ZZ*CTF_R_S_use
               enddo            !do ngz
            enddo ! do ndv
            end if !if (n_gamma_z.eq.n_w_max) then
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call ti8_ZZ_scan_4(flag_RTRT_vs_RTTR
     $           ,delta_x_est_(nm),delta_y_est_(nm),gamma_z_est_(nm)
     $           ,displacement_max,n_delta_v ,delta_x_ ,delta_y_
     $           ,n_gamma_z,gamma_z_,ZZ_ ,ndv_optimal ,ngz_optimal
     $           ,C_Z_optimal)
            delta_x_optimal = delta_x_(ndv_optimal)
            delta_y_optimal = delta_y_(ndv_optimal)
            gamma_z_optimal = gamma_z_(ngz_optimal)
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            call get_CTF_R_S_periodize_0(n_gamma_z,gamma_z_ ,CTF_R_S_(0
     $           +n_gamma_z*(nctf + n_CTF*ns)), +gamma_z_est_(nm)
     $           ,ngz_optimal,CTF_R_S_optimal)
            if (verbose.gt.2) then
               write(6,'(2(A,I0),A,I4,1X,I4,3(A,2F8.3))')
     $              ' Match between M_q_(' , nm , ') and S_q_(',ns
     $              ,') at ndv_optimal,ngz_optimal: '
     $              ,ndv_optimal ,ngz_optimal
     $              ,'; C_M: ',C_M_(nm) 
     $              ,'; C_Z_optimal: ' ,C_Z_optimal
     $              ,'; CTF_R_S_optimal: ',CTF_R_S_optimal
            end if !verbose            
            if (zabs(CTF_R_S_optimal).le.1.0d-15) then
               l2_norm_optimal = 1.0d0
            else 
               l2_norm_optimal = zabs(C_M_(nm)) *zabs(C_Z_optimal)
     $              /zabs(CTF_R_S_optimal)
            end if ! if (zabs(CTF_R_S_optimal).le.1.0d-15) then
            call cl1_r8(n_alpha,alpha__in_)
            alpha__in_(nalpha_polar_a) = S_alpha_polar_a_(ns)
            alpha__in_(nalpha_azimu_b) = S_alpha_azimu_b_(ns)
            alpha__in_(nalpha_gamma_z) = gamma_z_optimal
            alpha__in_(nalpha_delta_x) = delta_x_optimal
            alpha__in_(nalpha_delta_y) = delta_y_optimal
            alpha__in_(nalpha_l2_norm) = l2_norm_optimal
            alpha__in_(nalpha_ctf_ind) = nctf
            alpha__in_(nalpha_S_index) = S_alpha_S_index_(ns)
            alpha__in_(nalpha_M_index) = M_index_est_(nm)
            alpha__in_(nalpha_CTF_R_S) = CTF_R_S_optimal
            alpha__in_(nalpha_C_Z_opt) = C_Z_optimal
            if (verbose.gt.2) then
               write(6,'(A)') ' calling alpha_SM_update_1 with '
               write(6,'(5(A,I0))') ' n_alpha ' , n_alpha , ' n_SM_max '
     $              , n_SM_max , ' nm ' , nm ,' nm*n_alpha*n_SM_max ' ,
     $              nm*n_alpha*n_SM_max , ' n_SM_(nm) ' , n_SM_(nm) 
               write(6,'(A,I0)') ' calling alpha_SM_update_1 with '
               call print_all_r8(n_alpha,alpha__in_
     $              ,' alpha__in_: ')
            end if !if (verbose.gt.2) then
            if (flag_MS_vs_SM.eqv..true.) then
c$$$        Note: we use alpha_SM_update to update MS as well.
            call alpha_SM_update_1(n_MS_max,n_MS_(ns)
     $           ,alpha_MS__(ns*n_alpha*n_MS_max),alpha__in_)
            end if !if (flag_MS_vs_SM.eqv..true.) then
            if (flag_MS_vs_SM.eqv..false.) then
            call alpha_SM_update_1(n_SM_max,n_SM_(nm)
     $           ,alpha_SM__(nm*n_alpha*n_SM_max),alpha__in_)
            end if !if (flag_MS_vs_SM.eqv..false.) then
         enddo !do ns=0,n_S_sum-1
      enddo !do nm=0,n_M_sub-1
c$$$            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished ti8_Zstore_4]'
      end if !if (verbose.gt.0) then

      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Scans across valid displacements for best innerproduct. ;\n
      subroutine ti8_ZZ_scan_2(flag_RTRT_vs_RTTR
     $     ,delta_x_est,delta_y_est,gamma_z_est,displacement_max
     $     ,n_delta_x,delta_x_,n_delta_y,delta_y_,n_gamma_z,gamma_z_,ZZ_
     $     ,ndx_optimal,ndy_optimal ,ngz_optimal ,C_Z_optimal)
      implicit none
      integer verbose
      data verbose / 0 /
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      real *8 delta_x_est,delta_y_est,gamma_z_est,displacement_max
      real *8 delta_x_(0:n_delta_x-1),delta_y_(0:n_delta_y-1)
      real *8 gamma_z_(0:n_gamma_z-1)
      integer n_delta_x,n_delta_y,n_gamma_z,ndx_optimal,ndy_optimal
     $     ,ngz_optimal
      complex *16 ZZ_(0:n_delta_x*n_delta_y*n_gamma_z-1)
      complex *16 C_Z_optimal
      real *8 delta_x_pre,delta_y_pre
      real *8 delta_x_pos,delta_y_pos
      integer ndx,ndy,ngz,na
      complex *16 C_Z
      logical flag_found
      real *8 delta_pos
      if (verbose.gt.0) then
         write(6,'(A)') ' [entering ti8_ZZ_scan_2] '
      end if !if (verbose.gt.0) then
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' n_delta_x: ' , n_delta_x
         write(6,'(A,I0)') ' n_delta_y: ' , n_delta_y
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
      end if !if (verbose.gt.0) then
      flag_found = .false.
      ndx_optimal = 0
      ndy_optimal = 0
      ngz_optimal = 0
      na=0
      do ngz=0,n_gamma_z-1
         delta_x_pre = delta_x_est
         delta_y_pre = delta_y_est
         call get_interchange_delta(delta_x_pre,delta_y_pre
     $        ,gamma_z_(ngz),delta_x_pos,delta_y_pos)
         do ndy=0,n_delta_y-1
            do ndx=0,n_delta_x-1
               if (flag_RTRT_vs_RTTR.eqv..true.) then
                  delta_pos = dsqrt((delta_x_(ndx) + delta_x_pos)**2 +
     $                 (delta_y_(ndy) + delta_y_pos)**2)
               end if !if (flag_RTRT_vs_RTTR.eqv..true.) then
               if (flag_RTRT_vs_RTTR.eqv..false.) then
                  delta_pos = dsqrt((delta_x_(ndx) + delta_x_est)**2 +
     $                 (delta_y_(ndy) + delta_y_est)**2)
               end if !if (flag_RTRT_vs_RTTR.eqv..false.) then
               if (verbose.gt.1) then
                  write(6,'(A,F8.4)') ' delta_x_pre ' , delta_x_pre 
                  write(6,'(A,F8.4)') ' delta_y_pre ' , delta_y_pre 
                  write(6,'(A,F8.4)') ' delta_x_pos ' , delta_x_pos 
                  write(6,'(A,F8.4)') ' delta_y_pos ' , delta_y_pos 
                  write(6,'(A,F8.4)') ' delta_x_est ' , delta_x_est 
                  write(6,'(A,F8.4)') ' delta_y_est ' , delta_y_est 
                  write(6,'(A,F8.4)') ' delta_pos ' , delta_pos 
               end if !if (verbose.gt.1) then
               if (delta_pos.le.displacement_max) then
                  if (flag_found.eqv..false.) then
                     C_Z = ZZ_(na)
                     C_Z_optimal = C_Z
                     ndx_optimal = ndx
                     ndy_optimal = ndy
                     ngz_optimal = ngz
                     flag_found = .true.
                  else !if (flag_found.eqv..true.) then
                     C_Z = ZZ_(na)
                     if (real(C_Z).gt.real(C_Z_optimal)) then
                        C_Z_optimal = C_Z
                        ndx_optimal = ndx
                        ndy_optimal = ndy
                        ngz_optimal = ngz
                     end if !if new value is bigger
                  end if !flag_found
               end if ! (delta_pos.le.displacement_max)
               na = na+1
            enddo ! n_delta_x
         enddo ! n_delta_y
      enddo ! n_gamma_z
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' ndx_optimal: ' , ndx_optimal
         write(6,'(A,I0)') ' ndy_optimal: ' , ndy_optimal
         write(6,'(A,I0)') ' ngz_optimal: ' , ngz_optimal
         write(6,'(A,2F8.4)') ' C_Z_optimal: ' , C_Z_optimal
      end if !if (verbose.gt.0) then
      if (flag_found.eqv..false.) then
         write(6,'(A)') 'Warning, flag_found.eqv..false. '
     $        ,'in ti8_ZZ_scan_2.f'
      end if !if (flag_found.eqv..false.) then
      if (verbose.gt.0) then
         write(6,'(A)') ' [finished ti8_ZZ_scan_2] '
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Scans across valid displacements for best innerproduct. ;\n
!> Does not interchange delta in the midde. ;\n
      subroutine ti8_ZZ_scan_4x(flag_RTRT_vs_RTTR
     $     ,delta_x_est,delta_y_est,gamma_z_est,displacement_max
     $     ,n_delta_v,delta_x_,delta_y_,n_gamma_z,gamma_z_,ZZ_
     $     ,ndv_optimal,ngz_optimal ,C_Z_optimal)
      implicit none
      integer verbose
      data verbose / 0 /
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      real *8 delta_x_est,delta_y_est,gamma_z_est,displacement_max
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1)
      integer n_delta_v,n_gamma_z,ndv_optimal
     $     ,ngz_optimal
      complex *16 ZZ_(0:n_delta_v*n_gamma_z-1)
      complex *16 C_Z_optimal
      real *8 delta_x_pre,delta_y_pre
      real *8 delta_x_pos,delta_y_pos
      integer ndv,ngz,na,na_tmp
      complex *16 C_Z
      logical flag_found
      real *8 delta_pos
      if (verbose.gt.0) then
         write(6,'(A)') ' [entering ti8_ZZ_scan_4x] '
      end if !if (verbose.gt.0) then
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
      end if !if (verbose.gt.0) then
      flag_found = .false.
      C_Z_optimal = cmplx( -1.0d0 , 0.0d0 )
      ndv_optimal = 0
      ngz_optimal = 0
      do na=0,n_gamma_z*n_delta_v-1
         if (real(ZZ_(na)).gt.real(C_Z_optimal)) then
            na_tmp = na
            ndv = mod(na_tmp,n_delta_v)
            na_tmp = na_tmp/n_delta_v
            ngz = na_tmp
            delta_x_pre = delta_x_est
            delta_y_pre = delta_y_est
c$$$            call get_interchange_delta(delta_x_pre,delta_y_pre
c$$$     $           ,gamma_z_(ngz),delta_x_pos,delta_y_pos)
c$$$            if (flag_RTRT_vs_RTTR.eqv..true.) then
c$$$               delta_pos = dsqrt((delta_x_(ndv) + delta_x_pos)**2 +
c$$$     $              (delta_y_(ndv) + delta_y_pos)**2)
c$$$            end if              !if (flag_RTRT_vs_RTTR.eqv..true.) then
c$$$            if (flag_RTRT_vs_RTTR.eqv..false.) then
c$$$               delta_pos = dsqrt((delta_x_(ndv) + delta_x_est)**2 +
c$$$     $              (delta_y_(ndv) + delta_y_est)**2)
c$$$            end if              !if (flag_RTRT_vs_RTTR.eqv..false.) then
c$$$            if (verbose.gt.1) then
c$$$               write(6,'(A,I0,A,I0)') ' ngz ' , ngz , ' ndv ' , ndv
c$$$               write(6,'(A,F8.4)') ' delta_x_pre ' , delta_x_pre 
c$$$               write(6,'(A,F8.4)') ' delta_y_pre ' , delta_y_pre 
c$$$               write(6,'(A,F8.4)') ' delta_x_pos ' , delta_x_pos 
c$$$               write(6,'(A,F8.4)') ' delta_y_pos ' , delta_y_pos 
c$$$               write(6,'(A,F8.4)') ' delta_x_est ' , delta_x_est 
c$$$               write(6,'(A,F8.4)') ' delta_y_est ' , delta_y_est 
c$$$               write(6,'(A,F8.4)') ' delta_pos ' , delta_pos 
c$$$            end if              !if (verbose.gt.1) then
c$$$            if (delta_pos.le.displacement_max) then 
               C_Z = ZZ_(na)
               C_Z_optimal = C_Z
               ndv_optimal = ndv
               ngz_optimal = ngz
               flag_found = .true.
c$$$            end if !if (delta_pos.le.displacement_max) then 
         end if !if (real(ZZ_(na)).gt.real(C_Z_optimal)) then
      enddo !do na=0,n_gamma_z*n_delta_v-1
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' ndv_optimal: ' , ndv_optimal
         write(6,'(A,I0)') ' ngz_optimal: ' , ngz_optimal
         write(6,'(A,2F8.4)') ' C_Z_optimal: ' , C_Z_optimal
      end if !if (verbose.gt.0) then
      if (flag_found.eqv..false.) then
         write(6,'(A)') 'Warning, flag_found.eqv..false. '
     $        ,'in ti8_ZZ_scan_4x.f'
         stop !exit program due to error ;
      end if !if (flag_found.eqv..false.) then
      if (verbose.gt.0) then
         write(6,'(A)') ' [finished ti8_ZZ_scan_4x] '
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> test_innerproduct_8 excerpt: ;\n
!> Scans across valid displacements for best innerproduct. ;\n
      subroutine ti8_ZZ_scan_4(flag_RTRT_vs_RTTR
     $     ,delta_x_est,delta_y_est,gamma_z_est,displacement_max
     $     ,n_delta_v,delta_x_,delta_y_,n_gamma_z,gamma_z_,ZZ_
     $     ,ndv_optimal,ngz_optimal ,C_Z_optimal)
      implicit none
      integer verbose
      data verbose / 0 /
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      real *8 delta_x_est,delta_y_est,gamma_z_est,displacement_max
      real *8 delta_x_(0:n_delta_v-1),delta_y_(0:n_delta_v-1)
      real *8 gamma_z_(0:n_gamma_z-1)
      integer n_delta_v,n_gamma_z,ndv_optimal
     $     ,ngz_optimal
      complex *16 ZZ_(0:n_delta_v*n_gamma_z-1)
      complex *16 C_Z_optimal
      real *8 delta_x_pre,delta_y_pre
      real *8 delta_x_pos,delta_y_pos
      integer ndv,ngz,na,na_tmp
      complex *16 C_Z
      logical flag_found
      real *8 delta_pos
      if (verbose.gt.0) then
         write(6,'(A)') ' [entering ti8_ZZ_scan_4] '
      end if !if (verbose.gt.0) then
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' n_delta_v: ' , n_delta_v
         write(6,'(A,I0)') ' n_gamma_z: ' , n_gamma_z
         write(6,'(A,F8.4)') ' displacement_max: ' , displacement_max
      end if !if (verbose.gt.0) then
      flag_found = .false.
      C_Z_optimal = cmplx( -1.0d0 , 0.0d0 )
      ndv_optimal = 0
      ngz_optimal = 0
      do na=0,n_gamma_z*n_delta_v-1
         if (verbose.gt.1) then
            write(6,'(A,I0,A,F8.4,F8.4)') ' ZZ_(' , na , ') ' , ZZ_(na)
         end if !if (verbose.gt.1) then
         if (real(ZZ_(na)).gt.real(C_Z_optimal)) then
            na_tmp = na
            ndv = mod(na_tmp,n_delta_v)
            na_tmp = na_tmp/n_delta_v
            ngz = na_tmp
            delta_x_pre = delta_x_est
            delta_y_pre = delta_y_est
            call get_interchange_delta(delta_x_pre,delta_y_pre
     $           ,gamma_z_(ngz),delta_x_pos,delta_y_pos)
            if (flag_RTRT_vs_RTTR.eqv..true.) then
               delta_pos = dsqrt((delta_x_(ndv) + delta_x_pos)**2 +
     $              (delta_y_(ndv) + delta_y_pos)**2)
            end if              !if (flag_RTRT_vs_RTTR.eqv..true.) then
            if (flag_RTRT_vs_RTTR.eqv..false.) then
               delta_pos = dsqrt((delta_x_(ndv) + delta_x_est)**2 +
     $              (delta_y_(ndv) + delta_y_est)**2)
            end if              !if (flag_RTRT_vs_RTTR.eqv..false.) then
            if (verbose.gt.1) then
               write(6,'(A,I0,A,I0)') ' ngz ' , ngz , ' ndv ' , ndv
               write(6,'(A,F8.4)') ' delta_x_pre ' , delta_x_pre 
               write(6,'(A,F8.4)') ' delta_y_pre ' , delta_y_pre 
               write(6,'(A,F8.4)') ' delta_x_pos ' , delta_x_pos 
               write(6,'(A,F8.4)') ' delta_y_pos ' , delta_y_pos 
               write(6,'(A,F8.4)') ' delta_x_est ' , delta_x_est 
               write(6,'(A,F8.4)') ' delta_y_est ' , delta_y_est 
               write(6,'(A,F8.4)') ' delta_pos ' , delta_pos 
            end if              !if (verbose.gt.1) then
            if (delta_pos.le.displacement_max) then 
               C_Z = ZZ_(na)
               C_Z_optimal = C_Z
               ndv_optimal = ndv
               ngz_optimal = ngz
               flag_found = .true.
            end if !if (delta_pos.le.displacement_max) then 
         end if !if (real(ZZ_(na)).gt.real(C_Z_optimal)) then
      enddo !do na=0,n_gamma_z*n_delta_v-1
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' ndv_optimal: ' , ndv_optimal
         write(6,'(A,I0)') ' ngz_optimal: ' , ngz_optimal
         write(6,'(A,2F8.4)') ' C_Z_optimal: ' , C_Z_optimal
      end if !if (verbose.gt.0) then
      if (flag_found.eqv..false.) then
         write(6,'(A)') 'Warning, flag_found.eqv..false. '
     $        ,'in ti8_ZZ_scan_4.f'
         write(6,'(A,F8.4)') ' displacement_max ' ,
     $        displacement_max 
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR ' ,
     $        flag_RTRT_vs_RTTR 
         write(6,'(A,I0)') ' n_gamma_z ' , n_gamma_z 
         write(6,'(A,I0)') ' n_delta_v ' , n_delta_v 
         do na=0,n_gamma_z*n_delta_v-1
            if (verbose.gt.-1) then
               write(6,'(A,I0,A,F8.4,F8.4)') ' ZZ_(' , na , ') ' ,
     $              ZZ_(na)
            end if              !if (verbose.gt.-1) then
            if (real(ZZ_(na)).gt.real(C_Z_optimal)) then
               na_tmp = na
               ndv = mod(na_tmp,n_delta_v)
               na_tmp = na_tmp/n_delta_v
               ngz = na_tmp
               delta_x_pre = delta_x_est
               delta_y_pre = delta_y_est
               call get_interchange_delta(delta_x_pre,delta_y_pre
     $              ,gamma_z_(ngz),delta_x_pos,delta_y_pos)
               if (flag_RTRT_vs_RTTR.eqv..true.) then
                  delta_pos = dsqrt((delta_x_(ndv) + delta_x_pos)**2 +
     $                 (delta_y_(ndv) + delta_y_pos)**2)
               end if           !if (flag_RTRT_vs_RTTR.eqv..true.) then
               if (flag_RTRT_vs_RTTR.eqv..false.) then
                  delta_pos = dsqrt((delta_x_(ndv) + delta_x_est)**2 +
     $                 (delta_y_(ndv) + delta_y_est)**2)
               end if           !if (flag_RTRT_vs_RTTR.eqv..false.) then
               if (verbose.gt.-1) then
                  write(6,'(2(A,I0),10(A,F8.4))')
     $                 ' ngz ' , ngz ,
     $                 ' ndv ' , ndv, 
     $                 ' delta_x_(ndv) ' , delta_x_(ndv) ,
     $                 ' delta_y_(ndv) ' , delta_y_(ndv) ,
     $                 ' delta_x_pre ' , delta_x_pre ,
     $                 ' delta_y_pre ' , delta_y_pre ,
     $                 ' delta_x_est ' , delta_x_est ,
     $                 ' delta_y_est ' , delta_y_est ,
     $                 ' delta_x_pos ' , delta_x_pos ,
     $                 ' delta_y_pos ' , delta_y_pos ,
     $                 ' delta_pos ' , delta_pos ,
     $                 ' displacement_max ' , displacement_max 
               end if           !if (verbose.gt.-1) then
               if (delta_pos.le.displacement_max) then 
                  C_Z = ZZ_(na)
                  C_Z_optimal = C_Z
                  ndv_optimal = ndv
                  ngz_optimal = ngz
               end if           !if (delta_pos.le.displacement_max) then 
            end if              !if (real(ZZ_(na)).gt.real(C_Z_optimal)) then
         enddo                  !do na=0,n_gamma_z*n_delta_v-1
         stop !exit program due to error ;
      end if !if (flag_found.eqv..false.) then
      if (verbose.gt.0) then
         write(6,'(A)') ' [finished ti8_ZZ_scan_4] '
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> This function performs many of the tasks associated with molecular reconstruction: ;\n
!> 1.  First use current stack of image-parameters along with least-squares to find Y_est_. ;\n
!> 2a. Generate templates based on current model (using Y_est_). ;\n
!> 2b. Choose some number of templates to use when angle-fitting. ;\n
!> 3a. Given a memory budget, determine blocking structure for angle-fitting. ;\n
!> 3b. Perform angle-fitting. ;\n
!> 4.  Update stack of image-parameters alpha_est__. ;\n
      subroutine test_alpha_update_6(
     $     verbose ! verbosity level. ;
     $     ,rseed !integer *4: random seed (used for any random permutations). ;
     $     ,n_k_cur !integer *4: current index for current maximum value of n_k. Note that this runs from 1 to n_k_p_max. ;
     $     ,n_polar_a_ !integer *4 array (length at least n_k_cur): number of polar_a values on sphere of radius grid_k_p_(nk). also called nlats(nk). ;
     $     ,grid_k_p_ !real *8 array (length at least n_k_cur): values for k on successive shells for k-space polar coordinates. sometimes called grid_p_ or xnodesr. ;
     $     ,half_diameter_x_c !real *8: half diameter of particle support in x-space cartesian coordinates. sometimes called a. ;
     $     ,ld_S !integer *4: leading dimension of S_k_p__. Must be at least n_A. ;
     $     ,S_k_p__ !complex *16 array (length at least ld_S*max_i4_f_(I_S_sample_)): stack of templates associated with reconstructed molecule. sometimes called Y_slice__ or cslices or templates. ;
     $     ,tesselation_distance_req !real *8: !determines whether or not to adaptively sample templates. if tesselation_distance_req.ge.2.0d0, then all templates will be compared to all images. However, if tesselation_distance_req.lt.2.0d0, then only a few templates will be considered for each image. Roughly speaking, the value of tesselation_distance_req determines the neighborhood of viewing angles around each image which will be searched (in terms of distance on the sphere). When adaptively sampling templates, we might allow this value to shrink with the total number of templates (e.g., to ensure that the number of templates considered per image remains roughly constant). ;
     $      ,n_LT_add ! number of templates to add (randomly) after considering local neighborhood in local search. ;
     $      ,n_LT_ref ! number of image-template pairs to consider when refining local search.
     $      ,n_M_sample !integer *4: total number of sampled images (i.e., length of I_M_sample_). sometimes called nimages. ;
     $      ,I_M_sample_ !integer *4 array (length at least n_M_sample): indexing variable used to reference images. Only images M_k_p__(I_M_sample_(nm)*ld_M) will be accessed. ;
     $      ,ld_M !integer *4: leading dimension of M_k_p__. Must be at least n_A. ;
     $      ,M_k_p__ !complex *16 array (length at least ld_M*max_i4_f_(I_M_sample_)): stack of images. sometimes called Y_slice__ associated with reconstructed molecule. 
     $      ,n_CTF !integer *4: total number of CTF functions. ;
     $      ,ld_CTF !integer *4: leading dimension of CTF_k_p__. Must be at least n_A. ;
     $      ,CTF_k_p__ !complex *16 array (length at least ld_CTF*n_ctf): stack of CTF functions. ;
     $      ,alpha_est__ !real *8 array (length at least n_alpha*n_M_sample): ! estimated image parameters associated with sampled image set stored in 1-dimensional array. Note that we expect alpha_est__(n_alpha*nm) to apply to image M_k_p__(I_M_sample_(nm)*ld_M). ;
     $      ,alpha_update_f !real *8: fraction of 'best' templates to select from when updating image-parameters for any particular image (used when flag_MS_vs_SM.eqv..false.). Also interpreted as the fraction of 'best' images to select from when updating image-parameters when flag_MS_vs_SM.eqv..true. ;
     $      ,flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
     $      ,n_SM_max !integer *4: maximum number of templates-per-image whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
     $      ,n_MS_max !integer *4: maximum number of images-per-template whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
     $      ,n_pixels_in !real *8: if displacements are considered, this value determines the number of pixels (in each direction) to be considered. The number of pixels is related to the x-space cartesian coordinates by the maximum wavelength 'n_k_cur' under consideration (which can change from iteration to iteration). ;
     $      ,displacement_max !real *8: if displacements are considered, this value determines the maximum displacement (in x-space cartesian coordinates) allowed when assigning parameters to each image. This parameter can be set to mitigate the 'runaway' phenomenon that can occur as the displacements for each image are updated iteratively. ;
     $      ,n_delta_v !integer *4: if displacements are considered, this value determines the number of displacements considered (in x-space cartesian coordinates). ;
     $      ,n_gamma_z !integer *4: determines the number of in-plane rotations gamma_z to consider for each image-template pair. ; 
     $      ,svd_calculation_type !integer *4: integer determining how innerproducts are computed across rotations and translations. ;
c$$$      svd_calculation_type == 1 --> encode displacements using svd, then account for in-plane rotations using the fft, then multiply to access displacements. ;
c$$$      svd_calculation_type == 2 --> account for displacements via brute-force. ;
     $      ,eps_svd !real *8: svd tolerance epsilon, typically 0.1d0, 0.01d0 or 0.001d0. ;
     $      ,flag_RTRT_vs_RTTR !logical: determines whether to compute <R_{+upd}(T_{+upd}(Z)),T_{-est}(R_{-est}(CTF.*M))> (if .true.) or <Z,R_{-upd}(T_{-upd}(T_{-est}(R_{-est}(CTF.*M))))> (if .false.). ;
     $      ,fpm_howmany_max !integer *4: Maximum number of fftws to call simultaneously within the fftw_plan_many. 
     $      ,n_omp_sub__in !integer *4: number of omp sub-blocks (e.g., number of available processors). ;
     $      ,n_S_0_sub__in !integer *4: number of requested sub-blocks at level-0 for n_S_sample (used for O_S_q__, T_S_q__, Z_S_q__). ;
     $      ,n_S_1_sub__in !integer *4: number of requested sub-blocks at level-1 for n_S_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
     $      ,n_M_0_sub__in !integer *4: number of requested sub-blocks at level-0 for n_M_sample (used for O_T_R_CTF_M_q__, T_T_R_CTF_M_q__, Z_T_R_CTF_M_q__). ;
     $      ,n_M_1_sub__in !integer *4: number of requested sub-blocks at level-1 for n_M_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
     $      ,d_memory_limit !real *8: upper limit on the memory allowed by test_innerproduct_8. ;
     $      ,n_w_csum_ ! cumulative sum of n_w_. also called icstart(nk). ;
     $      ,quadrature_type_azimu_b ! quadrature type in the azimuthal direction. sometimes named itypep. ;
     $      ,n_w_ ! ngridc(nk) is the number of points on the ring of radius grid_k_p_(nk) for a template or image in k-space polar coordinates. also called ngridc(nk). ;
     $      ,n_k_low ! lowest value of nk (k-index in k-space polar coordinates) to use when building models. Note that this runs from 1 to n_k_p_max. ;
     $      ,n_Y_lm_sum ! total number of basis functions used in spherical harmonic expansion (in k-space polar coordinates). sometimes called nsphstore. ;
     $      ,n_Y_lm_csum_ ! cumulative sum of n_Y_lm_. also called isph_start(nk). ;
     $      ,n_Y_l_ ! order of spherical harmonic expansion on sphere at radius grid_k_p_(nk). also called nterms_sph(nk). ;
     $      ,lsq_oversample ! least-squares-solver oversampling parameter. sometimes called oversamp. ;
     $      ,lsq_interpolation_order ! least-squares-solver interpolation order. sometimes named kord. ;
     $      ,eps_default ! tolerance epsilon, typically 1e-6. used in many places (e.g., least-squares-solver). ;
     $      ,Y_est_ ! spherical harmonic coefficients obtained using estimated-angles to reconstruct molecule. sometimes called modsph_est. ;
     $      ,n_azimu_b_polar_a_sum_ ! total number of points on sphere at radius grid_k_p_(nk). also called numonsphere(nk). ;
     $      ,n_S_sample_max    ! maximum number of templates to consider (if quadrature_type_azimu_b==1, these will be distributed uniformly across the sphere). ;
     $      ,flag_fig  ! flag determining whether or not to dump output file. ;
     $      ,dname ! directory name to dump output (if flag_fig is set). ;
     $      ,timing_rebuild_est ! time to rebuild Y_est_. ;
     $      ,timing_template_create ! time to create templates. ;
     $      ,timing_innerproduct ! time to calculate innerproducts. ;
     $      )
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  rebuild model Y_est_ based on current alpha_est__ ;
c$$$  (i.e., array of estimated image parameters).
c$$$  Then use new Y_est_ to update alpha_est__ (using angle-fitting). ;
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      implicit none
      include 'omp_lib.h'
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
c$$$  Variables used for test_innerproduct_8. ;
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
      integer verbose ! verbosity level. ;
      logical flag_memory_estimate !logical: if set to .true. will only estimate total memory requirements. ;
c$$$      parameter(flag_memory_estimate=.false.)
      real *8 d_memory_estimate !real *8: estimate of required memory (in bytes). ;
      integer *4 rseed !integer *4: random seed (used for any random permutations). ;
      integer *4 n_k_cur !integer *4: current index for current maximum value of n_k. Note that this runs from 1 to n_k_p_max. ;
      integer *4 n_polar_a_(0:n_k_cur-1) !integer *4 array (length at least n_k_cur): number of polar_a values on sphere of radius grid_k_p_(nk). also called nlats(nk). ;
      real *8 grid_k_p_(0:n_k_cur-1) !real *8 array (length at least n_k_cur): values for k on successive shells for k-space polar coordinates. sometimes called grid_p_ or xnodesr. ;
      real *8 half_diameter_x_c !real *8: half diameter of particle support in x-space cartesian coordinates. sometimes called a. ;
      integer *4 n_S_sample !integer *4: total number of sampled templates (i.e., length of I_S_sample_). sometimes called ntemplates. ;
      integer *4, allocatable :: I_S_sample_(:) !temporary: integer *4 array (length at least n_S_sample): indexing variable used to reference templates. Only templates S_k_p__(I_S_sample_(ns)*ld_S) will be accessed. ;
      integer *4 ld_S !integer *4: leading dimension of S_k_p__. Must be at least n_A. ;
      complex *16 S_k_p__(0:0) !complex *16 array (length at least ld_S*max_i4_f_(I_S_sample_)): stack of templates associated with reconstructed molecule. sometimes called Y_slice__ or cslices or templates. ;
      real *8 tesselation_distance_req !real *8: !determines whether or not to adaptively sample templates. if tesselation_distance_req.ge.2.0d0, then all templates will be compared to all images. However, if tesselation_distance_req.lt.2.0d0, then only a few templates will be considered for each image. Roughly speaking, the value of tesselation_distance_req determines the neighborhood of viewing angles around each image which will be searched (in terms of distance on the sphere). When adaptively sampling templates, we might allow this value to shrink with the total number of templates (e.g., to ensure that the number of templates considered per image remains roughly constant). ;
      integer *4 n_LT_add ! number of templates to add (randomly) after considering local neighborhood in local search. ;
      integer *4 n_LT_ref ! number of image-template pairs to consider when refining local search.
      real *8, allocatable :: S_alpha_S_index_sample_(:) !temporary: real *8 array (length at least n_S_sample): array of S_index associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_S_index_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
      real *8, allocatable :: S_alpha_polar_a_sample_(:) !temporary: real *8 array (length at least n_S_sample): array of polar_a associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_polar_a_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
      real *8, allocatable :: S_alpha_azimu_b_sample_(:) !temporary: real *8 array (length at least n_S_sample): array of azimu_b associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_azimu_b_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
      integer *4 n_M_sample !integer *4: total number of sampled images (i.e., length of I_M_sample_). sometimes called nimages. ;
      integer *4 I_M_sample_(0:n_M_sample-1) !integer *4 array (length at least n_M_sample): indexing variable used to reference images. Only images M_k_p__(I_M_sample_(nm)*ld_M) will be accessed. ;
      integer *4 ld_M !integer *4: leading dimension of M_k_p__. Must be at least n_A. ;
      complex *16 M_k_p__(0:0) !complex *16 array (length at least ld_M*max_i4_f_(I_M_sample_)): stack of images. sometimes called Y_slice__ associated with reconstructed molecule. 
      integer *4 n_CTF !integer *4: total number of CTF functions. ;
      integer *4 ld_CTF !integer *4: leading dimension of CTF_k_p__. Must be at least n_A. ;
      complex *16 CTF_k_p__(0:0) !complex *16 array (length at least ld_CTF*n_ctf): stack of CTF functions. ;
      include 'nalpha_define.f'
      real *8 alpha_est__(0:0) !real *8 array (length at least n_alpha*n_M_sample): ! estimated image parameters associated with sampled image set stored in 1-dimensional array. Note that we expect alpha_est__(n_alpha*nm) to apply to image M_k_p__(I_M_sample_(nm)*ld_M). ;
      real *8 alpha_update_f !real *8: fraction of 'best' templates to select from when updating image-parameters for any particular image (used when flag_MS_vs_SM.eqv..false.). Also interpreted as the fraction of 'best' images to select from when updating image-parameters when flag_MS_vs_SM.eqv..true. ;
      logical flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
      integer *4 n_SM_max !integer *4: maximum number of templates-per-image whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
      integer *4, allocatable :: n_SM_(:) !temporary: integer *4 array (length at least n_M_sample): actual number of templates whose innerproduct-information is stored for a particular image. Note that n_SM_(nm) indicates the number of templates whose information is stored for the image M_k_p__(I_M_sample_(nm)). ;
      real *8, allocatable :: alpha_SM__(:) !temporary: real *8 array (length at least n_alpha*n_SM_max*n_M_sample): actual innerproduct-information stored for various template-image pairs. Note that alpha_SM__((ns + nm*n_SM_max)*n_alpha) (with ns.lt.n_SM_(nm)) stores the innerproduct-information for the image M_k_p__(I_M_sample_(nm)) and the ns-th template whose information is stored for that particular image. ;
      integer *4 n_MS_max !integer *4: maximum number of images-per-template whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
      integer *4, allocatable :: n_MS_(:) !temporary: integer *4 array (length at least n_S_sample): actual number of images whose innerproduct-information is stored for a particular template. Note that n_MS_(ns) indicates the number of images whose information is stored for the template S_k_p__(I_S_sample_(ns)). ;
      real *8, allocatable :: alpha_MS__(:) !temporary: real *8 array (length at least n_alpha*n_MS_max*n_S_sample): actual innerproduct-information stored for various image-template pairs. Note that alpha_MS__((nm + ns*n_MS_max)*n_alpha) (with nm.lt.n_MS_(ns)) stores the innerproduct-information for the template S_k_p__(I_S_sample_(ns)) and the nm-th image whose information is stored for that particular template. ;
      real *8 n_pixels_in !real *8: if displacements are considered, this value determines the number of pixels (in each direction) to be considered. The number of pixels is related to the x-space cartesian coordinates by the maximum wavelength 'n_k_cur' under consideration (which can change from iteration to iteration). ;
      real *8 displacement_max !real *8: if displacements are considered, this value determines the maximum displacement (in x-space cartesian coordinates) allowed when assigning parameters to each image. This parameter can be set to mitigate the 'runaway' phenomenon that can occur as the displacements for each image are updated iteratively. ;
      integer *4 n_delta_v !integer *4: if displacements are considered, this value determines the number of displacements considered (in x-space cartesian coordinates). ;
      integer *4 n_delta_v_use !integer *4: actual n_delta_v used to construct delta_x_ and delta_y_. ;
      real *8, allocatable :: delta_x_(:) !temporary: real *8 array: (length at least n_delta_v_use): x-coordinates of displacements. ;
      real *8, allocatable :: delta_y_(:) !temporary: real *8 array: (length at least n_delta_v_use): y-coordinates of displacements. ;
      integer *4 n_gamma_z !integer *4: determines the number of in-plane rotations gamma_z to consider for each image-template pair. ; 
      integer *4 svd_calculation_type !integer *4: integer determining how innerproducts are computed across rotations and translations. ;
c$$$      svd_calculation_type == 1 --> encode displacements using svd, then account for in-plane rotations using the fft, then multiply to access displacements. ;
c$$$      svd_calculation_type == 2 --> account for displacements via brute-force. ;
      real *8 eps_svd !real *8: svd tolerance epsilon, typically 0.1d0, 0.01d0 or 0.001d0. ;
      logical flag_RTRT_vs_RTTR !logical: determines whether to compute <R_{+upd}(T_{+upd}(Z)),T_{-est}(R_{-est}(CTF.*M))> (if .true.) or <Z,R_{-upd}(T_{-upd}(T_{-est}(R_{-est}(CTF.*M))))> (if .false.). ;
      integer *4 fpm_howmany_max !integer *4: Maximum number of fftws to call simultaneously within the fftw_plan_many. 
      integer *4 n_omp_sub__in !integer *4: number of omp sub-blocks (e.g., number of available processors). ;
      integer *4 n_S_0_sub__in !integer *4: number of requested sub-blocks at level-0 for n_S_sample (used for O_S_q__, T_S_q__, Z_S_q__). ;
      integer *4 n_S_1_sub__in !integer *4: number of requested sub-blocks at level-1 for n_S_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
      integer *4 n_M_0_sub__in !integer *4: number of requested sub-blocks at level-0 for n_M_sample (used for O_T_R_CTF_M_q__, T_T_R_CTF_M_q__, Z_T_R_CTF_M_q__). ;
      integer *4 n_M_1_sub__in !integer *4: number of requested sub-blocks at level-1 for n_M_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
      real *8 d_memory_limit !real *8: upper limit on the memory allowed by test_innerproduct_8. ;
      logical flag_continue,flag_proceed
      integer *4 nS_0_sub_tmp,nS_1_sub_tmp,nM_0_sub_tmp,nM_1_sub_tmp
      integer *4 n_S_0_sub_max,n_S_1_sub_max,n_M_0_sub_max,n_M_1_sub_max
      complex *16, allocatable :: C_M_(:) !temporary: complex *16 array (length at least n_M_sample): actual l2-norm (out to frequency n_k_cur) for each sampled image. Note that we expect C_M_(nm) to apply to image M_k_p__(I_M_sample_(nm)*ld_M). Note also that C_M_(nm) is a raw l2-norm, with no consideration for the CTF. ;
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
c$$$  Other variables used to generate templates and perform lsq-solve. ;
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
      integer n_w_csum_(0:n_k_cur-1) ! cumulative sum of n_w_. also called icstart(nk). ;
      integer quadrature_type_azimu_b ! quadrature type in the azimuthal direction. sometimes named itypep. ;
      integer n_w_(0:n_k_cur-1) ! ngridc(nk) is the number of points on the ring of radius grid_k_p_(nk) for a template or image in k-space polar coordinates. also called ngridc(nk). ;
      integer n_k_low ! lowest value of nk (k-index in k-space polar coordinates) to use when building models. Note that this runs from 1 to n_k_p_max. ;
      integer n_Y_lm_sum ! total number of basis functions used in spherical harmonic expansion (in k-space polar coordinates). sometimes called nsphstore. ;
      integer n_Y_lm_csum_(0:n_k_cur-1) ! cumulative sum of n_Y_lm_. also called isph_start(nk). ;
      integer n_Y_l_(0:n_k_cur-1) ! order of spherical harmonic expansion on sphere at radius grid_k_p_(nk). also called nterms_sph(nk). ;
      real *8 lsq_oversample ! least-squares-solver oversampling parameter. sometimes called oversamp. ;
      integer lsq_interpolation_order ! least-squares-solver interpolation order. sometimes named kord. ;
      real *8 eps_default ! tolerance epsilon, typically 1e-6. used in many places (e.g., least-squares-solver). ;
      complex *16 Y_est_(0:n_Y_lm_sum-1) ! spherical harmonic coefficients obtained using estimated-angles to reconstruct molecule. sometimes called modsph_est. ;
      integer n_azimu_b_polar_a_sum_(0:n_k_cur-1) ! total number of points on sphere at radius grid_k_p_(nk). also called numonsphere(nk). ;
      integer n_S_sample_max    ! maximum number of templates to consider (if quadrature_type_azimu_b==1, these will be distributed uniformly across the sphere). ;
      logical flag_fig  ! flag determining whether or not to dump output file. ;
      character(len=1024) dname ! directory name to dump output (if flag_fig is set). ;
      real *8 timing_rebuild_est ! time to rebuild Y_est_. ;
      real *8 timing_template_create ! time to create templates. ;
      real *8 timing_innerproduct ! time to calculate innerproducts. ;
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
c$$$  Other temporary variables. ;
c$$$  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% ;
      logical flag_memory_checkset !temporary: used to check memory. ;
      integer nk !temporary: index for grid_k_p_(nk). ;
      real *8 tesselation_distance_req_use !temporary: actual value of tesselation_distance_req passed to test_innerproduct_fast_wrapper_1. ;
      integer n_azimu_b_polar_a_sum_cur !temporary: n_azimu_b_polar_a_sum_(n_k_cur-1). sometimes called numonsphere_cur. ;
      integer n_k_p_lowerbound ! lower bound on the number of k-values (in k-space polar coordintes). sometimes named ntmax. ;      
      real *8, allocatable :: grid_cos_polar_a_tmp_(:) !temporary: values for cos(polar_a) associated with n_polar_a_(nk) in k-space polar coordinates for a particular grid_k_p_(nk). sometimes called xnodesth(nk). ;
      real *8, allocatable :: grid_sin_polar_a_tmp_(:) !temporary: values for sin(polar_a) associated with n_polar_a_(nk) in k-space polar coordinates for a particular grid_k_p_(nk). sometimes called sthetas(nk). ;
      real *8, allocatable :: weight_cos_polar_a_tmp_(:) !temporary: weight associated with grid_cos_polar_a_(nk) in k-space polar coordinates for a particular grid_k_p_(nk). sometimes called wtsth_(np). ;
      integer, allocatable :: n_azimu_b_tmp_(:) !temporary: number of nodes in azimu_b for each polar_a in k-space polar coordinates for a particular grid_k_p_(nk). also called ngridps(np). ;
      real *8, allocatable :: azimu_b_step_tmp_(:) !temporary: grid-spacing for azimu_b. ;
      integer n_azimu_b_polar_a_sum_tmp !temporary: total number of points on sphere at a particular radius grid_k_p_(nk) in k-space polar coordinates. sometimes called nspherebig_tmp. ;
      integer nM_sample,nm !temporary: values used to track number of sampled images. ;
      integer npolar_a,nazimu_b,nA !temporary indices for polar_a, azimu_b and azimu_b_polar_a. ;
      real *8 cos_polar_a !temporary: cos(polar angle). ;
      real *8 sin_polar_a !temporary: sin(polar angle). ;
      real *8 azimu_b !temporary: azimuthal angle. sometimes called phi. ;
      real *8 azimu_b_step !temporary: grid spacing for azimuthal angle. sometimes called phistep. ;
      integer nS_sample,ns !temporary: values used to track number of sampled templates. ;
      real *8, allocatable :: S_alpha_S_index_all_(:) !temporary: array of S_index associated with templates (used for updating image parameters). ;
      real *8, allocatable :: S_alpha_polar_a_all_(:) !temporary: array of polar_a associated with templates (used for updating image parameters). ;
      real *8, allocatable :: S_alpha_azimu_b_all_(:) !temporary: array of azimu_b associated with templates (used for updating image parameters). ;
      integer *4 n_delta_x,n_delta_y !temporary: used to determine displacements delta_x_ and delta_y_. ;
      real *8 timing_tic,timing_toc !temporary: timing variables. ;
      character(len=1024) tmp_fname,format_string,prefix_string !temporary: strings. ;
      real *8 pi
      pi=4.0d0*atan(1.0d0)
      
      if (verbose.gt.0) write(6,'(A)')
     $     '[entering test_alpha_update_6]'
      if (verbose.gt.1) then
         write(6,'(A,I0)') ' verbose ' , verbose ! verbosity level. ;
         write(6,'(A,I0)') ' rseed ' , rseed !integer *4: random seed (used for any random permutations). ;
         write(6,'(A,I0)') ' n_k_cur ' , n_k_cur !integer *4: current index for current maximum value of n_k. Note that this runs from 1 to n_k_p_max. ;
         call print_sub_i4(n_k_cur,n_polar_a_,' n_polar_a_: ') !integer *4 array (length at least n_k_cur): number of polar_a values on sphere of radius grid_k_p_(nk). also called nlats(nk). ;
         call print_sub_i4(n_k_cur,grid_k_p_,' grid_k_p_: ') !real *8 array (length at least n_k_cur): values for k on successive shells for k-space polar coordinates. sometimes called grid_p_ or xnodesr. ;
         write(6,'(A,F8.4)') ' half_diameter_x_c ' , half_diameter_x_c !real *8: half diameter of particle support in x-space cartesian coordinates. sometimes called a. ;
         write(6,'(A,I0)') ' ld_S ' , ld_S !integer *4: leading dimension of S_k_p__. Must be at least n_A. ;
         write(6,'(A,F8.4)') ' tesselation_distance_req ' ,
     $        tesselation_distance_req !real *8: !determines whether or not to adaptively sample templates. if tesselation_distance_req.ge.2.0d0, then all templates will be compared to all images. However, if tesselation_distance_req.lt.2.0d0, then only a few templates will be considered for each image. Roughly speaking, the value of tesselation_distance_req determines the neighborhood of viewing angles around each image which will be searched (in terms of distance on the sphere). When adaptively sampling templates, we might allow this value to shrink with the total number of templates (e.g., to ensure that the number of templates considered per image remains roughly constant). ;
         write(6,'(A,I0)') ' n_LT_add ' , n_LT_add ! number of templates to add (randomly) after considering local neighborhood in local search. ;
         write(6,'(A,I0)') ' n_LT_ref ' , n_LT_ref ! number of image-template pairs to consider when refining local search.
         write(6,'(A,I0)') ' n_M_sample ' , n_M_sample !integer *4: total number of sampled images (i.e., length of I_M_sample_). sometimes called nimages. ;
         call print_sub_i4(n_M_sample,I_M_sample_,' I_M_sample_: ') !integer *4 array (length at least n_M_sample): indexing variable used to reference images. Only images M_k_p__(I_M_sample_(nm)*ld_M) will be accessed. ;
         write(6,'(A,I0)') ' ld_M ' , ld_M !integer *4: leading dimension of M_k_p__. Must be at least n_A. ;
         call print_sub_c16(ld_M*I_M_sample_(n_M_sample-1),M_k_p__,
     $        ' M_k_p__: ') !complex *16 array (length at least ld_M*max_i4_f_(I_M_sample_)): stack of images. sometimes called Y_slice__ associated with reconstructed molecule. 
         write(6,'(A,I0)') ' n_CTF ' , n_CTF !integer *4: total number of CTF functions. ;
         write(6,'(A,I0)') ' ld_CTF ' , ld_CTF !integer *4: leading dimension of CTF_k_p__. Must be at least n_A. ;
         call print_sub_c16(ld_CTF*n_CTF,CTF_k_p__,' CTF_k_p__: ') !complex *16 array (length at least ld_CTF*n_ctf): stack of CTF functions. ;
         call print_sub_r8(n_alpha*n_M_sample,alpha_est__
     $        ,' alpha_est__: ') !real *8 array (length at least n_alpha*n_M_sample): ! estimated image parameters associated with sampled image set stored in 1-dimensional array. Note that we expect alpha_est__(n_alpha*nm) to apply to image M_k_p__(I_M_sample_(nm)*ld_M). ;
         write(6,'(A,F8.4)') ' alpha_update_f ' , alpha_update_f !real *8: fraction of 'best' templates to select from when updating image-parameters for any particular image (used when flag_MS_vs_SM.eqv..false.). Also interpreted as the fraction of 'best' images to select from when updating image-parameters when flag_MS_vs_SM.eqv..true. ;
         write(6,'(A,L2)') ' flag_MS_vs_SM ' , flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
         write(6,'(A,I0)') ' n_SM_max ' , n_SM_max !integer *4: maximum number of templates-per-image whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
         write(6,'(A,I0)') ' n_MS_max ' , n_MS_max !integer *4: maximum number of images-per-template whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
         write(6,'(A,F8.4)') ' n_pixels_in ' , n_pixels_in !real *8: if displacements are considered, this value determines the number of pixels (in each direction) to be considered. The number of pixels is related to the x-space cartesian coordinates by the maximum wavelength 'n_k_cur' under consideration (which can change from iteration to iteration). ;
         write(6,'(A,F8.4)') ' displacement_max ' , displacement_max !real *8: if displacements are considered, this value determines the maximum displacement (in x-space cartesian coordinates) allowed when assigning parameters to each image. This parameter can be set to mitigate the 'runaway' phenomenon that can occur as the displacements for each image are updated iteratively. ;
         write(6,'(A,I0)') ' n_delta_v ' , n_delta_v !integer *4: if displacements are considered, this value determines the number of displacements considered (in x-space cartesian coordinates). ;
         write(6,'(A,I0)') ' n_gamma_z ' , n_gamma_z !integer *4: determines the number of in-plane rotations gamma_z to consider for each image-template pair. ; 
         write(6,'(A,I0)') ' svd_calculation_type ' ,
     $        svd_calculation_type !integer *4: integer determining how innerproducts are computed across rotations and translations. ;
c$$$  svd_calculation_type == 1 --> encode displacements using svd, then account for in-plane rotations using the fft, then multiply to access displacements. ;
c$$$  svd_calculation_type == 2 --> account for displacements via brute-force. ;
         write(6,'(A,F8.6)') ' eps_svd ' , eps_svd !real *8: svd tolerance epsilon, typically 0.1d0, 0.01d0 or 0.001d0. ;
         write(6,'(A,l2)') ' flag_RTRT_vs_RTTR ' , flag_RTRT_vs_RTTR !logical: determines whether to compute <R_{+upd}(T_{+upd}(Z)),T_{-est}(R_{-est}(CTF.*M))> (if .true.) or <Z,R_{-upd}(T_{-upd}(T_{-est}(R_{-est}(CTF.*M))))> (if .false.). ;
         write(6,'(A,I0)') ' fpm_howmany_max ' , fpm_howmany_max !integer *4: Maximum number of fftws to call simultaneously within the fftw_plan_many. 
         write(6,'(A,I0)') ' n_omp_sub__in ' , n_omp_sub__in !integer *4: number of omp sub-blocks (e.g., number of available processors). ;
         write(6,'(A,I0)') ' n_S_0_sub__in ' , n_S_0_sub__in !integer *4: number of requested sub-blocks at level-0 for n_S_sample (used for O_S_q__, T_S_q__, Z_S_q__). ;
         write(6,'(A,I0)') ' n_S_1_sub__in ' , n_S_1_sub__in !integer *4: number of requested sub-blocks at level-1 for n_S_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
         write(6,'(A,I0)') ' n_M_0_sub__in ' , n_M_0_sub__in !integer *4: number of requested sub-blocks at level-0 for n_M_sample (used for O_T_R_CTF_M_q__, T_T_R_CTF_M_q__, Z_T_R_CTF_M_q__). ;
         write(6,'(A,I0)') ' n_M_1_sub__in ' , n_M_1_sub__in !integer *4: number of requested sub-blocks at level-1 for n_M_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
         call print_sub_i4(n_k_cur,n_w_csum_,' n_w_csum_: ') ! cumulative sum of n_w_. also called icstart(nk). ;
         write(6,'(A,I0)') ' quadrature_type_azimu_b ' ,
     $        quadrature_type_azimu_b ! quadrature type in the azimuthal direction. sometimes named itypep. ;
         call print_sub_i4(n_k_cur,n_w_,' n_w_: ') ! ngridc(nk) is the number of points on the ring of radius grid_k_p_(nk) for a template or image in k-space polar coordinates. also called ngridc(nk). ;
         write(6,'(A,I0)') ' n_k_low ' , n_k_low ! lowest value of nk (k-index in k-space polar coordinates) to use when building models. Note that this runs from 1 to n_k_p_max. ;
         write(6,'(A,I0)') ' n_k_cur ' , n_k_cur ! current value of nk (k-index in k-space polar coordinates) to use when reconstructing mole
         write(6,'(A,I0)') ' n_Y_lm_sum ' , n_Y_lm_sum ! total number of basis functions used in spherical harmonic expansion (in k-space polar coordinates). sometimes called nsphstore. ;
         call print_sub_i4(n_k_cur,n_Y_lm_csum_,' n_Y_lm_csum_: ') ! cumulative sum of n_Y_lm_. also called isph_start(nk). ;
         call print_sub_i4(n_k_cur,n_Y_l_,' n_Y_l_: ') ! order of spherical harmonic expansion on sphere at radius grid_k_p_(nk). also called nterms_sph(nk). ;
         write(6,'(A,F8.4)') ' lsq_oversample ' , lsq_oversample ! least-squares-solver oversampling parameter. sometimes called oversamp. ;
         write(6,'(A,I0)') ' lsq_interpolation_order ' ,
     $        lsq_interpolation_order ! least-squares-solver interpolation order. sometimes named kord. ;
         write(6,'(A,F8.6)') ' eps_default ' , eps_default ! tolerance epsilon, typically 1e-6. used in many places (e.g., least-squares-solver). ;
         call print_sub_i4(n_k_cur,n_azimu_b_polar_a_sum_,
     $        ' n_azimu_b_polar_a_sum_: ') ! total number of points on sphere at radius grid_k_p_(nk). also called numonsphere(nk). ;
         write(6,'(A,I0)') ' n_S_sample_max ' , n_S_sample_max ! maximum number of templates to consider (if quadrature_type_azimu_b==1, these will be distributed uniformly across the sphere). ;
         write(6,'(A,L2)') ' flag_fig ' , flag_fig ! flag determining whether or not to dump output file. ;
         write(6,'(A,A)') ' dname ' , trim(dname) ! directory name to dump output (if flag_fig is set). ;
      end if                    !if (verbose.gt.1) then

      n_k_p_lowerbound=4*n_k_cur ! lower bound on the number of k-values (in k-space polar coordintes). sometimes named ntmax. ;      
      n_azimu_b_polar_a_sum_cur = n_azimu_b_polar_a_sum_(n_k_cur-1)
      allocate(C_M_(0:1+n_M_sample-1))
      call cs1_c16(n_M_sample,C_M_)
      allocate(S_alpha_S_index_all_(0:1+n_azimu_b_polar_a_sum_cur-1))
      call cs1_r8(n_azimu_b_polar_a_sum_cur,S_alpha_S_index_all_)
      allocate(S_alpha_polar_a_all_(0:1+n_azimu_b_polar_a_sum_cur-1))
      call cs1_r8(n_azimu_b_polar_a_sum_cur,S_alpha_polar_a_all_)
      allocate(S_alpha_azimu_b_all_(0:1+n_azimu_b_polar_a_sum_cur-1))
      call cs1_r8(n_azimu_b_polar_a_sum_cur,S_alpha_azimu_b_all_)
      allocate(grid_cos_polar_a_tmp_(0:1+n_k_p_lowerbound-1))
      call cs1_r8(n_k_p_lowerbound,grid_cos_polar_a_tmp_)
      allocate(grid_sin_polar_a_tmp_(0:1+n_k_p_lowerbound-1))
      call cs1_r8(n_k_p_lowerbound,grid_sin_polar_a_tmp_)
      allocate(weight_cos_polar_a_tmp_(0:1+n_k_p_lowerbound-1))
      call cs1_r8(n_k_p_lowerbound,weight_cos_polar_a_tmp_)
      allocate(azimu_b_step_tmp_(0:1+n_k_p_lowerbound-1))
      call cs1_r8(n_k_p_lowerbound,azimu_b_step_tmp_)
      allocate(n_azimu_b_tmp_(0:1+n_k_p_lowerbound-1))
      call cs1_i4(n_k_p_lowerbound,n_azimu_b_tmp_)

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  First find Y_est_
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      if (verbose.gt.0) write(6,*) 'rebuilding Y_est_'
      timing_tic = omp_get_wtime()
      call rebuild_model_2(n_M_sample,I_M_sample_,ld_M,M_k_p__,n_ctf
     $     ,ld_CTF,CTF_k_p__,alpha_est__ ,n_w_csum_ ,n_polar_a_
     $     ,quadrature_type_azimu_b,grid_k_p_,n_w_,n_k_low,n_k_cur
     $     ,n_Y_lm_csum_,n_Y_l_ ,lsq_oversample ,lsq_interpolation_order
     $     ,eps_default ,Y_est_)
      timing_toc = omp_get_wtime()
      timing_rebuild_est = timing_toc-timing_tic
      if (verbose.gt.0) then
         write(6,'(A,A,F8.3)') 'rebuild_model_2 (est):'
     $        ,' total_time ',timing_toc-timing_tic
      end if

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  generate templates based on current model (using Y_est_)
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      n_azimu_b_polar_a_sum_cur = n_azimu_b_polar_a_sum_(n_k_cur-1)
      if (verbose.gt.0) write(6,'(A,I0,A)')
     $     'generating n_azimu_b_polar_a_sum_cur = '
     $     ,n_azimu_b_polar_a_sum_cur ,' templates'
      timing_tic = omp_get_wtime()
      call cl1_c16(ld_S*n_azimu_b_polar_a_sum_cur,S_k_p__)
      call template_gen(Y_est_,n_Y_lm_sum,n_Y_lm_csum_, n_Y_l_
     $     ,n_k_cur,n_w_,ld_S,n_w_csum_, n_polar_a_
     $     ,quadrature_type_azimu_b,n_k_cur
     $     ,n_azimu_b_polar_a_sum_cur ,S_k_p__)
      timing_toc = omp_get_wtime()
      timing_template_create = timing_toc-timing_tic
      if (verbose.gt.0) then
         write(6,'(A,A,F8.3)') 'template_gen:' ,' total_time '
     $        ,timing_toc-timing_tic
      end if

      call getspheregrid(n_polar_a_(n_k_cur-1)
     $     ,quadrature_type_azimu_b,grid_cos_polar_a_tmp_,
     $     grid_sin_polar_a_tmp_,weight_cos_polar_a_tmp_
     $     ,n_azimu_b_tmp_,azimu_b_step_tmp_
     $     ,n_azimu_b_polar_a_sum_tmp)
      if (n_azimu_b_polar_a_sum_tmp.ne.n_azimu_b_polar_a_sum_cur)
     $     then
         write(6,'(A,I0,A,I0)') 'Warning, n_azimu_b_polar_a_sum '
     $        ,n_azimu_b_polar_a_sum_tmp,'.ne.'
     $        ,n_azimu_b_polar_a_sum_(n_k_cur-1)
      end if
      nA = 0
      do npolar_a = 0,n_polar_a_(n_k_cur-1)-1
         cos_polar_a = grid_cos_polar_a_tmp_(npolar_a)
         sin_polar_a = grid_sin_polar_a_tmp_(npolar_a)
         azimu_b_step = azimu_b_step_tmp_(npolar_a)
         do nazimu_b = 0,n_azimu_b_tmp_(npolar_a)-1
            azimu_b = nazimu_b*azimu_b_step
            S_alpha_S_index_all_(nA) = nA
            S_alpha_polar_a_all_(nA) = dacos(cos_polar_a)
            S_alpha_azimu_b_all_(nA) = azimu_b
            nA = nA+1
         enddo
      enddo
      n_azimu_b_polar_a_sum_tmp = nA
      if (verbose.gt.1) write(6,*) '  n_azimu_b_polar_a_sum is '
     $     ,n_azimu_b_polar_a_sum_tmp
      if (n_azimu_b_polar_a_sum_tmp.ne.n_azimu_b_polar_a_sum_cur)
     $     then
         write(6,'(A,I0,A,I0)') 'Warning, n_azimu_b_polar_a_sum '
     $        ,n_azimu_b_polar_a_sum_tmp,'.ne.'
     $        ,n_azimu_b_polar_a_sum_(n_k_cur-1)
      end if

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  Choose number of templates to use 
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      n_S_sample = min(n_azimu_b_polar_a_sum_cur,n_S_sample_max)
      if (verbose.gt.0) write(6,'(A,I0,A)') 'selecting ',n_S_sample
     $     ,' templates'
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  Allocate memory appropriately
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      allocate(I_S_sample_(0:1+n_S_sample-1))
      call cs1_i4(n_S_sample,I_S_sample_)
      allocate(S_alpha_S_index_sample_(0:1+n_S_sample-1))
      call cs1_r8(n_S_sample,S_alpha_S_index_sample_)
      allocate(S_alpha_polar_a_sample_(0:1+n_S_sample-1))
      call cs1_r8(n_S_sample,S_alpha_polar_a_sample_)
      allocate(S_alpha_azimu_b_sample_(0:1+n_S_sample-1))
      call cs1_r8(n_S_sample,S_alpha_azimu_b_sample_)
      n_delta_x = ceiling(dsqrt(n_delta_v*2.0d0/pi))
      n_delta_y = ceiling(dsqrt(n_delta_v*2.0d0/pi))
      n_delta_v_use = 1 + ceiling(1.5d0 * pi/2.0d0 * n_delta_x
     $     *n_delta_y)
      if (verbose.gt.0) then
         write(6,'(A,I0)') ' n_delta_v_use ' , n_delta_v_use
      end if !if (verbose.gt.0) then
      allocate(delta_x_(0:1+n_delta_v_use-1))
      call cs1_r8(n_delta_v_use,delta_x_)
      allocate(delta_y_(0:1+n_delta_v_use-1))
      call cs1_r8(n_delta_v_use,delta_y_)
      if (flag_MS_vs_SM.eqv..false.) then
         allocate(n_SM_(0:1+n_M_sample-1))
         call cs1_i4(n_M_sample,n_SM_)
         allocate(alpha_SM__(0:1+n_alpha*n_SM_max*n_M_sample-1))
         call cs1_r8(n_alpha*n_SM_max*n_M_sample,alpha_SM__)
      end if !if (flag_MS_vs_SM.eqv..false.) then
      if (flag_MS_vs_SM.eqv..true.) then
         allocate(n_MS_(0:1+n_S_sample-1))
         call cs1_i4(n_S_sample,n_MS_)
         allocate(alpha_MS__(0:1+n_alpha*n_MS_max*n_S_sample-1))
         call cs1_r8(n_alpha*n_MS_max*n_S_sample,alpha_MS__)
      end if !if (flag_MS_vs_SM.eqv..true.) then

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  calling checkset. ;
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      include 'test_alpha_update_6_checkset.f'

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  Extracting sample templates
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      do nS_sample=0,n_S_sample-1
         if (n_S_sample.lt.n_azimu_b_polar_a_sum_cur) then
            I_S_sample_(nS_sample) = min(n_azimu_b_polar_a_sum_cur-1
     $           ,floor(n_azimu_b_polar_a_sum_cur*1.0d0*nS_sample
     $           /(n_S_sample -1)))
         else
            I_S_sample_(nS_sample) = nS_sample
         end if
         ns = I_S_sample_(nS_sample)
         S_alpha_S_index_sample_(nS_sample) =
     $        S_alpha_S_index_all_(ns)
         S_alpha_polar_a_sample_(nS_sample) =
     $        S_alpha_polar_a_all_(ns)
         S_alpha_azimu_b_sample_(nS_sample) =
     $        S_alpha_azimu_b_all_(ns)
      enddo

      include 'test_alpha_update_6_checkset.f'

      call get_delta_1(n_pixels_in,n_k_cur,half_diameter_x_c
     $     ,n_delta_x,n_delta_y,n_delta_v,delta_x_,delta_y_)
      if (verbose.gt.0) then
         call print_sub_r8(n_delta_v,delta_x_,'delta_x_')
         call print_sub_r8(n_delta_v,delta_y_,'delta_y_')
      end if !if (verbose.gt.0) then

      include 'test_alpha_update_6_checkset.f'

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  calculate innerproducts
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      if (verbose.gt.0) write(6,'(A,I0,A,I0,A,I0,A,I0)') 'get (n_M = '
     $     ,n_M_sample,')-x-(n_S_sample = ',n_S_sample, ') = (',
     $     n_M_sample *n_S_sample,') innerproducts of length ' ,
     $     n_w_csum_(n_k_cur -1) + n_w_(n_k_cur-1)
      timing_tic = omp_get_wtime()
      tesselation_distance_req_use = tesselation_distance_req
      if (verbose.gt.1) then
         write(6,'(A)') ' Estimating memory requirements: '
      end if !if (verbose.gt.1) then
      n_S_0_sub_max = ceiling(dsqrt(1.0d0*n_S_sample))
      n_S_1_sub_max = ceiling(dsqrt(1.0d0*n_S_sample))
      n_M_0_sub_max = ceiling(dsqrt(1.0d0*n_M_sample))
      n_M_1_sub_max = ceiling(dsqrt(1.0d0*n_M_sample))
      nS_0_sub_tmp = 1
      nS_1_sub_tmp = 1
      nM_0_sub_tmp = 1
      nM_1_sub_tmp = 1
      flag_continue = .true.
      flag_proceed = .true.
      do while (flag_continue.eqv..true.)
         flag_memory_estimate = .true.
         d_memory_estimate = 0.0d0
         if (verbose.gt.1) write(6,'(A)') ' Testing memory: '
         include 'test_alpha_update_6_checkset.f'
      call test_innerproduct_8(
     $     verbose-2 !integer *4: verbosity level. ;
     $     ,flag_memory_estimate !logical: if set to .true. will only estimate total memory requirements. ;
     $     ,d_memory_estimate !real *8: estimate of required memory (in bytes). ;
     $     ,rseed !integer *4: random seed (used for any random permutations). ;
     $     ,n_k_cur !integer *4: current index for current maximum value of n_k. Note that this runs from 1 to n_k_p_max. ;
     $     ,n_polar_a_ !integer *4 array (length at least n_k_cur): number of polar_a values on sphere of radius grid_k_p_(nk). also called nlats(nk). ;
     $     ,grid_k_p_ !real *8 array (length at least n_k_cur): values for k on successive shells for k-space polar coordinates. sometimes called grid_p_ or xnodesr. ;
     $     ,half_diameter_x_c !real *8: half diameter of particle support in x-space cartesian coordinates. sometimes called a. ;
     $     ,n_S_sample !integer *4: total number of sampled templates (i.e., length of I_S_sample_). sometimes called ntemplates. ;
     $     ,I_S_sample_ !integer *4 array (length at least n_S_sample): indexing variable used to reference templates. Only templates S_k_p__(I_S_sample_(ns)*ld_S) will be accessed. ;
     $     ,ld_S !integer *4: leading dimension of S_k_p__. Must be at least n_A. ;
     $     ,S_k_p__ !complex *16 array (length at least ld_S*max_i4_f_(I_S_sample_)): stack of templates associated with reconstructed molecule. sometimes called Y_slice__ or cslices or templates. ;
     $     ,tesselation_distance_req_use !real *8: !determines whether or not to adaptively sample templates. if tesselation_distance_req.ge.2.0d0, then all templates will be compared to all images. However, if tesselation_distance_req.lt.2.0d0, then only a few templates will be considered for each image. Roughly speaking, the value of tesselation_distance_req determines the neighborhood of viewing angles around each image which will be searched (in terms of distance on the sphere). When adaptively sampling templates, we might allow this value to shrink with the total number of templates (e.g., to ensure that the number of templates considered per image remains roughly constant). ;
     $     ,n_LT_add ! number of templates to add (randomly) after considering local neighborhood in local search. ;
     $     ,n_LT_ref ! number of image-template pairs to consider when refining local search.
     $     ,S_alpha_S_index_sample_ !real *8 array (length at least n_S_sample): array of S_index associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_S_index_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
     $     ,S_alpha_polar_a_sample_ !real *8 array (length at least n_S_sample): array of polar_a associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_polar_a_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
     $     ,S_alpha_azimu_b_sample_ !real *8 array (length at least n_S_sample): array of azimu_b associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_azimu_b_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
     $     ,n_M_sample !integer *4: total number of sampled images (i.e., length of I_M_sample_). sometimes called nimages. ;
     $     ,I_M_sample_ !integer *4 array (length at least n_M_sample): indexing variable used to reference images. Only images M_k_p__(I_M_sample_(nm)*ld_M) will be accessed. ;
     $     ,ld_M !integer *4: leading dimension of M_k_p__. Must be at least n_A. ;
     $     ,M_k_p__ !complex *16 array (length at least ld_M*max_i4_f_(I_M_sample_)): stack of images. sometimes called Y_slice__ associated with reconstructed molecule. 
     $     ,n_CTF !integer *4: total number of CTF functions. ;
     $     ,ld_CTF !integer *4: leading dimension of CTF_k_p__. Must be at least n_A. ;
     $     ,CTF_k_p__ !complex *16 array (length at least ld_CTF*n_ctf): stack of CTF functions. ;
     $     ,alpha_est__ !real *8 array (length at least n_alpha*n_M_sample): ! estimated image parameters associated with sampled image set stored in 1-dimensional array. Note that we expect alpha_est__(n_alpha*nm) to apply to image M_k_p__(I_M_sample_(nm)*ld_M). ;
     $     ,alpha_update_f !real *8: fraction of 'best' templates to select from when updating image-parameters for any particular image (used when flag_MS_vs_SM.eqv..false.). Also interpreted as the fraction of 'best' images to select from when updating image-parameters when flag_MS_vs_SM.eqv..true. ;
     $     ,flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
     $     ,n_SM_max !integer *4: maximum number of templates-per-image whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
     $     ,n_SM_ !integer *4 array (length at least n_M_sample): actual number of templates whose innerproduct-information is stored for a particular image. Note that n_SM_(nm) indicates the number of templates whose information is stored for the image M_k_p__(I_M_sample_(nm)). ;
     $     ,alpha_SM__ !real *8 array (length at least n_alpha*n_SM_max*n_M_sample): actual innerproduct-information stored for various template-image pairs. Note that alpha_SM__((ns + nm*n_SM_max)*n_alpha) (with ns.lt.n_SM_(nm)) stores the innerproduct-information for the image M_k_p__(I_M_sample_(nm)) and the ns-th template whose information is stored for that particular image. ;
     $     ,n_MS_max !integer *4: maximum number of images-per-template whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
     $     ,n_MS_ !integer *4 array (length at least n_S_sample): actual number of images whose innerproduct-information is stored for a particular template. Note that n_MS_(ns) indicates the number of images whose information is stored for the template S_k_p__(I_S_sample_(ns)). ;
     $     ,alpha_MS__ !real *8 array (length at least n_alpha*n_MS_max*n_S_sample): actual innerproduct-information stored for various image-template pairs. Note that alpha_MS__((nm + ns*n_MS_max)*n_alpha) (with nm.lt.n_MS_(ns)) stores the innerproduct-information for the template S_k_p__(I_S_sample_(ns)) and the nm-th image whose information is stored for that particular template. ;
     $     ,n_pixels_in !real *8: if displacements are considered, this value determines the number of pixels (in each direction) to be considered. The number of pixels is related to the x-space cartesian coordinates by the maximum wavelength 'n_k_cur' under consideration (which can change from iteration to iteration). ;
     $     ,displacement_max !real *8: if displacements are considered, this value determines the maximum displacement (in x-space cartesian coordinates) allowed when assigning parameters to each image. This parameter can be set to mitigate the 'runaway' phenomenon that can occur as the displacements for each image are updated iteratively. ;
     $     ,n_delta_v !integer *4: if displacements are considered, this value determines the number of displacements considered (in x-space cartesian coordinates). ;
     $     ,delta_x_ !real *8 array: (length at least n_delta_v): x-coordinates of displacements. ;
     $     ,delta_y_ !real *8 array: (length at least n_delta_v): y-coordinates of displacements. ;
     $     ,n_gamma_z !integer *4: determines the number of in-plane rotations gamma_z to consider for each image-template pair. ; 
     $     ,svd_calculation_type !integer *4: integer determining how innerproducts are computed across rotations and translations. ;
c$$$      svd_calculation_type == 1 --> encode displacements using svd, then account for in-plane rotations using the fft, then multiply to access displacements. ;
c$$$      svd_calculation_type == 2 --> account for displacements via brute-force. ;
     $     ,eps_svd !real *8: svd tolerance epsilon, typically 0.1d0, 0.01d0 or 0.001d0. ;
     $     ,flag_RTRT_vs_RTTR !logical: determines whether to compute <R_{+upd}(T_{+upd}(Z)),T_{-est}(R_{-est}(CTF.*M))> (if .true.) or <Z,R_{-upd}(T_{-upd}(T_{-est}(R_{-est}(CTF.*M))))> (if .false.). ;
     $     ,fpm_howmany_max !integer *4: Maximum number of fftws to call simultaneously within the fftw_plan_many. 
     $     ,n_omp_sub__in !integer *4: number of omp sub-blocks (e.g., number of available processors). ;
     $     ,nS_0_sub_tmp !integer *4: number of requested sub-blocks at level-0 for n_S_sample (used for O_S_q__, T_S_q__, Z_S_q__). ;
     $     ,nS_1_sub_tmp !integer *4: number of requested sub-blocks at level-1 for n_S_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
     $     ,nM_0_sub_tmp !integer *4: number of requested sub-blocks at level-0 for n_M_sample (used for O_T_R_CTF_M_q__, T_T_R_CTF_M_q__, Z_T_R_CTF_M_q__). ;
     $     ,nM_1_sub_tmp !integer *4: number of requested sub-blocks at level-1 for n_M_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
     $     ,C_M_ !complex *16 array (length at least n_M_sample): actual l2-norm (out to frequency n_k_cur) for each sampled image. Note that we expect C_M_(nm) to apply to image M_k_p__(I_M_sample_(nm)*ld_M). Note also that C_M_(nm) is a raw l2-norm, with no consideration for the CTF. ;
     $     )
        if (d_memory_estimate.le.d_memory_limit) then
           if (verbose.gt.-1) then
              write(6,'(A,4(A,I0))') ' Memory limit not exceeded: '
     $             , ' nS_0_sub_tmp ' ,nS_0_sub_tmp , ' nS_1_sub_tmp ' ,
     $             nS_1_sub_tmp ,' nM_0_sub_tmp ' , nM_0_sub_tmp ,
     $             ' nM_1_sub_tmp' , nM_1_sub_tmp 
              write(6,'(A,2(I0,A))') ' d_memory estimate: ' ,
     $             nint(d_memory_estimate*1.0d-6) , ' (MB); ' , 
     $             nint(d_memory_estimate*1.0d-9) , ' (GB); ' 
           end if !if (verbose.gt.1) then
           flag_continue = .false.
           flag_proceed = .true.
        end if !if (d_memory_estimate.le.d_memory_limit) then
        if (d_memory_estimate.gt.d_memory_limit) then
           flag_continue = .true.
           if ((nS_0_sub_tmp.ge.n_S_0_sub_max) .and.
     $          (nS_1_sub_tmp.ge.n_S_1_sub_max) .and.
     $          (nM_0_sub_tmp.ge.n_M_0_sub_max) .and.
     $          (nM_1_sub_tmp.ge.n_M_1_sub_max)) then
              write(6,'(A,4(A,I0))') ' Warning, memory limit exceeded: '
     $             , ' nS_0_sub_tmp ' ,nS_0_sub_tmp , ' nS_1_sub_tmp ' ,
     $             nS_1_sub_tmp ,' nM_0_sub_tmp ' , nM_0_sub_tmp ,
     $             ' nM_1_sub_tmp' , nM_1_sub_tmp 
              write(6,'(A,2(I0,A))') ' d_memory estimate: ' ,
     $             nint(d_memory_estimate*1.0d-6) , ' (MB); ' , 
     $             nint(d_memory_estimate*1.0d-9) , ' (GB); ' 
              flag_continue = .false.
              flag_proceed = .false.
           else
              if (.false.) then
c$$$             do nothing. ;
              else if (nM_0_sub_tmp.lt.n_M_0_sub_max) then
                 nM_0_sub_tmp = nM_0_sub_tmp + 1
              else if (nM_1_sub_tmp.lt.n_M_1_sub_max) then
                 nM_1_sub_tmp = nM_1_sub_tmp + 1
              else if (nS_0_sub_tmp.lt.n_S_0_sub_max) then
                 nS_0_sub_tmp = nS_0_sub_tmp + 1
              else if (nS_1_sub_tmp.lt.n_S_1_sub_max) then
                 nS_1_sub_tmp = nS_1_sub_tmp + 1
              end if ! blocks small. ;
           end if ! blocks too big. ;
        end if !if (d_memory_estimate.le.d_memory_limit) then
      enddo !do while (flag_continue.eqv..true.)
      if (flag_proceed.eqv..true.) then
      flag_memory_estimate = .false.
      if (verbose.gt.1) write(6,'(A)') ' call test_innerproduct_8: '
      include 'test_alpha_update_6_checkset.f'
      call test_innerproduct_8(
     $     verbose !integer *4: verbosity level. ;
     $     ,flag_memory_estimate !logical: if set to .true. will only estimate total memory requirements. ;
     $     ,d_memory_estimate !real *8: estimate of required memory (in bytes). ;
     $     ,rseed !integer *4: random seed (used for any random permutations). ;
     $     ,n_k_cur !integer *4: current index for current maximum value of n_k. Note that this runs from 1 to n_k_p_max. ;
     $     ,n_polar_a_ !integer *4 array (length at least n_k_cur): number of polar_a values on sphere of radius grid_k_p_(nk). also called nlats(nk). ;
     $     ,grid_k_p_ !real *8 array (length at least n_k_cur): values for k on successive shells for k-space polar coordinates. sometimes called grid_p_ or xnodesr. ;
     $     ,half_diameter_x_c !real *8: half diameter of particle support in x-space cartesian coordinates. sometimes called a. ;
     $     ,n_S_sample !integer *4: total number of sampled templates (i.e., length of I_S_sample_). sometimes called ntemplates. ;
     $     ,I_S_sample_ !integer *4 array (length at least n_S_sample): indexing variable used to reference templates. Only templates S_k_p__(I_S_sample_(ns)*ld_S) will be accessed. ;
     $     ,ld_S !integer *4: leading dimension of S_k_p__. Must be at least n_A. ;
     $     ,S_k_p__ !complex *16 array (length at least ld_S*max_i4_f_(I_S_sample_)): stack of templates associated with reconstructed molecule. sometimes called Y_slice__ or cslices or templates. ;
     $     ,tesselation_distance_req_use !real *8: !determines whether or not to adaptively sample templates. if tesselation_distance_req.ge.2.0d0, then all templates will be compared to all images. However, if tesselation_distance_req.lt.2.0d0, then only a few templates will be considered for each image. Roughly speaking, the value of tesselation_distance_req determines the neighborhood of viewing angles around each image which will be searched (in terms of distance on the sphere). When adaptively sampling templates, we might allow this value to shrink with the total number of templates (e.g., to ensure that the number of templates considered per image remains roughly constant). ;
     $     ,n_LT_add ! number of templates to add (randomly) after considering local neighborhood in local search. ;
     $     ,n_LT_ref ! number of image-template pairs to consider when refining local search.
     $     ,S_alpha_S_index_sample_ !real *8 array (length at least n_S_sample): array of S_index associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_S_index_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
     $     ,S_alpha_polar_a_sample_ !real *8 array (length at least n_S_sample): array of polar_a associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_polar_a_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
     $     ,S_alpha_azimu_b_sample_ !real *8 array (length at least n_S_sample): array of azimu_b associated with templates indexed within I_S_sample_. ; (used for updating image parameters). Note that we expect S_alpha_azimu_b_(ns) to apply to template S_k_p__(I_S_sample_(ns)*ld_S). ;
     $     ,n_M_sample !integer *4: total number of sampled images (i.e., length of I_M_sample_). sometimes called nimages. ;
     $     ,I_M_sample_ !integer *4 array (length at least n_M_sample): indexing variable used to reference images. Only images M_k_p__(I_M_sample_(nm)*ld_M) will be accessed. ;
     $     ,ld_M !integer *4: leading dimension of M_k_p__. Must be at least n_A. ;
     $     ,M_k_p__ !complex *16 array (length at least ld_M*max_i4_f_(I_M_sample_)): stack of images. sometimes called Y_slice__ associated with reconstructed molecule. 
     $     ,n_CTF !integer *4: total number of CTF functions. ;
     $     ,ld_CTF !integer *4: leading dimension of CTF_k_p__. Must be at least n_A. ;
     $     ,CTF_k_p__ !complex *16 array (length at least ld_CTF*n_ctf): stack of CTF functions. ;
     $     ,alpha_est__ !real *8 array (length at least n_alpha*n_M_sample): ! estimated image parameters associated with sampled image set stored in 1-dimensional array. Note that we expect alpha_est__(n_alpha*nm) to apply to image M_k_p__(I_M_sample_(nm)*ld_M). ;
     $     ,alpha_update_f !real *8: fraction of 'best' templates to select from when updating image-parameters for any particular image (used when flag_MS_vs_SM.eqv..false.). Also interpreted as the fraction of 'best' images to select from when updating image-parameters when flag_MS_vs_SM.eqv..true. ;
     $     ,flag_MS_vs_SM !logical: determines whether to assign images to templates (.true.) or templates to images (.false.). ;
     $     ,n_SM_max !integer *4: maximum number of templates-per-image whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
     $     ,n_SM_ !integer *4 array (length at least n_M_sample): actual number of templates whose innerproduct-information is stored for a particular image. Note that n_SM_(nm) indicates the number of templates whose information is stored for the image M_k_p__(I_M_sample_(nm)). ;
     $     ,alpha_SM__ !real *8 array (length at least n_alpha*n_SM_max*n_M_sample): actual innerproduct-information stored for various template-image pairs. Note that alpha_SM__((ns + nm*n_SM_max)*n_alpha) (with ns.lt.n_SM_(nm)) stores the innerproduct-information for the image M_k_p__(I_M_sample_(nm)) and the ns-th template whose information is stored for that particular image. ;
     $     ,n_MS_max !integer *4: maximum number of images-per-template whose innerproduct-information will be stored when updating the image-parameters for a particular image. ;
     $     ,n_MS_ !integer *4 array (length at least n_S_sample): actual number of images whose innerproduct-information is stored for a particular template. Note that n_MS_(ns) indicates the number of images whose information is stored for the template S_k_p__(I_S_sample_(ns)). ;
     $     ,alpha_MS__ !real *8 array (length at least n_alpha*n_MS_max*n_S_sample): actual innerproduct-information stored for various image-template pairs. Note that alpha_MS__((nm + ns*n_MS_max)*n_alpha) (with nm.lt.n_MS_(ns)) stores the innerproduct-information for the template S_k_p__(I_S_sample_(ns)) and the nm-th image whose information is stored for that particular template. ;
     $     ,n_pixels_in !real *8: if displacements are considered, this value determines the number of pixels (in each direction) to be considered. The number of pixels is related to the x-space cartesian coordinates by the maximum wavelength 'n_k_cur' under consideration (which can change from iteration to iteration). ;
     $     ,displacement_max !real *8: if displacements are considered, this value determines the maximum displacement (in x-space cartesian coordinates) allowed when assigning parameters to each image. This parameter can be set to mitigate the 'runaway' phenomenon that can occur as the displacements for each image are updated iteratively. ;
     $     ,n_delta_v !integer *4: if displacements are considered, this value determines the number of displacements considered (in x-space cartesian coordinates). ;
     $     ,delta_x_ !real *8 array: (length at least n_delta_v): x-coordinates of displacements. ;
     $     ,delta_y_ !real *8 array: (length at least n_delta_v): y-coordinates of displacements. ;
     $     ,n_gamma_z !integer *4: determines the number of in-plane rotations gamma_z to consider for each image-template pair. ; 
     $     ,svd_calculation_type !integer *4: integer determining how innerproducts are computed across rotations and translations. ;
c$$$      svd_calculation_type == 1 --> encode displacements using svd, then account for in-plane rotations using the fft, then multiply to access displacements. ;
c$$$      svd_calculation_type == 2 --> account for displacements via brute-force. ;
     $     ,eps_svd !real *8: svd tolerance epsilon, typically 0.1d0, 0.01d0 or 0.001d0. ;
     $     ,flag_RTRT_vs_RTTR !logical: determines whether to compute <R_{+upd}(T_{+upd}(Z)),T_{-est}(R_{-est}(CTF.*M))> (if .true.) or <Z,R_{-upd}(T_{-upd}(T_{-est}(R_{-est}(CTF.*M))))> (if .false.). ;
     $     ,fpm_howmany_max !integer *4: Maximum number of fftws to call simultaneously within the fftw_plan_many. 
     $     ,n_omp_sub__in !integer *4: number of omp sub-blocks (e.g., number of available processors). ;
     $     ,nS_0_sub_tmp !integer *4: number of requested sub-blocks at level-0 for n_S_sample (used for O_S_q__, T_S_q__, Z_S_q__). ;
     $     ,nS_1_sub_tmp !integer *4: number of requested sub-blocks at level-1 for n_S_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
     $     ,nM_0_sub_tmp !integer *4: number of requested sub-blocks at level-0 for n_M_sample (used for O_T_R_CTF_M_q__, T_T_R_CTF_M_q__, Z_T_R_CTF_M_q__). ;
     $     ,nM_1_sub_tmp !integer *4: number of requested sub-blocks at level-1 for n_M_sample (used for S_T_T_R_CTF_M_q__, S_Z_T_R_CTF_M_q__). ;
     $     ,C_M_ !complex *16 array (length at least n_M_sample): actual l2-norm (out to frequency n_k_cur) for each sampled image. Note that we expect C_M_(nm) to apply to image M_k_p__(I_M_sample_(nm)*ld_M). Note also that C_M_(nm) is a raw l2-norm, with no consideration for the CTF. ;
     $     )
      timing_toc = omp_get_wtime()
      timing_innerproduct = timing_toc-timing_tic
      if ((verbose.gt.0) .and. (flag_memory_estimate.eqv..false.)) then
         write(6,'(A,A,F8.3)') 'test_innerproduct_8:'
     $        ,' total_time ',timing_toc-timing_tic
      end if !if ((verbose.gt.0) .and. (flag_memory_estimate.eqv..false.)) then
      end if !if (flag_proceed.eqv..true.) then

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  calling checkset. ;
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      include 'test_alpha_update_6_checkset.f'

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  update alpha_est__
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      if (flag_MS_vs_SM.eqv..false.) then 
         if (verbose.gt.1) then
         write(6,'(A)') ' alpha_SM: '
         do nm=0,n_M_sample-1
            write(prefix_string,'(A,I2,A)') ' alpha_SM: nm:', nm , ' '
            call alpha_SM_write_0(n_SM_max,n_SM_(nm),alpha_SM__(n_alpha
     $           *n_SM_max*nm),len_trim(prefix_string)+1,prefix_string)
         enddo !do nm=0,n_M_sample-1
         end if !if (verbose.gt.1) then
         do nm=0,n_M_sample-1
            call test_alpha_update_SM_3(verbose,rseed,n_SM_max,n_SM_(nm)
     $           ,alpha_SM__(n_alpha*n_SM_max*nm),flag_RTRT_vs_RTTR
     $           ,alpha_est__(n_alpha*nm),alpha_update_f
     $           ,alpha_est__(n_alpha*nm))
         enddo !do nm=0,n_M_sample-1
      end if !if (flag_MS_vs_SM.eqv..false.) then 
      if (flag_MS_vs_SM.eqv..true.) then 
         if (verbose.gt.1) then
         write(6,'(A)') ' alpha_MS: '
         do ns=0,n_S_sample-1
            write(prefix_string,'(A,I2,A)') ' alpha_MS: ns:', ns , ' '
            call alpha_SM_write_0(n_MS_max,n_MS_(ns),alpha_MS__(n_alpha
     $           *n_MS_max*ns),len_trim(prefix_string)+1,prefix_string)
         enddo !do ns=0,n_S_sample-1
         end if !if (verbose.gt.1) then
         call test_alpha_update_MS_3(verbose,rseed,n_MS_max,n_MS_
     $        ,n_S_sample,n_M_sample,alpha_MS__,flag_RTRT_vs_RTTR
     $        ,alpha_est__,alpha_est__)
      end if !if (flag_MS_vs_SM.eqv..true.) then 

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  print out a subset of image-template pairs
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      if (flag_fig) then
         write(tmp_fname,'(A,A,I0)') trim(dname) , '/Fig_MTS_c_' ,
     $        n_k_cur
         call Fig_gen_ver5(n_k_cur,n_polar_a_,grid_k_p_,n_S_sample
     $        ,I_S_sample_,ld_S,S_k_p__,n_M_sample,I_M_sample_,ld_M
     $        ,M_k_p__ ,ld_CTF,CTF_k_p__,alpha_est__ ,min(16
     $        ,n_M_sample) ,tmp_fname)
      end if !if (flag_fig) then

c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
c$$$  calling checkset. ;
c$$$  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
      include 'test_alpha_update_6_checkset.f'

      if (flag_MS_vs_SM.eqv..false.) then
         deallocate(n_SM_)
         deallocate(alpha_SM__)
      end if !if (flag_MS_vs_SM.eqv..false.) then
      if (flag_MS_vs_SM.eqv..true.) then
         deallocate(n_MS_)
         deallocate(alpha_MS__)
      end if !if (flag_MS_vs_SM.eqv..true.) then
      deallocate(delta_x_)
      deallocate(delta_y_)
      deallocate(S_alpha_S_index_all_)
      deallocate(S_alpha_polar_a_all_)
      deallocate(S_alpha_azimu_b_all_)
      deallocate(grid_cos_polar_a_tmp_)
      deallocate(grid_sin_polar_a_tmp_)
      deallocate(weight_cos_polar_a_tmp_)
      deallocate(azimu_b_step_tmp_)
      deallocate(n_azimu_b_tmp_)
      deallocate(C_M_)
      deallocate(I_S_sample_)
      deallocate(S_alpha_S_index_sample_)
      deallocate(S_alpha_polar_a_sample_)
      deallocate(S_alpha_azimu_b_sample_)

      if (verbose.gt.0) write(6,'(A)')
     $     '[finished test_alpha_update_6]'
      
      end


!> Doxygen comment: ;\n
!> This function updates a stack of image-parameters by matching images to templates. ;\n
!> (This enforces a uniform distribution of viewing angles, which is not what angle-fitting typically does). ;\n
      subroutine test_alpha_update_MS_3(verbose,rseed,n_MS_max,n_MS_,n_S
     $     ,n_M,alpha_MS__,flag_RTRT_vs_RTTR,alpha_est__,alpha_upd__)
c$$$      Update alphas
      implicit none
      integer verbose
      integer *4 rseed
      integer *4 n_MS_max,n_MS_(0:0),n_S,n_M
      real *8 alpha_MS__(0:0)
      logical flag_RTRT_vs_RTTR ! flag indicating whether transformation operations are ordered as: R_{est}T_{est}R_{upd}T_{upd}(S) [flag_RTRT_vs_RTTR.eqv..true.] or R_{est}T_{est}T_{upd}R_{upd}(S) [flag_RTRT_vs_RTTR.eqv..false.] ;
      real *8 alpha_est__(0:0)
      real *8 alpha_upd__(0:0)
      include 'nalpha_define.f'
      real *8 delta_x_upd,delta_y_upd,gamma_z_upd
      real *8 delta_x_est,delta_y_est,gamma_z_est
c$$$      temporary arrays
      integer *4, allocatable :: I_S_(:)
      logical, allocatable :: B_M_(:)
      integer *4, allocatable :: n_MS_tmp_(:)
      logical bm,continue_flag
      integer sum_i4_f
      integer ns,ns_tmp,nm,nm_sum,n_MS_sum,nm_srt,na,nb
      character(len=64) format_string

      if (verbose.gt.1) then
         write(6,'(A)') '[entering test_alpha_update_MS_3]'
      end if

      if (verbose.gt.2) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,I0)') ' n_MS_max: ' , n_MS_max
         call print_sub_i4(n_S,n_MS_,' n_MS_: ')
         write(6,'(A,I0)') ' n_S: ' , n_S
         write(6,'(A,I0)') ' n_M: ' , n_M
         call print_sub_r8(n_alpha*n_MS_max*n_S,alpha_MS__
     $        ,' alpha_MS__: ')
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         do nM=0,n_M-1
            call print_all_r8(n_alpha,alpha_est__(n_alpha*nM)
     $           ,' alpha_est__: ')
            call print_all_r8(n_alpha,alpha_upd__(n_alpha*nM)
     $           ,' alpha_upd__: ')
         enddo ! do nM=0,n_M-1
      end if !if (verbose.gt.2) then

      do ns=0,n_S-1
      if (n_MS_(ns).lt.n_MS_max) then
         call alpha_SM_sort_0(n_MS_max,n_MS_(ns),alpha_MS__(n_alpha
     $        *n_MS_max*ns))
      end if !if (n_MS_(ns).lt.n_MS_max) then
      enddo !do ns=0,n_S-1

      allocate(I_S_(0:n_S-1))
      allocate(B_M_(0:n_M-1))
      allocate(n_MS_tmp_(0:n_S-1))
      call cp1_i4(n_S,n_MS_,n_MS_tmp_)
      n_MS_sum = sum_i4_f(n_s,n_MS_)

      call adi_randperm(rseed,n_S,I_S_)
      if (verbose.gt.1) then
         call print_all_i4(n_S,I_S_,' I_S_: ')
         call print_all_i4(n_S,n_MS_,' n_MS_: ')
      end if !if (verbose.gt.1) then

      do nm=0,n_M-1
         B_M_(nm) = .false.
      enddo
      nm_sum = 0
      ns_tmp = 0
      do while (nm_sum.le.n_M-1 .and. nm_sum.le.n_MS_sum-1)
         ns = I_S_(ns_tmp)
         if (verbose.gt.2) then
            call print_all_i4(n_S,n_MS_tmp_,' n_MS_tmp_: ')
            write(6,'(4(A,I0))') 'nm_sum ',nm_sum,'; ns_tmp ', ns_tmp
     $           ,'; ns ',ns , '; n_MS_tmp_: ' , n_MS_tmp_(ns)
         end if !if (verbose.gt.2) then
         nm_srt = n_MS_tmp_(ns)-1
         continue_flag = .true.
         do while (continue_flag)
            continue_flag = .false.
            na = n_alpha*(nm_srt + n_MS_max*ns)
            nm = alpha_MS__(nalpha_M_index + na)
            bm = B_M_(nm)
            if (bm) then
               if (verbose.gt.2) then
                  write(6,'(A,I0,A,I0,A)') ' nm_srt ',nm_srt,'; nm ',nm
     $                 ,'; skipping'
               end if
               n_MS_tmp_(ns) = n_MS_tmp_(ns) - 1
               nm_srt = nm_srt - 1
               if (nm_srt.ge.0) then
                  continue_flag = .true.
               end if !if (nm_srt.ge.0) then
               if (nm_srt.lt.0) then
                  continue_flag = .false.
               end if !if (nm_srt.lt.0) then
            else ! if unused
               if (verbose.gt.2) then
                  write(6,'(A,I0,A,I0,A)') ' nm_srt ',nm_srt,'; nm ',nm
     $                 ,'; updating'
               end if
               bm = .true.
               B_M_(nm) = .true.
               n_MS_tmp_(ns) = n_MS_tmp_(ns) - 1
               continue_flag = .false.
               nm_sum = nm_sum + 1
c$$$           %%%%%%%%%%%%%%%%
               nb = n_alpha*nm
               delta_x_upd = alpha_MS__(nalpha_delta_x + na)
               delta_y_upd = alpha_MS__(nalpha_delta_y + na)
               gamma_z_upd = alpha_MS__(nalpha_gamma_z + na)
               delta_x_est = alpha_est__(nalpha_delta_x + nb)
               delta_y_est = alpha_est__(nalpha_delta_y + nb)
               gamma_z_est = alpha_est__(nalpha_gamma_z + nb)
               call get_interchange_delta_RTRT_vs_RTTR(flag_RTRT_vs_RTTR
     $              ,delta_x_est,delta_y_est,gamma_z_est,delta_x_upd
     $              ,delta_y_upd ,gamma_z_upd)
               call cp1_r8(n_alpha,alpha_MS__(na),alpha_upd__(nb))
               alpha_upd__(nalpha_delta_x + nb) = delta_x_upd
               alpha_upd__(nalpha_delta_y + nb) = delta_y_upd
               alpha_upd__(nalpha_gamma_z + nb) = gamma_z_upd
c$$$           %%%%%%%%%%%%%%%%
            end if ! check bm
         end do ! continue_flag
         ns_tmp = ns_tmp + 1
         if (ns_tmp.ge.n_S) then
            ns_tmp = 0
         end if
      end do ! while (nm_sum.le.n_M-1 .and. nm_sum.le.n_MS_sum-1)
      ns = I_S_(ns_tmp)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0,A,I0,A)') 'nm_sum ',nm_sum,'; ns_tmp '
     $        ,ns_tmp,'; ns ',ns,'; finished'
      end if !if (verbose.gt.1) then

      deallocate(I_S_)
      deallocate(B_M_)
      deallocate(n_MS_tmp_)

      if (verbose.gt.1) then
         write(6,'(A)') '[finished test_alpha_update_MS_3]'
      end if
      end

!> Doxygen comment: ;\n
!> This function updates a stack of image-parameters by matching templates to images. ;\n
!> (This uses a parameter 'f', stored as alpha_update_f, as described in leslie's frequency marching paper). ;\n
      subroutine test_alpha_update_SM_3(verbose,rseed,n_SM_max,n_SM
     $     ,alpha_SM_,flag_RTRT_vs_RTTR,alpha_est_,alpha_update_f
     $     ,alpha_upd_)
      implicit none
      include 'nalpha_define.f'
      integer *4 verbose
      integer *4 rseed
      integer *4 n_SM_max,n_SM
      real *8 alpha_SM_(0:n_alpha*n_SM_max-1)
      logical flag_RTRT_vs_RTTR
      real *8 alpha_est_(0:n_alpha-1)
      real *8 alpha_update_f
      real *8 alpha_upd_(0:n_alpha-1)
      real *8 adi_rand_f
      integer *4 ns_use
      real *8 delta_x_upd,delta_y_upd,gamma_z_upd
      real *8 delta_x_est,delta_y_est,gamma_z_est

      if (verbose.gt.1) then
         write(6,'(A)') ' [entering test_alpha_update_SM_3].'
      end if !if (verbose.gt.1) then

      if (verbose.gt.2) then
         write(6,'(A,I0)') ' verbose: ' , verbose
         write(6,'(A,I0)') ' rseed: ' , rseed
         write(6,'(A,I0)') ' n_SM_max: ' , n_SM_max
         write(6,'(A,I0)') ' n_SM: ' , n_SM
         call print_sub_r8(n_alpha*n_SM_max,alpha_SM_,12,' alpha_SM_: ')
         write(6,'(A,L1)') ' flag_RTRT_vs_RTTR: ' , flag_RTRT_vs_RTTR
         call print_all_r8(n_alpha,alpha_est_,13,' alpha_est_: ')
         call print_all_r8(n_alpha,alpha_upd_,13,' alpha_upd_: ')
      end if !if (verbose.gt.2) then
      
      if (n_SM.lt.n_SM_max) then
         call alpha_SM_sort_0(n_SM_max,n_SM,alpha_SM_)
      end if !if (n_SM.lt.n_SM_max) then

c$$$      In this particular context, alpha_update_f is used to 
c$$$      choose an entry from 0,n_SM-1
      ns_use = max(0,min(n_SM-1,floor((1.0d0-adi_rand_f(rseed)
     $     *alpha_update_f)*n_SM)))
      delta_x_upd = alpha_SM_(nalpha_delta_x + n_alpha*ns_use)
      delta_y_upd = alpha_SM_(nalpha_delta_y + n_alpha*ns_use)
      gamma_z_upd = alpha_SM_(nalpha_gamma_z + n_alpha*ns_use)
      delta_x_est = alpha_est_(nalpha_delta_x)
      delta_y_est = alpha_est_(nalpha_delta_y)
      gamma_z_est = alpha_est_(nalpha_gamma_z)
      call get_interchange_delta_RTRT_vs_RTTR(flag_RTRT_vs_RTTR
     $     ,delta_x_est,delta_y_est,gamma_z_est,delta_x_upd,delta_y_upd
     $     ,gamma_z_upd)
      call cp1_r8(n_alpha,alpha_SM_(n_alpha*ns_use),alpha_upd_)
      alpha_upd_(nalpha_delta_x) = delta_x_upd
      alpha_upd_(nalpha_delta_y) = delta_y_upd
      alpha_upd_(nalpha_gamma_z) = gamma_z_upd

      if (verbose.gt.1) then
         write(6,'(A)') ' [finished test_alpha_update_SM_3].'
      end if !if (verbose.gt.1) then
      end
      
!> Doxygen comment: ;\n
!> This program tests simple maximum timing. ;\n
      subroutine test_max_0(verbose,n_x,n_iteration)
      implicit none
      include 'omp_lib.h'
      integer *4 verbose
      integer *4 n_x,nx,nx_max
      integer *4 n_iteration,niteration
      real *8, allocatable :: x_(:)
      complex *16 x,x_max
      real *8 timing_tic,timing_toc
      if (verbose.gt.0) then
         write(6,'(A)') '[entering test_max_0]'
      end if !if (verbose.gt.0) then
      allocate(x_(0:n_x-1))
      do nx=0,n_x-1
         x_(nx) = cmplx( sin(1.0d0*nx) , 0.0d0 )
      enddo !do nx=0,n_x-1
c$$$      %%%%%%%%%%%%%%%%
      timing_tic = omp_get_wtime()
      do niteration=0,n_iteration-1
      nx_max = 0
      x_max = x_(nx_max)
      do nx=0,n_x-1
         x = x_(nx)
         if (real(x).gt.real(x_max)) then
            nx_max = nx
            x_max = x
         end if !if (x.gt.x_max) then
      enddo !do nx=0,n_x-1
      enddo ! do niteration=0,n_iteration-1
      timing_toc = omp_get_wtime()
      if (verbose.gt.1) then
         write(6,'(A,I0,A,F8.3)') ' max brute force: ' , nx_max
     $        ,' total_time ',timing_toc-timing_tic
      end if !if (verbose.gt.0) then
c$$$      %%%%%%%%%%%%%%%%
      timing_tic = omp_get_wtime()
      do niteration=0,n_iteration-1
      nx_max = 0
      x_max = x_(nx_max)
      nx_max = maxloc(x_,1)
      enddo ! do niteration=0,n_iteration-1
      timing_toc = omp_get_wtime()
      if (verbose.gt.1) then
         write(6,'(A,I0,A,F8.3)') ' max location: ' , nx_max
     $        ,' total_time ',timing_toc-timing_tic
      end if !if (verbose.gt.0) then
c$$$      %%%%%%%%%%%%%%%%

      if (verbose.gt.0) then
         write(6,'(A)') '[finished test_max_0]'
      end if !if (verbose.gt.0) then
      end
!> Doxygen comment: ;\n
!> minimum of integer *4 array. ;\n
      integer *4 function min_i4_f(n_x,x_)
      integer *4 n_x,nx
      integer *4 x_(0:n_x-1),m
      if (n_x.le.0) then
         m=0
      else
         m=x_(0)
         do nx=0,n_x-1
            if (x_(nx).lt.m) then
               m = x_(nx)
            end if
         enddo
      end if
      min_i4_f = m
      return
      end
!> Doxygen comment: ;\n
!> maximum of integer *4 array. ;\n
      integer *4 function max_i4_f(n_x,x_)
      integer *4 n_x,nx
      integer *4 x_(0:n_x-1),m
      if (n_x.le.0) then
         m=0
      else
         m=x_(0)
         do nx=0,n_x-1
            if (x_(nx).gt.m) then
               m = x_(nx)
            end if
         enddo
      end if
      max_i4_f = m
      return
      end
!> Doxygen comment: ;\n
!> maximum of real *8 array. ;\n
      real *8 function max_r8_f(n_x,x_)
      integer n_x,nx
      real *8 x_(0:n_x-1),m
      if (n_x.le.0) then
         m=0.0d0
      else
         m=x_(0)
         do nx=0,n_x-1
            if (x_(nx).gt.m) then
               m = dabs(x_(nx))
            end if
         enddo
      end if
      max_r8_f = m
      return
      end
!> Doxygen comment: ;\n
!> maximum of complex *16 array, with maximum taken over real entries. ;\n
      complex *16 function maxr_c16_f(n_x,x_)
      integer n_x,nx
      complex *16 x_(0:n_x-1),m
      if (n_x.le.0) then
         m=cmplx(0.0d0,0.0d0)
      else
         m=x_(0)
         do nx=0,n_x-1
            if (dreal(x_(nx)).gt.dreal(m)) then
               m = x_(nx)
            end if
         enddo
      end if
      maxr_c16_f = m
      return
      end
!> Doxygen comment: ;\n
!> calculates average of real *8 array x_ ;\n
      real *8 function avg_r8_f(n_x,x_)
      integer n_x,nx
      real *8 x_(0:n_x-1),m
      if (n_x.le.0) then
         m=0.0d0
      else
         m=x_(0)
         do nx=1,n_x-1
            m = m + x_(nx)
         enddo
         m = m/n_x
      end if
      avg_r8_f = m
      return
      end
!> Doxygen comment: ;\n
!> Calculates l2-norm of real *8 array x_
      real *8 function al2_r8_f(n_x,x_)
      integer n_x,nx
      real *8 x_(0:n_x-1),m
      if (n_x.le.0) then
         m=0.0d0
      else
         m=x_(0)*x_(0)
         do nx=1,n_x-1
            m = m + x_(nx)*x_(nx)
         enddo
         m = dsqrt(m)
      end if
      al2_r8_f = m
      return
      end
!> Doxygen comment: ;\n
!> Calculates l2-norm of complex *16 array x_
      real *8 function al2_c16_f(n_x,x_)
      integer n_x,nx
      complex *16 x_(0:n_x-1)
      real *8 m
      if (n_x.le.0) then
         m=0.0d0
      else
         m=dreal(dconjg(x_(0))*x_(0))
         do nx=1,n_x-1
            m = m + dreal(dconjg(x_(nx))*x_(nx))
         enddo
         m = dsqrt(m)
      end if
      al2_c16_f = m
      return
      end
!> Doxygen comment: ;\n
!> Evaluates a polynomial given by: ; \n
!> v_(j) = p_(0) + p_(1)*x_(j) + p_(2)*x_(j)**2 + .. + p_(n_p-1)*x_(j)**(n_p-1) ; \n
      subroutine polyval_r8_reverse_0(n_p,p_,n_x,x_,v_)
c$$$      Evaluates a polynomial given by: ;
c$$$      v_(j) = p_(0) + p_(1)*x_(j) + p_(2)*x_(j)**2 + .. + p_(n_p-1)*x_(j)**(n_p-1) ;
      implicit none
      integer n_p,n_x
      real *8 p_(0:n_p-1)
      real *8 x_(0:n_x-1)
      real *8 v_(0:n_x-1)
      integer np,nx,nj
      real *8 p,x
      do nx=0,n_x-1
         x = x_(nx)
         p = 0.0d0
         nj=n_p-1
         do np=0,n_p-1
            p = p_(nj) + p*x
            nj = nj-1
         enddo                  !do np=0,n_p-1
         v_(nx) = p
      enddo                     !do nx=0,n_x-1
      end
!> Doxygen comment: ;\n
!> Calculates angle between complex *16 vectors x_ and y_  ;\n
      real *8 function costheta_c16_f(n_a,x_,y_)
      integer n_a,na
      complex *16 x_(0:n_a-1)
      complex *16 y_(0:n_a-1)
      real *8 xy
      real *8 xx
      real *8 yy
      if (n_a.le.0) then
         xy=0.0d0
         xx=1.0d0
         yy=1.0d0
      else
         xy=dreal(dconjg(x_(0))*y_(0))
         xx=dreal(dconjg(x_(0))*x_(0))
         yy=dreal(dconjg(y_(0))*y_(0))
         do na=1,n_a-1
            xy = xy + dreal(dconjg(x_(na))*y_(na))
            xx = xx + dreal(dconjg(x_(na))*x_(na))
            yy = yy + dreal(dconjg(y_(na))*y_(na))
         enddo
         if (xx.le.0.0d0) xx=1.0d0
         if (yy.le.0.0d0) yy=1.0d0
      end if
      costheta_c16_f = xy/(dsqrt(xx)*dsqrt(yy))
      return
      end
!> Doxygen comment: ;\n
!> sum of integer *4 array. ;\n
      integer *4 function sum_i4_f(n_x,x_)
      integer *4 n_x,nx
      integer *4 x_(0:n_x-1),s
      if (n_x.le.0) then
         s=0
      else
         s=0
         do nx=0,n_x-1
            s = s + x_(nx)
         enddo
      end if
      sum_i4_f = s
      return
      end
!> Doxygen comment: ;\n
!> sum of logical array. ;\n
!> .true. counts as 1, and .false. counts as 0. ;\n
      integer *4 function sum_l2_f(n_x,x_)
      integer *4 n_x,nx
      logical x_(0:n_x-1)
      integer *4 s
      if (n_x.le.0) then
         s=0
      else
         s=0
         do nx=0,n_x-1
            if (x_(nx).eqv..true.) then
               s = s+1
            end if !if (x_(nx).eqv..true.) then
         enddo !do nx=0,n_x-1
      end if
      sum_l2_f = s
      return
      end
!> Doxygen comment: ;\n
!> returns unique indices from witihin integer *4 list L_. ;\n
      subroutine unique_I4(n_L,L_,n_I_out,I_out)
      implicit none
      integer *4 n_L,n_I_out
      integer *4 L_(0:n_L-1)
      integer *4 I_out(0:0)
      integer *4 nL,n_I
      integer *4, allocatable :: J_(:)
      integer *4, allocatable :: K_(:)
      external quicksort_i4
      allocate(J_(0:n_L-1))
      allocate(K_(0:n_L-1))
      call cp1_i4(n_L,L_,J_)
      do nL=0,n_L-1
         K_(nL) = nL
      enddo !do nL=0,n_L-1
      call quicksort_i4(0,n_L-1,J_,1,K_,1,quicksort_i4)
      n_I=0
      do nL=0,n_L-1
         if (nL.eq.0) then
            I_out(n_I) = J_(nL)
            n_I = n_I+1
         end if !if (nL.eq.0) then
         if (nL.gt.0) then
            if (J_(nL).gt.J_(nL-1)) then
               I_out(n_I) = J_(nL)
               n_I = n_I+1
            end if !if (J_(nL).gt.J_(nL-1)) then
         end if !if (nL.gt.0) then
      enddo !do nL=0,n_L-1
      n_I_out = n_I
      deallocate(K_)
      deallocate(J_)
      end
      
      
!> Doxygen comment: ;\n
!> Calculates real *8 cross-product v3 = v1 x v2 ;\n
      subroutine cross_r8(v1,v2,v3)
      real *8 v1(0:3-1)
      real *8 v2(0:3-1)
      real *8 v3(0:3-1)
      v3(0) = v1(1)*v2(2) - v2(1)*v1(2)
      v3(1) = v1(2)*v2(0) - v2(2)*v1(0)
      v3(2) = v1(0)*v2(1) - v2(0)*v1(1)
      end
!> Doxygen comment: ;\n
!> Calculates dot-product aa of real *8 vectors v1_ and v2_ ;\n
      subroutine dot_r8(v1,v2,aa)
      real *8 v1(0:3-1)
      real *8 v2(0:3-1)
      real *8 aa
      aa = v1(0)*v2(0) + v1(1)*v2(1) + v1(2)*v2(2)
      end
!> Doxygen comment: ;\n
!> Calculates dot-product aa of complex *16 vectors v1_ and v2_ ;\n
      subroutine dot_c16(n_v,v1_,v2_,aa)
      implicit none
      integer n_v
      complex *16 v1_(0:n_v-1)
      complex *16 v2_(0:n_v-1)
      complex *16 aa
      integer nv
      aa = cmplx(0.0d0,0.0d0)
      do nv=0,n_v-1
         aa = aa + dconjg(v1_(nv))*v2_(nv)
      enddo !do nv=0,n_v-1
      end
!> Doxygen comment: ;\n
!> Calculates real *8 distance dd between vectors vA_ and vB_ ;\n
      subroutine distance_r8(n_v,vA_,vB_,dd)
      integer *4 n_v
      real *8 vA_(0:n_v-1)
      real *8 vB_(0:n_v-1)
      real *8 dd
      integer *4 nv
      dd = 0.0d0
      do nv=0,n_v-1
         dd = dd + (vA_(nv) - vB_(nv))**2
      enddo !do nv=0,n_v-1
      dd = dsqrt(dd)
      end
!> Doxygen comment: ;\n
!> Normalize a real *8 vector v_. ;\n
      subroutine normalize_r8(n_v,v_)
      implicit none
      integer n_v,nv
      real *8 v_(0:0)
      real *8 vn
      vn=0.0d0
      do nv=0,n_v-1
         vn = vn + v_(nv)**2
      enddo !do nv=0,n_v-1
      vn = dsqrt(vn)
      do nv=0,n_v-1
         v_(nv) = v_(nv)/vn;
      enddo !do nv=0,n_v-1
      end
      
!> Doxygen comment: ;\n
!> Normalize a complex *16 vector v_. ;\n
      subroutine normalize_c16(n_v,v_)
      implicit none
      integer n_v,nv
      complex *16 v_(0:0)
      real *8 vn
      vn=0.0d0
      do nv=0,n_v-1
         vn = vn + dreal(dconjg(v_(nv))*v_(nv))
      enddo !do nv=0,n_v-1
      vn = dsqrt(vn)
      vn = max(1.0d-15,vn)
      do nv=0,n_v-1
         v_(nv) = v_(nv)/vn;
      enddo !do nv=0,n_v-1
      end
      
!> Doxygen comment: ;\n
!> Simple gram-schmidt orthonormalization of columns of complex *16 array A_. ;\n
      subroutine gramschmidt_c16(n_r,n_c,A_)
      implicit none
      integer n_r,n_c
      complex *16 A_(0:n_r*n_c-1)
      complex *16 aa
      integer nr,nc,nd
      do nc=0,n_c-1
         call normalize_c16(n_r,A_(0+nc*n_r))
         do nd=nc+1,n_c-1
            call dot_c16(n_r,A_(0+nc*n_r),A_(0+nd*n_r),aa)
            do nr=0,n_r-1
               A_(nr+nd*n_r) = A_(nr+nd*n_r) - aa*A_(nr+nc*n_r)
            enddo !do nr=0,n_r-1
         enddo !do nd=nc+1,n_c-1
      enddo !do nc=0,n_c-1
      end
!> Doxygen comment: ;\n
!> maps polar and azumithal angles to a vector on sphere. ;\n
      subroutine get_angle_to_vp_(alpha_polar_a,alpha_azimu_b,vp_)
      implicit none
      real *8 alpha_polar_a
      real *8 alpha_azimu_b
      real *8 vp_(0:2)
      vp_(0) = cos(alpha_azimu_b)*sin(alpha_polar_a)
      vp_(1) = sin(alpha_azimu_b)*sin(alpha_polar_a)
      vp_(2) = cos(alpha_polar_a)
      end
!> Doxygen comment: ;\n
!> For tesselation-tree. ;\n
!> Finds size of the tesselation-tree. ;\n
      recursive subroutine tesselation_size(tradius_min ,nl__in,v0_i
     $     ,v1_i,v2_i,parity,n_L,L_,LT_,nl_out,nm_out,ll_out)
      implicit none
      integer *4 verbose
      data verbose / 0 /
      real *8 tradius_min
      integer *4 nl__in,n_L,nl_out,nm_out,ll_out
      real *8 v0_i(0:3-1),v1_i(0:3-1),v2_i(0:3-1)
      logical parity,lf
      real *8 L_(0:3*n_L-1)
      integer *4 LT_(0:n_L-1)
      integer *4 nd
      real *8, allocatable :: v0_j(:)
      real *8, allocatable :: v1_j(:)
      real *8, allocatable :: v2_j(:)
      real *8, allocatable :: v0_k(:)
      real *8, allocatable :: v1_k(:)
      real *8, allocatable :: v2_k(:)
      real *8, allocatable :: vm(:)
      real *8, allocatable :: nn(:)
      real *8, allocatable :: e0(:)
      real *8, allocatable :: e1(:)
      real *8, allocatable :: e2(:)
      real *8, allocatable :: m0(:)
      real *8, allocatable :: m1(:)
      real *8, allocatable :: m2(:)
      real *8, allocatable :: n0(:)
      real *8, allocatable :: n1(:)
      real *8, allocatable :: n2(:)
      real *8, allocatable :: vtA(:)
      real *8, allocatable :: vtB(:)
      real *8, allocatable :: L_sub_(:)
      integer *4, allocatable :: LT_sub_(:)
      integer *4 n_L_sub,nL,nL_sub
      real *8 aa,a0,a1,a2
      logical isin
      integer *4 nl_child_0
      integer *4 nl_child_1
      integer *4 nl_child_2
      integer *4 nl_child_3
      integer *4, allocatable :: nl_child_(:)
      integer *4 nm_child_0
      integer *4 nm_child_1
      integer *4 nm_child_2
      integer *4 nm_child_3
      integer *4, allocatable :: nm_child_(:)
      integer *4 ll_child_0
      integer *4 ll_child_1
      integer *4 ll_child_2
      integer *4 ll_child_3
      integer *4, allocatable :: ll_child_(:)
      integer *4 max_i4_f,sum_i4_f
      real *8, allocatable :: tradius_(:)
      real *8 tradius,max_r8_f
      character(len=1024) prefix,format_string
      write(format_string,'(A,I0,A)') '(A',nl__in+1,')'
      write(prefix,format_string) '%'      
      if (verbose.gt.0) then
         write(6,'(A,A,I0)') trim(prefix) ,
     $        '[entering tesselation_size]: ',nl__in
      end if ! if (verbose.gt.0) then
      if (verbose.gt.1) then
         do nL=0,n_L-1
            write(6,'(A,A,I0,1X,3F8.4)') trim(prefix) , 'L_ ' , nL ,L_(0
     $           +3*nL) , L_(1+3*nL) , L_(2+3*nL)
         enddo !do nL=0,n_L-1
      end if ! if (verbose.gt.0) then
      nl_out = nl__in
      nm_out = 0
      ll_out = 0
      include 'tesselation_excerpt.f'
      if (n_L_sub.eq.0) then
         nl_out = -1
         nm_out = 0
         ll_out = 0
      end if !if (n_L_sub.eq.0) then
      if (n_L_sub.ge.1) then
         if (lf) then
         nl_out = nl__in
         nm_out = 1
         ll_out = n_L_sub
         end if !if (lf) then
         if (.not. lf) then
            if (verbose.gt.1) then
               write(6,'(A,A)') trim(prefix) , 'calling children'
            end if ! if (verbose.gt.0) then
            call tesselation_size(tradius_min,nl__in+1,v0_k,m2 ,m1
     $           ,parity,n_L_sub,L_sub_,LT_sub_,nl_child_0,nm_child_0
     $           ,ll_child_0)
            call tesselation_size(tradius_min,nl__in+1,v1_k,m0 ,m2
     $           ,parity,n_L_sub,L_sub_,LT_sub_,nl_child_1,nm_child_1
     $           ,ll_child_1)
            call tesselation_size(tradius_min,nl__in+1,v2_k,m1 ,m0
     $           ,parity,n_L_sub,L_sub_,LT_sub_,nl_child_2,nm_child_2
     $           ,ll_child_2)
            call tesselation_size(tradius_min,nl__in+1,m0,m1,m2, .not.
     $           parity,n_L_sub,L_sub_,LT_sub_,nl_child_3,nm_child_3
     $           ,ll_child_3)
            allocate(nl_child_(0:3))
            nl_child_(0) = nl_child_0
            nl_child_(1) = nl_child_1
            nl_child_(2) = nl_child_2
            nl_child_(3) = nl_child_3
            if (verbose.gt.1) then
               write(6,'(A,A,I0,1X,I0,1X,I0,1X,I0)') trim(prefix) ,
     $              'nl_child_: ' , nl_child_0 , nl_child_1 ,
     $              nl_child_2 , nl_child_3
            end if ! if (verbose.gt.1) then
            allocate(nm_child_(0:3))
            nm_child_(0) = nm_child_0
            nm_child_(1) = nm_child_1
            nm_child_(2) = nm_child_2
            nm_child_(3) = nm_child_3
            if (verbose.gt.1) then
               write(6,'(A,A,I0,1X,I0,1X,I0,1X,I0)') trim(prefix) ,
     $              'nm_child_: ' , nm_child_0 , nm_child_1 ,
     $              nm_child_2 , nm_child_3
            end if ! if (verbose.gt.1) then
            allocate(ll_child_(0:3))
            ll_child_(0) = ll_child_0
            ll_child_(1) = ll_child_1
            ll_child_(2) = ll_child_2
            ll_child_(3) = ll_child_3
            if (verbose.gt.1) then
               write(6,'(A,A,I0,1X,I0,1X,I0,1X,I0)') trim(prefix) ,
     $              'll_child_: ' , ll_child_0 , ll_child_1 ,
     $              ll_child_2 , ll_child_3
            end if ! if (verbose.gt.1) then
            nl_out = max_i4_f(4,nl_child_)
            nm_out = 1 + sum_i4_f(4,nm_child_)
            ll_out = sum_i4_f(4,ll_child_)
         end if !if (.not. lf) then
      end if !if (n_L_sub.ge.1) then
      end


!> Doxygen comment: ;\n
!> For tesselation-tree. ;\n
!> Build index list for tesselation-tree. ;\n
      recursive subroutine tesselation_index(
     $ tradius_min , nl_max , nl__in ,
     $ v0_i , v1_i , v2_i ,
     $ parity ,
     $ n_L , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      implicit none
      integer *4 verbose
      data verbose / 0 /
      real *8 tradius_min
      integer *4 nl_max,nl__in,n_L
      integer *4 index_parent
      integer *4 index__input,index_output
      integer *4 ls__input,ls_output      
      real *8 v0_i(0:3-1),v1_i(0:3-1),v2_i(0:3-1)
      logical parity,lf
      real *8 L_(0:3*n_L-1)
      integer *4 LT_(0:0) ! LT_(j) = j = index of L_(j)
      integer *4 TL_(0:0) ! TL_(j) = tesselation_index associated with L_(j)
      integer *4 T_nl_(0:0) !level
      logical    T_up_(0:0) !parity
      integer *4 T_id_(0:0) !self tesselation_index
      integer *4 T_pa_(0:0) !parent tesselation_index
      real *8    T_v0_(0:0) !vertex 0
      real *8    T_v1_(0:0) !vertex 1
      real *8    T_v2_(0:0) !vertex 2
      real *8    T_vm_(0:0) !vertex center
      real *8    T_m0_(0:0) !edge midpoint 0
      real *8    T_m1_(0:0) !edge midpoint 1
      real *8    T_m2_(0:0) !edge midpoint 2
      real *8    T_e0_(0:0) !edge vector 0
      real *8    T_e1_(0:0) !edge vector 1
      real *8    T_e2_(0:0) !edge vector 2
      real *8    T_n0_(0:0) !edge normal 0
      real *8    T_n1_(0:0) !edge normal 1
      real *8    T_n2_(0:0) !edge normal 2
      real *8    T_nn_(0:0) !center normal
      real *8    T_tr_(0:0) !tradius
      integer *4 T_ll_(0:0) !number of points from L_ in T_
      logical    T_lf_(0:0) !is leaf
      integer *4 T_c0_(0:0) !child_0 tesselation_index
      integer *4 T_c1_(0:0) !child_1 tesselation_index
      integer *4 T_c2_(0:0) !child_2 tesselation_index
      integer *4 T_c3_(0:0) !child_3 tesselation_index
      integer *4 T_ls_(0:0) !starting index of point_index_list for T_ if leaf (leaves only)
      integer *4 T_LT_(0:0) !full point_index_list for all of T_ (leaves only)
      integer *4 nd
      real *8, allocatable :: v0_j(:)
      real *8, allocatable :: v1_j(:)
      real *8, allocatable :: v2_j(:)
      real *8, allocatable :: v0_k(:)
      real *8, allocatable :: v1_k(:)
      real *8, allocatable :: v2_k(:)
      real *8, allocatable :: vm(:)
      real *8, allocatable :: nn(:)
      real *8, allocatable :: e0(:)
      real *8, allocatable :: e1(:)
      real *8, allocatable :: e2(:)
      real *8, allocatable :: m0(:)
      real *8, allocatable :: m1(:)
      real *8, allocatable :: m2(:)
      real *8, allocatable :: n0(:)
      real *8, allocatable :: n1(:)
      real *8, allocatable :: n2(:)
      real *8, allocatable :: vtA(:)
      real *8, allocatable :: vtB(:)
      real *8, allocatable :: L_sub_(:)
      integer *4, allocatable :: LT_sub_(:)
      integer *4 n_L_sub,nL,nL_sub
      real *8 aa,a0,a1,a2
      logical isin
      integer index_tempA,index_tempB,ls_tempA
      integer *4 max_i4_f,sum_i4_f
      real *8, allocatable :: tradius_(:)
      real *8 tradius,max_r8_f
      character(len=1024) prefix,format_string
      write(format_string,'(A,I0,A)') '(A',nl__in+1,')'
      write(prefix,format_string) '%'      
      if (verbose.gt.0) then
         write(6,'(A,A,I0)') trim(prefix) ,
     $        '[entering tesselation_index]: ',nl__in
      end if ! if (verbose.gt.0) then
      if (verbose.gt.1) then
         do nL=0,n_L-1
            write(6,'(A,A,I0,1X,3F8.4)') trim(prefix) , 'L_ ' , nL ,L_(0
     $           +3*nL) , L_(1+3*nL) , L_(2+3*nL)
         enddo !do nL=0,n_L-1
      end if ! if (verbose.gt.0) then
      include 'tesselation_excerpt.f'
      if (n_L_sub.eq.0) then
         if (verbose.gt.0) then
            write(6,'(A,A)') trim(prefix) , 'skipping self'
         end if !if (verbose.gt.0) then
         index_output = index__input
         ls_output = ls__input
      end if !if (n_L_sub.eq.0) then
      if (n_L_sub.ge.1) then
         if (verbose.gt.0) then
            write(6,'(A,A)') trim(prefix) , 'creating self'
         end if !if (verbose.gt.0) then
         T_nl_(1*index__input) = nl__in
         T_up_(1*index__input) = parity
         T_id_(1*index__input) = index__input
         T_pa_(1*index__input) = index_parent
         call cp1_r8(3,v0_k,T_v0_(3*index__input))
         call cp1_r8(3,v1_k,T_v1_(3*index__input))
         call cp1_r8(3,v2_k,T_v2_(3*index__input))
         call cp1_r8(3,vm,T_vm_(3*index__input))
         call cp1_r8(3,m0,T_m0_(3*index__input))
         call cp1_r8(3,m1,T_m1_(3*index__input))
         call cp1_r8(3,m2,T_m2_(3*index__input))
         call cp1_r8(3,e0,T_e0_(3*index__input))
         call cp1_r8(3,e1,T_e1_(3*index__input))
         call cp1_r8(3,e2,T_e2_(3*index__input))
         call cp1_r8(3,n0,T_n0_(3*index__input))
         call cp1_r8(3,n1,T_n1_(3*index__input))
         call cp1_r8(3,n2,T_n2_(3*index__input))
         call cp1_r8(3,nn,T_nn_(3*index__input))
         T_tr_(1*index__input) = tradius
         T_ll_(1*index__input) = n_L_sub
         T_lf_(1*index__input) = lf
         T_c0_(1*index__input) = -1
         T_c1_(1*index__input) = -1
         T_c2_(1*index__input) = -1
         T_c3_(1*index__input) = -1
         T_ls_(1*index__input) = -1
         index_output = index__input + 1
         ls_output = ls__input
         if (lf) then
            if (verbose.gt.0) then
               write(6,'(A,A)') trim(prefix) ,
     $              'leaf, copying LT_sub to T_LT_ '
            end if !if (verbose.gt.0) then
            T_ls_(1*index__input) = ls__input
            do nL_sub=0,n_L_sub-1
               T_LT_(ls__input + nL_sub) = LT_sub_(nL_sub)
               TL_(LT_sub_(nL_sub)) = index__input
            enddo !do nL_sub=0,n_L_sub-1
            ls_output = ls__input + n_L_sub
         end if !if (lf) then
         if (.not. lf) then
            if (verbose.gt.1) then
               write(6,'(A,A)') trim(prefix) , 'creating children'
            end if ! if (verbose.gt.0) then

            index_tempB = index_output
            if (verbose.gt.1) then
               write(6,'(A,A,I0,A,I0)') trim(prefix) ,
     $              'creating child_0 at index ' , index_output , ' ls '
     $              , ls_output
            end if ! if (verbose.gt.0) then
            call tesselation_index(
     $           tradius_min , nl_max , nl__in + 1 ,
     $           v0_k , m2 , m1 ,
     $           parity ,
     $           n_L_sub , L_sub_ , LT_sub_ , TL_ , 
     $           T_id_(index__input) , index_output , ls_output ,
     $           T_nl_ , 
     $           T_up_ , 
     $           T_id_ , 
     $           T_pa_ , 
     $           T_v0_ , 
     $           T_v1_ , 
     $           T_v2_ , 
     $           T_vm_ , 
     $           T_m0_ , 
     $           T_m1_ , 
     $           T_m2_ , 
     $           T_e0_ , 
     $           T_e1_ , 
     $           T_e2_ , 
     $           T_n0_ , 
     $           T_n1_ , 
     $           T_n2_ , 
     $           T_nn_ , 
     $           T_tr_ , 
     $           T_ll_ , 
     $           T_lf_ , 
     $           T_c0_ , 
     $           T_c1_ , 
     $           T_c2_ , 
     $           T_c3_ , 
     $           T_ls_ ,
     $           T_LT_ ,
     $           index_tempA ,
     $           ls_tempA)
            index_output = index_tempA
            ls_output = ls_tempA
            if (index_output.gt.index_tempB) then
               T_c0_(index__input) = index_tempB
            end if !if (index_output.gt.index_tempB) then

            index_tempB = index_output
            if (verbose.gt.1) then
               write(6,'(A,A,I0,A,I0)') trim(prefix) ,
     $              'creating child_1 at index ' , index_output , ' ls '
     $              , ls_output
            end if ! if (verbose.gt.0) then
            call tesselation_index(
     $           tradius_min , nl_max , nl__in + 1 ,
     $           v1_k , m0 , m2 ,
     $           parity ,
     $           n_L_sub , L_sub_ , LT_sub_ , TL_ , 
     $           T_id_(index__input) , index_output , ls_output ,
     $           T_nl_ , 
     $           T_up_ , 
     $           T_id_ , 
     $           T_pa_ , 
     $           T_v0_ , 
     $           T_v1_ , 
     $           T_v2_ , 
     $           T_vm_ , 
     $           T_m0_ , 
     $           T_m1_ , 
     $           T_m2_ , 
     $           T_e0_ , 
     $           T_e1_ , 
     $           T_e2_ , 
     $           T_n0_ , 
     $           T_n1_ , 
     $           T_n2_ , 
     $           T_nn_ , 
     $           T_tr_ , 
     $           T_ll_ , 
     $           T_lf_ , 
     $           T_c0_ , 
     $           T_c1_ , 
     $           T_c2_ , 
     $           T_c3_ , 
     $           T_ls_ ,
     $           T_LT_ ,
     $           index_tempA ,
     $           ls_tempA)
            index_output = index_tempA
            ls_output = ls_tempA
            if (index_output.gt.index_tempB) then
               T_c1_(index__input) = index_tempB
            end if !if (index_output.gt.index_tempB) then

            index_tempB = index_output
            if (verbose.gt.1) then
               write(6,'(A,A,I0,A,I0)') trim(prefix) ,
     $              'creating child_2 at index ' , index_output , ' ls '
     $              , ls_output
            end if ! if (verbose.gt.0) then
            call tesselation_index(
     $           tradius_min , nl_max , nl__in + 1 ,
     $           v2_k , m1 , m0 ,
     $           parity ,
     $           n_L_sub , L_sub_ , LT_sub_ , TL_ , 
     $           T_id_(index__input) , index_output , ls_output ,
     $           T_nl_ , 
     $           T_up_ , 
     $           T_id_ , 
     $           T_pa_ , 
     $           T_v0_ , 
     $           T_v1_ , 
     $           T_v2_ , 
     $           T_vm_ , 
     $           T_m0_ , 
     $           T_m1_ , 
     $           T_m2_ , 
     $           T_e0_ , 
     $           T_e1_ , 
     $           T_e2_ , 
     $           T_n0_ , 
     $           T_n1_ , 
     $           T_n2_ , 
     $           T_nn_ , 
     $           T_tr_ , 
     $           T_ll_ , 
     $           T_lf_ , 
     $           T_c0_ , 
     $           T_c1_ , 
     $           T_c2_ , 
     $           T_c3_ , 
     $           T_ls_ ,
     $           T_LT_ ,
     $           index_tempA ,
     $           ls_tempA)
            index_output = index_tempA
            ls_output = ls_tempA
            if (index_output.gt.index_tempB) then
               T_c2_(index__input) = index_tempB
            end if !if (index_output.gt.index_tempB) then

            index_tempB = index_output
            if (verbose.gt.1) then
               write(6,'(A,A,I0,A,I0)') trim(prefix) ,
     $              'creating child_3 at index ' , index_output , ' ls '
     $              , ls_output
            end if ! if (verbose.gt.0) then
            call tesselation_index(
     $           tradius_min , nl_max , nl__in + 1 ,
     $           m0 , m1 , m2 ,
     $           .not. parity ,
     $           n_L_sub , L_sub_ , LT_sub_ , TL_ , 
     $           T_id_(index__input) , index_output , ls_output ,
     $           T_nl_ , 
     $           T_up_ , 
     $           T_id_ , 
     $           T_pa_ , 
     $           T_v0_ , 
     $           T_v1_ , 
     $           T_v2_ , 
     $           T_vm_ , 
     $           T_m0_ , 
     $           T_m1_ , 
     $           T_m2_ , 
     $           T_e0_ , 
     $           T_e1_ , 
     $           T_e2_ , 
     $           T_n0_ , 
     $           T_n1_ , 
     $           T_n2_ , 
     $           T_nn_ , 
     $           T_tr_ , 
     $           T_ll_ , 
     $           T_lf_ , 
     $           T_c0_ , 
     $           T_c1_ , 
     $           T_c2_ , 
     $           T_c3_ , 
     $           T_ls_ ,
     $           T_LT_ ,
     $           index_tempA ,
     $           ls_tempA)
            index_output = index_tempA
            ls_output = ls_tempA
            if (index_output.gt.index_tempB) then
               T_c3_(index__input) = index_tempB
            end if !if (index_output.gt.index_tempB) then

         end if !if (.not. lf) then
      end if !if (n_L_sub.ge.1) then
      if (verbose.gt.0) then
         write(6,'(A,A,I0,A,I0)') trim(prefix) , ' final index_output '
     $        , index_output , ' ls_output ' , ls_output
      end if !if (verbose.gt.0) then
      end



!> Doxygen comment: ;\n
!> For tesselation-tree. ;\n
!> Finds neighborhood of a given tesselation element. ;\n
      recursive subroutine tesselation_neighborhood(
     $ nl_max , nl__in ,
     $ vp ,
     $ distance_req ,
     $ n_L , L_ , 
     $ index__input , 
     $ T_nl_ , 
     $ T_vm_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ n_LT_neighborhood ,
     $ LT_neighborhood_)
      implicit none
      integer *4 verbose
      data verbose / 0 /
      integer *4 nl_max,nl__in,n_L,index__input
      integer *4 n_LT_neighborhood
      real *8 vp(0:3-1) , distance_req
      real *8 L_(0:3*n_L-1)
      integer *4 LT_neighborhood_(0:0)
      integer *4 T_nl_(0:0) !level
      real *8    T_vm_(0:0) !vertex center
      real *8    T_tr_(0:0) !tradius
      integer *4 T_ll_(0:0) !number of points from L_ in T_
      logical    T_lf_(0:0) !is leaf
      integer *4 T_c0_(0:0) !child_0 tesselation_index
      integer *4 T_c1_(0:0) !child_1 tesselation_index
      integer *4 T_c2_(0:0) !child_2 tesselation_index
      integer *4 T_c3_(0:0) !child_3 tesselation_index
      integer *4 T_ls_(0:0) !starting index of point_index_list for T_ if leaf (leaves only)
      integer *4 T_LT_(0:0) !full point_index_list for all of T_ (leaves only)
      integer *4 nd,nL,nLT_neighborhood
      real *8 distance_to_vm,distance_lowerbound,distance_to_vs
      real *8, allocatable :: vs(:)
      integer *4 n_L_sub,ls_start,nL_sub,LT_tmp
      character(len=1024) prefix,format_string
      write(format_string,'(A,I0,A)') '(A',nl__in+1,')'
      write(prefix,format_string) '%'      
      if (verbose.gt.0) then
         write(6,'(A,A,I0,1X,I0)') trim(prefix) ,
     $        '[entering tesselation_neighborhood]: ',nl__in ,
     $        T_nl_(index__input)
      end if ! if (verbose.gt.0) then
      if (verbose.gt.1) then
         do nL=0,n_L-1
            write(6,'(A,A,I0,1X,3F8.4)') trim(prefix) , 'L_ ' , nL ,L_(0
     $           +3*nL) , L_(1+3*nL) , L_(2+3*nL)
         enddo !do nL=0,n_L-1
         do nLT_neighborhood=0,n_LT_neighborhood-1
            write(6,'(A,A,I0,1X,I0)') 
     $ trim(prefix) , 
     $ 'LT_neighborhood_ ' , nLT_neighborhood ,
     $ LT_neighborhood_(nLT_neighborhood) 
         enddo !do nLT_neighborhood=0,n_LT_neighborhood-1
      end if ! if (verbose.gt.0) then
      if (verbose.gt.0) then
         write(6,'(A,A,3F8.4)') trim(prefix) , 'T_vm_: ' , T_vm_(0 + 3
     $        *index__input) , T_vm_(1 + 3*index__input) ,T_vm_(2 + 3
     $        *index__input)
      end if !if (verbose.gt.0) then
      call distance_r8(3,T_vm_(3*index__input),vp,distance_to_vm)
      distance_lowerbound = distance_to_vm - T_tr_(index__input)
      if (distance_lowerbound.gt.distance_req) then
         if (verbose.gt.0) then
            write(6,'(A,A,F8.4,A,F8.4)') trim(prefix) ,
     $           'distance_lowerbound' , distance_lowerbound ,
     $           ' > distance_req ', distance_req
         end if ! if (verbose.gt.0) then
      end if !if (distance_lowerbound.gt.distance_req) then
      if (distance_lowerbound.le.distance_req) then
         if (verbose.gt.0) then
            write(6,'(A,A,F8.4,A,F8.4)') trim(prefix) ,
     $           'distance_lowerbound' , distance_lowerbound ,
     $           ' <= distance_req ', distance_req
         end if ! if (verbose.gt.0) then
         if (T_lf_(index__input)) then
            if (verbose.gt.0) then
               write(6,'(A,A)') trim(prefix) , 'leaf, checking self'
            end if ! if (verbose.gt.0) then
            allocate(vs(0:3-1))
            n_L_sub = T_ll_(index__input)
            ls_start = T_ls_(index__input)
            do nL_sub=0,n_L_sub-1
               LT_tmp = T_LT_(ls_start + nL_sub)
               call cp1_r8(3,L_(3*LT_tmp),vs)
               call distance_r8(3,vs,vp,distance_to_vs)
               if (distance_to_vs.le.distance_req) then
                  if (verbose.gt.0) then
                     write(6,'(A,A,I0)') trim(prefix) ,
     $                    'adding LT_tmp: ' , LT_tmp
                  end if ! if (verbose.gt.0) then
                  LT_neighborhood_(n_LT_neighborhood) = LT_tmp
                  n_LT_neighborhood = n_LT_neighborhood + 1
               end if !if (distance_to_vs.le.distance_req) then
            enddo !do nL_sub=0,n_L_sub-1
         end if !if (T_lf_(index__input)) then
         if (.not. T_lf_(index__input)) then
            if (verbose.gt.0) then
               write(6,'(A,A)') trim(prefix) ,
     $              'branch, checking children'
             end if ! if (verbose.gt.0) then
            if (T_c0_(index__input).ge.0) then
               call tesselation_neighborhood(
     $              nl_max , nl__in+1 ,
     $              vp ,
     $              distance_req ,
     $              n_L , L_ , 
     $              T_c0_(index__input) , 
     $              T_nl_ , 
     $              T_vm_ , 
     $              T_tr_ , 
     $              T_ll_ , 
     $              T_lf_ , 
     $              T_c0_ , 
     $              T_c1_ , 
     $              T_c2_ , 
     $              T_c3_ , 
     $              T_ls_ ,
     $              T_LT_ ,
     $              n_LT_neighborhood ,
     $              LT_neighborhood_)
            end if !if (T_c0_(index__input).ge.0) then
            if (T_c1_(index__input).ge.0) then
               call tesselation_neighborhood(
     $              nl_max , nl__in+1 ,
     $              vp ,
     $              distance_req ,
     $              n_L , L_ , 
     $              T_c1_(index__input) , 
     $              T_nl_ , 
     $              T_vm_ , 
     $              T_tr_ , 
     $              T_ll_ , 
     $              T_lf_ , 
     $              T_c0_ , 
     $              T_c1_ , 
     $              T_c2_ , 
     $              T_c3_ , 
     $              T_ls_ ,
     $              T_LT_ ,
     $              n_LT_neighborhood ,
     $              LT_neighborhood_)
            end if !if (T_c1_(index__input).ge.0) then
            if (T_c2_(index__input).ge.0) then
               call tesselation_neighborhood(
     $              nl_max , nl__in+1 ,
     $              vp ,
     $              distance_req ,
     $              n_L , L_ , 
     $              T_c2_(index__input) , 
     $              T_nl_ , 
     $              T_vm_ , 
     $              T_tr_ , 
     $              T_ll_ , 
     $              T_lf_ , 
     $              T_c0_ , 
     $              T_c1_ , 
     $              T_c2_ , 
     $              T_c3_ , 
     $              T_ls_ ,
     $              T_LT_ ,
     $              n_LT_neighborhood ,
     $              LT_neighborhood_)
            end if !if (T_c2_(index__input).ge.0) then
            if (T_c3_(index__input).ge.0) then
               call tesselation_neighborhood(
     $              nl_max , nl__in+1 ,
     $              vp ,
     $              distance_req ,
     $              n_L , L_ , 
     $              T_c3_(index__input) , 
     $              T_nl_ , 
     $              T_vm_ , 
     $              T_tr_ , 
     $              T_ll_ , 
     $              T_lf_ , 
     $              T_c0_ , 
     $              T_c1_ , 
     $              T_c2_ , 
     $              T_c3_ , 
     $              T_ls_ ,
     $              T_LT_ ,
     $              n_LT_neighborhood ,
     $              LT_neighborhood_)
            end if !if (T_c3_(index__input).ge.0) then
         end if !if (.not. T_lf_(index__input)) then
      end if !if (distance_lowerbound.le.distance_req) then
      end



!> Doxygen comment: ;\n
!> For tesselation-tree. ;\n
!> Defines initial octants. ;\n
      subroutine tesselation_define_octants(v_n00_,v_0n0_,v_00n_,v_p00_
     $     ,v_0p0_,v_00p_)
      implicit none
      real *8 v_n00_(0:2)
      real *8 v_0n0_(0:2)
      real *8 v_00n_(0:2)
      real *8 v_p00_(0:2)
      real *8 v_0p0_(0:2)
      real *8 v_00p_(0:2)
      v_n00_(0) = -1
      v_n00_(1) = 0
      v_n00_(2) = 0
      v_0n0_(0) = 0
      v_0n0_(1) = -1
      v_0n0_(2) = 0
      v_00n_(0) = 0
      v_00n_(1) = 0
      v_00n_(2) = -1
      v_p00_(0) = +1
      v_p00_(1) = 0
      v_p00_(2) = 0
      v_0p0_(0) = 0
      v_0p0_(1) = +1
      v_0p0_(2) = 0
      v_00p_(0) = 0
      v_00p_(1) = 0
      v_00p_(2) = +1
      end
!> Doxygen comment: ;\n
!> For tesselation-tree. ;\n
!> Calculates size of tesselation-tree ;\n
      subroutine tesselation_get_nl_nm_ll(n_point,L_,tradius_min,nl_max
     $     ,nm_sum,ll_sum)
      implicit none
      include 'omp_lib.h'
      integer verbose
      data verbose / 0 /
      integer *4 n_point,npoint
      real *8 L_(0:3*n_point-1)
      integer *4, allocatable :: LT_(:) ! LT_(j) = j = index of point j within L_
      real *8 tradius_min
      real *8, allocatable :: v_n00_(:)
      real *8, allocatable :: v_0n0_(:)
      real *8, allocatable :: v_00n_(:)
      real *8, allocatable :: v_p00_(:)
      real *8, allocatable :: v_0p0_(:)
      real *8, allocatable :: v_00p_(:)
      integer *4 nl_nnn,nl_nnp,nl_npn,nl_npp
      integer *4 nl_pnn,nl_pnp,nl_ppn,nl_ppp
      integer *4 nl_(0:7),nl_max
      integer *4 nm_nnn,nm_nnp,nm_npn,nm_npp
      integer *4 nm_pnn,nm_pnp,nm_ppn,nm_ppp
      integer *4 nm_(0:7),nm_sum
      integer *4 ll_nnn,ll_nnp,ll_npn,ll_npp
      integer *4 ll_pnn,ll_pnp,ll_ppn,ll_ppp
      integer *4 ll_(0:7),ll_sum
      integer *4 nl,nm,ll
      integer *4 max_i4_f,sum_i4_f
      real *8 timing_tic,timing_toc
      if (verbose.gt.0) then
         write (6,'(A)') ' [entering tesselation_get_nl_nm_ll]'
      end if !if (verbose.gt.0) then

      allocate(LT_(0:n_point-1)) ! LT_(j) = j = index of L_(j)
      do npoint=0,n_point-1
         LT_(npoint) = npoint
      enddo !do npoint=0,n_point-1

      timing_tic = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A)') 'defining octants'
      end if ! if (verbose.gt.0) then
      allocate(v_n00_(0:2))
      allocate(v_0n0_(0:2))
      allocate(v_00n_(0:2))
      allocate(v_p00_(0:2))
      allocate(v_0p0_(0:2))
      allocate(v_00p_(0:2))
      call tesselation_define_octants(v_n00_,v_0n0_,v_00n_,v_p00_
     $     ,v_0p0_,v_00p_)
      timing_toc = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A,A,F8.4)') 'defining octants:'
     $        ,' total_time ',timing_toc-timing_tic
      end if

      timing_tic = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_size'
      end if ! if (verbose.gt.0) then
      call tesselation_size(tradius_min,0,v_n00_,v_0n0_,v_00n_,.false.
     $     ,n_point,L_,LT_,nl_nnn,nm_nnn,ll_nnn)
      call tesselation_size(tradius_min,0,v_n00_,v_0n0_,v_00p_,.true.
     $     ,n_point,L_,LT_,nl_nnp,nm_nnp,ll_nnp)
      call tesselation_size(tradius_min,0,v_n00_,v_0p0_,v_00n_,.true.
     $     ,n_point,L_,LT_,nl_npn,nm_npn,ll_npn)
      call tesselation_size(tradius_min,0,v_n00_,v_0p0_,v_00p_,.false.
     $     ,n_point,L_,LT_,nl_npp,nm_npp,ll_npp)
      call tesselation_size(tradius_min,0,v_p00_,v_0n0_,v_00n_,.true.
     $     ,n_point,L_,LT_,nl_pnn,nm_pnn,ll_pnn)
      call tesselation_size(tradius_min,0,v_p00_,v_0n0_,v_00p_,.false.
     $     ,n_point,L_,LT_,nl_pnp,nm_pnp,ll_pnp)
      call tesselation_size(tradius_min,0,v_p00_,v_0p0_,v_00n_,.false.
     $     ,n_point,L_,LT_,nl_ppn,nm_ppn,ll_ppn)
      call tesselation_size(tradius_min,0,v_p00_,v_0p0_,v_00p_,.true.
     $     ,n_point,L_,LT_,nl_ppp,nm_ppp,ll_ppp)
      nl_(0) = nl_nnn
      nl_(1) = nl_nnp
      nl_(2) = nl_npn
      nl_(3) = nl_npp
      nl_(4) = nl_pnn
      nl_(5) = nl_pnp
      nl_(6) = nl_ppn
      nl_(7) = nl_ppp
      nl_max = max_i4_f(8,nl_)
      nm_(0) = nm_nnn
      nm_(1) = nm_nnp
      nm_(2) = nm_npn
      nm_(3) = nm_npp
      nm_(4) = nm_pnn
      nm_(5) = nm_pnp
      nm_(6) = nm_ppn
      nm_(7) = nm_ppp
      nm_sum = sum_i4_f(8,nm_)
      ll_(0) = ll_nnn
      ll_(1) = ll_nnp
      ll_(2) = ll_npn
      ll_(3) = ll_npp
      ll_(4) = ll_pnn
      ll_(5) = ll_pnp
      ll_(6) = ll_ppn
      ll_(7) = ll_ppp
      ll_sum = sum_i4_f(8,ll_)
      if (verbose.gt.0) then
         write(6,'(A,I0,A,8(I0,1X))') 'n_point: ',n_point,' nl_: '
     $        ,(nl_(nl),nl=0,7)
         write(6,'(A,I0,A,I0)') 'n_point: ',n_point,' nl_max: ',nl_max
         write(6,'(A,I0,A,8(I0,1X))') 'n_point: ',n_point,' nm_: '
     $        ,(nm_(nm),nm=0,7)
         write(6,'(A,I0,A,I0)') 'n_point: ',n_point,' nm_sum: ',nm_sum
         write(6,'(A,I0,A,8(I0,1X))') 'n_point: ',n_point,' ll_: '
     $        ,(ll_(ll),ll=0,7)
         write(6,'(A,I0,A,I0)') 'n_point: ',n_point,' ll_sum: ',ll_sum
      end if                    !verbose
      timing_toc = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A,A,F8.4)') 'calling tesselation_size:'
     $        ,' total_time ',timing_toc-timing_tic
      end if

      if (verbose.gt.0) then
         write (6,'(A)') ' [finished tesselation_get_nl_nm_ll]'
      end if !if (verbose.gt.0) then

      deallocate(v_n00_)
      deallocate(v_0n0_)
      deallocate(v_00n_)
      deallocate(v_p00_)
      deallocate(v_0p0_)
      deallocate(v_00p_)

      deallocate(LT_) ! LT_(j) = j = index of L_(j)

      end
!> Doxygen comment: ;\n
!> For tesselation-tree. ;\n
!> Build index list for tesselation-tree. ;\n
      subroutine tesselation_index_wrapper_0(n_point,L_,tradius_min
     $     ,nl_max,nm_sum,ll_sum,T_nl_,T_vm_,T_tr_,T_ll_,T_lf_,T_c0_
     $     ,T_c1_,T_c2_,T_c3_,T_ls_,T_LT_,n_root_base,root_base_)
      implicit none
      include 'omp_lib.h'
      integer verbose
      data verbose / 0 /
      integer *4 n_point,npoint
      real *8 L_(0:3*n_point-1)
      integer *4, allocatable :: LT_(:) ! LT_(j) = j = index of point j within L_
      real *8 tradius_min
      real *8, allocatable :: v_n00_(:)
      real *8, allocatable :: v_0n0_(:)
      real *8, allocatable :: v_00n_(:)
      real *8, allocatable :: v_p00_(:)
      real *8, allocatable :: v_0p0_(:)
      real *8, allocatable :: v_00p_(:)
      integer *4 nl_nnn,nl_nnp,nl_npn,nl_npp
      integer *4 nl_pnn,nl_pnp,nl_ppn,nl_ppp
      integer *4 nl_(0:7),nl_max
      integer *4 nm_nnn,nm_nnp,nm_npn,nm_npp
      integer *4 nm_pnn,nm_pnp,nm_ppn,nm_ppp
      integer *4 nm_(0:7),nm_sum
      integer *4 ll_nnn,ll_nnp,ll_npn,ll_npp
      integer *4 ll_pnn,ll_pnp,ll_ppn,ll_ppp
      integer *4 ll_(0:7),ll_sum
      integer *4 nl,nm,ll
      integer *4 max_i4_f,sum_i4_f
      real *8 timing_tic,timing_toc
      integer *4 nl__in
      integer *4 index__input,index_output,index_output_old
      integer *4 ls__input,ls_output
      integer *4 index_parent
      integer *4 n_root_base,nroot_base
      real *8, allocatable :: v0_input_(:)
      real *8, allocatable :: v1_input_(:)
      real *8, allocatable :: v2_input_(:)
      logical parity_input

c$$$      preallocated T_ structure 
      integer *4 T_nl_(0:0) !level
      real *8    T_vm_(0:0) !vertex center
      real *8    T_tr_(0:0) !tradius
      integer *4 T_ll_(0:0) !number of points from L_ in T_
      logical    T_lf_(0:0) !is leaf
      integer *4 T_c0_(0:0) !child_0 tesselation_index
      integer *4 T_c1_(0:0) !child_1 tesselation_index
      integer *4 T_c2_(0:0) !child_2 tesselation_index
      integer *4 T_c3_(0:0) !child_3 tesselation_index
      integer *4 T_ls_(0:0) !starting index of point_index_list for T_ if leaf (leaves only)
      integer *4 T_LT_(0:0) !full point_index_list for all of T_ (leaves only)
c$$$      preallocated T_ roots
      integer *4 root_base_(0:0) !T_ roots

c$$$      remaining T_ structure
      integer *4, allocatable :: TL_(:) ! TL_(j) = tesselation_index associated with L_(j)
      logical   , allocatable :: T_up_(:) !parity
      integer *4, allocatable :: T_id_(:) !self tesselation_index
      integer *4, allocatable :: T_pa_(:) !parent tesselation_index
      real *8   , allocatable :: T_v0_(:) !vertex 0
      real *8   , allocatable :: T_v1_(:) !vertex 1
      real *8   , allocatable :: T_v2_(:) !vertex 2
      real *8   , allocatable :: T_m0_(:) !edge midpoint 0
      real *8   , allocatable :: T_m1_(:) !edge midpoint 1
      real *8   , allocatable :: T_m2_(:) !edge midpoint 2
      real *8   , allocatable :: T_e0_(:) !edge vector 0
      real *8   , allocatable :: T_e1_(:) !edge vector 1
      real *8   , allocatable :: T_e2_(:) !edge vector 2
      real *8   , allocatable :: T_n0_(:) !edge normal 0
      real *8   , allocatable :: T_n1_(:) !edge normal 1
      real *8   , allocatable :: T_n2_(:) !edge normal 2
      real *8   , allocatable :: T_nn_(:) !center normal

      if (verbose.gt.0) then
         write (6,'(A)') ' [entering tesselation_index_wrapper_0]'
      end if !if (verbose.gt.0) then

      allocate(LT_(0:n_point-1)) ! LT_(j) = j = index of L_(j)
      do npoint=0,n_point-1
         LT_(npoint) = npoint
      enddo !do npoint=0,n_point-1

      timing_tic = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A)') 'defining octants'
      end if ! if (verbose.gt.0) then
      allocate(v_n00_(0:2))
      allocate(v_0n0_(0:2))
      allocate(v_00n_(0:2))
      allocate(v_p00_(0:2))
      allocate(v_0p0_(0:2))
      allocate(v_00p_(0:2))
      call tesselation_define_octants(v_n00_,v_0n0_,v_00n_,v_p00_
     $     ,v_0p0_,v_00p_)
      timing_toc = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A,A,F8.4)') 'defining octants:'
     $        ,' total_time ',timing_toc-timing_tic
      end if

      timing_tic = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A)') 'allocating tesselation structure'
      end if ! if (verbose.gt.0) then
      allocate(TL_(0:n_point-1)) ! TL_(j) = tesselation_index associated with L_(j)
      allocate(T_up_(0:1*nm_sum-1)) !parity
      allocate(T_id_(0:1*nm_sum-1)) !self tesselation_index
      allocate(T_pa_(0:1*nm_sum-1)) !parent tesselation_index
      allocate(T_v0_(0:3*nm_sum-1)) !vertex 0
      allocate(T_v1_(0:3*nm_sum-1)) !vertex 1
      allocate(T_v2_(0:3*nm_sum-1)) !vertex 2
      allocate(T_m0_(0:3*nm_sum-1)) !edge midpoint 0
      allocate(T_m1_(0:3*nm_sum-1)) !edge midpoint 1
      allocate(T_m2_(0:3*nm_sum-1)) !edge midpoint 2
      allocate(T_e0_(0:3*nm_sum-1)) !edge vector 0
      allocate(T_e1_(0:3*nm_sum-1)) !edge vector 1
      allocate(T_e2_(0:3*nm_sum-1)) !edge vector 2
      allocate(T_n0_(0:3*nm_sum-1)) !edge normal 0
      allocate(T_n1_(0:3*nm_sum-1)) !edge normal 1
      allocate(T_n2_(0:3*nm_sum-1)) !edge normal 2
      allocate(T_nn_(0:3*nm_sum-1)) !center normal
      timing_toc = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A,A,F8.4)') 'allocating tesselation structure:'
     $        ,' total_time ',timing_toc-timing_tic
      end if

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index'
      end if ! if (verbose.gt.0) then

      allocate(v0_input_(0:3-1))
      allocate(v1_input_(0:3-1))
      allocate(v2_input_(0:3-1))
      index_output = 0
      ls_output = 0
      nl = 0
      n_root_base = 0

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index for octant nnn'
      end if ! if (verbose.gt.0) then      
      call cp1_r8(3,v_n00_,v0_input_)
      call cp1_r8(3,v_0n0_,v1_input_)
      call cp1_r8(3,v_00n_,v2_input_)
      parity_input = .false.
      index__input = index_output
      index_output_old = index_output
      ls__input = ls_output
      nl__in = 0
      call tesselation_index(tradius_min,nl_max,nl__in,
     $     v0_input_,v1_input_,v2_input_ , 
     $ parity_input ,
     $ n_point , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      if (index_output.gt.index_output_old) then
         if (verbose.gt.0) then
            write(6,'(A,I0,A,I0)') 'index_output: ' , index_output_old ,
     $           ' --> ' , index_output
         end if !if (verbose.gt.0) then
         root_base_(n_root_base) = index_output_old
         n_root_base = n_root_base + 1
      end if !if (index_output.gt.index_output_old) then

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index for octant nnp'
      end if ! if (verbose.gt.0) then      
      call cp1_r8(3,v_n00_,v0_input_)
      call cp1_r8(3,v_0n0_,v1_input_)
      call cp1_r8(3,v_00p_,v2_input_)
      parity_input = .true.
      index__input = index_output
      index_output_old = index_output
      ls__input = ls_output
      nl__in = 0
      call tesselation_index(tradius_min,nl_max,nl__in,
     $     v0_input_,v1_input_,v2_input_ , 
     $ parity_input ,
     $ n_point , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      if (index_output.gt.index_output_old) then
         if (verbose.gt.0) then
            write(6,'(A,I0,A,I0)') 'index_output: ' , index_output_old ,
     $           ' --> ' , index_output
         end if !if (verbose.gt.0) then
         root_base_(n_root_base) = index_output_old
         n_root_base = n_root_base + 1
      end if !if (index_output.gt.index_output_old) then

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index for octant npn'
      end if ! if (verbose.gt.0) then      
      call cp1_r8(3,v_n00_,v0_input_)
      call cp1_r8(3,v_0p0_,v1_input_)
      call cp1_r8(3,v_00n_,v2_input_)
      parity_input = .true.
      index__input = index_output
      index_output_old = index_output
      ls__input = ls_output
      nl__in = 0
      call tesselation_index(tradius_min,nl_max,nl__in,
     $     v0_input_,v1_input_,v2_input_ , 
     $ parity_input ,
     $ n_point , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      if (index_output.gt.index_output_old) then
         if (verbose.gt.0) then
            write(6,'(A,I0,A,I0)') 'index_output: ' , index_output_old ,
     $           ' --> ' , index_output
         end if !if (verbose.gt.0) then
         root_base_(n_root_base) = index_output_old
         n_root_base = n_root_base + 1
      end if !if (index_output.gt.index_output_old) then

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index for octant npp'
      end if ! if (verbose.gt.0) then      
      call cp1_r8(3,v_n00_,v0_input_)
      call cp1_r8(3,v_0p0_,v1_input_)
      call cp1_r8(3,v_00p_,v2_input_)
      parity_input = .false.
      index__input = index_output
      index_output_old = index_output
      ls__input = ls_output
      nl__in = 0
      call tesselation_index(tradius_min,nl_max,nl__in,
     $     v0_input_,v1_input_,v2_input_ , 
     $ parity_input ,
     $ n_point , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      if (index_output.gt.index_output_old) then
         if (verbose.gt.0) then
            write(6,'(A,I0,A,I0)') 'index_output: ' , index_output_old ,
     $           ' --> ' , index_output
         end if !if (verbose.gt.0) then
         root_base_(n_root_base) = index_output_old
         n_root_base = n_root_base + 1
      end if !if (index_output.gt.index_output_old) then

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index for octant pnn'
      end if ! if (verbose.gt.0) then      
      call cp1_r8(3,v_p00_,v0_input_)
      call cp1_r8(3,v_0n0_,v1_input_)
      call cp1_r8(3,v_00n_,v2_input_)
      parity_input = .true.
      index__input = index_output
      index_output_old = index_output
      ls__input = ls_output
      nl__in = 0
      call tesselation_index(tradius_min,nl_max,nl__in,
     $     v0_input_,v1_input_,v2_input_ , 
     $ parity_input ,
     $ n_point , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      if (index_output.gt.index_output_old) then
         if (verbose.gt.0) then
            write(6,'(A,I0,A,I0)') 'index_output: ' , index_output_old ,
     $           ' --> ' , index_output
         end if !if (verbose.gt.0) then
         root_base_(n_root_base) = index_output_old
         n_root_base = n_root_base + 1
      end if !if (index_output.gt.index_output_old) then

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index for octant pnp'
      end if ! if (verbose.gt.0) then      
      call cp1_r8(3,v_p00_,v0_input_)
      call cp1_r8(3,v_0n0_,v1_input_)
      call cp1_r8(3,v_00p_,v2_input_)
      parity_input = .false.
      index__input = index_output
      index_output_old = index_output
      ls__input = ls_output
      nl__in = 0
      call tesselation_index(tradius_min,nl_max,nl__in,
     $     v0_input_,v1_input_,v2_input_ , 
     $ parity_input ,
     $ n_point , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      if (index_output.gt.index_output_old) then
         if (verbose.gt.0) then
            write(6,'(A,I0,A,I0)') 'index_output: ' , index_output_old ,
     $           ' --> ' , index_output
         end if !if (verbose.gt.0) then
         root_base_(n_root_base) = index_output_old
         n_root_base = n_root_base + 1
      end if !if (index_output.gt.index_output_old) then

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index for octant ppn'
      end if ! if (verbose.gt.0) then      
      call cp1_r8(3,v_p00_,v0_input_)
      call cp1_r8(3,v_0p0_,v1_input_)
      call cp1_r8(3,v_00n_,v2_input_)
      parity_input = .false.
      index__input = index_output
      index_output_old = index_output
      ls__input = ls_output
      nl__in = 0
      call tesselation_index(tradius_min,nl_max,nl__in,
     $     v0_input_,v1_input_,v2_input_ , 
     $ parity_input ,
     $ n_point , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      if (index_output.gt.index_output_old) then
         if (verbose.gt.0) then
            write(6,'(A,I0,A,I0)') 'index_output: ' , index_output_old ,
     $           ' --> ' , index_output
         end if !if (verbose.gt.0) then
         root_base_(n_root_base) = index_output_old
         n_root_base = n_root_base + 1
      end if !if (index_output.gt.index_output_old) then

      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_index for octant ppp'
      end if ! if (verbose.gt.0) then      
      call cp1_r8(3,v_p00_,v0_input_)
      call cp1_r8(3,v_0p0_,v1_input_)
      call cp1_r8(3,v_00p_,v2_input_)
      parity_input = .true.
      index__input = index_output
      index_output_old = index_output
      ls__input = ls_output
      nl__in = 0
      call tesselation_index(tradius_min,nl_max,nl__in,
     $     v0_input_,v1_input_,v2_input_ , 
     $ parity_input ,
     $ n_point , L_ , LT_ , TL_ , 
     $ index_parent , index__input , ls__input ,
     $ T_nl_ , 
     $ T_up_ , 
     $ T_id_ , 
     $ T_pa_ , 
     $ T_v0_ , 
     $ T_v1_ , 
     $ T_v2_ , 
     $ T_vm_ , 
     $ T_m0_ , 
     $ T_m1_ , 
     $ T_m2_ , 
     $ T_e0_ , 
     $ T_e1_ , 
     $ T_e2_ , 
     $ T_n0_ , 
     $ T_n1_ , 
     $ T_n2_ , 
     $ T_nn_ , 
     $ T_tr_ , 
     $ T_ll_ , 
     $ T_lf_ , 
     $ T_c0_ , 
     $ T_c1_ , 
     $ T_c2_ , 
     $ T_c3_ , 
     $ T_ls_ ,
     $ T_LT_ ,
     $ index_output ,
     $ ls_output)
      if (index_output.gt.index_output_old) then
         if (verbose.gt.0) then
            write(6,'(A,I0,A,I0)') 'index_output: ' , index_output_old ,
     $           ' --> ' , index_output
         end if !if (verbose.gt.0) then
         root_base_(n_root_base) = index_output_old
         n_root_base = n_root_base + 1
      end if !if (index_output.gt.index_output_old) then

      if (verbose.gt.0) then
         write(6,'(A,I0)') 'n_root_base ' , n_root_base
         write(6,'(A,I0)') 'index_output ' , index_output
         write(6,'(A,I0)') 'ls_output ' , ls_output
      end if ! if (verbose.gt.0) then      

      timing_toc = omp_get_wtime()
      if (verbose.gt.0) then
         write(6,'(A,A,F8.4)') 'calling tesselation_index:'
     $        ,' total_time ',timing_toc-timing_tic
      end if

      if (verbose.gt.0) then
         write (6,'(A)') ' [finished tesselation_index_wrapper_0]'
      end if !if (verbose.gt.0) then

      deallocate(T_up_) !parity
      deallocate(T_id_) !self tesselation_index
      deallocate(T_pa_) !parent tesselation_index
      deallocate(T_v0_) !vertex 0
      deallocate(T_v1_) !vertex 1
      deallocate(T_v2_) !vertex 2
      deallocate(T_m0_) !edge midpoint 0
      deallocate(T_m1_) !edge midpoint 1
      deallocate(T_m2_) !edge midpoint 2
      deallocate(T_e0_) !edge vector 0
      deallocate(T_e1_) !edge vector 1
      deallocate(T_e2_) !edge vector 2
      deallocate(T_n0_) !edge normal 0
      deallocate(T_n1_) !edge normal 1
      deallocate(T_n2_) !edge normal 2
      deallocate(T_nn_) !center normal

      deallocate(v_n00_)
      deallocate(v_0n0_)
      deallocate(v_00n_)
      deallocate(v_p00_)
      deallocate(v_0p0_)
      deallocate(v_00p_)

      deallocate(LT_) ! LT_(j) = j = index of L_(j)

      end
!> Doxygen comment: ;\n
!> For tesselation-tree. ;\n
!> Finds neighborhood of a given tesselation element. ;\n
      subroutine tesselation_neighborhood_wrapper_0(n_point,L_ ,nl_max
     $     ,nm_sum,ll_sum,T_nl_,T_vm_,T_tr_ ,T_ll_,T_lf_,T_c0_,T_c1_
     $     ,T_c2_,T_c3_,T_ls_,T_LT_,n_root_base ,root_base_,vp_input_
     $     ,tesselation_distance_req,n_LT_unique,LT_unique_)
      implicit none
      integer verbose
      data verbose / 0 /
      integer *4 n_point,npoint
      real *8 L_(0:3*n_point-1)
      integer *4, allocatable :: LT_(:) ! LT_(j) = j = index of point j within L_
c$$$      real *8 diamater_min
      real *8, allocatable :: v_n00_(:)
      real *8, allocatable :: v_0n0_(:)
      real *8, allocatable :: v_00n_(:)
      real *8, allocatable :: v_p00_(:)
      real *8, allocatable :: v_0p0_(:)
      real *8, allocatable :: v_00p_(:)
      integer *4 nl_nnn,nl_nnp,nl_npn,nl_npp
      integer *4 nl_pnn,nl_pnp,nl_ppn,nl_ppp
      integer *4 nl_(0:7),nl_max
      integer *4 nm_nnn,nm_nnp,nm_npn,nm_npp
      integer *4 nm_pnn,nm_pnp,nm_ppn,nm_ppp
      integer *4 nm_(0:7),nm_sum
      integer *4 ll_nnn,ll_nnp,ll_npn,ll_npp
      integer *4 ll_pnn,ll_pnp,ll_ppn,ll_ppp
      integer *4 ll_(0:7),ll_sum
      integer *4 nl,nm,ll
      integer *4 max_i4_f,sum_i4_f
      real *8 timing_tic,timing_toc
      integer *4 nl__in
      integer *4 index__input,index_output,index_output_old
      integer *4 ls__input,ls_output
      integer *4 index_parent
      integer *4 n_root_base,nroot_base
      real *8, allocatable :: v0_input_(:)
      real *8, allocatable :: v1_input_(:)
      real *8, allocatable :: v2_input_(:)
      logical parity_input
      real *8 vp_input_(0:2),tesselation_distance_req
      integer *4 n_LT_neighborhood,nLT_neighborhood
      integer *4, allocatable :: LT_neighborhood_(:)
      integer *4 n_LT_unique,nLT_unique
      integer *4  LT_unique_(0:0)
      logical neighborhood_unique
      character(len=16) str_tmp

c$$$      preallocated T_ structure 
      integer *4 T_nl_(0:0) !level
      real *8    T_vm_(0:0) !vertex center
      real *8    T_tr_(0:0) !tradius
      integer *4 T_ll_(0:0) !number of points from L_ in T_
      logical    T_lf_(0:0) !is leaf
      integer *4 T_c0_(0:0) !child_0 tesselation_index
      integer *4 T_c1_(0:0) !child_1 tesselation_index
      integer *4 T_c2_(0:0) !child_2 tesselation_index
      integer *4 T_c3_(0:0) !child_3 tesselation_index
      integer *4 T_ls_(0:0) !starting index of point_index_list for T_ if leaf (leaves only)
      integer *4 T_LT_(0:0) !full point_index_list for all of T_ (leaves only)
c$$$      preallocated T_ roots
      integer *4 root_base_(0:0) !T_ roots

      if (verbose.gt.0) then
         write (6,'(A)')
     $        ' [entering tesselation_neighborhood_wrapper_0]'
      end if !if (verbose.gt.0) then

      allocate(LT_(0:n_point-1)) ! LT_(j) = j = index of L_(j)
      do npoint=0,n_point-1
         LT_(npoint) = npoint
      enddo !do npoint=0,n_point-1
      if (verbose.gt.0) then
         write(6,'(A)') 'allocating neighborhood list'
      end if ! if (verbose.gt.0) then
      allocate(LT_neighborhood_(0:ll_sum-1))

      timing_tic = second()
      if (verbose.gt.0) then
         write(6,'(A)') 'calling tesselation_neighborhood_wrapper_0'
      end if ! if (verbose.gt.0) then

      do nLT_neighborhood=0,ll_sum-1
         LT_neighborhood_(nLT_neighborhood)=-1
      enddo                     !do nLT_neighborhood=0,ll_sum-1
      n_LT_neighborhood = 0
      nl__in = 0
      do nroot_base=0,n_root_base-1
         index__input = root_base_(nroot_base)
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'nroot_base: ' , nroot_base ,
     $           ' index__input: ' , index__input
         end if                 ! if (verbose.gt.1) then
         call tesselation_neighborhood(
     $        nl_max , nl__in ,
     $        vp_input_ ,
     $        tesselation_distance_req ,
     $        n_point , L_ , 
     $        index__input , 
     $        T_nl_ , 
     $        T_vm_ , 
     $        T_tr_ , 
     $        T_ll_ , 
     $        T_lf_ , 
     $        T_c0_ , 
     $        T_c1_ , 
     $        T_c2_ , 
     $        T_c3_ , 
     $        T_ls_ ,
     $        T_LT_ ,
     $        n_LT_neighborhood ,
     $        LT_neighborhood_)
      enddo                     !do nroot_base=0,n_root_base-1
      call unique_i4(n_LT_neighborhood,LT_neighborhood_,n_LT_unique
     $     ,LT_unique_)
      if (n_LT_unique.eq.n_LT_neighborhood) then
         neighborhood_unique = .true.
         write(str_tmp,'(A)') '  '
      end if                    !if (n_LT_unique.eq.n_LT_neighborhood) then
      if (n_LT_unique.lt.n_LT_neighborhood) then
         neighborhood_unique = .false.
         write(str_tmp,'(A)') ' !'
      end if                    !if (n_LT_unique.lt.n_LT_neighborhood) then
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0,A)') ' n_LT_neighborhood: ' ,
     $        n_LT_neighborhood , ' --> n_LT_unique: ' , n_LT_unique ,
     $        str_tmp
         if (neighborhood_unique.eqv..false.) then
            write(6,*) (LT_neighborhood_(nLT_neighborhood) ,
     $           nLT_neighborhood=0 , n_LT_neighborhood-1)
            write(6,*) (LT_unique_(nLT_unique) ,
     $           nLT_unique=0 , n_LT_unique-1)
         end if                 !if (neighborhood_unique.eqv..false.) then
      end if                    ! if (verbose.gt.1) then         
      if (verbose.gt.1) then
         write(6,*) (LT_neighborhood_(nLT_neighborhood) ,
     $        nLT_neighborhood=0 , n_LT_neighborhood-1)
      end if                    ! if (verbose.gt.1) then         

      if (verbose.gt.0) then
         write (6,'(A)')
     $        ' [finished tesselation_neighborhood_wrapper_0]'
      end if !if (verbose.gt.0) then

      deallocate(LT_) ! LT_(j) = j = index of L_(j)
      deallocate(LT_neighborhood_)

      end
!> Doxygen comment: ;\n
!> map from hsv coordinates to rgb coordinates. ;\n
      subroutine hsv2rgb(h,s,v,r,g,b)
      real *8 h,s,v,r,g,b,f,p,q,t
      integer *4 i
      if (s.eq.0.0) then
         r=v
         g=v
         b=v
      else
         i=int(h/60.0)
         f=(h/60.0)-i
         p=v*(1.0-s)
         q=v*(1.0-s*f)
         t=v*(1-s*(1-f))
         if (i.eq.0) then
            r=v
            g=t
            b=p
         else if (i.eq.1) then
            r=q
            g=v
            b=p
         else if (i.eq.2) then
            r=p
            g=v
            b=t
         else if (i.eq.3) then
            r=p
            g=q
            b=v
         else if (i.eq.4) then
            r=t
            g=p
            b=v;
         else if (i.eq.5) then
            r=v
            g=p
            b=q
         end if
      end if
      end
!> Doxygen comment: ;\n
!> Simple colorscale to map interval into RGB vector. ;\n
      subroutine colorscale(val,valmin,valmax,rcolor,gcolor,bcolor)
      real *8 val,valmin,valmax,rcolor,gcolor,bcolor,valmin2,valmax2,v,h
      valmin2=valmin
      valmax2=valmax
      if (valmax2.le.valmin2) then
         valmax2 = valmin2+1.0;
      end if
      v=val
      if (v.le.valmin2) then
         v=valmin2
      end if
      if (v.ge.valmax2) then
         v=valmax2
      end if
c$$$      h = 300.0*(valmax2-v)/(valmax2-valmin2) - 180.0
      h = 300.0*(valmax2-v)/(valmax2-valmin2) - 60.0
      if (h.gt.360.0) then
         h=h-360.0
      end if
      if (h.lt.0.0) then
         h=h+360.0
      end if
      call hsv2rgb(h,1.0d0,1.0d0,rcolor,gcolor,bcolor)
      end
!> Doxygen comment: ;\n
!> Header for xfig figure generation. ;\n
      subroutine Fig_header(unitnumber)
      integer *4 unitnumber,nx
      real *8 rcolor,gcolor,bcolor
      character(len=20) fmtcccccc,fmtr,fmtg,fmtb,fmtc_,fmt_c
      integer *4 tmpcc,tmp_c,tmpc_
      write(unitnumber,'(A)') '#FIG 3.2'
      write(unitnumber,'(A)') 'Landscape'
      write(unitnumber,'(A)') 'Center'
      write(unitnumber,'(A)') 'Inches'
      write(unitnumber,'(A)') 'Letter'
      write(unitnumber,'(A)') '100.00'
      write(unitnumber,'(A)') 'Single'
      write(unitnumber,'(A)') '-2'
      write(unitnumber,'(A)') '1200 2'
      do nx=0,511
         call colorscale(1.0d0*nx,0.0d0,511.0d0,rcolor,gcolor,bcolor)
c$$$         if (nx.eq.0 .or. nx.eq.511) then
c$$$            write(6,'(I0,2X,F6.3,F6.3,F6.3)') nx,rcolor,gcolor,bcolor
c$$$         end if
         tmpcc = int(dmax1(0.0,dmin1(255.0,255.0*rcolor)))
         tmpc_ = tmpcc/16
         tmp_c = mod(tmpcc,16)
         if (tmpc_.lt.10) then
            write(fmtc_,'(I0)') tmpc_
         else if (tmpc_.ge.10) then
            write(fmtc_,'(A)') char(97+tmpc_-10)
         end if
         if (tmp_c.lt.10) then
            write(fmt_c,'(I0)') tmp_c
         else if (tmp_c.ge.10) then
            write(fmt_c,'(A)') char(97+tmp_c-10)
         end if
         fmtr = trim(fmtc_)//trim(fmt_c)
         tmpcc = int(dmax1(0.0,dmin1(255.0,255.0*gcolor)))
         tmpc_ = tmpcc/16
         tmp_c = mod(tmpcc,16)
         if (tmpc_.lt.10) then
            write(fmtc_,'(I0)') tmpc_
         else if (tmpc_.ge.10) then
            write(fmtc_,'(A)') char(97+tmpc_-10)
         end if
         if (tmp_c.lt.10) then
            write(fmt_c,'(I0)') tmp_c
         else if (tmp_c.ge.10) then
            write(fmt_c,'(A)') char(97+tmp_c-10)
         end if
         fmtg = trim(fmtc_)//trim(fmt_c)
         tmpcc = int(dmax1(0.0,dmin1(255.0,255.0*bcolor)))
         tmpc_ = tmpcc/16
         tmp_c = mod(tmpcc,16)
         if (tmpc_.lt.10) then
            write(fmtc_,'(I0)') tmpc_
         else if (tmpc_.ge.10) then
            write(fmtc_,'(A)') char(97+tmpc_-10)
         end if
         if (tmp_c.lt.10) then
            write(fmt_c,'(I0)') tmp_c
         else if (tmp_c.ge.10) then
            write(fmt_c,'(A)') char(97+tmp_c-10)
         end if
         fmtb = trim(fmtc_)//trim(fmt_c)
         fmtcccccc = trim(fmtr)//trim(fmtg)//trim(fmtb)
         write(unitnumber,'(A,I0,1X,A,A)') '0 ',(nx+32),'#',fmtcccccc
      enddo
      end
!> Doxygen comment: ;\n
!> Used to place text into an xfig figure. ;\n
      subroutine Fig_text(unitnumber,n_t,text,color_index,font_type
     $     ,font_size,x_loc,y_loc,x_offset,y_offset,x_side,y_side)
      integer *4 unitnumber,n_t
      real *8 x_loc,y_loc
      character text(0:n_t-1)
      integer *4 color_index,font_type,font_size
      real *8 x_offset,y_offset,x_side,y_side
      integer *4 diameter
      integer *4 xyval_(0:3)
      character(len=48) format_string
      write(format_string,'(A,I0,A)') '(A,I0,A,I0,1X,I0,A,(4(I0,1X)),('
     $     ,n_t,'(A)),A)'
      diameter = 1000
      xyval_(0) = 0
      xyval_(1) = 0
      xyval_(2) = +int(diameter*(x_loc*x_side + x_offset))
      xyval_(3) = -int(diameter*(y_loc*y_side + y_offset))
      write(unitnumber,format_string) '4 0 ' ,color_index,' 50 -1 '
     $     ,font_type,font_size,' 0.0000 4 ' ,(xyval_(j),j=0,3)
     $     ,text(0:n_t-1),'\001'
      end
!> Doxygen comment: ;\n
!> Recenters complex *16. ;\n
!> Note that this is only its own inverse when n_x and n_y are even! ;\n
!> Otherwise, use decenter_c16 to invert. ;\n
!> a+b = N
!> 0,1,2,...,a-1,a,a+1,...,N-1 --> a,a+1,a+2,...,a+a-1,0,1,...,n-a-1 ;\n
      subroutine recenter_c16(n_x,n_y,a_,b_)
      integer n_x,n_y,nx,ny,nxt,nyt
      complex *16 a_(0:n_x*n_y-1),b_(0:n_x*n_y-1)
      complex *16, allocatable :: c_(:)
      integer n_x_l,n_y_l
      integer n_x_u,n_y_u
      n_x_l = n_x/2
      n_y_l = n_y/2
      n_x_u = n_x - n_x_l
      n_y_u = n_y - n_y_l
      allocate(c_(0:n_x*n_y-1))
      do ny=0,n_y-1
         if (ny.lt.n_y_u) then
            nyt = ny + n_y_l
         else
            nyt = ny - n_y_l
         end if
         do nx=0,n_x-1
            if (nx.lt.n_x_u) then
               nxt = nx + n_x_l
            else
               nxt = nx - n_x_l
            end if
            c_(nxt+nyt*n_x) = a_(nx+ny*n_x)
         enddo
      enddo
      do ny=0,n_y-1
         do nx=0,n_x-1
            b_(nx+ny*n_x) = c_(nx+ny*n_x)
         enddo
      enddo
      deallocate(c_)
      end      
!> Doxygen comment: ;\n
!> Decenters complex *16. ;\n
!> Note that this is only its own inverse when n_x and n_y are even! ;\n
!> Otherwise, use recenter_c16 to invert. ;\n
!> a+b = N
!> 0,1,2,...,a-1,a,a+1,...,N-1 --> a,a+1,a+2,...,a+a-1,0,1,...,n-a-1 ;\n
      subroutine decenter_c16(n_x,n_y,a_,b_)
      integer n_x,n_y,nx,ny,nxt,nyt
      complex *16 a_(0:n_x*n_y-1),b_(0:n_x*n_y-1)
      complex *16, allocatable :: c_(:)
      integer n_x_l,n_y_l
      integer n_x_u,n_y_u
      n_x_l = n_x/2
      n_y_l = n_y/2
      n_x_u = n_x - n_x_l
      n_y_u = n_y - n_y_l
      allocate(c_(0:n_x*n_y-1))
      do ny=0,n_y-1
         if (ny.lt.n_y_l) then
            nyt = ny + n_y_u
         else
            nyt = ny - n_y_u
         end if
         do nx=0,n_x-1
            if (nx.lt.n_x_l) then
               nxt = nx + n_x_u
            else
               nxt = nx - n_x_u
            end if
            c_(nxt+nyt*n_x) = a_(nx+ny*n_x)
         enddo
      enddo
      do ny=0,n_y-1
         do nx=0,n_x-1
            b_(nx+ny*n_x) = c_(nx+ny*n_x)
         enddo
      enddo
      deallocate(c_)
      end      
!> Doxygen comment: ;\n
!> Generates an xfig figure. ;\n
!> Uses fig2dev to convert to jpeg. ;\n
      subroutine Fig_c16_carte(unitnumber,n_x,grid_x_c_,n_y,grid_y_c_
     $     ,real_or_imag,F_,Fmin,Fmax,x_offset,y_offset,x_side,y_side)
      implicit none
      integer *4 unitnumber
      integer *4 n_x,n_y
      real *8 grid_x_c_(0:n_x-1),grid_y_c_(0:n_y-1)
      logical real_or_imag
      complex *16 F_(0:n_x*n_y-1)
      real *8 Fmin,Fmax
      real *8 x_offset,y_offset,x_side,y_side
      real *8 F_avg,F_std,Fmin_use,Fmax_use
      complex *16, allocatable :: T_(:)
      real *8 x_pos,y_pos,x_pre,y_pre
      integer *4 diameter,nx,ny,nd
      integer *4 xyval_(0:9)
      integer *4 color_index
      character(len=20) format_string
      allocate(T_(0:n_x*n_y-1))
      call recenter_c16(n_x,n_y,F_,T_)
      write(format_string,'(A,I0,A)') '(A,1X,',10,'(I0,1X))'
      Fmin_use = Fmin
      Fmax_use = Fmax
      if (Fmin_use.ge.Fmax_use) then
         call stdlim_c16(n_x*n_y,real_or_imag,F_,F_avg,F_std)
         Fmin_use = F_avg - 2.0*F_std
         Fmax_use = F_avg + 2.0*F_std
      end if
      diameter = 1000
      do ny=0,n_y-1
         if (ny.gt.0) then
            y_pre = 0.5*(grid_y_c_(ny-1) + grid_y_c_(ny))
         else
            y_pre = grid_y_c_(0)
         end if
         if (ny.lt.n_y-1) then
            y_pos = 0.5*(grid_y_c_(ny) + grid_y_c_(ny+1))
         else
            y_pos = grid_y_c_(n_y-1)
         end if
         do nx=0,n_x-1
            if (nx.gt.0) then
               x_pre = 0.5*(grid_x_c_(nx-1) + grid_x_c_(nx))
            else
               x_pre = grid_x_c_(0)
            end if
            if (nx.lt.n_x-1) then
               x_pos = 0.5*(grid_x_c_(nx) + grid_x_c_(nx+1))
            else
               x_pos = grid_x_c_(n_x-1)
            end if
            xyval_(0 + 2*0) = +int(diameter*(x_pre*x_side + x_offset))
            xyval_(1 + 2*0) = -int(diameter*(y_pre*y_side + y_offset))
            xyval_(0 + 2*1) = +int(diameter*(x_pos*x_side + x_offset))
            xyval_(1 + 2*1) = -int(diameter*(y_pre*y_side + y_offset))
            xyval_(0 + 2*2) = +int(diameter*(x_pos*x_side + x_offset))
            xyval_(1 + 2*2) = -int(diameter*(y_pos*y_side + y_offset))
            xyval_(0 + 2*3) = +int(diameter*(x_pre*x_side + x_offset))
            xyval_(1 + 2*3) = -int(diameter*(y_pos*y_side + y_offset))
            xyval_(0 + 2*4) = +int(diameter*(x_pre*x_side + x_offset))
            xyval_(1 + 2*4) = -int(diameter*(y_pre*y_side + y_offset))
            if (real_or_imag.eqv..true.) then
               color_index = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(real(T_(nx+ny*n_x))-Fmin_use)/(Fmax_use
     $              -Fmin_use))))
            else
               color_index = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(aimag(T_(nx+ny*n_x))-Fmin_use)/(Fmax_use
     $              -Fmin_use))))
            end if
            write(unitnumber,'(A,I0,A,I0)') '2 3 0 0 0 ',color_index
     $           ,' 50 -1 20 0.000 0 0 -1 0 0 ',5
            write(unitnumber,format_string) char(9),(xyval_(nd),nd=0,9)
         enddo
      enddo
      deallocate(T_)
      end
!> Doxygen comment: ;\n
!> Generates an xfig figure. ;\n
!> Uses fig2dev to convert to jpeg. ;\n
      subroutine Fig_c16_polar(unitnumber,n_r,grid_x_p_,n_t_
     $     ,real_or_imag,F_ ,Fmin,Fmax,x_offset,y_offset,x_side,y_side)
      implicit none
      real *8 pi
      integer *4 unitnumber,n_r,n_t_(0:n_r-1)
      real *8 grid_x_p_(0:n_r-1)
      logical real_or_imag
      complex *16 F_(0:0)
      real *8 Fmax,Fmin
      real *8 x_offset,y_offset,x_side,y_side
      real *8 F_avg,F_std,Fmin_use,Fmax_use
      real *8 xval_tmp,yval_tmp
      real *8 rval_pre,tval_pre,rval_pos,tval_pos,tval_mid
      integer *4 diameter,arclength
      integer *4 nr,nt,n_A,na,narc,nd
      real *8, allocatable :: tvals_(:)
      integer *4, allocatable :: y_(:)
      integer *4, allocatable :: xyval_(:)
      character(len=20) format_string
      pi = 4*atan(1.0)
      n_A=0
      do nr=0,n_r-1
         n_A = n_A + n_t_(nr)
      enddo
      Fmin_use = Fmin
      Fmax_use = Fmax
      if (Fmin_use.ge.Fmax_use) then
         call stdlim_c16(n_A,real_or_imag,F_,F_avg,F_std)
         Fmin_use = F_avg - 2.0*F_std
         Fmax_use = F_avg + 2.0*F_std
      end if
      allocate(tvals_(0:n_A-1))
      na=0
      do nr=0,n_r-1
         do nt=0,n_t_(nr)-1
            tvals_(na) = 2.0*pi*(1.0*nt)/(1.0*n_t_(nr))
            na = na + 1;
         enddo
      enddo
      allocate(y_(0:n_A-1));
      na=0
      do nr=0,n_r-1
         do nt=0,n_t_(nr)-1
            if (real_or_imag.eqv..true.) then
               y_(na) = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(real(F_(na))-Fmin_use)/(Fmax_use-Fmin_use))))
            else
               y_(na) = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(aimag(F_(na))-Fmin_use)/(Fmax_use-Fmin_use))))
            end if
            na = na + 1;
         enddo
      enddo
      diameter = 1000
      arclength = 8
      allocate(xyval_(0:4*arclength+1))
      write(format_string,'(A,I0,A)') '(A,1X,',(4*arclength+2)
     $     ,'(I0,1X))'
      na=0
      do nr=0,n_r-1
         if (nr.gt.0) then
            rval_pre = 0.5*(grid_x_p_(nr) + grid_x_p_(nr-1))
         else
            rval_pre = grid_x_p_(0)
         end if
         if (nr.lt.n_r-1) then
            rval_pos = 0.5*(grid_x_p_(nr+1) + grid_x_p_(nr))
         else 
            rval_pos = grid_x_p_(n_r-1)
         end if
         do nt=0,n_t_(nr)-1
            if (nt.gt.0) then
               tval_pre = 0.5*(tvals_(na) + tvals_(na-1))
            else
               tval_pre = 0.5*(tvals_(na) + tvals_(na+n_t_(nr)-1) - 2
     $              *pi)
            end if
            if (nt.lt.n_t_(nr)-1) then
               tval_pos = 0.5*(tvals_(na+1) + tvals_(na))
            else
               tval_pos = 0.5*(tvals_(na-n_t_(nr)+1) + 2*pi +
     $              tvals_(na))
            end if
            do narc=0,arclength-1
               tval_mid = (narc*tval_pos + (arclength-1-narc)*tval_pre)
     $              /(arclength-1)
               xyval_(0 + 2*narc) = +int(diameter*(rval_pre
     $              *cos(tval_mid)*x_side + x_offset))
               xyval_(1 + 2*narc) = -int(diameter*(rval_pre
     $              *sin(tval_mid)*y_side + y_offset))
            enddo
            do narc=0,arclength-1
               tval_mid = (narc*tval_pre + (arclength-1-narc)*tval_pos)
     $              /(arclength-1)
               xyval_(0 + 2*narc + 2*arclength) = +int(diameter
     $              *(rval_pos*cos(tval_mid)*x_side + x_offset))
               xyval_(1 + 2*narc + 2*arclength) = -int(diameter
     $              *(rval_pos*sin(tval_mid)*y_side + y_offset))
            enddo
            xyval_(4*arclength+0) = +int(diameter*(rval_pre
     $           *cos(tval_pre)*x_side + x_offset))
            xyval_(4*arclength+1) = -int(diameter*(rval_pre
     $           *sin(tval_pre)*y_side + y_offset))
            write(unitnumber,'(A,I0,A,I0)') '2 3 0 0 0 ',y_(na)
     $           ,' 50 -1 20 0.000 0 0 -1 0 0 ',(2*arclength+1)
            write(unitnumber,format_string) char(9),(xyval_(nd),nd=0,4
     $           *arclength+1)
            na = na + 1;
         enddo
      enddo
      deallocate(xyval_)
      deallocate(y_)
      deallocate(tvals_)
      end

!> Doxygen comment: ;\n
!> Generates an xfig figure. ;\n
!> Uses fig2dev to convert to jpeg. ;\n
      subroutine Fig_c16_bessl(unitnumber,n_r,grid_x_p_,n_t_
     $     ,real_or_imag,F_ ,Fmin,Fmax,x_offset,y_offset,x_side,y_side)
      implicit none
      integer *4 unitnumber,n_r,n_t_(0:n_r-1)
      real *8 grid_x_p_(0:n_r-1)
      logical real_or_imag
      complex *16 F_(0:0)
      real *8 Fmax,Fmin
      real *8 x_offset,y_offset,x_side,y_side
      real *8 F_avg,F_std,Fmin_use,Fmax_use
      real *8 r_pre,r_pos,q_pre,q_pos
      integer *4 diameter
      integer *4 nr,nt,n_A,na,ntmax,nd
      integer *4 xyval_(0:9),j
      integer *4, allocatable :: y_(:)
      character(len=20) format_string
      n_A=0
      ntmax=0
      do nr=0,n_r-1
         n_A = n_A + n_t_(nr)
         if (n_t_(nr).gt.ntmax) then
            ntmax = n_t_(nr)
         end if
      enddo
      Fmin_use = Fmin
      Fmax_use = Fmax
      if (Fmin_use.ge.Fmax_use) then
         call stdlim_c16(n_A,real_or_imag,F_,F_avg,F_std)
         Fmin_use = F_avg - 2.0*F_std
         Fmax_use = F_avg + 2.0*F_std
      end if
      allocate(y_(0:n_A-1));
      na=0
      do nr=0,n_r-1
         do nt=0,n_t_(nr)-1
            if (real_or_imag.eqv..true.) then
               y_(na) = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(real(F_(na))-Fmin_use)/(Fmax_use-Fmin_use))))
            else
               y_(na) = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(aimag(F_(na))-Fmin_use)/(Fmax_use-Fmin_use))))
            end if
            na = na + 1;
         enddo
      enddo
      diameter = 1000
      write(format_string,'(A,I0,A)') '(A,1X,',10,'(I0,1X))'
      na=0
      do nr=0,n_r-1
         if (nr.gt.0) then
            r_pre = 2.0*0.5*(grid_x_p_(nr) + grid_x_p_(nr-1))
         else
            r_pre = 2.0*grid_x_p_(0)
         end if
         if (nr.lt.n_r-1) then
            r_pos = 2.0*0.5*(grid_x_p_(nr+1) + grid_x_p_(nr))
         else 
            r_pos = 2.0*grid_x_p_(n_r-1)
         end if
         do nt=0,n_t_(nr)-1
            if (nt.ge.n_t_(nr)/2) then
               q_pre = 0.5 + 0.5*(1.0d0*(nt+0-1*n_t_(nr)))/(0.5d0*ntmax)
               q_pos = 0.5 + 0.5*(1.0d0*(nt+1-1*n_t_(nr)))/(0.5d0*ntmax)
            else
               q_pre = 0.5 + 0.5*(1.0d0*(nt+0-0*n_t_(nr)))/(0.5d0*ntmax)
               q_pos = 0.5 + 0.5*(1.0d0*(nt+1-0*n_t_(nr)))/(0.5d0*ntmax)
            end if
            xyval_(0 + 2*0) = +int(diameter*(r_pre*x_side + x_offset))
            xyval_(1 + 2*0) = -int(diameter*(q_pre*y_side + y_offset))
            xyval_(0 + 2*1) = +int(diameter*(r_pos*x_side + x_offset))
            xyval_(1 + 2*1) = -int(diameter*(q_pre*y_side + y_offset))
            xyval_(0 + 2*2) = +int(diameter*(r_pos*x_side + x_offset))
            xyval_(1 + 2*2) = -int(diameter*(q_pos*y_side + y_offset))
            xyval_(0 + 2*3) = +int(diameter*(r_pre*x_side + x_offset))
            xyval_(1 + 2*3) = -int(diameter*(q_pos*y_side + y_offset))
            xyval_(0 + 2*4) = +int(diameter*(r_pre*x_side + x_offset))
            xyval_(1 + 2*4) = -int(diameter*(q_pre*y_side + y_offset))
            write(unitnumber,'(A,I0,A,I0)') '2 3 0 0 0 ',y_(na)
     $           ,' 50 -1 20 0.000 0 0 -1 0 0 ',5
            write(unitnumber,format_string) char(9),(xyval_(nd),nd=0,9)
            na = na + 1;
         enddo
      enddo
      deallocate(y_)
      end

!> Doxygen comment: ;\n
!> Generates an xfig figure. ;\n
!> Uses fig2dev to convert to jpeg. ;\n
      subroutine Fig_c16_bess2(unitnumber,n_r,grid_x_p_,n_t_
     $     ,real_or_imag,F_ ,Fmin,Fmax,x_offset,y_offset,x_side,y_side)
c$$$      expanding q-axis for visibility
c$$$      rows no longer align equivalent q-values as r varies
      implicit none
      integer *4 unitnumber,n_r,n_t_(0:n_r-1)
      real *8 grid_x_p_(0:n_r-1)
      logical real_or_imag
      complex *16 F_(0:0)
      real *8 Fmax,Fmin
      real *8 x_offset,y_offset,x_side,y_side
      real *8 F_avg,F_std,Fmin_use,Fmax_use
      real *8 r_pre,r_pos,q_pre,q_pos
      integer *4 diameter
      integer *4 nr,nt,n_A,na,ntmax,nd
      integer *4 xyval_(0:9)
      integer *4, allocatable :: y_(:)
      character(len=20) format_string
      n_A=0
c$$$      ntmax is not actually used
      ntmax=0
      do nr=0,n_r-1
         n_A = n_A + n_t_(nr)
         if (n_t_(nr).gt.ntmax) then
            ntmax = n_t_(nr)
         end if
      enddo
      Fmin_use = Fmin
      Fmax_use = Fmax
      if (Fmin_use.ge.Fmax_use) then
         call stdlim_c16(n_A,real_or_imag,F_,F_avg,F_std)
         Fmin_use = F_avg - 2.0*F_std
         Fmax_use = F_avg + 2.0*F_std
      end if
      allocate(y_(0:n_A-1));
      na=0
      do nr=0,n_r-1
         do nt=0,n_t_(nr)-1
            if (real_or_imag.eqv..true.) then
               y_(na) = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(real(F_(na))-Fmin_use)/(Fmax_use-Fmin_use))))
            else
               y_(na) = 32 + int(dmax1(0.0,dmin1(511.0,511.0
     $              *(aimag(F_(na))-Fmin_use)/(Fmax_use-Fmin_use))))
            end if
            na = na + 1;
         enddo
      enddo
      diameter = 1000
      write(format_string,'(A,I0,A)') '(A,1X,',10,'(I0,1X))'
      na=0
      do nr=0,n_r-1
         if (nr.gt.0) then
            r_pre = 2.0*0.5*(grid_x_p_(nr) + grid_x_p_(nr-1))
         else
            r_pre = 2.0*grid_x_p_(0)
         end if
         if (nr.lt.n_r-1) then
            r_pos = 2.0*0.5*(grid_x_p_(nr+1) + grid_x_p_(nr))
         else 
            r_pos = 2.0*grid_x_p_(n_r-1)
         end if
         do nt=0,n_t_(nr)-1
            if (nt.ge.n_t_(nr)/2) then
               q_pre = 0.5 + 0.5*(1.0d0*(nt+0-1*n_t_(nr)))/(0.5d0
     $              *n_t_(nr))
               q_pos = 0.5 + 0.5*(1.0d0*(nt+1-1*n_t_(nr)))/(0.5d0
     $              *n_t_(nr))
            else
               q_pre = 0.5 + 0.5*(1.0d0*(nt+0-0*n_t_(nr)))/(0.5d0
     $              *n_t_(nr))
               q_pos = 0.5 + 0.5*(1.0d0*(nt+1-0*n_t_(nr)))/(0.5d0
     $              *n_t_(nr))
            end if
            xyval_(0 + 2*0) = +int(diameter*(r_pre*x_side + x_offset))
            xyval_(1 + 2*0) = -int(diameter*(q_pre*y_side + y_offset))
            xyval_(0 + 2*1) = +int(diameter*(r_pos*x_side + x_offset))
            xyval_(1 + 2*1) = -int(diameter*(q_pre*y_side + y_offset))
            xyval_(0 + 2*2) = +int(diameter*(r_pos*x_side + x_offset))
            xyval_(1 + 2*2) = -int(diameter*(q_pos*y_side + y_offset))
            xyval_(0 + 2*3) = +int(diameter*(r_pre*x_side + x_offset))
            xyval_(1 + 2*3) = -int(diameter*(q_pos*y_side + y_offset))
            xyval_(0 + 2*4) = +int(diameter*(r_pre*x_side + x_offset))
            xyval_(1 + 2*4) = -int(diameter*(q_pre*y_side + y_offset))
            write(unitnumber,'(A,I0,A,I0)') '2 3 0 0 0 ',y_(na)
     $           ,' 50 -1 20 0.000 0 0 -1 0 0 ',5
            write(unitnumber,format_string) char(9),(xyval_(nd),nd=0,9)
            na = na + 1;
         enddo
      enddo
      deallocate(y_)
      end

!> Doxygen comment: ;\n
!> Generates an xfig figure. ;\n
!> Uses fig2dev to convert to jpeg. ;\n
!> Reads in a few templates and images and plots a comparison. ;\n
      subroutine Fig_gen_ver8(ncur,nlats_,grid_k_p_,n_S,I_S_sample_,ld_S
     $     ,S_k_p_,n_M,I_M_sample_,ld_M,M_k_p_,ld_CTF,CTF_k_p_
     $     ,alpha_est_,n_M_sample,prefix)
c$$$      Reads in a few templates and images and plots a comparison
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      data verbose / 0 /
      logical plot_flag
      integer *4 ncur,nlats_(0:ncur-1)
      integer *4 n_S,ld_S,n_M,ld_M,ld_CTF,n_M_sample
      integer *4 I_S_sample_(0:n_S-1),I_M_sample_(0:n_M-1)
      real *8 grid_k_p_(0:0)
      real *8 alpha_est_(0:0)
      include 'nalpha_define.f'
      complex *16 S_k_p_(0:0),M_k_p_(0:0),CTF_k_p_(0:0)
      character(len=1024) prefix
      integer *4 ntemplatesize
      integer *4, allocatable :: ngridc_(:)
      integer *4, allocatable :: icstart_(:)
c$$$      indices
      integer *4 n_r,nr,n_w_max,n_A,na,ns,nm,nctf,nM_sample
      integer *4, allocatable :: n_w_(:)
c$$$      temporary storage for templates and images
      complex *16, allocatable :: T_k_p_(:)
      real *8 pi
      real *8 max_r8_f
      real *8 max_k_c
      real *8 delta_x_est,delta_y_est,gamma_z_est
      real *8 delta_x_tmp,delta_y_tmp
      real *8 delta_x,delta_y,gamma_z
      character(len=64) format_string
c$$$      parameters for figure generation
      character(len=1024) fig_title,fname_pre,fname_fig,fname_jpg
      integer unitnumber,text_length,color_index,font_type,font_size
      real *8 F_avg,F_std,F_max,F_min
      real *8 x_loc,y_loc,x_side,y_side,x_offset,y_offset
      character(len=1024) fig2dev_system_call
      integer system,system_error

      if (verbose.gt.0) then
          write(6,'(A)')
     $        '[entering Fig_gen_ver8]: '
       end if
       if (verbose.gt.1) then
         write(6,'(A,I0)') 'verbose: ',verbose
         write(6,'(A,I0)') 'ncur: ',ncur
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'nlats_: ',(nlats_(nr),nr=0,ncur-1)
         write(format_string,'(A,I0,A)') '(A,',ncur,'(F8.3,1X))'
         write(6,format_string) 'grid_k_p_: ',(grid_k_p_(nr),nr=0,ncur
     $        -1)
         write(6,'(A,I0)') 'n_S: ',n_S
         write(6,'(A,I0)') 'ld_S: ',ld_S
         write(6,'(A,I0)') 'n_M: ',n_M
         write(6,'(A,I0)') 'ld_M: ',ld_M
         write(6,'(A,I0)') 'ld_CTF: ',ld_CTF
         write(6,'(A,I0)') 'n_M_sample: ',n_M_sample
         write(6,'(A)') trim(prefix)
      end if

      pi = 4*atan(1.0)

c$$$      Calculating template size using 'get_template_size'
      allocate(ngridc_(ncur))
      allocate(icstart_(ncur))
      if (verbose.gt.1) then
         write(6,'(A,I0,A,A)') 'ncur = ',ncur
     $        ,'; calling get_template_size to'
     $        ,' determine ngridc_ and ntemplatesize'
      end if
      call get_template_size(nlats_,ncur,ntemplatesize,ngridc_,icstart_)
      if (verbose.gt.1) then
         write(6,'(A,I0)') 'ntemplatesize = ',ntemplatesize
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'ngridc_: ',(ngridc_(nr),nr=1,ncur)
      end if
      
c$$$      indices
      n_r = ncur
      if (n_r.lt.2) then
         write(6,'(A,I0,A)') 'Error n_r',n_r,'<2'
      end if
      allocate(n_w_(0:n_r-1))
      n_A = 0
      do nr=0,n_r-1
         n_w_(nr) = ngridc_(1+nr)
         n_A = n_A + n_w_(nr)
      enddo
      n_w_max = n_w_(nr-1)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0)') 'n_w_max ',n_w_max,'; n_A ',n_A
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'n_w_: ',(n_w_(nr),nr=0,ncur-1)
      end if
      
c$$$      generating grids for templates and images 
      max_k_c = 2*grid_k_p_(n_r-1)

c$$$      allocating temporary storage for images and templates 
      allocate(T_k_p_(0:n_A-1))

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We initialize the first figure file.' 
      end if

      unitnumber = 7
      write(fname_pre,'(A)') trim(prefix)
      write(fname_fig,'(A,A)') trim(fname_pre),'.fig'
      write(fname_jpg,'(A,A)') trim(fname_pre),'.jpg'
      open(unitnumber,file=fname_fig,status='replace' ,form='formatted')
      call Fig_header(unitnumber);

      if (verbose.gt.1) then
         write(6,'(A)') ''
         write(6,'(A)')
     $        'We display the images on a k-space polar grid'
     $        ,' along with their best matching (transformed) templates'
     $        ,' also on a k-space polar grid.'
      end if
c$$$      printing templates and images
      do nM_sample=0,n_M_sample-1
         nm = floor((n_M*nM_sample*1.0d0)/(n_M_sample*1.0d0))
         nctf = nint(alpha_est_(nalpha_ctf_ind + nm*n_alpha))
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'sample ',nM_sample,' is image ',nm
            write(6,'(A,I0,A,I0)') 'sample ',nM_sample,' has ctf ',nctf
         end if
c$$$         Display image with ctf
         call stdlim_c16(n_A,.true.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(M_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(M_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$         Pick best matching template
         ns = nint(alpha_est_(nalpha_S_index + nm*n_alpha))
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'Best match to image ',nm,' is ',ns
         end if
c$$$         Display template without perturbation
         ns = nint(alpha_est_(nalpha_S_index + nm*n_alpha))
         call cp1_c16(n_A,S_k_p_(I_S_sample_(ns)*ld_S),T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 67.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(S_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 67.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(S_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$         Display template with perturbation but no ctf
         ns = nint(alpha_est_(nalpha_S_index + nm*n_alpha))
         delta_x_est = alpha_est_(nalpha_delta_x + nm*n_alpha)
         delta_y_est = alpha_est_(nalpha_delta_y + nm*n_alpha)
         gamma_z_est = alpha_est_(nalpha_gamma_z + nm*n_alpha)
         call cp1_c16(n_A,S_k_p_(I_S_sample_(ns)*ld_S),T_k_p_)
         call transf_p_to_p(n_r,grid_k_p_,n_w_,n_A,T_k_p_,+delta_x_est,
     $        +delta_y_est,T_k_p_)
         call rotate_p2p_fz(n_r,n_w_,n_A,T_k_p_,+gamma_z_est,T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 45.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(T_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 45.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(T_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$         Display template with perturbation and ctf
         ns = nint(alpha_est_(nalpha_S_index + nm*n_alpha))
         delta_x_est = alpha_est_(nalpha_delta_x + nm*n_alpha)
         delta_y_est = alpha_est_(nalpha_delta_y + nm*n_alpha)
         gamma_z_est = alpha_est_(nalpha_gamma_z + nm*n_alpha)
         call cp1_c16(n_A,S_k_p_(I_S_sample_(ns)*ld_S),T_k_p_)
         call transf_p_to_p(n_r,grid_k_p_,n_w_,n_A,T_k_p_,+delta_x_est,
     $        +delta_y_est,T_k_p_)
         call rotate_p2p_fz(n_r,n_w_,n_A,T_k_p_,+gamma_z_est,T_k_p_)
         call xx1_c16(n_A,T_k_p_,CTF_k_p_(nctf*ld_CTF),T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(CT_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 19
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(CT_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 19
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
      enddo

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We write the figure file to disk.'
         write(6,'(A,A)') 'try: '
     $        ,'"gthumb ?.jpg"'
      end if
c$$$      Printing figure file for image
      close(unitnumber,status='keep')
      write(fig2dev_system_call,'(A,A,1X,A)') 'fig2dev -Ljpeg -q 10 '
     $     ,trim(fname_fig),trim(fname_jpg)
      system_error = system(fig2dev_system_call)

      deallocate(T_k_p_)
      deallocate(n_w_)
      deallocate(ngridc_)
      deallocate(icstart_)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished Fig_gen_ver8]'
      end if

      end
!> Doxygen comment: ;\n
!> Generates an xfig figure. ;\n
!> Uses fig2dev to convert to jpeg. ;\n
!> Reads in a few ctfs and plots them ;\n
!> In this function the 'S' label is used to refer to ctf-functions ;\n
      subroutine Fig_gen_ctf_ver0(ncur,nlats_,grid_k_p_,n_S,ld_S,S_k_p_
     $     ,prefix)
c$$$      Reads in a few ctfs and plots them
c$$$      In this function the 'S' label is used to refer to ctf-functions
      implicit none
      integer verbose
      data verbose / 0 /
      logical plot_flag
      integer *4 ncur,nlats_(0:ncur-1),n_S,ld_S
      real *8 grid_k_p_(0:0)
      complex *16 S_k_p_(0:0)
      character(len=1024) prefix
      integer *4 ntemplatesize
      integer *4, allocatable :: ngridc_(:)
      integer *4, allocatable :: icstart_(:)
c$$$      indices
      integer *4 n_r,nr,n_w_max,n_A,na,ns
      integer *4, allocatable :: n_w_(:)
      real *8 pi
      real *8 max_k_c
      character(len=64) format_string
c$$$      parameters for figure generation
      character(len=1024) fig_title,fname_pre,fname_fig,fname_jpg
      integer unitnumber,text_length,color_index,font_type,font_size
      real *8 F_avg,F_std,F_max,F_min
      real *8 x_loc,y_loc,x_side,y_side,x_offset,y_offset
      character(len=1024) fig2dev_system_call
      integer system,system_error

      if (verbose.gt.0) then
          write(6,'(A)')
     $        '[entering Fig_gen_ctf_ver0]: '
       end if
       if (verbose.gt.1) then
         write(6,'(A,I0)') 'verbose: ',verbose
         write(6,'(A,I0)') 'ncur: ',ncur
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'nlats_: ',(nlats_(nr),nr=0,ncur-1)
         write(format_string,'(A,I0,A)') '(A,',ncur,'(F8.3,1X))'
         write(6,format_string) 'grid_k_p_: ',(grid_k_p_(nr),nr=0,ncur
     $        -1)
         write(6,'(A,I0)') 'n_S: ',n_S
         write(6,'(A,I0)') 'ld_S: ',ld_S
         write(6,'(A)') trim(prefix)
      end if

      pi = 4*atan(1.0)

c$$$      Calculating ctf-function size using 'get_template_size'
      allocate(ngridc_(ncur))
      allocate(icstart_(ncur))
      if (verbose.gt.1) then
         write(6,'(A,I0,A,A)') 'ncur = ',ncur
     $        ,'; calling get_template_size to'
     $        ,' determine ngridc_ and ntemplatesize'
      end if
      call get_template_size(nlats_,ncur,ntemplatesize,ngridc_,icstart_)
      if (verbose.gt.1) then
         write(6,'(A,I0)') 'ntemplatesize = ',ntemplatesize
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'ngridc_: ',(ngridc_(nr),nr=1,ncur)
      end if
      
c$$$      indices
      n_r = ncur
      if (n_r.lt.2) then
         write(6,'(A,I0,A)') 'Error n_r',n_r,'<2'
      end if
      allocate(n_w_(0:n_r-1))
      n_A = 0
      do nr=0,n_r-1
         n_w_(nr) = ngridc_(1+nr)
         n_A = n_A + n_w_(nr)
      enddo
      n_w_max = n_w_(nr-1)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0)') 'n_w_max ',n_w_max,'; n_A ',n_A
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'n_w_: ',(n_w_(nr),nr=0,ncur-1)
      end if
      
c$$$      generating grids for ctf-function
      max_k_c = 2*grid_k_p_(n_r-1)

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We initialize the first figure file.' 
      end if

      unitnumber = 7
      write(fname_pre,'(A)') trim(prefix)
      write(fname_fig,'(A,A)') trim(fname_pre),'.fig'
      write(fname_jpg,'(A,A)') trim(fname_pre),'.jpg'
      open(unitnumber,file=fname_fig,status='replace' ,form='formatted')
      call Fig_header(unitnumber);

      if (verbose.gt.1) then
         write(6,'(A)') ''
         write(6,'(A)')
     $        'We display the ctf-functions on a k-space polar grid'
      end if
c$$$      printing ctf-functions
      do ns=0,n_S-1
         call stdlim_c16(n_A,.true.,S_k_p_(ns*ld_S),F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*ns
         y_offset = +17.0d0 - 0.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,S_k_p_(ns*ld_S),F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(S_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,S_k_p_(ns*ld_S),F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*ns
         y_offset = +17.0d0 - 10.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,S_k_p_(ns*ld_S),F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(S_k_p(',ns,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
      enddo                     !ns = 0,n_S-1

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We write the figure file to disk.'
         write(6,'(A,A)') 'try: '
     $        ,'"gthumb ?.jpg"'
      end if
c$$$      Printing figure file for image
      close(unitnumber,status='keep')
      write(fig2dev_system_call,'(A,A,1X,A)') 'fig2dev -Ljpeg -q 10 '
     $     ,trim(fname_fig),trim(fname_jpg)
      system_error = system(fig2dev_system_call)

      deallocate(n_w_)
      deallocate(ngridc_)
      deallocate(icstart_)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished Fig_gen_ctf_ver0]'
      end if

      end
!> Doxygen comment: ;\n
!> Generates an xfig figure. ;\n
!> Uses fig2dev to convert to jpeg. ;\n
!> Reads in a few images and plots them after ;\n
!> convolution with their ctf-function. ;\n
      subroutine Fig_gen_ctf_ver4(ncur,nlats_,grid_k_p_,n_M,I_M_sample_
     $     ,ld_M,N_k_p_,M_k_p_,ld_CTF,CTF_k_p_,alpha_est_
     $     ,n_M_sample,prefix)
c$$$      Reads in a few images and plots them after
c$$$      convolution with their ctf-function
      implicit none
      include '/usr/include/fftw3.f'
      integer verbose
      data verbose / 2 /
      logical plot_flag
      integer *4 ncur,nlats_(0:ncur-1),n_M,I_M_sample_(0:n_M-1),ld_M
     $     ,ld_CTF,n_M_sample
      real *8 grid_k_p_(0:0)
      real *8 alpha_est_(0:0)
      include 'nalpha_define.f'
      complex *16 N_k_p_(0:0),M_k_p_(0:0),CTF_k_p_(0:0)
      character(len=1024) prefix
      integer *4 I_M_sample_tmp_(0:n_M_sample)
      integer *4 ntemplatesize
      integer *4, allocatable :: ngridc_(:)
      integer *4, allocatable :: icstart_(:)
c$$$      indices
      integer *4 n_r,nr,n_w_max,n_A,na,nctf,nm,nM_sample
      integer *4, allocatable :: n_w_(:)
c$$$      temporary storage for ctf
      complex *16, allocatable :: T_k_p_(:)
      real *8 pi
      real *8 max_r8_f
      real *8 max_k_c
      character(len=64) format_string
c$$$      parameters for figure generation
      character(len=1024) fig_title,fname_pre,fname_fig,fname_jpg
      integer unitnumber,text_length,color_index,font_type,font_size
      real *8 F_avg,F_std,F_max,F_min
      real *8 x_loc,y_loc,x_side,y_side,x_offset,y_offset
      character(len=1024) fig2dev_system_call
      integer system,system_error

      if (verbose.gt.0) then
          write(6,'(A)')
     $        '[entering Fig_gen_ctf_ver4]: '
       end if
       if (verbose.gt.1) then
         write(6,'(A,I0)') 'verbose: ',verbose
         write(6,'(A,I0)') 'ncur: ',ncur
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'nlats_: ',(nlats_(nr),nr=0,ncur-1)
         write(format_string,'(A,I0,A)') '(A,',ncur,'(F8.3,1X))'
         write(6,format_string) 'grid_k_p_: ',(grid_k_p_(nr),nr=0,ncur
     $        -1)
         write(6,'(A,I0)') 'n_M: ',n_M
         write(6,'(A,I0)') 'ld_M: ',ld_M
         write(6,'(A,I0)') 'ld_CTF: ',ld_CTF
         write(6,'(A,I0)') 'n_alpha: ',n_alpha
         write(6,'(A,I0)') 'n_M_sample: ',n_M_sample
         write(6,'(A)') trim(prefix)
      end if

      do nM_sample=0,n_M_sample-1
         if (n_M_sample.lt.n_M) then
            I_M_sample_tmp_(nM_sample) = min(n_M-1,floor(n_M
     $           *1.0d0*nM_sample/(n_M_sample-1)))
         else
            I_M_sample_tmp_(nM_sample) = nM_sample
         end if
      enddo
      if (verbose.gt.1) then
         write(format_string,'(A,I0,A)') '(',n_M_sample,'(I0,1X))'
         write(6,format_string) (I_M_sample_tmp_(nM_sample),nM_sample=0
     $        ,n_M_sample-1)
      end if

      pi = 4*atan(1.0)

c$$$      Calculating template size using 'get_template_size'
      allocate(ngridc_(ncur))
      allocate(icstart_(ncur))
      if (verbose.gt.1) then
         write(6,'(A,I0,A,A)') 'ncur = ',ncur
     $        ,'; calling get_template_size to'
     $        ,' determine ngridc_ and ntemplatesize'
      end if
      call get_template_size(nlats_,ncur,ntemplatesize,ngridc_,icstart_)
      if (verbose.gt.1) then
         write(6,'(A,I0)') 'ntemplatesize = ',ntemplatesize
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'ngridc_: ',(ngridc_(nr),nr=1,ncur)
      end if
      
c$$$      indices
      n_r = ncur
      if (n_r.lt.2) then
         write(6,'(A,I0,A)') 'Error n_r',n_r,'<2'
      end if
      allocate(n_w_(0:n_r-1))
      n_A = 0
      do nr=0,n_r-1
         n_w_(nr) = ngridc_(1+nr)
         n_A = n_A + n_w_(nr)
      enddo
      n_w_max = n_w_(nr-1)
      if (verbose.gt.1) then
         write(6,'(A,I0,A,I0)') 'n_w_max ',n_w_max,'; n_A ',n_A
         write(format_string,'(A,I0,A)') '(A,',ncur,'(I0,1X))'
         write(6,format_string) 'n_w_: ',(n_w_(nr),nr=0,ncur-1)
      end if
      
c$$$      generating grids for templates and images 
      max_k_c = 2*grid_k_p_(n_r-1)

c$$$      allocating temporary storage for images and templates 
      allocate(T_k_p_(0:n_A-1))

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We initialize the first figure file.' 
      end if

      unitnumber = 7
      write(fname_pre,'(A)') trim(prefix)
      write(fname_fig,'(A,A)') trim(fname_pre),'.fig'
      write(fname_jpg,'(A,A)') trim(fname_pre),'.jpg'
      open(unitnumber,file=fname_fig,status='replace' ,form='formatted')
      call Fig_header(unitnumber);

      if (verbose.gt.1) then
         write(6,'(A)') ''
         write(6,'(A)')
     $        'We display the images on a k-space polar grid'
     $        ,' along with their values after ctf-convolution.'
      end if
      do nM_sample=0,n_M_sample-1
         nm = I_M_sample_tmp_(nM_sample)
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'sample ',nM_sample,' is image ',nm
         end if
c$$$      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$      printing images post-CTF ;
         call stdlim_c16(n_A,.true.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(M_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,M_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,M_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(M_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$      printing images pre-CTF ;
         call stdlim_c16(n_A,.true.,N_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 - 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,N_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(N_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,N_k_p_(I_M_sample_(nm)*ld_M),F_avg
     $        ,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 - 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,N_k_p_(I_M_sample_(nm)*ld_M),F_min,F_max,x_offset
     $        ,y_offset,x_side ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(N_k_p(',nm,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c$$$         Print ctf-function associated with image
         nctf = alpha_est_(nalpha_ctf_ind + I_M_sample_(nm)*n_alpha)
         if (verbose.gt.1) then
            write(6,'(A,I0,A,I0)') 'ctf for image ',nm,' is ',nctf
         end if
c$$$         Display ctf-function
         call cp1_c16(n_A,CTF_k_p_(nctf*ld_CTF),T_k_p_)
         call stdlim_c16(n_A,.true.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 0.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.true.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'R(C_k_p(',nctf,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
         call stdlim_c16(n_A,.false.,T_k_p_,F_avg,F_std)
         F_max = F_avg + 2.5*F_std
         F_min = F_avg - 2.5*F_std
         x_offset = +5.0d0 + 10.0d0*nM_sample
         y_offset = +17.0d0 - 10.0d0 + 22.5d0
         x_side = 10.0d0/(max_k_c)
         y_side = 10.0d0/(max_k_c)
         call Fig_c16_polar(unitnumber,n_r,grid_k_p_,n_w_,.false.
     $        ,T_k_p_,F_min,F_max,x_offset,y_offset,x_side
     $        ,y_side)
         write(fig_title,'(A,I0,A,I4,A)') 'I(C_k_p(',nctf,')) '
     $        ,nint(dlog(F_std)),'    '
         text_length = 18
         color_index = 0
         font_type = 0
         font_size = 72
         x_loc = -0.5d0*(max_k_c)
         y_loc = -0.5d0*(max_k_c)
         call Fig_text(unitnumber,text_length,fig_title,color_index
     $        ,font_type,font_size,x_loc,y_loc,x_offset,y_offset,x_side
     $        ,y_side)
c$$$      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      enddo !do nM_sample=0,n_M_sample-1

      if (verbose.gt.1) then
         write(6,'(A)') 
         write(6,'(A)') 'We write the figure file to disk.'
         write(6,'(A,A)') 'try: '
     $        ,'"gthumb ?.jpg"'
      end if
c$$$      Printing figure file for image
      close(unitnumber,status='keep')
      write(fig2dev_system_call,'(A,A,1X,A)') 'fig2dev -Ljpeg -q 10 '
     $     ,trim(fname_fig),trim(fname_jpg)
      system_error = system(fig2dev_system_call)

      deallocate(T_k_p_)
      deallocate(n_w_)
      deallocate(ngridc_)
      deallocate(icstart_)

      if (verbose.gt.0) then
         write(6,'(A)') '[finished Fig_gen_ctf_ver4]'
      end if

      end
!> Doxygen comment: ;\n
!> Simple brute force fourier transform for 1 dimension. ;\n
!> Only use for testing. ;\n
      subroutine adi_fft1(sgn,n,a_,a_start,a_stride,c_,c_start,c_stride)
      integer sgn
      integer n,j,k,a_start,a_stride,c_start,c_stride
      complex *16 a_(0:(a_start + n*a_stride)-1)
      complex *16 c_(0:(c_start + n*c_stride)-1)
      complex *16, allocatable :: b_(:)
      complex *16 wk,wkj
      real *8 pi,theta
      integer kb,ja
      pi = 4.0*atan(1.0)
      allocate(b_(0:n-1))
      do k=0,n-1
         theta = 2*pi*k/n
         wk = cmplx(+cos(theta),sgn*sin(theta))
         wkj = ( 1.0 , 0.0 )
         b_(k)=0
         ja = a_start
         do j=0,n-1
            b_(k) = b_(k) + wkj*a_(ja)
            wkj = wkj*wk
            ja = ja + a_stride
         enddo
         if (sgn.eq.+1) then
            b_(k) = b_(k) / n
         end if
      enddo
      do k=0,n-1
         c_(c_start + k*c_stride) = b_(k)
      enddo
      deallocate(b_)
      end
!> Doxygen comment: ;\n
!> Simple brute force fourier transform for 2 dimensions. ;\n
!> Only use for testing. ;\n
      subroutine adi_fft2(sgn,m,n,a_,c_)
      integer sgn,m,n,j
      complex *16 a_(0:m*n-1),c_(0:m*n-1)
      complex *16, allocatable :: b_(:)
      allocate(b_(0:m*n-1))
      do k=0,n-1
         call adi_fft1(sgn,m,a_,k*m,1,b_,k*m,1)
      enddo
      do j=0,m-1
         call adi_fft1(sgn,n,b_,j,m,c_,j,m)
      enddo
      deallocate(b_)
      end
!> Doxygen comment: ;\n
!> Quicksort applied to complex *16 array Z_. ;\n
!> Sorts in ascending order. ;\n
      subroutine quicksort_c16(nl,nr,Z_,Z_stride,J_,J_stride
     $     ,p_quicksort_c16)
      implicit none
      integer verbose
      data verbose / 0 /
      integer nl,nr,Z_stride,J_stride
      complex *16 Z_(0:0)
      integer *4 J_(0:0)
c$$$      real *8 D_(0:nr-nl)
      external p_quicksort_c16
      integer nj,nd
c$$$      character(len=20) format_string
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)') '[entering quicksort_c16] nl,nr:',nl,nr
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'F4.0)'
c$$$            do nd=0,nr-nl
c$$$               D_(nd) = Z_(nl+nd)
c$$$            enddo
c$$$            write(6,format_string) (D_(nd),nd=nl,nr)
c$$$         end if
      end if
      nj=0
      if (nl.lt.nr) then
         call quicksort_c16_excerpt(nl,nr,Z_,Z_stride,J_,J_stride,nj)
         call p_quicksort_c16(nl,nj-1,Z_,Z_stride,J_,J_stride
     $        ,p_quicksort_c16)
         call p_quicksort_c16(nj+1,nr,Z_,Z_stride,J_,J_stride
     $        ,p_quicksort_c16)
      end if
c$$$      if (verbose.gt.0) then
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'F4.0)'
c$$$            do nd=0,nr-nl
c$$$               D_(nd) = Z_(nl+nd)
c$$$            enddo
c$$$            write(6,format_string) (D_(nd),nd=nl,nr)
c$$$         end if
c$$$      end if
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)') '[finished quicksort_c16] nl,nr:',nl,nr
      end if
      end

      subroutine quicksort_c16_excerpt(nl,nr,Z_,Z_stride,J_,J_stride
     $     ,nj_out)
      implicit none
      integer verbose
      data verbose / 0 /
      integer nl,nr,Z_stride,J_stride,nj_out
      complex *16 Z_(0:0)
      integer *4 J_(0:0)
c$$$      real *8 D_(0:nr-nl)
      complex *16 Z_pivot,Z_C
      integer ni,nj,nd,J_C
c$$$      character(len=20) format_string
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)')
     $        '[entering quicksort_c16_excerpt] nl,nr: ',nl,nr
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'F4.0)'
c$$$            do nd=0,nr-nl
c$$$               D_(nd) = Z_(nl+nd)
c$$$            enddo
c$$$            write(6,format_string) (D_(nd),nd=nl,nr)
c$$$         end if
      end if
      Z_pivot = Z_(nl*Z_stride)
      ni = nl
      nj = nr+1
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0,1X,F4.0)') 'ni,nj,Z_pivot: '
     $        ,ni,nj,real(Z_pivot)
      end if
      do while (.true.)
         do while (.true.)
            ni = ni+1
            if ((real(Z_(ni*Z_stride)).gt.real(Z_pivot)) .or.
     $           (ni.gt.nr)) then
               goto 10
            end if
         enddo
 10      continue
         if (verbose.gt.0) then
            write(6,'(A,I0,1X,F4.0)') 'stopping: ni,Z_(ni): ',ni
     $           ,real(Z_(ni*Z_stride))
         end if
         do while (.true.)
            nj = nj-1
            if (real(Z_(nj*Z_stride)).le.real(Z_pivot)) then
               goto 20
            end if
         enddo
 20      continue
         if (verbose.gt.0) then
            write(6,'(A,I0,1X,F4.0)') 'stopping: nj,Z_(nj): ',nj
     $           ,real(Z_(nj*Z_stride))
         end if
         if (ni.ge.nj) then
            goto 30
         end if
         if (verbose.gt.0) then
            write(6,'(A,F4.0,1X,F4.0)') 'ni<nj: swapping ',real(Z_(ni
     $           *Z_stride)),real(Z_(nj*Z_stride))
         end if
         Z_C = Z_(ni*Z_stride)
         Z_(ni*Z_stride) = Z_(nj*Z_stride)
         Z_(nj*Z_stride) = Z_C
         J_C = J_(ni*J_stride)
         J_(ni*J_stride) = J_(nj*J_stride)
         J_(nj*J_stride) = J_C
      enddo
 30   continue
      if (verbose.gt.0) then
         write(6,'(A,F4.0,1X,F4.0)') 'final: swapping ',real(Z_(nl
     $        *Z_stride)),real(Z_(nj*Z_stride))
      end if
      Z_C = Z_(nl*Z_stride)
      Z_(nl*Z_stride) = Z_(nj*Z_stride)
      Z_(nj*Z_stride) = Z_C
      J_C = J_(nl*J_stride)
      J_(nl*J_stride) = J_(nj*J_stride)
      J_(nj*J_stride) = J_C
c$$$      if (verbose.gt.0) then
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'F4.0)'
c$$$            do nd=0,nr-nl
c$$$               D_(nd) = Z_(nl+nd)
c$$$            enddo
c$$$            write(6,format_string) (D_(nd),nd=nl,nr)
c$$$         end if
c$$$      end if
      nj_out = nj
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0,1X,I0)')
     $        '[finished quicksort_c16_excerpt] nl,nr,nj_out: ' ,nl,nr
     $        ,nj_out
      end if
      end

!> Doxygen comment: ;\n
!> Quicksort applied to real *8 array Z_. ;\n
!> Sorts in ascending order. ;\n
      subroutine quicksort_r8(nl,nr,Z_,Z_stride,J_,J_stride
     $     ,p_quicksort_r8)
      implicit none
      integer verbose
      data verbose / 0 /
      integer nl,nr,Z_stride,J_stride
      real *8 Z_(0:0)
      integer *4 J_(0:0)
c$$$      real *8 D_(0:nr-nl)
      external p_quicksort_r8
      integer nj,nd
c$$$      character(len=20) format_string
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)') '[entering quicksort_r8] nl,nr:',nl,nr
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'F4.0)'
c$$$            do nd=0,nr-nl
c$$$               D_(nd) = Z_(nl+nd)
c$$$            enddo
c$$$            write(6,format_string) (D_(nd),nd=nl,nr)
c$$$         end if
      end if
      nj=0
      if (nl.lt.nr) then
         call quicksort_r8_excerpt(nl,nr,Z_,Z_stride,J_,J_stride,nj)
         call p_quicksort_r8(nl,nj-1,Z_,Z_stride,J_,J_stride
     $        ,p_quicksort_r8)
         call p_quicksort_r8(nj+1,nr,Z_,Z_stride,J_,J_stride
     $        ,p_quicksort_r8)
      end if
c$$$      if (verbose.gt.0) then
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'F4.0)'
c$$$            do nd=0,nr-nl
c$$$               D_(nd) = Z_(nl+nd)
c$$$            enddo
c$$$            write(6,format_string) (D_(nd),nd=nl,nr)
c$$$         end if
c$$$      end if
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)') '[finished quicksort_r8] nl,nr:',nl,nr
      end if
      end

      subroutine quicksort_r8_excerpt(nl,nr,Z_,Z_stride,J_,J_stride
     $     ,nj_out)
      implicit none
      integer verbose
      data verbose / 0 /
      integer nl,nr,Z_stride,J_stride,nj_out
      real *8 Z_(0:0)
      integer *4 J_(0:0)
c$$$      real *8 D_(0:nr-nl)
      real *8 Z_pivot,Z_C
      integer ni,nj,nd,J_C
c$$$      character(len=20) format_string
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)')
     $        '[entering quicksort_r8_excerpt] nl,nr: ',nl,nr
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'F4.0)'
c$$$            do nd=0,nr-nl
c$$$               D_(nd) = Z_(nl+nd)
c$$$            enddo
c$$$            write(6,format_string) (D_(nd),nd=nl,nr)
c$$$         end if
      end if
      Z_pivot = Z_(nl*Z_stride)
      ni = nl
      nj = nr+1
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0,1X,F4.0)') 'ni,nj,Z_pivot: ' ,ni,nj
     $        ,Z_pivot
      end if
      do while (.true.)
         do while (.true.)
            ni = ni+1
            if ((Z_(ni*Z_stride).gt.Z_pivot) .or. (ni.gt.nr)) then
               goto 10
            end if
         enddo
 10      continue
         if (verbose.gt.0) then
            write(6,'(A,I0,1X,F4.0)') 'stopping: ni,Z_(ni): ',ni ,Z_(ni
     $           *Z_stride)
         end if
         do while (.true.)
            nj = nj-1
            if (Z_(nj*Z_stride).le.Z_pivot) then
               goto 20
            end if
         enddo
 20      continue
         if (verbose.gt.0) then
            write(6,'(A,I0,1X,F4.0)') 'stopping: nj,Z_(nj): ',nj ,Z_(nj
     $           *Z_stride)
         end if
         if (ni.ge.nj) then
            goto 30
         end if
         if (verbose.gt.0) then
            write(6,'(A,F4.0,1X,F4.0)') 'ni<nj: swapping ',Z_(ni
     $           *Z_stride),Z_(nj*Z_stride)
         end if
         Z_C = Z_(ni*Z_stride)
         Z_(ni*Z_stride) = Z_(nj*Z_stride)
         Z_(nj*Z_stride) = Z_C
         J_C = J_(ni*J_stride)
         J_(ni*J_stride) = J_(nj*J_stride)
         J_(nj*J_stride) = J_C
      enddo
 30   continue
      if (verbose.gt.0) then
         write(6,'(A,F4.0,1X,F4.0)') 'final: swapping ',Z_(nl *Z_stride)
     $        ,Z_(nj*Z_stride)
      end if
      Z_C = Z_(nl*Z_stride)
      Z_(nl*Z_stride) = Z_(nj*Z_stride)
      Z_(nj*Z_stride) = Z_C
      J_C = J_(nl*J_stride)
      J_(nl*J_stride) = J_(nj*J_stride)
      J_(nj*J_stride) = J_C
c$$$      if (verbose.gt.0) then
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'F4.0)'
c$$$            do nd=0,nr-nl
c$$$               D_(nd) = Z_(nl+nd)
c$$$            enddo
c$$$            write(6,format_string) (D_(nd),nd=nl,nr)
c$$$         end if
c$$$      end if
      nj_out = nj
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0,1X,I0)')
     $        '[finished quicksort_r8_excerpt] nl,nr,nj_out: ' ,nl,nr
     $        ,nj_out
      end if
      end

!> Doxygen comment: ;\n
!> Quicksort applied to integer *4 array I_. ;\n
!> Sorts in ascending order. ;\n
      subroutine quicksort_i4(nl,nr,I_,I_stride,J_,J_stride
     $     ,p_quicksort_i4)
      implicit none
      integer verbose
      data verbose / 0 /
      integer nl,nr,I_stride,J_stride
      integer *4 I_(0:0)
      integer *4 J_(0:0)
      external p_quicksort_i4
      integer nj,nd
c$$$      character(len=20) format_string
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)') '[entering quicksort_i4] nl,nr:',nl,nr
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'I0)'
c$$$            write(6,format_string) (I_(nd),nd=nl,nr)
c$$$         end if
      end if
      nj=0
      if (nl.lt.nr) then
         call quicksort_i4_excerpt(nl,nr,I_,I_stride,J_,J_stride,nj)
         call p_quicksort_i4(nl,nj-1,I_,I_stride,J_,J_stride
     $        ,p_quicksort_i4)
         call p_quicksort_i4(nj+1,nr,I_,I_stride,J_,J_stride
     $        ,p_quicksort_i4)
      end if
c$$$      if (verbose.gt.0) then
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'I0)'
c$$$            write(6,format_string) (I_(nd),nd=nl,nr)
c$$$         end if
c$$$      end if
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)') '[finished quicksort_i4] nl,nr:',nl,nr
      end if
      end

      subroutine quicksort_i4_excerpt(nl,nr,I_,I_stride,J_,J_stride
     $     ,nj_out)
      implicit none
      integer verbose
      data verbose / 0 /
      integer nl,nr,I_stride,J_stride,nj_out
      integer *4 I_(0:0)
      integer *4 J_(0:0)
      integer *4 I_pivot,I_C
      integer ni,nj,nd,J_C
c$$$      character(len=20) format_string
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)')
     $        '[entering quicksort_i4_excerpt] nl,nr: ',nl,nr
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'I0)'
c$$$            write(6,format_string) (I_(nd),nd=nl,nr)
c$$$         end if
      end if
      I_pivot = I_(nl*I_stride)
      ni = nl
      nj = nr+1
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0,1X,I0)') 'ni,nj,I_pivot: '
     $        ,ni,nj,I_pivot
      end if
      do while (.true.)
         do while (.true.)
            ni = ni+1
            if ((I_(ni*I_stride).gt.I_pivot) .or.
     $           (ni.gt.nr)) then
               goto 10
            end if
         enddo
 10      continue
         if (verbose.gt.0) then
            write(6,'(A,I0,1X,I0)') 'stopping: ni,I_(ni): ',ni
     $           ,I_(ni*I_stride)
         end if
         do while (.true.)
            nj = nj-1
            if (I_(nj*I_stride).le.I_pivot) then
               goto 20
            end if
         enddo
 20      continue
         if (verbose.gt.0) then
            write(6,'(A,I0,1X,I0)') 'stopping: nj,I_(nj): ',nj
     $           ,I_(nj*I_stride)
         end if
         if (ni.ge.nj) then
            goto 30
         end if
         if (verbose.gt.0) then
            write(6,'(A,I0,1X,I0)') 'ni<nj: swapping ',I_(ni*I_stride)
     $           ,I_(nj*I_stride)
         end if
         I_C = I_(ni*I_stride)
         I_(ni*I_stride) = I_(nj*I_stride)
         I_(nj*I_stride) = I_C
         J_C = J_(ni*J_stride)
         J_(ni*J_stride) = J_(nj*J_stride)
         J_(nj*J_stride) = J_C
      enddo
 30   continue
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0)') 'final: swapping ',I_(nl*I_stride)
     $        ,I_(nj*I_stride)
      end if
      I_C = I_(nl*I_stride)
      I_(nl*I_stride) = I_(nj*I_stride)
      I_(nj*I_stride) = I_C
      J_C = J_(nl*J_stride)
      J_(nl*J_stride) = J_(nj*J_stride)
      J_(nj*J_stride) = J_C
c$$$      if (verbose.gt.0) then
c$$$         if (nl.le.nr) then
c$$$            write(format_string,'(A,I0,A)') '(',(nr-nl+1),'I0)'
c$$$            write(6,format_string) (I_(nd),nd=nl,nr)
c$$$         end if
c$$$      end if
      nj_out = nj
      if (verbose.gt.0) then
         write(6,'(A,I0,1X,I0,1X,I0)')
     $        '[finished quicksort_i4_excerpt] nl,nr,nj_out: ' ,nl,nr
     $        ,nj_out
      end if
      end

!> Doxygen comment: ;\n
!> A dummy subroutine used to mark the end of the source list in the makefile. ;\n
      subroutine source_end()
      end
