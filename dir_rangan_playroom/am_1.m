function [X_best_,a_k_Y_0lsq__,euler_polar_a__,euler_azimu_b__,euler_gamma_z__] = am_1(rseed,n_iteration,n_iteration_register,viewing_k_eq_d,n_order,n_k_p_r,k_p_r_,k_p_r_max,weight_k_p_r_,weight_2d_k_p_r_,n_w_,n_M,M_k_p__,M_k_q__,CTF_index_,CTF_k_p__,l_max_,a_k_Y_true_,euler_polar_a_,euler_azimu_b_,euler_gamma_z_);
%%%%%%%%;
% simple alternating minimization. ;
% No displacements involved. ;
% ;
% Input: ;
% rseed: integer random seed. ;
% n_iteration: integer number of iterations for alternating minimization. ;
% n_iteration_register: integer number of iterations to wait before registering result against a_k_Y_true_. ;
% viewing_k_eq_d: real equatorial distance for building viewing angles (i.e., each viewing angle is associated with a template). ;
% n_order: integer polynomial interpolation order used for conjugate-gradient interpolation operator. ;
% n_k_p_r: integer number of shells. ;
% k_p_r_: real array of size n_k_p_r. k_p_r for each shell. ;
% k_p_r_max: real maximum radius (of sphere) to be integrated. ;
% weight_k_p_r_: real array of size n_k_p_r. radial quadrature weighting for sphere. ;
% weight_2d_k_p_r_: real array of size n_k_p_r. radial quadrature weighting for disk. ;
% n_w_: integer array of size n_k_p_r. n_w_(1+nk_p_r) is the number of inplane_gamma_z values recorded at that ring. ;
% n_M: integer number of images. ;
% M_k_p__: complex array of size (n_w_sum,n_M). stack of images in k_p_ format. ;
% M_k_q__: complex array of size (n_w_sum,n_M). stack of images in k_q_ format. ;
%          will calculate if empty. ;
% CTF_index_: integer array of size n_M. CTF_index_(1+nM) is the CTF_index used for image M_k_p__(:,1+nM). ;
%             This can be empty or set to 1, in which case the same CTF_k_p_ will be used for each image. ;
% CTF_k_p__: complex array of size(n_w_sum,n_CTF). stack of ctf-functions in k_p_ format. ;
%            If CTF_index_ is empty or set to 1, then we assume this contains only a single CTF_k_p_, ;
%            which will then be used for all images. ;
% l_max_: integer array of size n_k_p_r. l_max_(1+nk_p_r) is the order used for a_k_Y_0lsq_ on shell nk_p_r. ;
% euler_polar_a_: real array of size n_M. initial polar_a used for each image (randomized if empty). ;
% euler_azimu_b_: real array of size n_M. initial azimu_b used for each image (randomized if empty). ;
% euler_gamma_z_: real array of size n_M. initial gamma_z used for each image (randomized if empty). ;
% ;
% Output: ;
% X_best_: real array of size n_iteration. correlation with a_k_Y_true_ at every n_iteration_register iterations. ;
% a_k_Y_0lsq__: complex array of size (n_lm_sum,n_iteration). stack of output functions in k_Y_ format. ;
% euler_polar_a__: real array of size (n_M,n_iteration). list of polar_a used for each image at each iteration. ;
% euler_azimu_b__: real array of size (n_M,n_iteration). list of azimu_b used for each image at each iteration. ;
% euler_gamma_z__: real array of size (n_M,n_iteration). list of gamma_z used for each image at each iteration. ;
%%%%%%%%;

verbose=1;
flag_QLS=0;
flag_blas=1;
flag_SVD=1;

rng(rseed);

n_lm_ = (1+l_max_).^2;
n_lm_sum = sum(n_lm_);
n_lm_csum_ = cumsum([0;n_lm_]);
n_w_max = max(n_w_);
n_w_sum = sum(n_w_);
n_w_csum_ = cumsum([0;n_w_]);

if flag_QLS;
tmp_t = tic();
QLS = prepare_quadrature_approximation_to_cg_lsq_3(n_k_p_r,l_max_,n_w_);
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% prepare_quadrature_approximation_to_cg_lsq_3: %0.3fs',tmp_t)); end;
end;%if flag_QLS;

if isempty(M_k_q__);
M_k_q__ = zeros(n_w_sum,n_M);
for nM=0:n_M-1;
M_k_q__(:,1+nM) = interp_p_to_q(n_k_p_r,n_w_,n_w_sum,M_k_p__(:,1+nM));
end;%for nM=0:n_M-1;
end;%if isempty(M_k_q__);

if flag_SVD;
tmp_t = tic();
SM_k_q_ = svd(M_k_q__);
n_M_rank = min(find(SM_k_q_/SM_k_q_(1)<1e-3)); if isempty(n_M_rank); n_M_rank = min(size(M_k_q__)); end;
[UM_k_q__,SM_k_q__,VM_k_q__] = svds(M_k_q__,n_M_rank);
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% svd of images: %0.3fs',tmp_t)); end;
end;%if flag_SVD;

M_k_q_rMw___ = permute(innerproduct_q_k_stretch_quad_stack__0(n_k_p_r,weight_2d_k_p_r_,n_w_,n_M,M_k_q__),[1,3,2]);

%%%%%%%%;
% Calculate image norms. ;
%%%%%%%%;
MM_ = zeros(n_M,1);
for nM=0:n_M-1;
MM_(1+nM) = innerproduct_p_quad(n_k_p_r,k_p_r_,weight_2d_k_p_r_/(2*pi),n_w_,n_w_sum,M_k_p__(:,1+nM),M_k_p__(:,1+nM));
end;%for nM=0:n_M-1;

X_best_ = zeros(n_iteration,1);
if (nargout>1);
euler_polar_a__ = zeros(n_M,n_iteration);
euler_azimu_b__ = zeros(n_M,n_iteration);
euler_gamma_z__ = zeros(n_M,n_iteration);
a_k_Y_0lsq__ = zeros(n_lm_sum,n_iteration);
end;%if (nargout>1);
%%%%%%%%;
% initialize current euler-angles randomly. ;
%%%%%%%%;
if isempty(euler_polar_a_); euler_polar_a_ = 1*pi*rand(n_M,1); end;
if isempty(euler_azimu_b_); euler_azimu_b_ = 2*pi*rand(n_M,1); end;
if isempty(euler_gamma_z_); euler_gamma_z_ = 2*pi*rand(n_M,1); end;
for niteration=0:n_iteration-1;
%%%%%%%%;
% use current euler-angles to solve for current model. ;
%%%%%%%%;
if flag_QLS==0;
tmp_t = tic();
a_k_Y_0lsq_ = cg_lsq_3(n_order,n_k_p_r,l_max_,n_w_,n_M,M_k_p__,CTF_index_,CTF_k_p__,euler_polar_a_,euler_azimu_b_,euler_gamma_z_);
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% cg_lsq_3: %0.3fs',tmp_t)); end;
end;%if flag_QLS==0;
if flag_QLS==1;
tmp_t = tic();
a_k_Y_0lsq_ = quadrature_approximation_to_cg_lsq_3(n_k_p_r,l_max_,n_w_,n_M,M_k_p__,CTF_index_,CTF_k_p__,euler_polar_a_,euler_azimu_b_,euler_gamma_z_,QLS);
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% quadrature_approximation_to_cg_lsq_3: %0.3fs',tmp_t)); end;
end;%if flag_QLS==1;
if (nargout>1);
a_k_Y_0lsq__(:,1+niteration) = a_k_Y_0lsq_;
euler_polar_a__(:,1+niteration) = euler_polar_a_;
euler_azimu_b__(:,1+niteration) = euler_azimu_b_;
euler_gamma_z__(:,1+niteration) = euler_gamma_z_;
end;%if (nargout>1);
%%%%%%%%;
if (mod(niteration,n_iteration_register)==n_iteration_register-1);
%%%%%%%%;
% Compare current model to a_k_Y_true_. ;
%%%%%%%%;
tmp_t = tic();
[X_best_orig,~,~,~,~,~,~] = register_spharm_to_spharm_wigner_0(n_k_p_r,k_p_r_,k_p_r_max,weight_k_p_r_,0,l_max_,a_k_Y_true_,a_k_Y_0lsq_);
[X_best_flip,~,~,~,~,~,~] = register_spharm_to_spharm_wigner_0(n_k_p_r,k_p_r_,k_p_r_max,weight_k_p_r_,0,l_max_,a_k_Y_true_,flipY(n_k_p_r,l_max_,a_k_Y_0lsq_));
X_best = max(real(X_best_orig),real(X_best_flip));
X_best_(1+niteration) = X_best;
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% register_spharm_to_spharm_wigner_0: %0.3fs',tmp_t)); end;
disp(sprintf(' %% a_k_Y_true_ vs a_k_Y_lsq0_: correlation %+0.6f',X_best));
end;%if (mod(niteration,n_iteration_register)==n_iteration_register-1);
%%%%%%%%;
% use current model to generate current templates. ;
%%%%%%%%;
tmp_t = tic();
tmp_verbose=0;
[S_k_p__,~,~,~,n_viewing_all,viewing_azimu_b_all_,viewing_polar_a_all_,~,~,~,~,~,~] = get_template_0(tmp_verbose,n_k_p_r,k_p_r_,k_p_r_max,weight_k_p_r_,l_max_,a_k_Y_0lsq_,viewing_k_eq_d,-1,n_w_);
if (tmp_verbose>0); disp(sprintf(' %% viewing_k_eq_d %0.3f, n_viewing_all %d',viewing_k_eq_d,n_viewing_all)); end;
n_S = n_viewing_all;
SS_ = zeros(n_S,1);
for nS=0:n_S-1;
SS_(1+nS) = innerproduct_p_quad(n_k_p_r,k_p_r_,weight_2d_k_p_r_/(2*pi),n_w_,n_w_sum,S_k_p__(:,1+nS),S_k_p__(:,1+nS));
end;%for nS=0:n_S-1;
S_k_q__ = zeros(n_w_sum,n_S);
for nS=0:n_S-1; S_k_q__(:,1+nS) = interp_p_to_q(n_k_p_r,n_w_,n_w_sum,S_k_p__(:,1+nS)); end;%for nS=0:n_S-1; 
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% get_template_0: %0.3fs',tmp_t)); end;
if flag_SVD;
tmp_t = tic();
SS_k_q_ = svd(S_k_q__);
n_S_rank = min(find(SS_k_q_/SS_k_q_(1)<1e-3)); if isempty(n_S_rank); n_S_rank = min(size(S_k_q__)); end;
[US_k_q__,SS_k_q__,VS_k_q__] = svds(S_k_q__,n_S_rank);
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% svd of templates: %0.3fs',tmp_t)); end;
end;%if flag_SVD;
%%%%%%%%;
% Use current templates to calculate current innerproducts/correlations. ;
%%%%%%%%;
if flag_blas==1;
if flag_SVD==0;
tmp_t = tic();
X_wSM___ = ifft(innerproduct_q_k_stretch_quad__0(n_k_p_r,weight_2d_k_p_r_/(2*pi),n_w_,n_S,S_k_q__,[],n_M,M_k_q__,M_k_q_rMw___))*n_w_max .* repmat(reshape(1./sqrt(MM_),[1,1,n_M]),[n_w_max,n_S,1]) .* repmat(reshape(1./sqrt(SS_),[1,n_S,1]),[n_w_max,1,n_M]) ;
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% use blas for all innerproducts/correlations: %0.3fs',tmp_t)); end;
end;%if flag_SVD==0;
if flag_SVD==1;
tmp_t = tic();
Y_wSM___ = ifft(innerproduct_q_k_stretch_quad__0(n_k_p_r,weight_2d_k_p_r_/(2*pi),n_w_,n_S_rank,US_k_q__,[],n_M_rank,UM_k_q__,[]))*n_w_max ;
X_wSM___ = zeros(n_w_max,n_S,n_M);
for nw=0:n_w_max-1;
X_wSM___(1+nw,:,:) = ( repmat(1./sqrt(SS_),[1,n_S_rank]) .* VS_k_q__ )*SS_k_q__*squeeze(Y_wSM___(1+nw,:,:))*SM_k_q__*ctranspose( repmat(1./sqrt(MM_),[1,n_M_rank]) .* VM_k_q__ ) ;
end;%for nw=0:n_w_max-1;
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% use blas and svd for compressed innerproducts/correlations: %0.3fs',tmp_t)); end;
end;%if flag_SVD==1;
end;%if flag_blas==1;
if flag_blas==0;
tmp_t = tic();
X_wSM___ = zeros(n_w_max,n_S,n_M);
for nM=0:n_M-1;
for nS=0:n_S-1;
X_wSM___(:,1+nS,1+nM) = ifft(innerproduct_q_k_stretch_quad_0(n_k_p_r,k_p_r_,weight_2d_k_p_r_/(2*pi),n_w_,n_w_sum,S_k_q__(:,1+nS),M_k_q__(:,1+nM)))*n_w_max/sqrt(MM_(1+nM))/sqrt(SS_(1+nS)) ; %<-- multiplication by n_w_max not needed in fortran fftw_plan_back. ;
end;%for nS=0:n_S-1;
end;%for nM=0:n_M-1;
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% calculate innerproducts/correlations: %0.3fs',tmp_t)); end;
end;%if flag_blas==0;
%%%%%%%%;
% Use current correlations to udate current euler-angles. ;
%%%%%%%%;
tmp_t = tic();
flag_M_used_ = zeros(n_M,1);
tmp_permutation_ = randperm(n_S)-1;
nS=0; nM_sum=0;
while (sum(flag_M_used_)<n_M);
index_M_unused_ = find(flag_M_used_==0)-1;
[~,index_wM_best] = max(real(X_wSM___(:,1+tmp_permutation_(1+nS),1+index_M_unused_)),[],'all','linear'); index_wM_best = index_wM_best-1;
[nw_best,index_M_best] = ind2sub([n_w_max,numel(index_M_unused_)],1+index_wM_best); 
nw_best = nw_best-1; index_M_best = index_M_best-1;
nM_best = index_M_unused_(1+index_M_best);
flag_M_used_(1+nM_best)=1;
euler_polar_a_(1+nM_best) = viewing_polar_a_all_(1+tmp_permutation_(1+nS));
euler_azimu_b_(1+nM_best) = viewing_azimu_b_all_(1+tmp_permutation_(1+nS));
euler_gamma_z_(1+nM_best) = 2*pi*nw_best/n_w_max;
nS=nS+1; if (nS>=n_S); nS=0; end;
nM_sum=nM_sum+1;
end;%while (sum(flag_M_used_)<n_M);
assert(nM_sum==n_M);
tmp_t = toc(tmp_t); if (verbose); disp(sprintf(' %% update euler_polar_a_ euler_azimu_b_ euler_gamma_z_ : %0.3fs',tmp_t)); end;
%%%%%%%%;
% Now return to beginning of loop. ;
%%%%%%%%;
end;%for niteration=0:n_iteration-1;

