function [U_,V_,W_,S,E] = svd3(T_,n_s) ;
% tensor svd of 3-dim array T_;
% n_s singular values are returned;
verbose=0;
if (verbose); disp(sprintf('')); end;% if verbose;
if (verbose); disp(sprintf('[entering svd3]')); end;% if verbose;

[nrow,ncol,nlyr] = size(T_);
if (verbose); disp(sprintf('T_ of size [%d,%d,%d]',nrow,ncol,nlyr)); end;% if verbose;
U_ = zeros(nrow,n_s); V_ = zeros(ncol,n_s); W_ = zeros(nlyr,n_s); S = zeros(n_s,1); E = zeros(n_s,1);
etol = 1e-6; n_iteration = 1024*8;
if (verbose); disp(sprintf('setting error tolerance to %0.16f and n_iteration to %d',etol,n_iteration)); end;% if verbose;
for ns=1:n_s;
if (verbose); disp(sprintf('searching for ns %d/%d',ns,n_s)); end;% if verbose;
if (verbose); disp(sprintf('defining permuted tensors')); end;% if verbose;
T123_ = permute(T_,[1,2,3]); T231_ = permute(T_,[2,3,1]); T312_ = permute(T_,[3,1,2]);
u_pre = randn(nrow,1); v_pre = randn(ncol,1); w_pre = randn(nlyr,1);
u_pre = u_pre/norm(u_pre); v_pre = v_pre/norm(v_pre); w_pre = w_pre/norm(w_pre);
continue_flag=1; niteration = 0;
while (continue_flag);
if (verbose); disp(sprintf('niteration %d/%d',niteration,n_iteration)); end;% if verbose;
u_pos = u_pre; v_pos = v_pre; w_pos = w_pre;
for nr=1:nrow; u_pos(nr) = transpose(v_pre)*T231_(:,:,nr)*w_pre; end;
for nc=1:ncol; v_pos(nc) = transpose(w_pre)*T312_(:,:,nc)*u_pre; end;
for nl=1:nlyr; w_pos(nl) = transpose(u_pre)*T123_(:,:,nl)*v_pre; end;
u_nrm = norm(u_pos); v_nrm = norm(v_pos); w_nrm = norm(w_pos);
if (verbose); disp(sprintf('found u_nrm %0.8f v_nrm %0.8f w_nrm %0.8f',u_nrm,v_nrm,w_nrm)); end;% if verbose;
s_pos = (u_nrm + v_nrm + w_nrm)/3;
u_pos = u_pos/u_nrm; v_pos = v_pos/v_nrm; w_pos = w_pos/w_nrm;
enow = norm(u_pos-u_pre) + norm(v_pos-v_pre) + norm(w_pos-w_pre);
if (verbose); disp(sprintf('enow %0.16f',enow)); end;% if verbose;
u_pre = u_pos; v_pre = v_pos; w_pre = w_pos;
niteration = niteration+1;
continue_flag = (niteration<n_iteration & enow>etol);
end;%while (continue_flag);
if (1+verbose); disp(sprintf('finished with enow %0.16f niteration %d',enow,niteration)); end;% if verbose;
U_(:,ns) = u_pos; V_(:,ns) = v_pos; W_(:,ns) = w_pos; S(ns) = s_pos;
if (verbose); disp(sprintf('subtracting off outer product')); end;% if verbose;
T_tmp = zeros(nrow,ncol,nlyr);
uv_tmp = u_pos*transpose(v_pos);
for nl=1:nlyr;
T_tmp(:,:,nl) = uv_tmp*s_pos*w_pos(nl);
end;%for nl=1:nlyr;
T_ = T_ - T_tmp;
E(ns) = norm(T_(:));
end;%for ns=1:n_s;
