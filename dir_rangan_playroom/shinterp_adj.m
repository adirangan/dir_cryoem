function val_out_ = shinterp_adj(n_out,n_order,n_polar_a,n_azimu_b,weight__,index__,val_0in_);
%*********************************************************************** ;
%     Apply adjoint of interpolation matrix in sparse format. ;
%--------------------------------------------------------------------- ;
%     INPUT: ;
% ;
%     n_out          : number of targets ;
%     n_order        : interpolation order ;
%     n_polar_a      : number of nodes in theta ;
%     n_azimu_b      : number of nodes in phi ;
%     weight__       : sparse format interpolation weights ;
%     index__        : sparse format col indices ;
%     val_0in_       : input vector (dimensioned as values on irregular grid). ;
%--------------------------------------------------------------------- ;
%     OUTPUT: ;
% ;
%     val_out_       : adjoint of interp matrix applied to val_0in_. ;
%*********************************************************************** ;
% ;
assert(size(index__,1))>=n_out;
assert(size(index__,2))>=n_order*n_order;
assert(size(weight__,1))>=n_out;
assert(size(weight__,2))>=n_order*n_order;
val_out_ = zeros(n_azimu_b*n_polar_a,1);
assert(numel(val_0in_)>=n_out);
for nout=1:n_out;
for norder2=1:n_order*norder;
index_use = index__(nout,norder2);
val_out_(index_use) = val_out_(index_use) + weight__(nout,norder2)*val_0in_(nout);
end;%for norder2=1:n_order*norder;
end;%for nout=1:n_out;

