function [X0_,n_op,n_mult] = register_spharm_to_spharm_single_beta_0(verbose,n_k,k_,n_l_,a_,b_,beta,n_alpha,alpha_,n_gamma,gamma_,a___,b___,ab__,d__);
% tests registration between molecule_A and molecule_B using a single beta (fast only);
% tries to reorder the calculation as a sparse-matrix-multiplication. ;
% ;
% verbose = integer verbosity_level ;
% n_k = integer maximum k ;
% k_ = real array of length n_k; k_(nk) = k_value for shell nk ;
% n_l_ = integer array of length n_k; n_l_(nk) = spherical harmonic order on shell nk; n_l_(nk) corresponds to n_lm_(nk) = (n_l_(nk)+1)^2 coefficients ;
% a_ = complex array of length \sum_{nk} (n_l_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% b_ = complex array of length \sum_{nk} (n_l_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% a_ corresponds to molecule_a, b_ to molecule_b ;
% beta = beta angles ;
% n_alpha = integer number of alpha angles (optional);
% alpha_ = real array of alpha angles (optional);
% n_gamma = integer number of gamma angles (optional);
% gamma_ = real array of gamma angles (optional);
% ;
% If arrays alpha_ and gamma_ are not provided we use the standard arrays: ;
% alpha_ = linspace(0,2*pi,n_m_max+1); alpha_ = alpha_(1:end-1);
% gamma_ = linspace(0,2*pi,n_m_max+1); gamma_ = gamma_(1:end-1);
% and use the standard fft to calculate X0_.; 
% ;
% However, if n_alpha, alpha_ and n_gamma, gamma_ are provided, we use these arrays instead, ;
% and use the nufft to calculate X0_. ;
% ;
% X_ = complex array of size (n_alpha,n_gamma,1);
% The default values of n_alpha and n_gamma are n_m_max. ;
% X_(nalpha,ngamma,nbeta) corresponds to the innerproduct between molecule_A and molecule_B, where ;
% the latter has been rotated by euler-angles alpha,beta,gamma. ;
% Note that alpha_ and gamma_ are arrays from 0 to 2*pi, ;
% whereas beta_ is an array from -pi to pi. ;
%%%%%%%%;
% a___ = a_ rearranged so that mn varies quickly, then k, then l. ;
% b___ = b_ rearranged so that mp varies quickly, then k, then l. ;
% ab__ = \sum_{k} conj(a___)*b___ rearranged so that mn varies quickly, then mp, then l. ;
% d__ = W_ rearranged so that mn varies quickly, then mp, then l. ;

if nargin<1;
verbose=0;
for n_l = 2.^[4:7];
n_k=1;k_=1;n_l_ = [n_l];n_lm_=(n_l_+1).^2;
a_=randn(sum(n_lm_),1);b_=randn(sum(n_lm_),1);
beta = 0;
tic;
[X1_,n_op,n_mult] = register_spharm_to_spharm_single_beta_1(verbose,n_k,k_,n_l_,a_,b_,beta);
disp(sprintf(' %% n_l %d; register_spharm_to_spharm_single_beta_1 time %0.2f',n_l_,toc));
tic;
[X0_,n_op,n_mult] = register_spharm_to_spharm_single_beta_0(verbose,n_k,k_,n_l_,a_,b_,beta);
disp(sprintf(' %% n_l %d; register_spharm_to_spharm_single_beta_0 time %0.2f',n_l_,toc));
disp(sprintf(' %% n_l %d; error %0.16f',n_l_,norm(X0_-X1_)./norm(X0_)));
end;%for n_l = 2.^[4:7];
disp('returning');return;
end;%if nargin<1;

n_lm_ = (n_l_+1).^2; n_lm_csum_ = cumsum([0;n_lm_(:)]);
k_max = k_(end);
n_l_max = n_l_(end);
m_max_ = -n_l_max : +n_l_max;
n_m_max = length(m_max_);

if ((nargin<=7) | n_alpha==0 | n_gamma==0);
fft_flag = 0; 
n_alpha = n_m_max;
n_gamma = n_m_max;
 else;
fft_flag = 1;
end;%else;

X0_ = zeros(n_alpha,n_gamma,1);
% Note that rotating a molecule by [+alpha,+beta,+gamma] ;
% corresponds to rotating the coordinate-frame by [-gamma,-beta,-alpha] ;
if (isempty(d__));
W_ = wignerd_b(n_l_max,-beta);
C_ = zeros(n_m_max,n_m_max);
n_W_ = zeros(1,1+n_l_max); for (nl=0:n_l_max); n_W_(1+nl) = numel(W_{1+nl}); end;
d__ = zeros(n_m_max,n_m_max,1+n_l_max);
for nl=0:n_l_max;
d__(1+n_l_max + [-nl:+nl],1+n_l_max + [-nl:+nl],1+nl) = W_{1+nl};
end;%for nl=0:n_l_max;
end%if (isempty(d__));
if ((isempty(a___) | isempty(b___)) & isempty(ab__));
a___ = zeros(n_m_max,n_k,1+n_l_max); b___ = zeros(n_m_max,n_k,1+n_l_max);
ixk=0;
for nk=0:n_k-1;
ixl=0;
for nl=0:n_l_max;
%ixl = nl*(nl+1);
%a___(1+n_l_max + [-nl:+nl],1+nk,1+nl) = a_(1+ixk+ixl+-[-nl:+nl]);
%b___(1+n_l_max + [-nl:+nl],1+nk,1+nl) = b_(1+ixk+ixl+-[-nl:+nl]);
a___(1+n_l_max + [-nl:+nl],1+nk,1+nl) = a_(1+ixk+ixl+nl+-[-nl:+nl]);
b___(1+n_l_max + [-nl:+nl],1+nk,1+nl) = b_(1+ixk+ixl+nl+-[-nl:+nl]);
ixl = ixl+(2*nl+1);
end;%for nl=0:n_l_max;
assert(ixl==n_lm_(1+nk));
ixk = ixk+n_lm_(1+nk);
end;%for nk=0:n_k-1;
assert(ixk==sum(n_lm_));
end;%if ((isempty(a___) | isempty(b___)) & isempty(ab__));
if (isempty(ab__));
ab__ = zeros(n_m_max,n_m_max,1+n_l_max);
for nl=0:n_l_max;
ab__(:,:,1+nl) = conj(squeeze(a___(:,:,1+nl)))*diag(k_.^2)*transpose(b___(:,:,1+nl));
end;%for nl=0:n_l_max;
end;%if (isempty(ab__));
t_0in = tic;
C_ = zeros(n_m_max,n_m_max);
C_ = sum(ab__.*d__,3);
t_out = toc(t_0in);
if (verbose>1); disp(sprintf(' %% t %0.6f',t_out)); end;
n_op = (n_m_max*n_m_max)*n_k*(1+n_l_max) + (n_m_max*n_m_max)*(1+n_l_max);
n_mult = (n_m_max*n_m_max)*n_k*(1+n_l_max) + (n_m_max*n_m_max)*(1+n_l_max);

if (fft_flag==0);
tmp_C = recenter2(squeeze(C_(:,:)));
X0_(:,:,1) = fft2(tmp_C);
X0_(:,:,1) = conj(X0_(:,:,1)); %<-- ?;
end;%if (fft_flag==0);
if (fft_flag==1);
[gamma__,alpha__] = meshgrid(gamma_,alpha_);
tmp_C = decenter2(recenter2(squeeze(C_(:,:))));
tmp = nufft2d2(n_alpha*n_gamma,alpha__(:),gamma__(:),-1,1e-12,n_m_max,n_m_max,tmp_C);
X0_(:,:,1) = reshape(tmp,n_alpha,n_gamma);
X0_(:,:,1) = conj(X0_(:,:,1)); %<-- ?;
end;%if (fft_flag==1);

