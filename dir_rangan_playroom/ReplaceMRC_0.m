function [map,s,hdr,extraHeader]=ReplaceMRC_0(filename_0in,startSlice, numSlices,test,map_out,filename_out);
% modeled after ReadMRC_0;
verbose=1 ;
hdr=[];
extraHeader=[];
s=struct;
s.err=0;
map=[];
if nargin<1 || numel(filename_0in)<1; % no name given: put up a file selector ;
fprintf('Select an MRC file: ');
[filename_0in,path]=uigetfile('*.mrc;*.mrcs','Open an MRC file');
if isnumeric(filename_0in) ;
disp(' no file selected.');
return ;
 else ;
disp([path filename_0in]);
end;
cd(path);
end;
if nargin<2 || startSlice<1 ;
startSlice=1;
end;
if nargin<3 ;
numSlices=inf;
end;
if nargin<4 ;
test=0;
end;
if nargin<5 ;
map_out = [];
end;
if nargin<6 ;
filename_out = filename_0in;
tmp_ij = strfind(filename_out,'.');
if (~isempty(tmp_ij));
filename_out = sprintf('%s_replaced%s',filename_out(1:tmp_ij-1),filename_out(tmp_ij:end));
end;%if (~isempty(tmp_ij));
if (verbose); disp(sprintf(' %% filename_out: %s',filename_out)); end;
end;%if nargin<6 ;
% We first try for little-endian data ;
f=fopen(filename_0in,'r','ieee-le');
if f<0 ;
error(['in ReadMRC the file could not be opened: ' filename_0in]) ;
end;
% Check the file size ;
fseek(f,0,'eof');  % go to the end of the file ;
nBytes=ftell(f);
fseek(f,0,'bof');  % rewind to start of the file ;
if nBytes<1024;  % Not enough room for the header ;
s.err=2;  % Serious error ;
warning('File is too short for mrc header');
return ;
end;
% Get the first 10 values, which are integers: ;
% nc nr ns mode ncstart nrstart nsstart nx ny nz ;
a=fread(f,10,'*int32');
% Check the nx value. ;
if abs(a(1))>1e5;  % we must have the wrong endian data.  Try again. ;
if (verbose); disp(' %% wrong endian'); end;
fclose(f);
f=fopen(filename_0in,'r','ieee-be');
a=fread(f,10,'int32');  % convert to doubles ;
end;
if test ;
disp(a(1:10)) ;
end;
s.mode=a(4);
% Get the next 12 (entries 11 to 23), which are floats. ;
% the first three are the cell dimensions. ;
% xlength ylength zlength alpha beta gamma mapc mapr maps ;
% amin amax amean. ;
[b,cnt]=fread(f,12,'float32');
if test ;
disp(b) ;
end;
% b(4,5,6) angles ;
s.mi=b(10); % minimum value ;
s.ma=b(11); % maximum value ;
s.av=b(12);  % average value ;
s.rez=double(b(1)); % cell size x, in A. ;
% get the next 30, which brings us up to entry no. 52. ;
[c,cnt]=fread(f,30,'*int32');
if test; disp(c(1:3)); end;
% c(2) is the extended header in bytes. ;
% the next two are supposed to be character strings. ;
[d,cnt]=fread(f,8,'*uint8');
s.chars=char(d)';
if test ;
disp(d) ;
end;
% Two more ints... ;
[e,cnt]=fread(f,2,'*int32');
if test; disp(e); end;
% up to 10 strings.... ;
ns=min(e(2),10);
str=char(zeros(10,80));
for i=1:10 ;
[g,cnt]=fread(f,80,'*uint8');
str(i,:)=char(g)';
end;
% disp('header:'); disp(' ');
% disp(str(1:ns,:));
% disp(' ');
s.header=str(1:ns,:);
% Get ready to read the data. ;
s.nx=double(a(1));
s.ny=double(a(2));
s.nz=double(a(3));
s.mx=double(a(8));
s.my=double(a(9));
s.mz=double(a(10));
s.org=double(a(5:7));
s.pixA=s.rez/s.mx;
nx1=s.nx;
packedBytes=0;
switch s.mode ;
case 0 ;
string='*uint8';
pixbytes=1;
case 1 ;
string='*int16';
pixbytes=2;
case 2 ;
string='*float32';
pixbytes=4;
case 6 ;
string='*uint16';
case {32 101} ;
packedBytes=1;
string='*uint8';
pixbytes=1;
nx1=ceil(nx1/2);  % no. of bytes to read per row ;
otherwise ;
error(['ReadMRC: unknown data mode: ' num2str(s.mode)]);
end;
if (verbose); disp(sprintf(' %% packedBytes %d',packedBytes)); end;
s.string=string;
% Make sure we are at the end of the header. ;
fseek(f,1024,'bof');
if nBytes<1024+c(2)  % not enough space for extended header ;
s.err=2;
warning('File is too short for the mrc extended header');
return ;
end;
if(c(2)>0) ;
%     [extraHeader,cnt]=fread(f,c(2)/4,'*float32');
[extraHeader,cnt]=fread(f,c(2)/2,'*int16');
if test ;
%         disp(['Read extra header of ',num2str(c(2)/4),' floats!']) ;
disp(['Read extra header of ',num2str(c(2)/2),' int16s']) ;
extraHeader(1:16) ;
end;
%    disp((ex_header'));
end ;
if startSlice>1 ;
skipbytes=(startSlice-1)*nx1*s.ny*pixbytes;
fseek(f,skipbytes,'cof');
end;
if numSlices<0 ;
map=f;
return;
elseif numSlices==0 ;
fclose(f);
map=0;
return ;
end;
nz=double(max(0,min(s.nz-(startSlice-1),numSlices)));
% Must be double because ndata can require double precision ;
nDataToRead=nx1 * s.ny * nz;
if test ;
disp(string) ;
disp(nDataToRead) ;
end;
if (verbose); disp(sprintf(' %% about to read map: ftell %d',ftell(f))); end;
if (verbose); disp(sprintf(' %% trying to read %d bytes',nDataToRead)); end;
[map,dcnt]=fread(f,nDataToRead,string);
if (verbose); disp(sprintf(' %% actually read %d bytes',dcnt)); end;
if dcnt ~= nDataToRead ;
warning(sprintf('Not enough data in file: %d pixels, %d expected.',dcnt,nDataToRead));
s.err=1;
end;
if (verbose); disp(sprintf(' %% zero padding %d bytes',numel(dcnt+1:nDataToRead))); end;
map(dcnt+1:nDataToRead)=0;  % fill up the rest of the data array ;
if packedBytes  % have to unpack bytes ;
if (verbose); disp(sprintf(' %% unpacking packed bytes')); end;
tempMap=rem(map',16);
tempMap(2,:)=idivide(map',16);
if 2*nx1>s.nx  % there's a padded element ;
%         diff= 2*nx1-s.nx ;
map=reshape(tempMap,[nx1*2 s.ny nz]);
map(nx1*2,:,:)=[]; % delete one element ;
 else ;
map=reshape(tempMap,[s.nx s.ny nz]);
end;
end;
%%%%;
if (verbose); disp(sprintf(' %% reading header of length %d',256+c(2)/4)); end;
frewind(f);
[hdr, cnt]=fread(f,256+c(2)/4,'*int32');
%%%%;
fclose(f);
%%%%;
if (verbose); disp(sprintf(' %% opening %s',filename_out)); end;
f_out = fopen(filename_out,'w');
if (verbose); disp(sprintf(' %% writing header')); end;
fwrite(f_out,hdr,'*int32');
if (verbose); disp(sprintf(' %% writing replaced map')); end;
if ( isempty(map_out)); disp(sprintf(' %% Warning, map_out not specified')); end;
if (~isempty(map_out));
if numel(map_out)~=numel(map); disp(sprintf(' %% Warning, numel(map) %d numel(map_out) %d',numel(map),numel(map_out))); end;
if numel(map_out)==numel(map); 
fwrite(f_out,map_out,string);
end;%if numel(map_out)==numel(map); 
end;%if (~isempty(map_out));
if (verbose); disp(sprintf(' %% closing %s',filename_out)); end;
fclose(f_out);
map=reshape(map,s.nx,s.ny,nz);
% ;
% f=fopen(filename_0in,'r','ieee-be');
% fseek(f,1024,'bof');
% ;
% if(c(2)>0) ;
%     [extraHeader,cnt]=fread(f,c(2)/4,'*float32');
%     disp(['Read extra header of ',num2str(c(2)/4),' floats!']) ;
% %    disp((ex_header'));
% end ;
% fclose(f);
