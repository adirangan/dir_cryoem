function [a_] = convert_k_p_to_spharm_0(verbose,n_k_p_r,k_p_r_,l_val_,n_all,n_sub_,k_p_r_all_,azimu_b_all_,polar_a_all_,weight_all_,a_all_);
% reconstitutes spherical-harmonic-expansion a_ from a collection of points on spherical shells determined by k_p_r_. ;
% These points are themselves represented using polar (spherical) coordinates (i.e., azimu_b_ and polar_a_). ;
% We assume that the quadrature weights associated with these points have been previously calculated. ; 
% ;
% inputs: ;
% ;
% verbose = integer verbosity_level ;
% n_k_p_r = integer maximum k ;
% k_p_r_ = real array of length n_k_p_r; k_p_r_(nk_p_r) = k_p_r_value for shell nk_p_r ;
% l_val_ = integer array of length n_k_p_r; l_val_(nk_p_r) = spherical harmonic order on shell nk_p_r; l_val_(nk_p_r) corresponds to n_lm_(nk_p_r) = (l_val_(nk_p_r)+1)^2 coefficients ;
% n_all = integer total number of points ;
% n_sub_ = integer array of starting indices associated with each k-value ;
% k_p_r_all_ = real array of k-values for each point ;
% azimu_b_all_ = real array of azimu_b-values for each point ;
% polar_a_all_ = real array of polar_a-values for each point ;
% weight_all_ = real array of quadrature weights for each point ;
% a_all_ = complex array of a-values for each point ;
% ;
% outputs: ;
% ;
% a_ = complex array of length \sum_{nk_p_r} (n_lm_(nk_p_r)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;

n_lm_ = (l_val_+1).^2;
k_p_r_max = k_p_r_(end);
l_val_max = l_val_(end);
m_max_ = -l_val_max : +l_val_max;
n_m_max = length(m_max_);

a_ = zeros(sum(n_lm_),1);
n_sub = 0;
for nk_p_r=1:n_k_p_r;
k_p_r = k_p_r_(nk_p_r); 
n_sub = n_sub_(nk_p_r);
if nk_p_r<n_k_p_r; length_sub = n_sub_(nk_p_r+1) - n_sub_(nk_p_r); else length_sub = n_all - n_sub ; end;
index_sub_ = n_sub + (1:length_sub);
k_p_r_sub_ = k_p_r_all_(index_sub_); 
assert(sum(k_p_r_sub_==k_p_r)==length_sub);
azimu_b_sub_ = azimu_b_all_(index_sub_);
polar_a_sub_ = polar_a_all_(index_sub_);
weight_sub_ = weight_all_(index_sub_);
a_sub_ = a_all_(index_sub_);
l_val_max = l_val_(nk_p_r); n_lm = n_lm_(nk_p_r); ix_base = sum(n_lm_(1:nk_p_r-1));
A_ = zeros(1,n_lm);
l_ = []; m_ = []; for nl=0:l_val_max; l_ = [l_ , nl*ones(1,2*nl+1) ]; m_ = [m_ , [-nl:+nl] ]; end;%for nl=0:l_val_max;
if (verbose>1); disp(sprintf(' %% length_sub %d nk_p_r %d k %d/%d: l_val_max %d n_lm %d ix_base %d',length_sub,nk_p_r,k_p_r,k_p_r_max,l_val_max,n_lm,ix_base)); end;
for nl=0:l_val_max;
l_val = nl;
if (verbose>2); disp(sprintf(' %% nk_p_r %d k_p_r %d/%d: nl %d l_val %d',nk_p_r,k_p_r,k_p_r_max,nl,l_val)); end;
Llm__=legendre(l_val,cos(polar_a_sub_),'unnorm');
for m_val = -l_val:+l_val;
ix = 1+l_val*(l_val+1)+m_val;
m_abs = abs(m_val);
if (length_sub>0); if (l_val>0); Llm_ = squeeze(Llm__(1+m_abs,:,:)); end; if (l_val==0); Llm_ = Llm__(:,:); end; end;
a1=((2*l_val+1)/(4*pi));
a2=exp(lfactorial(l_val-m_abs) - lfactorial(l_val+m_abs));
c=sqrt(a1*a2);
s=(-1)^((m_val<0)*m_val); % needed to preserve condon-shortley phase. ;
%s=1; % original phase ;
if (length_sub>0); 
Ylm_ = s*c*Llm_(:).*exp(+i*m_val*azimu_b_sub_(:)); 
A_(ix) = dot(s*Ylm_(:),a_sub_(:).*weight_sub_(:))./k_p_r.^2;
end;%if (length_sub>0); 
end;%for m_val = -l_val:+l_val;
end;%for nl=0:l_val_max;
a_(ix_base + (1:n_lm)) = A_;
end;%for nk_p_r=1:n_k_p_r;



