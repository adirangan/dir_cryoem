function ...
[ ...
 parameter ...
,flag_image_delta_upd_ ...
,FTK ...
,M_k_q__ ...
,svd_VUXM_lwnM____ ...
,UX_M_l2_dM__ ...
,VSCTF_Mc__ ...
,a_CTF_avg_UX_Y__ ...
,euler_polar_a__ ...
,euler_azimu_b__ ...
,euler_gamma_z__ ...
,image_delta_x_acc__ ...
,image_delta_y_acc__ ...
,image_delta_x_upd__ ...
,image_delta_y_upd__ ...
,flag_image_delta_upd__ ...
,image_I_value__ ...
,image_X_value__ ...
,image_S_index__ ...
] = ...
ampmut_3( ...
 parameter ...
,n_k_p_r ...
,k_p_r_ ...
,k_p_r_max ...
,n_w_max ...
,FTK ...
,pm_n_UX_rank ...
,UX__ ...
,X_weight_r_ ...
,n_M ...
,M_k_p__ ...
,M_k_q__ ...
,svd_VUXM_lwnM____ ...
,UX_M_l2_dM__ ...
,n_CTF_rank ...
,CTF_index_ ...
,CTF_k_p_r__ ...
,VSCTF_Mc__ ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_delta_x_acc_ ...
,image_delta_y_acc_ ...
,image_delta_x_upd_ ...
,image_delta_y_upd_ ...
,flag_image_delta_upd_ ...
,image_I_value_ ...
);
%%%%%%%%;
% simple alternating minimization using principal modes. ;
% displacements drawn from disc (e.g., of radius delta_r_max). ;
% updates displacements (i.e., updates translations) each iteration. ;
% uses a low-rank approximation of the ctf-function for each image. ;
% ;
% Input: ;
% n_k_p_r: integer number of shells. ;
% k_p_r_: real array of size n_k_p_r. k_p_r for each shell. ;
% k_p_r_max: real maximum radius (of sphere) to be integrated. ;
% FTK: structure produced by ampmh_FTK_1.m ;
% n_w_max: integer number of inplane_gamma_z values recorded on each image-ring. ;
%          Should be even. ;
%          Defined such that n_w_max = 2*(l_max_max+1);
% n_w_: integer array of size n_k_p_r. ;
%       fixed to be n_w_max*ones(n_k_p_r,1). ;
% pm_n_UX_rank: integer number of principal-modes used in UX__. ;
% UX__: real array of size (n_w_max,pm_n_UX_rank). principal-mode right-singular-vectors. ;
% X_weight_r_: real array of size n_w_max. variance scaling (weight) for different principle-image rings. ;
% n_M: integer number of images. ;
% M_k_p__: complex array of size (n_w_sum,n_M). stack of images in k_p_ format. ;
% M_k_q__: complex array of size (n_w_sum,n_M). stack of images in k_q_ format. ;
% svd_VUXM_lwnM____: complex array of size(FTK.n_svd_l,n_w_max,pm_n_UX_rank,n_M). Principal-images combined with FTK-modes. ;
% UX_M_l2_dM__: real array of size(FTK.n_delta_v,n_M). norms of principal-images (translated in accordance with the FTK.delta_x_ and FTK.delta_y_). ; 
% n_CTF_rank: integer number of ranks to use in CTF_k_p_r__ approximation. ;
% CTF_index_: integer array of size n_M. CTF_index_(1+nM) is the CTF_index used for image M_k_p__(:,1+nM). ;
% CTF_k_p_r__: complex array of size(n_k_p_r,n_CTF). stack of ctf-functions in k_p_r_ format. ;
% VSCTF_Mc__: complex array of size(n_M,n_CTF_rank). Equal to VCTF_Mc__*SCTF_c__, where [UCTF_kc__,SCTF_c__,VCTF_Mc__] = svds(CTF_k_p_r__). ;
% l_max_max: integer order used for each principal-mode of the principal-volumes a_UCTF_UX_Y_ync__ and a_CTF_avg_UX_Y_. ;
%            fixed to be n_w_max/2 - 1. ;
% euler_polar_a_: real array of size n_M. initial polar_a used for each image (randomized if empty). ;
% euler_azimu_b_: real array of size n_M. initial azimu_b used for each image (randomized if empty). ;
% euler_gamma_z_: real array of size n_M. initial gamma_z used for each image (randomized if empty). ;
% image_delta_x_acc_: real array of size n_M. accumulated delta_x used for each image (zero if empty). ;
% image_delta_y_acc_: real array of size n_M. accumulated delta_y used for each image (zero if empty). ;
% image_delta_x_upd_: real array of size n_M. update to delta_x used for each image (zero if empty). ;
% image_delta_y_upd_: real array of size n_M. update to delta_y used for each image (zero if empty). ;
% flag_image_delta_upd_: integer array of size n_M. flag identifying principal-images that need to be recalculated. (one if empty);
% image_I_value_: real array of size n_M. initial I_value used for each image (one if empty). ;
%%%%%%%%;
% Parameters: ;
% rseed: integer random seed. default 0. ;
% n_iteration: integer number of iterations for alternating minimization. default 16. ;
% delta_r_max: real number maximum displacement used for FTK. ;
%              default 0.1. ;
% delta_r_upb: real number maximum displacement used to bound accumulated translation. default 2*delta_r_max ;
% delta_r_upd_threshold: real number used to determine when to combine displacement-update with accumulated-displacement. ;
%                        default 0*delta_r_max (i.e., always combine). ;
%%%%;
% flag_I_value_vs_1: integer 0 or 1. ;
%                    if set to 1 will use I_value estimated from alignment. ;
%                    if set to 0 will ignore I_value. ;
%                    default 0. ;
% flag_qbp_vs_lsq: integer 0 or 1. ;
%                  if set to 1 will use quadrature-back-projection. ;
%                  if set to 0 will use least-squares ;
%                  default 0. ;
% n_order: integer polynomial interpolation order used for conjugate-gradient interpolation operator. default 5. ;
% order_limit_MS: integer greater or equal to 0. This is the order to which the MS-phase model is limited during the first half of the iterations. ;
%         default -1. (i.e., not used). ;
%%%%;
% svd_eps: real number FTK svd error. ;
%          default is tolerance_master. ;
% svd_eps_use: real number FTK svd error to use. default 0 (i.e., use svd_eps). ;
% n_svd_l_use: integer number of l-values to use in FTK. default 0 (i.e., use FTK.n_svd_l). ;
% n_delta_v_requested: integer number of displacements requested (actual number of displacements will be stored in FTK.n_delta_v). ;
%                      default is 2*FTK.n_svd_l. ;
% n_delta_v_requested_use: integer number of displacements to use. default 0 (i.e., use n_delta_v_requested). ;
% n_w_max_use: integer number of bessel-modes to use. default 0 (i.e., use n_w_max). ;
% pm_n_UX_rank_use: integer number of principal-modes to use. default 0 (i.e., use pm_n_UX_rank). ;
% n_CTF_rank_use: integer number of ranks to use in CTF_k_p_r__ approximation. default 0 (i.e., use n_CTF_rank). ;
% flag_optimize_over_gamma: integer equal to 1. ; optimizes over gamma when aligning images (hardcoded). ;
% n_M_per_Mbatch: integer number of images to consider in each batch during alignment. default 24. ;
% n_S_per_Sbatch: integer number of templates to consider in each batch during alignment. default 24. ;
% flag_compute_I_value: integer set to 0. Will not compute I-values during alignment (hardcoded). ;
%%%%;
% flag_MS_vs_SM: integer 0 or 1. ;
%                if set to 1 will enforce uniform distribution of viewing angles. ;
%                if set to 0 will match templates to images. ;
%                default 1. ;
% f_rand: real number. fraction of best templates to select from when matching templates to images. default 0.05. ;
%%%%;
% flag_X_local_vs_global: integer 0 or 1. ;
%                         if set to 1 will apply local search to align images. ;
%                         if set to 0 will apply global search to align images. ;
%                         default 0. ;
% n_neighborhood_retain: integer greater or equal to 1. The number of template-neighbors to retain during the local-alignment. default 2. ;
% template_tree_n_level: integer number of levels in template tree during local-alignment. default 2. ;
% template_viewing_k_eq_d: real equatorial distance (measured on sphere of radius 1) for building viewing angles ;
%                          (i.e., each viewing angle is associated with a principal-template). ;
%                          default is 1.0/max(1e-12,k_p_r_max). ;
% template_viewing_k_eq_d_min: real number for the equatorial-distance used for building the template-tree.
%                              must be equal to template_viewing_k_eq_d (hardcoded). ;
%%%%%%%%;
% ;
% Output: ;
% Many of the inputs are listed as outputs as well, so that subsequent iterations of this function can be called without needless recalculation. ;
% In addition, the following are returned: ;
% a_CTF_avg_UX_Y__: complex array of size (pm_n_lm_sum,n_iteration). stack of output principal-volumes in k_Y_ format. ;
% euler_polar_a__: real array of size (n_M,n_iteration). list of polar_a used for each image at each iteration. ;
% euler_azimu_b__: real array of size (n_M,n_iteration). list of azimu_b used for each image at each iteration. ;
% euler_gamma_z__: real array of size (n_M,n_iteration). list of gamma_z used for each image at each iteration. ;
% image_delta_x_acc__: real array of size (n_M,n_iteration). list of accumulated delta_x used for each image at each iteration. ;
% image_delta_y_acc__: real array of size (n_M,n_iteration). list of accumulated delta_y used for each image at each iteration. ;
% image_delta_x_upd__: real array of size (n_M,n_iteration). list of update to delta_x used for each image at each iteration. ;
% image_delta_y_upd__: real array of size (n_M,n_iteration). list of update to delta_y used for each image at each iteration. ;
% flag_image_delta_upd__: integer array of size (n_M,n_iteration). list of flag identifying principal-images that need to be recalculated. ;
% image_I_value__: real array of size (n_M,n_iteration). list of I_value (i.e., image intensity) used for each image at each iteration. ;
% image_X_value__: real array of size (n_M,n_iteration). list of X_S (i.e., template-image correlation) used for each image at each iteration. ;
% image_S_index__: real array of size (n_M,n_iteration). list of S_index (i.e., template index) used for each image at each iteration. ;
%%%%%%%%;

if nargin<1;
%%%%%%%%;
% First define integral of <f,f>. ;
%%%%%%%%;
h2d_ = @(kd) 4*pi^2*(besselj(0,kd) + besselj(2,kd)); % calculates <f_j,f_k>, normalized so that <f,f> = (4*pi^2);
dh2d_ = @(kd) 4*pi^3*(besselj(-1,kd) - besselj(+3,kd));
h3d_ = @(kd) 4*pi*( sin(kd) - (kd).*cos(kd) ) ./ kd.^3 ; % calculates <f_j,f_k>, normalized so that <f,f> = 4*pi/3;
dh3d_ = @(kd) 12*pi*( (kd.^2/3 - 1) .* sin(kd) + (kd).*cos(kd) ) ./ kd.^4 ;
%%%%%%%%;
verbose=1; nf=0;
tolerance_master = 1e-2; %<-- used to determine accuracy. ;
if (verbose); disp(sprintf(' %% [testing ampmut_3.m]')); end;
%%%%%%%%;
half_diameter_x_c = 1.0d0;
diameter_x_c = 2.0d0*half_diameter_x_c;
x_p_r_max = 1.0;
x_u_res = 64;
x_u_0_ = linspace(-x_p_r_max,+x_p_r_max,x_u_res);
x_u_1_ = linspace(-x_p_r_max,+x_p_r_max,x_u_res);
x_u_2_ = linspace(-x_p_r_max,+x_p_r_max,x_u_res);
[X_u_0_,X_u_1_,X_u_2_] = ndgrid(x_u_0_,x_u_1_,x_u_2_); n_X_u = x_u_res^3;
X_u_weight_ = (2*x_p_r_max/x_u_res)^3;
%%%%%%%%;
k_p_r_max = 48/(2*pi); k_eq_d = 1.0/max(1e-12,k_p_r_max); TorL = 'L';
%%%%%%%%;
tmp_t = tic();
[ ...
 n_k_all ...
,n_k_all_csum_ ...
,k_p_r_all_ ...
,k_p_azimu_b_all_ ...
,k_p_polar_a_all_ ...
,weight_3d_k_all_ ...
,weight_shell_k_ ...
,n_k_p_r ...
,k_p_r_ ...
,weight_3d_k_p_r_ ...
,k_c_0_all_ ...
,k_c_1_all_ ...
,k_c_2_all_ ...
,J_node_ ...
,J_weight_ ...
,J_chebfun_ ...
,J_polyval_ ...
] = ...
sample_sphere_7( ...
 verbose ...
,k_p_r_max ...
,k_eq_d ...
,TorL ...
) ;
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% sample_sphere_7: %0.2fs',tmp_t)); end;
if (verbose); disp(sprintf(' %% k_p_r_max %0.2f k_eq_d %0.2f n_k_all %d n_k_p_r %d',k_p_r_max,k_eq_d,n_k_all,n_k_p_r)); end;
%%%%%%%%;
l_max_upb = 36;
l_max_ = zeros(n_k_p_r,1);
for nk_p_r=0:n_k_p_r-1;
l_max_(1+nk_p_r) = max(0,min(l_max_upb,1+ceil(2*pi*k_p_r_(1+nk_p_r))));
end;%for nk_p_r=0:n_k_p_r-1;
n_lm_ = (l_max_+1).^2;
n_lm_max = max(n_lm_);
n_lm_sum = sum(n_lm_);
n_lm_csum_ = cumsum([0;n_lm_]);
l_max_max = max(l_max_); dWtdkd__l_max_max = 2*l_max_max;
m_max_ = -l_max_max : +l_max_max;
n_m_max = length(m_max_);
Y_l_val_ = zeros(n_lm_sum,1);
Y_m_val_ = zeros(n_lm_sum,1);
Y_k_val_ = zeros(n_lm_sum,1);
for nk_p_r=0:n_k_p_r-1;
l_max = l_max_(1+nk_p_r);
tmp_l_val_ = zeros(n_lm_(1+nk_p_r),1);
tmp_m_val_ = zeros(n_lm_(1+nk_p_r),1);
na=0; 
for l_val=0:l_max;
for m_val=-l_val:+l_val;
tmp_l_val_(1+na) = l_val;
tmp_m_val_(1+na) = m_val;
na=na+1;
end;%for m_val=-l_val:+l_val;
end;%for l_val=0:l_max;
tmp_index_ = n_lm_csum_(1+nk_p_r) + (0:n_lm_(1+nk_p_r)-1);
Y_l_val_(1+tmp_index_) = tmp_l_val_;
Y_m_val_(1+tmp_index_) = tmp_m_val_;
Y_k_val_(1+tmp_index_) = k_p_r_(1+nk_p_r);
end;%for nk_p_r=0:n_k_p_r-1;
%%%%%%%%;
% Synthetic volume a_x_c_ a sum of point-sources with random locations drawn from centered uniform gaussian. ;
% Thus, a_k_p_ a sum of plane-waves with frequencies drawn from centered uniform gaussian. ;
%%%%%%%%;
n_delta_orig = 32;
delta_orig__ = zeros(3,n_delta_orig);
rng(0);
for ndelta_orig=0:n_delta_orig-1;
delta_orig_ = 0.15*randn(3,1);
delta_orig__(:,1+ndelta_orig) = delta_orig_;
end;%for ndelta_orig=0:n_delta_orig-1;
%%%%%%%%;
a_k_p_orig_ = zeros(n_k_all,1);
for ndelta_orig=0:n_delta_orig-1;
delta_orig_ = delta_orig__(:,1+ndelta_orig);
a_k_p_orig_ = a_k_p_orig_ + exp(+2*pi*i*(k_c_0_all_*delta_orig_(1+0) + k_c_1_all_*delta_orig_(1+1) + k_c_2_all_*delta_orig_(1+2)));
end;%for ndelta_orig=0:n_delta_orig-1;
%%%%%%%%;
% reconstruct a_x_u_ in x_c_space. ;
%%%%%%%%;
tmp_t = tic;
tmp_eta = pi/k_p_r_max;
a_x_u_reco_ = nufft3d3(n_k_all,2*pi*k_c_0_all_*tmp_eta,2*pi*k_c_1_all_*tmp_eta,2*pi*k_c_2_all_*tmp_eta,a_k_p_orig_.*(2*pi)^3.*weight_3d_k_all_,+1,1e-12,n_X_u,X_u_0_(:)/tmp_eta,X_u_1_(:)/tmp_eta,X_u_2_(:)/tmp_eta)/sqrt(2*pi)/sqrt(2*pi)/sqrt(2*pi);
a_x_u_reco_ = real(a_x_u_reco_);
tmp_t = toc(tmp_t); disp(sprintf(' %% nufft3d3: a_x_u_reco_ time %0.2fs',tmp_t));
%%%%%%%%;
flag_plot=1;
if flag_plot;
figure(1+nf);nf=nf+1;figbig;
isosurface_f_x_u_0(reshape(a_x_u_reco_,x_u_res,x_u_res,x_u_res),[90,95,99]);
axis equal; axis vis3d; xlabel('x'); ylabel('y'); zlabel('z');
end;%if flag_plot;
%%%%%%%%;
% a_k_Y_form_ represents a_k_p_orig_. ;
%%%%%%%%;
a_k_Y_form_ = zeros(n_lm_sum,1);
for ndelta_orig=0:n_delta_orig-1;
delta_orig_ = delta_orig__(:,1+ndelta_orig);
delta_orig_r012 = sqrt(delta_orig_(1+0)^2 + delta_orig_(1+1)^2 + delta_orig_(1+2)^2);
delta_orig_r01 = sqrt(delta_orig_(1+0)^2 + delta_orig_(1+1)^2);
delta_orig_polar_a = atan2(delta_orig_r01,delta_orig_(1+2));
delta_orig_azimu_b = atan2(delta_orig_(1+1),delta_orig_(1+0));
delta_Ylm_ = get_Ylm__(1+l_max_max,0:l_max_max,1,delta_orig_azimu_b,delta_orig_polar_a);
na=0;
for nk_p_r=0:n_k_p_r-1;
k_p_r = k_p_r_(1+nk_p_r);
l_max = l_max_(1+nk_p_r);
for l_val=0:l_max;
tmp_x = 2*pi*k_p_r*delta_orig_r012;
tmp_jl = besselj(l_val+0.5,tmp_x)*sqrt(pi/(2*tmp_x));
for m_val=-l_val:+l_val;
a_k_Y_form_(1+na) = a_k_Y_form_(1+na) + 4*pi * i^l_val * tmp_jl * conj(delta_Ylm_{1+l_val}(1+m_val+l_val));
na=na+1;
end;%for m_val=-l_val:+l_val;
end;%for l_val=0:l_max;
end;%for nk_p_r=0:n_k_p_r-1;
assert(na==n_lm_sum);
end;%for ndelta_orig=0:n_delta_orig-1;
%%%%%%%%;
% choose l_max based on tolerance_master. ;
%%%%%%%%;
a_k_Y_norm_ = zeros(1+l_max_max,1);
for l_val=0:l_max_max;
a_k_Y_norm_(1+l_val) = fnorm(a_k_Y_form_(1+efind(Y_l_val_==l_val)));
end;%for l_val=0:l_max_max;
a_k_Y_norm_ = sqrt(cumsum(a_k_Y_norm_.^2));
a_k_Y_norm_ = a_k_Y_norm_/max(a_k_Y_norm_);
l_max_max_use = min(find(a_k_Y_norm_> 1-tolerance_master));
a_k_Y_form_ = a_k_Y_form_(1+efind(Y_l_val_<=l_max_max_use));
l_max_max = l_max_max_use;
%%%%%%%%;
% redefine Y indices. ;
%%%%%%%%;
l_max_upb = l_max_max;
l_max_ = zeros(n_k_p_r,1);
for nk_p_r=0:n_k_p_r-1;
l_max_(1+nk_p_r) = max(0,min(l_max_upb,1+ceil(2*pi*k_p_r_(1+nk_p_r))));
end;%for nk_p_r=0:n_k_p_r-1;
n_lm_ = (l_max_+1).^2;
n_lm_max = max(n_lm_);
n_lm_sum = sum(n_lm_);
n_lm_csum_ = cumsum([0;n_lm_]);
l_max_max = max(l_max_); dWtdkd__l_max_max = 2*l_max_max;
m_max_ = -l_max_max : +l_max_max;
n_m_max = length(m_max_);
Y_l_val_ = zeros(n_lm_sum,1);
Y_m_val_ = zeros(n_lm_sum,1);
Y_k_val_ = zeros(n_lm_sum,1);
for nk_p_r=0:n_k_p_r-1;
l_max = l_max_(1+nk_p_r);
tmp_l_val_ = zeros(n_lm_(1+nk_p_r),1);
tmp_m_val_ = zeros(n_lm_(1+nk_p_r),1);
na=0; 
for l_val=0:l_max;
for m_val=-l_val:+l_val;
tmp_l_val_(1+na) = l_val;
tmp_m_val_(1+na) = m_val;
na=na+1;
end;%for m_val=-l_val:+l_val;
end;%for l_val=0:l_max;
tmp_index_ = n_lm_csum_(1+nk_p_r) + (0:n_lm_(1+nk_p_r)-1);
Y_l_val_(1+tmp_index_) = tmp_l_val_;
Y_m_val_(1+tmp_index_) = tmp_m_val_;
Y_k_val_(1+tmp_index_) = k_p_r_(1+nk_p_r);
end;%for nk_p_r=0:n_k_p_r-1;
%%%%%%%%;
% generate templates S_k_p_ on k_p_ grid with uniform n_w_. ;
%%%%%%%%;
n_w_max = 2*(l_max_max+1);
template_k_eq_d = -1;
viewing_k_eq_d = k_eq_d*8;
tmp_t = tic();
[ ...
 S_k_p__ ...
,n_w_ ...
,weight_2d_k_p_r_ ...
,weight_2d_k_all_ ...
,n_viewing_all ...
,viewing_azimu_b_all_ ...
,viewing_polar_a_all_ ...
,viewing_weight_all_ ...
,n_viewing_polar_a ...
,viewing_polar_a_ ...
,n_viewing_azimu_b_ ...
,template_k_c_0__ ...
,template_k_c_1__ ...
,template_k_c_2__ ...
] = ...
get_template_1( ...
 0*verbose ...
,n_k_p_r ...
,k_p_r_ ...
,k_p_r_max ...
,weight_3d_k_p_r_ ...
,l_max_ ...
,a_k_Y_form_ ...
,viewing_k_eq_d ...
,template_k_eq_d ...
,n_w_max*ones(n_k_p_r,1) ...
);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% get_template_1: %0.2fs',tmp_t)); end;
if (verbose); disp(sprintf(' %% n_viewing_all %d n_viewing_polar_a %d n_w_max %d',n_viewing_all,n_viewing_polar_a,max(n_w_))); end;
n_S = n_viewing_all; n_w_max = max(n_w_); n_w_sum = sum(n_w_); n_w_csum_ = cumsum([0;n_w_]);
%%%%%%%%;
flag_plot=1;
if flag_plot;
figure(1+nf);nf=nf+1;clf;figbig;
for nl=0:15-1;
subplot(3,5,1+nl); nS = max(0,min(n_S-1,floor(n_S*nl/15)));
imagesc_p(n_k_p_r,k_p_r_,n_w_,n_w_sum,real(S_k_p__(:,1+nS)),sqrt(n_delta_orig)*[-1,+1],colormap_80s);
axis equal; axisnotick; title(sprintf('nS %d',nS));
end;%for nl=0:15-1;
sgtitle(sprintf('Sample S_k_p__'),'Interpreter','none');
end;%if flag_plot;
%%%%%%%%;
S_k_q__ = zeros(n_w_sum,n_S);
for nS=0:n_S-1;
S_k_q__(:,1+nS) = ...
interp_p_to_q( ...
 n_k_p_r ...
,n_w_ ...
,n_w_sum ...
,S_k_p__(:,1+nS) ...
);
end;%for nS=0:n_S-1;
%%%%%%%%;
% Images drawn from templates. ;
% Random in-plane rotations and shifts. ;
% Synthetic ctfs are sinusoids. ;
% Roughly 50 images per ctf. ;
%%%%%%%%;
n_M = n_S;
euler_polar_a_true_ = zeros(n_M,1);
euler_azimu_b_true_ = zeros(n_M,1);
euler_gamma_z_true_ = zeros(n_M,1);
delta_r_max = 0.10;
image_delta_x_true_ = zeros(n_M,1);
image_delta_y_true_ = zeros(n_M,1);
image_delta_r_true_ = zeros(n_M,1);
T_k_p__ = zeros(n_w_sum,n_M);
M_k_p__ = zeros(n_w_sum,n_M);
rng(0);
for nM=0:n_M-1;
euler_polar_a_true_(1+nM) = viewing_polar_a_all_(1+nM);
euler_azimu_b_true_(1+nM) = viewing_azimu_b_all_(1+nM);
euler_gamma_z_true_(1+nM) = 2*pi*rand();
image_delta_x_true_(1+nM) = delta_r_max*randn();
image_delta_y_true_(1+nM) = delta_r_max*randn();
image_delta_r_true_(1+nM) = sqrt( image_delta_x_true_(1+nM).^2 + image_delta_y_true_(1+nM).^2 );
T_k_p_ = S_k_p__(:,1+nM);
T_k_p_ = rotate_p_to_p_fftw(n_k_p_r,n_w_,n_w_sum,T_k_p_,+euler_gamma_z_true_(1+nM));
T_k_p_ = transf_p_to_p(n_k_p_r,k_p_r_,n_w_,n_w_sum,T_k_p_,-image_delta_x_true_(1+nM),-image_delta_y_true_(1+nM));
T_k_p__(:,1+nM) = T_k_p_;
end;%for nM=0:n_M-1;
%%%%%%%%;
n_ctf = max(1,floor(n_M/50));
CTF_index_ = sort(mod(transpose(0:n_M-1),n_ctf));
CTF_k_p_r__ = zeros(n_k_p_r,n_ctf);
rng(0);
for nctf=0:n_ctf-1;
CTF_k_p_r__(:,1+nctf) = sin(k_p_r_*(1+0.25*rand()));
end;%for nctf=0:n_ctf-1;
SCTF_ = svd(CTF_k_p_r__(:,1+CTF_index_)); %<-- weighted average. ;
n_CTF_rank = min(efind(cumsum(SCTF_,'reverse')/sum(SCTF_)<tolerance_master));
[UCTF_kc__,SCTF_c__,VCTF_Mc__] = svds(CTF_k_p_r__(:,1+CTF_index_),n_CTF_rank);
VSCTF_Mc__ = VCTF_Mc__*SCTF_c__;
for nM=0:n_M-1;
nctf = CTF_index_(1+nM);
M_k_p_ = T_k_p__(:,1+nM);
M_k_p_wr__ = reshape(M_k_p_,[n_w_max,n_k_p_r]);
M_k_p_wr__ = M_k_p_wr__*diag(CTF_k_p_r__(:,1+nctf));
M_k_p_ = M_k_p_wr__(:);
M_k_p__(:,1+nM) = M_k_p_;
end;%for nM=0:n_M-1;
%%%%%%%%;
flag_plot=1;
if flag_plot;
figure(1+nf);nf=nf+1;clf;figbig;
for nl=0:15-1;
subplot(3,5,1+nl); nM = max(0,min(n_M-1,floor(n_M*nl/15)));
imagesc_p(n_k_p_r,k_p_r_,n_w_,n_w_sum,real(M_k_p__(:,1+nM)),sqrt(n_delta_orig)*[-1,+1],colormap_80s);
axis equal; axisnotick; title(sprintf('nM %d',nM));
end;%for nl=0:15-1;
sgtitle(sprintf('Sample M_k_p__'),'Interpreter','none');
end;%if flag_plot;
%%%%%%%%;
% Now determine the CTF cross correlation. ;
% This depends  on CTF_index_. ;
%%%%%%%%;
CTF_avg_k_p_r_ = mean(CTF_k_p_r__(:,1+CTF_index_),2);
CTF_k_p_r_xavg__ = CTF_avg_k_p_r_ * transpose(CTF_avg_k_p_r_);
CTF_k_p_r_xcor__ = CTF_k_p_r__(:,1+CTF_index_) * transpose(CTF_k_p_r__(:,1+CTF_index_)) / n_M;
%%%%%%%%;
n_UX_rank = n_k_p_r - 1 ; %<-- just a little different to check for errors. ;
delta_sigma = 1.0 * std([image_delta_x_true_ ; image_delta_y_true_],1); %<-- no reduction. ;
[X_2d_xcor_d1__,X_2d_xcor_d1_weight_r_] = principled_marching_cost_matrix_5(n_k_p_r,k_p_r_,weight_2d_k_p_r_,l_max_,[],[],a_k_Y_form_,CTF_k_p_r_xcor__,delta_sigma);
[UX_2d_xcor_d1__,SX_2d_xcor_d1__,VX_2d_xcor_d1__] = svds(X_2d_xcor_d1__,n_UX_rank); SX_2d_xcor_d1_ = diag(SX_2d_xcor_d1__);
[X_2d_Memp_d1__,X_2d_Memp_d1_weight_r_] = principled_marching_empirical_cost_matrix_0(n_k_p_r,k_p_r_,weight_2d_k_p_r_,n_w_,n_M,M_k_p__);
[UX_2d_Memp_d1__,SX_2d_Memp_d1__,VX_2d_Memp_d1__] = svds(X_2d_Memp_d1__,n_UX_rank); SX_2d_Memp_d1_ = diag(SX_2d_Memp_d1__);
%%%%%%%%;
flag_plot=1;
if flag_plot;
figure(1+nf);nf=nf+1;clf;figmed;figbeach();
np=0;
subplot(2,3,1+np);np=np+1; imagesc(X_2d_xcor_d1__); axis image; axisnotick; title(sprintf('X_2d_xcor_d1__'),'Interpreter','none');
subplot(2,3,1+np);np=np+1; imagesc(UX_2d_xcor_d1__); axis image; axisnotick; title(sprintf('UX_2d_xcor_d1__'),'Interpreter','none');
subplot(2,3,1+np);np=np+1; plot(SX_2d_xcor_d1_,'ko-'); title(sprintf('SX_2d_xcor_d1__'),'Interpreter','none');
subplot(2,3,1+np);np=np+1; imagesc(X_2d_Memp_d1__); axis image; axisnotick; title(sprintf('X_2d_Memp_d1__'),'Interpreter','none');
subplot(2,3,1+np);np=np+1; imagesc(UX_2d_Memp_d1__); axis image; axisnotick; title(sprintf('UX_2d_Memp_d1__'),'Interpreter','none');
subplot(2,3,1+np);np=np+1; plot(SX_2d_Memp_d1_,'ko-'); title(sprintf('SX_2d_Memp_d1__'),'Interpreter','none');
sgtitle(sprintf('Cost function kernels'),'Interpreter','none');
end;%if flag_plot;
%%%%%%%%;
% Decide which score to use. ;
% Here they are both very similar. ;
%%%%%%%%;
str_cost = sprintf('Memp');
%%%%%%%%;
if strfind(str_cost,'2d_xcor');
X__ = X_2d_xcor_d1__ ;
X_weight_r_ = X_2d_xcor_d1_weight_r_ ;
UX__ = UX_2d_xcor_d1__ ;
SX__ = diag(SX_2d_xcor_d1_) ;
SX_ = SX_2d_xcor_d1_ ;
VX__ = VX_2d_xcor_d1__ ;
end;%if strfind(str_cost,'2d_xcor');
%%%%%%%%;
if strfind(str_cost,'Memp');
X__ = X_2d_Memp_d1__ ;
X_weight_r_ = X_2d_Memp_d1_weight_r_ ;
UX__ = UX_2d_Memp_d1__ ;
SX__ = diag(SX_2d_Memp_d1_) ;
SX_ = SX_2d_Memp_d1_ ;
VX__ = VX_2d_Memp_d1__ ;
end;%if strfind(str_cost,'Memp');
%%%%%%%%;
pm_n_UX_rank = max(find(SX_>SX_(1)*tolerance_master));
disp(sprintf(' %% pm_n_UX_rank %d/%d',pm_n_UX_rank,n_UX_rank));
%%%%%%%%;
% Now form stack of principal-volume-shells a_CTF_avg_UX_Y_form__ ;
%%%%%%%%;
a_CTF_avg_UX_Y_form__ = zeros(n_lm_max,n_UX_rank);
for nUX_rank=0:n_UX_rank-1;
for nk_p_r=0:n_k_p_r-1;
tmp_l_max = l_max_(1+nk_p_r);
tmp_n_lm = (tmp_l_max+1).^2;
tmp_index_ = n_lm_csum_(1+nk_p_r) + (0:tmp_n_lm-1);
a_CTF_avg_UX_Y_form__(1:tmp_n_lm,1+nUX_rank) = a_CTF_avg_UX_Y_form__(1:tmp_n_lm,1+nUX_rank) + UX__(1+nk_p_r,1+nUX_rank)*X_weight_r_(1+nk_p_r)*a_k_Y_form_(1+tmp_index_)*CTF_avg_k_p_r_(1+nk_p_r); %<-- use average CTF here, under the assumption that a_CTF_avg_UX_Y_form_ will be used alone. ;
end;%for nk_p_r=0:n_k_p_r-1;
end;%for nUX_rank=0:n_UX_rank-1;
%%%%%%%%;
% Calculate a few principal-templates for visualization. ;
%%%%%%%%;
[ ...
 UX_CTF_avg_S_k_p__ ...
,~ ...
,~ ...
,~ ...
,tmp_n_S ...
] = ...
get_template_1( ...
 0*verbose ...
,n_UX_rank ...
,ones(n_UX_rank,1) ...
,1 ...
,ones(n_UX_rank,1) ...
,l_max_max*ones(n_UX_rank,1) ...
,a_CTF_avg_UX_Y_form__(:) ...
,viewing_k_eq_d ...
,template_k_eq_d ...
,n_w_max*ones(n_UX_rank,1) ...
);
%%%%;
UX_CTF_avg_S_k_q__ = zeros(n_w_max*n_UX_rank,tmp_n_S);
for nS=0:tmp_n_S-1;
UX_CTF_avg_S_k_q__(:,1+nS) = ...
interp_p_to_q( ...
 n_UX_rank ...
,n_w_max*ones(n_UX_rank,1) ...
,n_w_max*n_UX_rank ...
,UX_CTF_avg_S_k_p__(:,1+nS) ...
);
end;%for nS=0:tmp_n_S-1;
%%%%%%%%%%%%%%%%;
flag_check=0;
if flag_check;
%%%%%%%%;
% check reconstruction without ctf. ;
%%%%%%%%;
tmp_n_order = 5; tmp_n_M = n_M;
tmp_euler_polar_a_ = +euler_polar_a_true_;
tmp_euler_azimu_b_ = +euler_azimu_b_true_;
tmp_euler_gamma_z_ = +euler_gamma_z_true_;
tmp_image_delta_x_ = +1.0*image_delta_x_true_;
tmp_image_delta_y_ = +1.0*image_delta_y_true_;
tmp_CTF_k_p__ = ones(n_w_sum,n_ctf);
%%%%%%%%;
tmp_t = tic;
b_k_Y_reco_ = ...
cg_lsq_4( ...
 tmp_n_order ...
,n_k_p_r ...
,k_p_r_ ...
,l_max_ ...
,n_w_ ...
,tmp_n_M ...
,T_k_p__ ...
,CTF_index_ ...
,tmp_CTF_k_p__ ...
,tmp_euler_polar_a_ ...
,tmp_euler_azimu_b_ ...
,tmp_euler_gamma_z_ ...
,tmp_image_delta_x_ ...
,tmp_image_delta_y_ ...
);
tmp_t = toc(tmp_t); disp(sprintf(' %% T_k_p__ --> b_k_Y_reco_ time %0.2fs',tmp_t));
[tmp_b_X_best_orig,~,~,~,~,~,~] = register_spharm_to_spharm_wigner_1(n_k_p_r,k_p_r_,k_p_r_max,weight_3d_k_p_r_,0,l_max_,a_k_Y_form_,b_k_Y_reco_);
[tmp_b_X_best_flip,~,~,~,~,~,~] = register_spharm_to_spharm_wigner_1(n_k_p_r,k_p_r_,k_p_r_max,weight_3d_k_p_r_,0,l_max_,a_k_Y_form_,flipY(n_k_p_r,l_max_,b_k_Y_reco_));
b_X_best_reco = max(tmp_b_X_best_orig,tmp_b_X_best_flip);
disp(sprintf(' %% b_X_best_reco %0.3f',b_X_best_reco));
%%%%%%%%;
% check reconstruction with ctf. ;
%%%%%%%%;
tmp_n_order = 5; tmp_n_M = n_M;
tmp_euler_polar_a_ = +euler_polar_a_true_;
tmp_euler_azimu_b_ = +euler_azimu_b_true_;
tmp_euler_gamma_z_ = +euler_gamma_z_true_;
tmp_image_delta_x_ = +1.0*image_delta_x_true_;
tmp_image_delta_y_ = +1.0*image_delta_y_true_;
tmp_CTF_k_p__ = ones(n_w_sum,n_ctf);
for nk_p_r=0:n_k_p_r-1;
n_w = n_w_(1+nk_p_r); tmp_index_ = n_w_csum_(1+nk_p_r) + (0:n_w-1);
tmp_CTF_k_p__(1+tmp_index_,:) = repmat(CTF_k_p_r__(1+nk_p_r,:),[n_w,1]);
end;%for nk_p_r=0:n_k_p_r-1;
%%%%%%%%;
tmp_t = tic;
c_k_Y_reco_ = ...
cg_lsq_4( ...
 tmp_n_order ...
,n_k_p_r ...
,k_p_r_ ...
,l_max_ ...
,n_w_ ...
,tmp_n_M ...
,M_k_p__ ...
,CTF_index_ ...
,tmp_CTF_k_p__ ...
,tmp_euler_polar_a_ ...
,tmp_euler_azimu_b_ ...
,tmp_euler_gamma_z_ ...
,tmp_image_delta_x_ ...
,tmp_image_delta_y_ ...
);
tmp_t = toc(tmp_t); disp(sprintf(' %% M_k_p__ --> c_k_Y_reco_ time %0.2fs',tmp_t));
[tmp_c_X_best_orig,~,~,~,~,~,~] = register_spharm_to_spharm_wigner_1(n_k_p_r,k_p_r_,k_p_r_max,weight_3d_k_p_r_,0,l_max_,a_k_Y_form_,c_k_Y_reco_);
[tmp_c_X_best_flip,~,~,~,~,~,~] = register_spharm_to_spharm_wigner_1(n_k_p_r,k_p_r_,k_p_r_max,weight_3d_k_p_r_,0,l_max_,a_k_Y_form_,flipY(n_k_p_r,l_max_,c_k_Y_reco_));
c_X_best_reco = max(tmp_c_X_best_orig,tmp_c_X_best_flip);
disp(sprintf(' %% c_X_best_reco %0.3f',c_X_best_reco));
%%%%%%%%;
end;%if flag_check;
%%%%%%%%%%%%%%%%;
parameter = struct('type','parameter');
parameter.delta_r_upb = delta_sigma*sqrt(log(20^2)); %<-- 95th percentile. ;
disp(sprintf(' %% delta_sigma %0.2f, delta_r_upb %0.2f, number of images outside bounds %d/%d',delta_sigma,parameter.delta_r_upb,numel(efind(image_delta_r_true_> parameter.delta_r_upb)),n_M));
delta_r_max = delta_sigma/2;
svd_eps = tolerance_master;
FTK = [];
pm_n_UX_rank = pm_n_UX_rank;
M_k_q__ = [];
svd_VUXM_lwnM____ = [];
UX_M_l2_dM__ = [];
VSCTF_Mc__ = [];
l_max_max = max(l_max_);
flag_warm_start = 1;
if flag_warm_start==1;
rng(0);
euler_polar_a_ = periodize(+euler_polar_a_true_ + 0.125*2*pi*rand(n_M,1),0,1*pi);
euler_azimu_b_ = periodize(+euler_azimu_b_true_ + 0.250*2*pi*rand(n_M,1),0,2*pi);
euler_gamma_z_ = periodize(+euler_gamma_z_true_ + 0.250*2*pi*rand(n_M,1),0,2*pi);
image_delta_x_acc_ = +image_delta_x_true_ + 0.125*delta_sigma*randn(n_M,1); 
image_delta_y_acc_ = +image_delta_y_true_ + 0.125*delta_sigma*randn(n_M,1); 
end;%if flag_warm_start==1;
if flag_warm_start==0;
rng(0);
euler_polar_a_ = 1*pi*rand(n_M,1);
euler_azimu_b_ = 2*pi*rand(n_M,1);
euler_gamma_z_ = 2*pi*rand(n_M,1);
image_delta_x_acc_ = zeros(n_M,1);
image_delta_y_acc_ = zeros(n_M,1);
end;%if flag_warm_start==0;
image_delta_x_upd_ = [];
image_delta_y_upd_ = [];
flag_image_delta_upd_ = [];
image_I_value_ = [];
parameter.n_iteration = 15;
parameter.delta_r_max = delta_r_max;
%%%%;
tmp_t = tic;
[ ...
 parameter ...
,flag_image_delta_upd_ ...
,FTK ...
,M_k_q__ ...
,svd_VUXM_lwnM____ ...
,UX_M_l2_dM__ ...
,VSCTF_Mc__ ...
,a_CTF_avg_UX_Y_MS__ ...
,euler_polar_a_MS__ ...
,euler_azimu_b_MS__ ...
,euler_gamma_z_MS__ ...
,image_delta_x_acc_MS__ ...
,image_delta_y_acc_MS__ ...
,image_delta_x_upd_MS__ ...
,image_delta_y_upd_MS__ ...
,flag_image_delta_upd_MS__ ...
,image_I_value_MS__ ...
,image_X_value_MS__ ...
,image_S_index_MS__ ...
] = ...
ampmut_3( ...
 parameter ...
,n_k_p_r ...
,k_p_r_ ...
,k_p_r_max ...
,n_w_max ...
,FTK ...
,pm_n_UX_rank ...
,UX__ ...
,X_weight_r_ ...
,n_M ...
,M_k_p__ ...
,M_k_q__ ...
,svd_VUXM_lwnM____ ...
,UX_M_l2_dM__ ...
,n_CTF_rank ...
,CTF_index_ ...
,CTF_k_p_r__ ...
,VSCTF_Mc__ ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_delta_x_acc_ ...
,image_delta_y_acc_ ...
,image_delta_x_upd_ ...
,image_delta_y_upd_ ...
,flag_image_delta_upd_ ...
,image_I_value_ ...
);
tmp_t = toc(tmp_t); disp(sprintf(' %% ampmut_3: time %0.2fs',tmp_t));
%%%%;
%%%%%%%%;
% Now for second stage, but with flag_MS_vs_SM==0. ;
%%%%%%%%;
euler_polar_a_ = euler_polar_a_MS__(:,end) ;
euler_azimu_b_ = euler_azimu_b_MS__(:,end) ;
euler_gamma_z_ = euler_gamma_z_MS__(:,end) ;
image_delta_x_acc_ = image_delta_x_acc_MS__(:,end) ;
image_delta_y_acc_ = image_delta_y_acc_MS__(:,end) ;
image_delta_x_upd_ = image_delta_x_upd_MS__(:,end) ;
image_delta_y_upd_ = image_delta_y_upd_MS__(:,end) ;
parameter.n_iteration = 15;
parameter.delta_r_max = delta_r_max;
parameter.flag_MS_vs_SM = 0;
%%%%;
tmp_t = tic;
[ ...
 parameter ...
,flag_image_delta_upd_ ...
,FTK ...
,M_k_q__ ...
,svd_VUXM_lwnM____ ...
,UX_M_l2_dM__ ...
,VSCTF_Mc__ ...
,a_CTF_avg_UX_Y_SM__ ...
,euler_polar_a_SM__ ...
,euler_azimu_b_SM__ ...
,euler_gamma_z_SM__ ...
,image_delta_x_acc_SM__ ...
,image_delta_y_acc_SM__ ...
,image_delta_x_upd_SM__ ...
,image_delta_y_upd_SM__ ...
,flag_image_delta_upd_SM__ ...
,image_I_value_SM__ ...
,image_X_value_SM__ ...
,image_S_index_SM__ ...
] = ...
ampmut_3( ...
 parameter ...
,n_k_p_r ...
,k_p_r_ ...
,k_p_r_max ...
,n_w_max ...
,FTK ...
,pm_n_UX_rank ...
,UX__ ...
,X_weight_r_ ...
,n_M ...
,M_k_p__ ...
,M_k_q__ ...
,svd_VUXM_lwnM____ ...
,UX_M_l2_dM__ ...
,n_CTF_rank ...
,CTF_index_ ...
,CTF_k_p_r__ ...
,VSCTF_Mc__ ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_delta_x_acc_ ...
,image_delta_y_acc_ ...
,image_delta_x_upd_ ...
,image_delta_y_upd_ ...
,flag_image_delta_upd_ ...
,image_I_value_ ...
);
tmp_t = toc(tmp_t); disp(sprintf(' %% ampmut_3: time %0.2fs',tmp_t));
%%%%;
%%%%%%%%;
% Now concatenate results. ;
%%%%%%%%;
a_CTF_avg_UX_Y__ = [a_CTF_avg_UX_Y_MS__,a_CTF_avg_UX_Y_SM__];
euler_polar_a__ = [euler_polar_a_MS__,euler_polar_a_SM__];
euler_azimu_b__ = [euler_azimu_b_MS__,euler_azimu_b_SM__];
euler_gamma_z__ = [euler_gamma_z_MS__,euler_gamma_z_SM__];
image_delta_x_acc__ = [image_delta_x_acc_MS__,image_delta_x_acc_SM__];
image_delta_y_acc__ = [image_delta_y_acc_MS__,image_delta_y_acc_SM__];
image_delta_x_upd__ = [image_delta_x_upd_MS__,image_delta_x_upd_SM__];
image_delta_y_upd__ = [image_delta_y_upd_MS__,image_delta_y_upd_SM__];
flag_image_delta_upd__ = [flag_image_delta_upd_MS__,flag_image_delta_upd_SM__];
image_I_value__ = [image_I_value_MS__,image_I_value_SM__];
image_X_value__ = [image_X_value_MS__,image_X_value_SM__];
image_S_index__ = [image_S_index_MS__,image_S_index_SM__];
%%%%%%%%;
% Now compare a_CTF_avg_UX_Y__ with a_CTF_avg_UX_Y_form__. ;
%%%%%%%%;
[ ...
 parameter ...
] = ...
ampmut_align_to_reference_0( ...
 parameter ...
,l_max_max ...
,pm_n_UX_rank ...
,reshape(a_CTF_avg_UX_Y_form__(:,1:pm_n_UX_rank),[n_lm_max*pm_n_UX_rank,1]) ...
,n_M ...
,euler_polar_a_true_ ...
,euler_azimu_b_true_ ...
,euler_gamma_z_true_ ...
,image_delta_x_true_ ...
,image_delta_y_true_ ...
,2*parameter.n_iteration ...
,a_CTF_avg_UX_Y__ ...
,euler_polar_a__ ...
,euler_azimu_b__ ...
,euler_gamma_z__ ...
,image_delta_x_acc__ + image_delta_x_upd__ ...
,image_delta_y_acc__ + image_delta_y_upd__ ...
);
%%%%%%%%;
disp('returning'); return;
end;% if nargin<1;

verbose=2;
if (verbose); disp(sprintf(' %% [entering ampmut_3]')); end;

if isempty(parameter);
parameter = struct('type','parameter');
end;%if isempty(parameter);
%%%%%%%%;
if (~isfield(parameter,'tolerance_master')); parameter.tolerance_master = 1e-2; end; %<-- parameter_bookmark. ;
if (~isfield(parameter,'rseed')); parameter.rseed = 0; end; %<-- parameter_bookmark. ;
if (~isfield(parameter,'n_iteration')); parameter.n_iteration = 1; end; %<-- parameter_bookmark. ;
if (~isfield(parameter,'n_delta_v_requested')); parameter.n_delta_v_requested = 0; end; %<-- parameter_bookmark. ;
if (~isfield(parameter,'flag_MS_vs_SM')); parameter.flag_MS_vs_SM = 1; end; %<-- parameter_bookmark. ;
if (~isfield(parameter,'order_limit_MS')); parameter.order_limit_MS = -1; end; %<-- parameter_bookmark. ;
if (~isfield(parameter,'delta_r_max')); parameter.delta_r_max = 0.1; end; %<-- parameter_bookmark. ;
if (~isfield(parameter,'delta_r_upb')); parameter.delta_r_upb = 2*delta_r_max; end; %<-- parameter_bookmark. ;
if (~isfield(parameter,'template_viewing_k_eq_d')); parameter.template_viewing_k_eq_d = 1.0/max(1e-12,k_p_r_max); end; %<-- parameter_bookmark. ;
%%%%%%%%;
tolerance_master = parameter.tolerance_master;
rseed = parameter.rseed;
n_iteration = parameter.n_iteration;
n_delta_v_requested = parameter.n_delta_v_requested;
flag_MS_vs_SM = parameter.flag_MS_vs_SM;
order_limit_MS = parameter.order_limit_MS;
delta_r_max = parameter.delta_r_max;
delta_r_upb = parameter.delta_r_upb;
svd_eps = tolerance_master;

%{
%%%%%%%%;
% Typical definitions. ;
%%%%%%%%;
l_max_max = max(l_max_);
n_lm_ = (1+l_max_).^2;
n_lm_sum = sum(n_lm_);
n_lm_csum_ = cumsum([0;n_lm_]);
%}

n_w_max = n_w_max + mod(n_w_max,2); %<-- round up to nearest even number. ;
l_max_max = n_w_max/2 - 1;
n_w_ = n_w_max*ones(n_k_p_r,1);
n_w_sum = sum(n_w_);
n_w_csum_ = cumsum([0;n_w_]);

pm_n_k_p_r = pm_n_UX_rank;
pm_k_p_r_ = ones(pm_n_k_p_r,1);
pm_k_p_r_max = 1;
pm_n_w_ = n_w_max*ones(pm_n_k_p_r,1);
pm_n_w_max = n_w_max;
pm_n_w_sum = sum(pm_n_w_);
pm_n_w_csum_ = cumsum([0;pm_n_w_]);
pm_l_max_ = l_max_max*ones(pm_n_k_p_r,1);
pm_n_lm_ = (1+pm_l_max_).^2; pm_n_lm_sum = sum(pm_n_lm_);
pm_weight_k_p_r_ = ones(pm_n_k_p_r,1);
pm_weight_2d_k_p_r_ = ones(pm_n_k_p_r,1);

if (order_limit_MS>-1);
Y_lm_cut_ = ones(pm_n_lm_sum,1);
Y_l_val_ = zeros(pm_n_lm_sum,1);
Y_m_val_ = zeros(pm_n_lm_sum,1);
na=0;
for pm_nk_p_r=0:pm_n_k_p_r-1;
l_max = pm_l_max_(1+pm_nk_p_r);
for l_val=0:l_max;
for m_val=-l_val:+l_val;
Y_l_val_(1+na) = l_val;
Y_m_val_(1+na) = m_val;
na=na+1;
end;%for m_val=-l_val:+l_val;
end;%for l_val=0:l_max;
end;%for pm_nk_p_r=0:pm_n_k_p_r-1;
%Y_lm_cut_ = Y_l_val_+abs(Y_m_val_)<=Y_lm_cut_threshold;
Y_lm_cut_ = Y_l_val_+0*abs(Y_m_val_)<=order_limit_MS;
end;%if (order_limit_MS>-1);

if isempty(FTK);
tmp_t = tic();
FTK = ampmh_FTK_1(n_k_p_r,k_p_r_,k_p_r_max,delta_r_max,svd_eps,n_delta_v_requested);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% FTK: %0.3fs',tmp_t)); end;
parameter = parameter_timing_update(parameter,'ampmh_FTK_1',tmp_t);
end;%if isempty(FTK);
assert(FTK.svd_d_max>=delta_r_max);
assert(FTK.n_delta_v>=n_delta_v_requested);

if isempty(VSCTF_Mc__);
if (n_CTF_rank<=0 | isempty(CTF_index_));
n_CTF_rank = 1;
USCTF_kc__ = ones(n_k_p_r,1); SCTF_C__ = 1; VCTF_Mc__ = ones(n_M,1);
else;
[UCTF_kc__,SCTF_c__,VCTF_Mc__] = svds(CTF_k_p_r__(:,1+CTF_index_(1:n_M)),n_CTF_rank);
end;%if (n_CTF_rank<=0 | isempty(CTF_index_));
VSCTF_Mc__ = VCTF_Mc__*SCTF_c__;
end;%if isempty(VSCTF_Mc__);

if (nargout>1);
euler_polar_a__ = zeros(n_M,n_iteration);
euler_azimu_b__ = zeros(n_M,n_iteration);
euler_gamma_z__ = zeros(n_M,n_iteration);
image_delta_x_acc__ = zeros(n_M,n_iteration);
image_delta_y_acc__ = zeros(n_M,n_iteration);
image_delta_x_upd__ = zeros(n_M,n_iteration);
image_delta_y_upd__ = zeros(n_M,n_iteration);
flag_image_delta_upd__ = zeros(n_M,n_iteration);
image_I_value__ = zeros(n_M,n_iteration);
image_X_value__ = zeros(n_M,n_iteration);
image_S_index__ = zeros(n_M,n_iteration);
a_CTF_avg_UX_Y__ = zeros(pm_n_lm_sum,n_iteration);
end;%if (nargout>1);
%%%%%%%%;
% initialize current euler-angles randomly. ;
%%%%%%%%;
if isempty(euler_polar_a_); euler_polar_a_ = 1*pi*rand(n_M,1); end;
if isempty(euler_azimu_b_); euler_azimu_b_ = 2*pi*rand(n_M,1); end;
if isempty(euler_gamma_z_); euler_gamma_z_ = 2*pi*rand(n_M,1); end;
if isempty(image_delta_x_acc_); image_delta_x_acc_ = zeros(n_M,1); end; %<-- accumulated displacement (i.e., current image center). ;
if isempty(image_delta_y_acc_); image_delta_y_acc_ = zeros(n_M,1); end; %<-- accumulated displacement (i.e., current image center). ;
if isempty(image_delta_x_upd_); image_delta_x_upd_ = zeros(n_M,1); end; %<-- update to displacement (i.e., current image shift). ;
if isempty(image_delta_y_upd_); image_delta_y_upd_ = zeros(n_M,1); end; %<-- update to displacement (i.e., current image shift). ;
image_delta_x_bit_ = zeros(n_M,1); %<-- increment to displacement update (calculated each iteration). ;
image_delta_y_bit_ = zeros(n_M,1); %<-- increment to displacement update (calculated each iteration). ;
if isempty(flag_image_delta_upd_); flag_image_delta_upd_ = ones(n_M,1); end; %<-- flag identifying principal-images that need to be recalculated. ;
if isempty(image_I_value_); image_I_value_ = ones(n_M,1); end;
if isempty(M_k_q__); M_k_q__ = zeros(n_w_sum,n_M); end;
if isempty(svd_VUXM_lwnM____); svd_VUXM_lwnM____ = zeros(FTK.n_svd_l,n_w_max,pm_n_UX_rank,n_M); end;
if isempty(UX_M_l2_dM__); UX_M_l2_dM__ = zeros(FTK.n_delta_v,n_M); end;
for niteration=0:n_iteration-1;
%%%%%%%%;
% Construct M_k_q__ while taking into account the translations. ;
%%%%%%%%;
tmp_M_index_ = efind(flag_image_delta_upd_); tmp_n_M = numel(tmp_M_index_);
if (verbose>0); disp(sprintf(' %% updating M_k_q__ for tmp_n_M %d/%d images',tmp_n_M,n_M)); end;
tmp_t = tic();
M_k_q__(:,1+tmp_M_index_) = zeros(n_w_sum,tmp_n_M);
for tmp_nM=0:tmp_n_M-1;
nM = tmp_M_index_(1+tmp_nM);
M_k_p_ = ...
transf_p_to_p( ...
 n_k_p_r ...
,k_p_r_ ...
,n_w_ ...
,n_w_sum ...
,M_k_p__(:,1+nM) ...
,+image_delta_x_acc_(1+nM) ...
,+image_delta_y_acc_(1+nM) ...
);
M_k_q__(:,1+nM) = ...
interp_p_to_q( ...
 n_k_p_r ...
,n_w_ ...
,n_w_sum ...
,M_k_p_ ...
);
end;%for tmp_nM=0:tmp_n_M-1;
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% M_k_q__: %0.3fs',tmp_t)); end;
parameter = parameter_timing_update(parameter,'M_k_q__',tmp_t);
%%%%%%%%;
% Now form svd_VUXM_lwnM____ using these translated images. ;
%%%%%%%%;
tmp_t = tic();
svd_VUXM_lwnM____(:,:,:,1+tmp_M_index_) = tpmh_VUXM_lwnM____3(FTK,n_k_p_r,n_w_,tmp_n_M,M_k_q__(:,1+tmp_M_index_),pm_n_UX_rank,UX__,X_weight_r_);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% svd_VUXM_lwnM____: %0.3fs',tmp_t)); end;
parameter = parameter_timing_update(parameter,'svd_VUXM_lwnM____',tmp_t);
%%%%%%%%;
% Now calculate norms of the translated images. ;
%%%%%%%%;
tmp_t = tic();
UX_M_l2_dM__(:,1+tmp_M_index_) = ampmh_UX_M_l2_dM__1(FTK,n_w_,tmp_n_M,pm_n_UX_rank,svd_VUXM_lwnM____(:,:,:,1+tmp_M_index_));
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% UX_M_l2_dM__: %0.3fs',tmp_t)); end;
parameter = parameter_timing_update(parameter,'ampmh_UX_M_l2_dM__1',tmp_t);
%%%%%%%%;
% Now, form principal-images (using the displacement-updates). ;
% If we had not included the accumulated-displacements +image_delta_x_acc_ and +image_delta_y_acc_ above, ;
% we would add them to the displacement-updates below (also with a positive-sign). ;
%%%%%%%%;
tmp_t = tic();
[UX_M_k_q_wnM___,UX_M_k_p_wnM___] = ampmh_UX_M_k_p_wnM___0(FTK,n_w_,pm_n_UX_rank,n_M,svd_VUXM_lwnM____,+image_delta_x_upd_,+image_delta_y_upd_);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% UX_M_k_q_wnM___: %0.6fs',tmp_t)); end;
parameter = parameter_timing_update(parameter,'ampmh_UX_M_k_p_wnM___0',tmp_t);
%%%%%%%%;
flag_image_delta_upd_ = zeros(n_M,1);
%%%%%%%%;
% use current euler-angles and displacements to solve for current model. ;
%%%%%%%%;
tmp_t = tic();
[ ...
 parameter ...
,a_UCTF_UX_Y_ync__ ... 
] = ...
a_UCTF_UX_Y_wrap_ync__0( ...
 parameter ...
,pm_n_k_p_r ...
,pm_l_max_ ...
,pm_n_w_ ...
,n_M ...
,reshape(UX_M_k_p_wnM___,[n_w_max*pm_n_k_p_r,n_M]) ...
,n_CTF_rank ...
,VSCTF_Mc__ ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_I_value_ ...
);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% a_UCTF_UX_Y_ync__: %0.3fs',tmp_t)); end;
parameter = parameter_timing_update(parameter,'a_UCTF_UX_Y_wrap_ync__0',tmp_t);
%%%%%%%%;
% Now normalize a_UCTF_avg_UX_Y_ync__. ;
% This step is necessary to prevent the intensity from diverging over successive iterations. ;
%%%%%%%%;
a_UCTF_UX_Y_ync__ = spharm__normalize_1(pm_n_k_p_r,pm_k_p_r_,pm_weight_k_p_r_,pm_l_max_,a_UCTF_UX_Y_ync__);
%%%%%%%%;
% Use a_UCTF_UX_Y_ync__ as well VSCTF_Mc__ to approximate the image-averaged a_CTF_avg_UX_Y_. ;
% This is not actually used in the calculation, but can be useful for postprocessing. ;
%%%%%%%%;
a_CTF_avg_UX_Y_ = spharm_normalize_1(pm_n_k_p_r,pm_k_p_r_,pm_weight_k_p_r_,pm_l_max_,mean(a_UCTF_UX_Y_ync__*transpose(VSCTF_Mc__),2));
%%%%%%%%;
% Now store image-parameters. ;
%%%%%%%%;
if (nargout>1);
a_CTF_avg_UX_Y__(:,1+niteration) = a_CTF_avg_UX_Y_;
euler_polar_a__(:,1+niteration) = euler_polar_a_;
euler_azimu_b__(:,1+niteration) = euler_azimu_b_;
euler_gamma_z__(:,1+niteration) = euler_gamma_z_;
image_delta_x_acc__(:,1+niteration) = image_delta_x_acc_;
image_delta_y_acc__(:,1+niteration) = image_delta_y_acc_;
image_delta_x_upd__(:,1+niteration) = image_delta_x_upd_;
image_delta_y_upd__(:,1+niteration) = image_delta_y_upd_;
image_I_value__(:,1+niteration) = image_I_value_;
end;%if (nargout>1);
%%%%%%%%;
% if flag_MS_vs_SM & order_limit_MS>-1 & niteration<n_iteration/2, then bandlimit a_UCTF_UX_Y_ync__. ;
%%%%%%%%;
if ( (flag_MS_vs_SM==1) & (order_limit_MS>-1) & (niteration<n_iteration/2) );
a_UCTF_UX_Y_ync__ = a_UCTF_UX_Y_ync__.*repmat(Y_lm_cut_,[1,n_CTF_rank]);
end;%if ( (flag_MS_vs_SM==1) & (order_limit_MS>-1) & (niteration<n_iteration/2) );
%%%%%%%%;
% Use current principal-model to align principal-images. ;
% Groups principal-images by micrograph (i.e., inefficient if there are only a few images per micrograph). ;
% Calculates principal-templates associated with each micrograph. ;
% Batches images into batches of size n_M_per_Mbatch (default 24). ;
% Batches templates into batches of size n_S_per_Sbatch (default 24). ;
% Only stores the optimal translation for each principal-image. ;
%%%%%%%%;
tmp_t = tic();
[ ...
 parameter ...
,n_S ...
,template_viewing_polar_a_all_ ...
,template_viewing_azimu_b_all_ ...
,X_SM__ ...
,delta_x_SM__ ...
,delta_y_SM__ ...
,gamma_z_SM__ ...
,I_value_SM__ ...
] = ...
ampmh_X_wrap_wrap_SM__8( ...
 parameter ...
,FTK ...
,n_w_max ...
,l_max_max ...
,pm_n_UX_rank ...
,n_CTF_rank ...
,a_UCTF_UX_Y_ync__ ...
,n_M ...
,CTF_index_ ...
,VSCTF_Mc__ ...
,svd_VUXM_lwnM____ ...
,UX_M_l2_dM__ ...
,[] ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% X_SM__: %0.3fs',tmp_t)); end;
parameter = parameter_timing_update(parameter,'ampmh_X_wrap_wrap_SM__8',tmp_t);
%%%%%%%%;
% Use current correlations to udate current euler-angles. ;
%%%%%%%%;
tmp_t = tic();
[ ...
 parameter ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_delta_x_bit_ ...
,image_delta_y_bit_ ...
,image_I_value_ ...
,image_X_value_ ...
,image_S_index_ ...
] = ...
ampmh_MS_vs_SM_2( ...
 parameter ...
,n_w_max ...
,n_S ...
,template_viewing_polar_a_all_ ...
,template_viewing_azimu_b_all_ ...
,n_M ...
,X_SM__ ...
,delta_x_SM__ ...
,delta_y_SM__ ...
,gamma_z_SM__ ...
,I_value_SM__ ...
);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% MS_vs_SM: update euler_polar_a_ euler_azimu_b_ euler_gamma_z_ : %0.3fs',tmp_t)); end;
parameter = parameter_timing_update(parameter,'ampmh_MS_vs_SM_2',tmp_t);
%%%%%%%%;
% update translations. ;
%%%%%%%%;
if (~isfield(parameter,'delta_r_upd_threshold')); parameter.delta_r_upd_threshold = 0.0*delta_r_max; end; %<-- parameter_bookmark. ;
delta_r_upd_threshold = parameter.delta_r_upd_threshold;
image_delta_x_upd_ = image_delta_x_upd_ + image_delta_x_bit_;
image_delta_y_upd_ = image_delta_y_upd_ + image_delta_y_bit_;
image_delta_r_upd_prenorm_ = sqrt(image_delta_x_upd_.^2 + image_delta_y_upd_.^2);
image_delta_x_tot_ = image_delta_x_acc_ + image_delta_x_upd_;
image_delta_y_tot_ = image_delta_y_acc_ + image_delta_y_upd_;
image_delta_r_tot_ = sqrt(image_delta_x_tot_.^2 + image_delta_y_tot_.^2);
image_delta_x_nrm_ = image_delta_x_tot_;
image_delta_y_nrm_ = image_delta_y_tot_;
tmp_index_ = efind(image_delta_r_tot_> delta_r_upb);
if (numel(tmp_index_)> 0);
if (verbose>1); disp(sprintf(' %% normalizing %d/%d image displacements',numel(tmp_index_),n_M)); end;
image_delta_x_nrm_(1+tmp_index_) = image_delta_x_tot_(1+tmp_index_)*delta_r_upb./image_delta_r_tot_(1+tmp_index_);
image_delta_y_nrm_(1+tmp_index_) = image_delta_y_tot_(1+tmp_index_)*delta_r_upb./image_delta_r_tot_(1+tmp_index_);
image_delta_x_upd_(1+tmp_index_) = image_delta_x_nrm_(1+tmp_index_) - image_delta_x_acc_(1+tmp_index_);
image_delta_y_upd_(1+tmp_index_) = image_delta_y_nrm_(1+tmp_index_) - image_delta_y_acc_(1+tmp_index_);
end;%if (numel(tmp_index_)> 0);
flag_image_delta_upd_ = zeros(n_M,1);
image_delta_r_upd_posnorm_ = sqrt(image_delta_x_upd_.^2 + image_delta_y_upd_.^2);
tmp_index_ = efind( (image_delta_r_upd_prenorm_>=delta_r_upd_threshold) | (image_delta_r_upd_posnorm_>=delta_r_upd_threshold) );
if (numel(tmp_index_)> 0);
if (verbose>1); disp(sprintf(' %% accumulating %d/%d image displacements',numel(tmp_index_),n_M)); end;
flag_image_delta_upd_(1+tmp_index_) = 1;
image_delta_x_acc_(1+tmp_index_) = image_delta_x_acc_(1+tmp_index_) + image_delta_x_upd_(1+tmp_index_);
image_delta_y_acc_(1+tmp_index_) = image_delta_y_acc_(1+tmp_index_) + image_delta_y_upd_(1+tmp_index_);
image_delta_x_upd_(1+tmp_index_) = 0;
image_delta_y_upd_(1+tmp_index_) = 0;
end;%if (numel(tmp_index_)> 0);
%%%%%%%%;
if (nargout>1);
if niteration<n_iteration-1;
flag_image_delta_upd__(:,1+niteration) = flag_image_delta_upd_; %<-- these actually refer to end of iteration. ;
image_X_value__(:,1+niteration) = image_X_value_; %<-- these actually refer to end of iteration. ;
image_S_index__(:,1+niteration) = image_S_index_; %<-- these actually refer to end of iteration. ;
end;%if niteration<n_iteration-1;
end;%if (nargout>1);

%%%%%%%%;
% Now return to beginning of loop. ;
%%%%%%%%;
end;%for niteration=0:n_iteration-1;

if (verbose); disp(sprintf(' %% [finished ampmut_3]')); end;
