function [index__,weight__] = mkshinterp(polar_a_,azimu_b_,n_all,n_order,n_polar_a,n_azimu_b);
% Create interpolation matrix in simple sparse storage ;
% format. Since we are using a kxk interpolation stencil, ;
% we only need to know the column index and interpolation ;
% weights. ;
% ;
% INPUT: ;
% ;
% polar_a_, azimu_b_ :  coordinates of target points ;
% n_all              :  number of target points ;
% n_order            :  interpolation order ;
% n_polar_a          :  number of nodes in polar_a ;
% n_azimu_b          :  number of nodes in azimu_b ;
% ;
% OUTPUT: ;
% ;
% index__     :  indices of source points for interp. ;
% weight__    :  interpolation weights from reg grid. ;
% ;
% For each target point, compute the next n_order*n_order interpolation ;
% weights and increment index__,weight__. ;
index__ = zeros(n_all,n_order*n_order);
weight__ = zeros(n_all,n_order*n_order);
for nall=1:n_all;
[index_,weight_] = getinterpsparse(polar_a_(nall),azimu_b_(nall),n_order,n_polar_a,n_azimu_b);
index__(nall,:) = index_(:);
weight__(nall,:) = weight_(:);
end;%for nall=1:n_all;
