function [X0_,n_op,n_mult] = register_spharm_to_spharm_angle_parfor_0(verbose,n_k,k_,n_l_,a_,b_,n_beta,beta_,n_alpha,alpha_,n_gamma,gamma_);
% tests registration between molecule_A and molecule_B using an array of beta (fast only);
% ;
% verbose = integer verbosity_level ;
% n_k = integer maximum k ;
% k_ = real array of length n_k; k_(nk) = k_value for shell nk ;
% n_l_ = integer array of length n_k; n_l_(nk) = spherical harmonic order on shell nk; n_l_(nk) corresponds to n_lm_(nk) = (n_l_(nk)+1)^2 coefficients ;
% a_ = complex array of length \sum_{nk} (n_lm_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% b_ = complex array of length \sum_{nk} (n_lm_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% a_ corresponds to molecule_a, b_ to molecule_b ;
% n_beta = integer number of beta angles ;
% beta_ = real array of beta angles ;
% n_alpha = integer number of alpha angles (optional);
% alpha_ = real array of alpha angles (optional);
% n_gamma = integer number of gamma angles (optional);
% gamma_ = real array of gamma angles (optional);
% ;
% If arrays alpha_ and gamma_ are not provided we use the standard arrays: ;
% alpha_ = linspace(0,2*pi,n_m_max+1); alpha_ = alpha_(1:end-1);
% gamma_ = linspace(0,2*pi,n_m_max+1); gamma_ = gamma_(1:end-1);
% and use the standard fft to calculate X0_.; 
% ;
% However, if n_alpha, alpha_ and n_gamma, gamma_ are provided, we use these arrays instead, ;
% and use the nufft to calculate X0_. ;
% ;
% X_ = complex array of size (n_alpha,n_gamma,n_beta);
% The default values of n_alpha and n_gamma are n_m_max. ;
% X_(nalpha,ngamma,nbeta) corresponds to the innerproduct between molecule_A and molecule_B, where ;
% the latter has been rotated by euler-angles alpha,beta,gamma. ;
% Note that alpha_ and gamma_ are arrays from 0 to 2*pi, ;
% whereas beta_ is an array from -pi to pi. ;

if nargin<1;
verbose=0;
n_k=1;k_=1;n_l_=128;n_lm_=(n_l_+1).^2;
a_=randn(sum(n_lm_),1);b_=randn(sum(n_lm_),1);
n_beta=2*n_l_(1);beta_=linspace(-pi,+pi,n_beta+1);beta_=beta_(1:end-1);
tic;
[X0_,n_op,n_mult] = register_spharm_to_spharm_angle_parfor_0(verbose,n_k,k_,n_l_,a_,b_,n_beta,beta_);
toc;
disp('returning');return;
end;%if nargin<1;

n_lm_ = (n_l_+1).^2; n_lm_csum_ = cumsum([0;n_lm_(:)]);
k_max = k_(end);
n_l_max = n_l_(end);
m_max_ = -n_l_max : +n_l_max;
n_m_max = length(m_max_);

if (nargin<=8);
fft_flag = 0; 
n_alpha = n_m_max;
n_gamma = n_m_max;
end;%if (nargin<=8);
if (nargin>=9 & nargin<=12); 
fft_flag = 1;
end;%if (nargin>=9 & nargin<=12); 

disp(sprintf(' %% n_alpha %d, n_beta %d, n_gamma %d, fft_flag %d',n_alpha,n_beta,n_gamma,fft_flag));

X0_ = zeros(n_alpha,n_gamma,n_beta);
n_op = 0;
n_mult = 0;
parfor nbeta = 0:n_beta-1;
tmp_X0_ = zeros(n_alpha,n_gamma,1);
tmp_n_op = 0;
tmp_n_mult = 0;
beta = beta_(1+nbeta);
%if (fft_flag==0)
%[tmp_X0_,tmp_n_op,tmp_n_mult] = register_spharm_to_spharm_single_beta_0(verbose,n_k,k_,n_l_,a_,b_,beta);
%end;%if (nargin<=8);
%if (fft_flag==1);
%[tmp_X0_,tmp_n_op,tmp_n_mult] = register_spharm_to_spharm_single_beta_0(verbose,n_k,k_,n_l_,a_,b_,beta,n_alpha,alpha_,n_gamma,gamma_);
%end;%if (nargin>8);
[tmp_X0_,tmp_n_op,tmp_n_mult] = register_spharm_to_spharm_single_beta_0(verbose,n_k,k_,n_l_,a_,b_,beta);
X0_(:,:,1+nbeta) = tmp_X0_;
n_op = n_op + tmp_n_op;
n_mult = n_mult + tmp_n_mult;
end;%parfor nbeta = 0:n_beta-1;
