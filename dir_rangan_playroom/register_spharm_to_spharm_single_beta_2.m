function [X0_,n_op,n_mult] = register_spharm_to_spharm_single_beta_2(verbose,n_k_p_r,k_p_r_,weight_k_p_r_,l_max_,a_,b_,beta,n_alpha,alpha_,n_gamma,gamma_,a___,b___,ab__,d__);
% tests registration between molecule_A and molecule_B using a single beta (fast only);
% tries to reorder the calculation as a sparse-matrix-multiplication. ;
% ;
% verbose = integer verbosity_level ;
% n_k_p_r = integer maximum k ;
% k_p_r_ = real array of length n_k_p_r; k_p_r_(nk) = k_p_r_value for shell nk ;
% l_max_ = integer array of length n_k_p_r; l_max_(nk) = spherical harmonic order on shell nk; l_max_(nk) corresponds to n_lm_(nk) = (l_max_(nk)+1)^2 coefficients ;
% a_ = complex array of length \sum_{nk} (l_max_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% b_ = complex array of length \sum_{nk} (l_max_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% a_ corresponds to molecule_a, b_ to molecule_b ;
% beta = beta angle ;
% n_alpha = integer number of alpha angles (optional);
% alpha_ = real array of alpha angles (optional);
% n_gamma = integer number of gamma angles (optional);
% gamma_ = real array of gamma angles (optional);
% ;
% If arrays alpha_ and gamma_ are not provided we use the standard arrays: ;
% alpha_ = linspace(0,2*pi,n_m_max+1); alpha_ = alpha_(1:end-1);
% gamma_ = linspace(0,2*pi,n_m_max+1); gamma_ = gamma_(1:end-1);
% and use the standard fft to calculate X0_.; 
% ;
% However, if n_alpha, alpha_ and n_gamma, gamma_ are provided, we use these arrays instead, ;
% and use the nufft to calculate X0_. ;
% ;
% X_ = complex array of size (n_alpha,n_gamma,1);
% The default values of n_alpha and n_gamma are n_m_max. ;
% X_(nalpha,ngamma,nbeta) corresponds to the innerproduct between molecule_A and molecule_B, where ;
% the latter has been rotated by euler-angles alpha,beta,gamma. ;
% Note that alpha_ and gamma_ are arrays from 0 to 2*pi, ;
% whereas beta_ is an array from -pi to pi. ;
%%%%%%%%;
% a___ = a_ rearranged so that mn varies quickly, then k, then l. ;
% b___ = b_ rearranged so that mp varies quickly, then k, then l. ;
% ab__ = \sum_{k} conj(a___)*b___ rearranged so that mn varies quickly, then mp, then l. ;
% d__ = W_ rearranged so that mn varies quickly, then mp, then l. ;

n_lm_ = (l_max_+1).^2; n_lm_csum_ = cumsum([0;n_lm_(:)]);
l_max_max = l_max_(end);
m_max_ = -l_max_max : +l_max_max;
n_m_max = length(m_max_);

if ((nargin<=8) | n_alpha==0 | n_gamma==0);
fft_flag = 0; 
n_alpha = n_m_max;
n_gamma = n_m_max;
 else;
fft_flag = 1;
end;%else;

X0_ = zeros(n_alpha,n_gamma,1);
% Note that rotating a molecule by [+alpha,+beta,+gamma] ;
% corresponds to rotating the coordinate-frame by [-gamma,-beta,-alpha] ;
if (isempty(d__));
W_ = wignerd_b(l_max_max,-beta);
C_ = zeros(n_m_max,n_m_max);
n_W_ = zeros(1,1+l_max_max); for (l_val=0:l_max_max); n_W_(1+l_val) = numel(W_{1+l_val}); end;
d__ = zeros(n_m_max,n_m_max,1+l_max_max);
for l_val=0:l_max_max;
d__(1+l_max_max + [-l_val:+l_val],1+l_max_max + [-l_val:+l_val],1+l_val) = W_{1+l_val};
end;%for l_val=0:l_max_max;
end%if (isempty(d__));
if ((isempty(a___) | isempty(b___)) & isempty(ab__));
a___ = zeros(n_m_max,n_k_p_r,1+l_max_max); b___ = zeros(n_m_max,n_k_p_r,1+l_max_max);
ixk=0;
for nk=0:n_k_p_r-1;
ixl=0;
for l_val=0:l_max_(1+nk);
%ixl = l_val*(l_val+1);
%a___(1+l_max_max + [-l_val:+l_val],1+nk,1+l_val) = a_(1+ixk+ixl+-[-l_val:+l_val]);
%b___(1+l_max_max + [-l_val:+l_val],1+nk,1+l_val) = b_(1+ixk+ixl+-[-l_val:+l_val]);
a___(1+l_max_max + [-l_val:+l_val],1+nk,1+l_val) = a_(1+ixk+ixl+l_val+-[-l_val:+l_val]);
b___(1+l_max_max + [-l_val:+l_val],1+nk,1+l_val) = b_(1+ixk+ixl+l_val+-[-l_val:+l_val]);
ixl = ixl+(2*l_val+1);
end;%for l_val=0:l_max_(1+nk);
assert(ixl==n_lm_(1+nk));
ixk = ixk+n_lm_(1+nk);
end;%for nk=0:n_k_p_r-1;
assert(ixk==sum(n_lm_));
end;%if ((isempty(a___) | isempty(b___)) & isempty(ab__));
if (isempty(ab__));
ab__ = zeros(n_m_max,n_m_max,1+l_max_max);
for l_val=0:l_max_max;
ab__(:,:,1+l_val) = conj(squeeze(a___(:,:,1+l_val)))*diag(weight_k_p_r_)*transpose(b___(:,:,1+l_val));
end;%for l_val=0:l_max_max;
end;%if (isempty(ab__));
t_0in = tic;
C_ = zeros(n_m_max,n_m_max);
C_ = sum(ab__.*d__,3);
t_out = toc(t_0in);
if (verbose>1); disp(sprintf(' %% t %0.6f',t_out)); end;
n_op = (n_m_max*n_m_max)*n_k_p_r*(1+l_max_max) + (n_m_max*n_m_max)*(1+l_max_max);
n_mult = (n_m_max*n_m_max)*n_k_p_r*(1+l_max_max) + (n_m_max*n_m_max)*(1+l_max_max);

if (fft_flag==0);
tmp_C = recenter2(squeeze(C_(:,:)));
X0_(:,:,1) = fft2(tmp_C);
%X0_(:,:,1) = conj(X0_(:,:,1)); %<-- ?;
end;%if (fft_flag==0);
if (fft_flag==1);
[gamma__,alpha__] = meshgrid(gamma_,alpha_);
tmp_C = squeeze(C_(:,:));
if (verbose>1); disp(sprintf(' %% calling nufft2d2')); end;
tmp = nufft2d2(n_alpha*n_gamma,alpha__(:),gamma__(:),-1,1e-12,n_m_max,n_m_max,tmp_C);
X0_(:,:,1) = reshape(tmp,n_alpha,n_gamma);
%X0_(:,:,1) = conj(X0_(:,:,1)); %<-- ?;
end;%if (fft_flag==1);

