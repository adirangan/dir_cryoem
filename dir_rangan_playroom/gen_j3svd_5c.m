function [n_svd_r,svd_r_,svd_r_m,svd_r_c,svd_r_w_,svd_r_Jv_,n_svd_d,svd_d_,svd_d_m,svd_d_c,svd_d_w_,svd_d_Jv_,n_svd_l,svd_l_,svd_U_d_,svd_s_,svd_V_r_] = gen_j3svd_5c(K_max,N_pixel,eps_target,l_max,a_K,b_K);
% Generating functional svd-expansion of various spherical-bessel-functions. ;
%
% Inputs: ;
% K_max: maximum K-value; R_target will be set to K_max-0.5. ;
% N_pixel: maximum pixel width (in wavelengths) allowed for square grid of displacements. ;
% eps_target: tolerance of svd-expansion. ;
% l_max: maximum order of spherical-bessel-functions in svd-expansion. ;
% a_K: degree of jacobi-polynomials used to represent r = |k|. ;
% b_K: degree of jacobi-polynomials used to represent d = |delta|. ;
% ;
% Outputs: ;
% n_svd_r: number of coefficients used to represent polynomials of r = k. ;
% svd_r_: vector of quadrature nodes associated with polynomials of r = k. ;
% svd_r_m: midpoint of interval for r = k. ;
% svd_r_c: half-width of interval for r = k. ;
% svd_r_w_: vector of quadrature weights for r = k. ;
% svd_r_Jv_: cell array of chebfuns for r = k. ; 
% n_svd_d: number of coefficients used to represent polynomials of d = delta. ;
% svd_d_: vector of quadrature nodes associated with polynomials of d = delta. ;
% svd_d_m: midpoint of interval for d = delta. ;
% svd_d_c: half-width of interval for d = delta. ;
% svd_d_w_: vector of quadrature weights for d = delta. ;
% svd_d_Jv_: cell array of chebfuns for d = delta. ; 
% n_svd_l: number of terms in svd-expansion. ;
% svd_l_: vector of spherical-bessel-orders for the terms in the svd-expansion. ;
% svd_U_d_: array of size b_K-x-n_svd_l storing the delta-side of the svd-expansion. ;
% svd_s_: vector of length n_svd_l storing the singular-values of the svd-expansion. ;
% svd_V_r_: array of size a_K-x-n_svd_l storing the r-side of the svd-expansion. ;
%     Note: if we define ij_tmp_ to be the list of indices for which svd_l_ = l_tmp,: ;
%           then we can use the svd-expansion to reconstruct the spherical-bessel-function of order l_tmp. ;
%           For example, try: ;
%           gen_j3svd_5c();

%{
if (nargin<3);

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
 % Here we calculate the l2-error ES_, integrated over Omega_{k} for a particular delta. ;
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
 clear;
 setup;
 K_max = 1.0; R_max = 2*pi*K_max; N_pixel = 1.5; l_max = 32; n_l = l_max+1; n_r_degree = 63; n_d_degree = 65; verbose=1;
 eps_target_ = 0.1.^[0:0.125:8]; eps_target_min = min(eps_target_); eps_target = eps_target_min; n_eps_target = length(eps_target_);
 disp(sprintf(' %% testing gen_j3svd_5c with K_max %d N_pixel %0.2f eps_target %0.2f and radial weight function',K_max,N_pixel,eps_target));
 [n_svd_r,svd_r_,svd_r_m,svd_r_c,svd_r_w_,svd_r_Jv_,n_svd_d,svd_d_,svd_d_m,svd_d_c,svd_d_w_,svd_d_Jv_,n_svd_l,svd_l_,svd_U_d_,svd_s_,svd_V_r_] = gen_j3svd_5c(K_max,N_pixel,eps_target,l_max,n_r_degree,n_d_degree);
 %;
 sample_d = 1/16; [n_all,theta_all_,phi_all_,weight_all_] = sample_shell_3(1.0,sample_d,'L') ;
 %%%%%%%%;
 x_all_ = cos(theta_all_).*sin(phi_all_);
 y_all_ = sin(theta_all_).*sin(phi_all_);
 z_all_ = cos(phi_all_);
 %%%%%%%%;
 % define delta_d. ;
 %%%%%%%%;
 nd_degree = 18;
 delta_d = svd_d_(nd_degree);
 %%%%%%%%;
 Ylm_d__ = get_Ylm__(n_l,0:l_max,1,0,0);

 Ylm_d__ = get_Ylm__(n_l,0:l_max,1,0,pi/2);
 for nl=1:l_max;
 l_val = nl-1;
 disp(num2str(transpose(Ylm_d__{nl})));
 end;%for nl=1:l_max;

 Ylm_r__ = get_Ylm__(n_l,0:l_max,n_all,theta_all_,phi_all_);
 Ylm_sum__ = zeros(n_all,n_l);
 for nl=1:n_l;
 l_val = nl-1;
 for m_val=-l_val:+l_val;
 tmp_ = 4*pi * (i)^(l_val) * reshape(Ylm_r__{nl}(1+l_val+m_val,:),n_all,1) .* conj(Ylm_d__{nl}(1+l_val+m_val,1)) ;
 Ylm_sum__(:,nl) = Ylm_sum__(:,nl) + tmp_;
 end;%for m_val=-l_val:+l_val;
 end;%for nl=1:n_l;
 %%%%%%%%;
 j_ = zeros(n_l,n_r_degree);
 for nl=1:n_l;
 l_val = nl-1;
 tmp_ = besselj(l_val+0.5,svd_r_.*delta_d).*sqrt(pi)./sqrt(2*svd_r_.*delta_d);
 j_(nl,:) = tmp_;
 end;%for nl=1:n_l;
 %%%%%%%%;
 U_d_ = zeros(1,n_svd_l);
 for nd_degree=0:n_d_degree-1;
 b_tmp = svd_d_Jv_{1+nd_degree}((delta_d - svd_d_m)/svd_d_c);
 U_d_ = U_d_ + svd_U_d_(1+nd_degree,:)*b_tmp;
 end;% for nd_degree=0:n_d_degree-1;
 %%%%%%%%;
 V_r__ = zeros(n_r_degree,n_svd_l);
 for nsvd_l=1:n_svd_l;
 tmp_nx = nsvd_l;
 V_r_ = zeros(n_r_degree,1);
 for nr_degree=0:n_r_degree-1;
 a_tmp = svd_r_Jv_{1+nr_degree}((svd_r_ - svd_r_m)/svd_r_c);
 V_r_ = V_r_ + svd_V_r_(1+nr_degree,tmp_nx)*a_tmp;
 end;%for nr_degree=0:a_K-1;
 V_r__(:,nsvd_l) = V_r_;
 end;%for nsvd_l=1:n_svd_l;
 %%%%%%%%;
 IT_ = zeros(n_r_degree,1);
 QT_ = zeros(n_r_degree,1);
 QJ__ = zeros(n_r_degree,n_l);
 EJ__ = zeros(n_r_degree,n_l);
 QS__ = zeros(n_r_degree,n_eps_target);
 ES__ = zeros(n_r_degree,n_eps_target);
 %%%%%%%%%%%%%%%%;
 for nr_degree=1:n_r_degree;
 r_tmp = svd_r_(nr_degree); k_tmp = r_tmp/(2*pi); 
 %xr_all_ = x_all_*k_tmp; yr_all_ = y_all_*k_tmp; zr_all_ = z_all_*k_tmp;
 zr_all_ = z_all_*k_tmp;
 %%%%%%%%;
 IT_(nr_degree) = 4*pi*(1/delta_d)*sin(delta_d*r_tmp).*r_tmp./r_tmp.^2;
 %IT_(nr_degree) = 4*pi*(1/delta_d)*sin(delta_d*r_tmp).*r_tmp;
 %%%%%%%%;
 T_ = exp(+i*2*pi*zr_all_.*delta_d);
 QT_(nr_degree) = sum(T_.*weight_all_); %<-- local mass on shell, normalized to have value 4*pi if T_ == 1 ;
 %%%%%%%%;
 J__ = zeros(n_all,n_l);
 for nl=1:n_l;
 l_val = nl-1;
 tmp_ = j_(nl,nr_degree) * Ylm_sum__(:,1+l_val);
 for nl2=nl:n_l; J__(:,nl2) = J__(:,nl2) + tmp_; end;
 end;%for nl=1:n_l;
 for nl=1:n_l; QJ__(nr_degree,nl) = sum(J__(:,nl).*weight_all_); end; %<-- local mass on shell, normalized to have value 4*pi if J__ == 1 ;
 for nl=1:n_l; tmp_ = abs(T_ - J__(:,nl)).^2; EJ__(nr_degree,nl) = sum(tmp_.*weight_all_); end; %<-- local mass on shell, normalized to have value 4*pi if T_-J__ == 1 ;
 %%%%%%%%;
 S__ = zeros(n_all,n_eps_target);
 for nt = 1:n_svd_l;
 l_val = svd_l_(nt);
 U_d = U_d_(1,nt);
 S = svd_s_(nt);
 V_r = V_r__(nr_degree,nt);
 tmp_j = U_d*S*V_r;
 tmp_ = tmp_j * Ylm_sum__(:,1+l_val);
 tmp_ij_ = find(eps_target_<S);
 S__(:,tmp_ij_) = S__(:,tmp_ij_) + repmat(tmp_,1,length(tmp_ij_));
 end;%for nt = 1:n_svd_l;
 for neps_target=1:n_eps_target; QS__(nr_degree,neps_target) = sum(S__(:,neps_target).*weight_all_); end; %<-- local mass on shell, normalized to have value 4*pi if S__ == 1 ;
 for neps_target=1:n_eps_target; tmp_ = abs(T_ - S__(:,neps_target)).^2; ES__(nr_degree,neps_target) = sum(tmp_.*weight_all_); end; %<-- local mass on shell, normalized to have value 4*pi if T_-S__ == 1 ;
 %%%%%%%%;
 end;%for nr_degree=1:n_r_degree;
 %%%%%%%%%%%%%%%%;
 %;
 %plot(1:n_r_degree,real(QT_),'ko-',1:n_r_degree,IT_,'rx-',1:n_r_degree,QJ__,'ms-');
 IT = 4*pi*(1/delta_d^3)*( sin(R_max*delta_d) - (R_max*delta_d)*cos(R_max*delta_d) );
 QT = sum(svd_r_w_.*QT_)*svd_r_c^3;
 QJ_ = zeros(n_l,1); for nl=1:n_l; QJ_(nl) = sum(svd_r_w_.*QJ__(:,nl))*svd_r_c^3; end;
 EJ_ = zeros(n_l,1); for nl=1:n_l; EJ_(nl) = sum(svd_r_w_.*EJ__(:,nl))*svd_r_c^3; end;
 QS_ = zeros(n_eps_target,1); for neps_target=1:n_eps_target; QS_(neps_target) = sum(svd_r_w_.*QS__(:,neps_target))*svd_r_c^3; end;
 ES_ = zeros(n_eps_target,1); for neps_target=1:n_eps_target; ES_(neps_target) = sum(svd_r_w_.*ES__(:,neps_target))*svd_r_c^3; end;
 ET = norm(QT - IT,'fro');
 disp(sprintf(' %% int_{Omega_{k}} exp(+i2pik*delta) dk = IT %0.16f',IT));
 disp(sprintf(' %% quadrature approximation of IT: QT %0.16f',QT));
 disp(sprintf(' %% bessel-function approximation of IT: QJ %0.16f',QJ_(n_l)));
 disp(sprintf(' %% l2-error for bessel-function approximation: EJ %0.16f',EJ_(n_l)));
 disp(sprintf(' %% svd-approximation of IT: QS %0.16f',QS_(n_eps_target)));
 disp(sprintf(' %% l2-error for svd-approximation: ES %0.16f',ES_(n_eps_target)));
 disp(sprintf(' %% l2-error for QT-IT: ET %0.16f',ET));
 %%%%%%%%%%%%%%%%;
 % Now compare ES_ (i.e., l2-error calculated directly from svd-expansion) with ES2_ (i.e,. l2-error calculated using only magnitude of terms). ;
 %%%%%%%%%%%%%%%%;
 ES2_ = zeros(n_eps_target,1);
 for nl=1:n_l;
 l_val = nl-1;
 tmp_ij_ = find(svd_l_==l_val);
 for m_val=-l_val:+l_val;
 for nt=1:length(tmp_ij_);
 nx = tmp_ij_(nt);
 tmp_E = svd_r_c^3 * ( (4*pi)^2 * (U_d_(1,nx))^2 * (svd_s_(nx))^2 * abs(Ylm_d__{nl}(1+l_val+m_val,1))^2 );
 for neps_target=1:n_eps_target;
 eps_target = eps_target_(neps_target);
 if (svd_s_(nx)>eps_target); ES2_(neps_target) = ES2_(neps_target) + tmp_E; end;
 end;%for neps_target=1:n_eps_target;
 end;%for nt=1:length(tmp_ij_);
 end;%for m_val=-l_val:+l_val;
 end;%for nl=1:n_l;
 ES2_ = (4/3)*pi*R_max^3 - ES2_;
 %%%%%%%%;
 %plot(1:n_eps_target,log10(ES2_),'ro-',1:n_eps_target,log10(ES_),'bx-');
 %%%%%%%%;
 %%%%%%%%%%%%%%%%;
 % Now calculate ES3_ (i.e., l2-error integrated over Omega_{d} and Omega_{k}) ;
 % Also accumulate the (approximate) number of terms required for this error. ;
 %%%%%%%%%%%%%%%%;
 n_term_base = 0;
 tmp_l_max = l_max*2;
 for tmp_l1=0:tmp_l_max;
 for tmp_m1=-tmp_l1:+tmp_l1;
 n_m = 1+2*tmp_l1;
 n_term_base = n_term_base + n_m;
 end;%for tmp_m1=-tmp_l1:+tmp_l1;
 end;%for tmp_l1=0:tmp_l_max;
 %%%%%%%%;
 % Here for any given nx=tau and l2=l_val, the number of terms is determined by: ;
 % 1. l3 in the range \|l1-l2\| to l1+l2, with l1+l2+l3 even. ;
 %    The values of l3 will sometimes range over (l1-l2):2:(l1+l2). ;
 % 2. The values of m2 should range between -l2:+l2, ;
 % 3. However, m3 must equal m1+m2, which means that the minimum of l3 must be abs(m3). ;
 n_term_ = zeros(1+max(svd_l_),1);
 for tmp_l2=0:max(svd_l_);
 n_term = 0;
 for tmp_m2 = -tmp_l2:+tmp_l2;
 for tmp_l1=0:tmp_l_max;
 for tmp_m1 = -tmp_l1:+tmp_l1;
 tmp_m3 = tmp_m1+tmp_m2;
 min_l3 = max(abs(tmp_m3),abs(tmp_l2-tmp_l1)); if mod(min_l3+tmp_l2+tmp_l1,2)==1; min_l3 = min_l3+1; end;
 step_l3 = 2; 
 max_l3 = tmp_l2+tmp_l1; if mod(max_l3+tmp_l2+tmp_l1,2)==1; max_l3 = max_l3-1; end;
 for tmp_l3=min_l3:step_l3:max_l3;
 n_m = 1+2*tmp_l1;
 n_term = n_term + n_m;
 end;%for tmp_l3=min_l3:step_l3:max_l3;
 end;%for tmp_m1 = -tmp_l1:+tmp_l1;
 end;%for tmp_l1=0:tmp_l_max;
 end;% for tmp_m2 = -tmp_l2:+tmp_l2;
 n_term_(1+tmp_l2) = n_term;
 end;% for tmp_l2=0:max(svd_l_);
 %%%%%%%%;
 n_tsvd_total_ = zeros(n_eps_target,1); %<-- total number of terms in svd-expansion, including only l1,l2,m1,m2,tau. ;
 for neps_target=1:n_eps_target;
 eps_target = eps_target_(neps_target);
 tmp_ij_ = find(svd_s_>eps_target);
 n_tsvd_total_(neps_target) = sum(1+2*svd_l_(tmp_ij_));
 end;%for neps_target=1:n_eps_target;
 %%%%%%%%;
 ES3_ = zeros(n_eps_target,1);
 n_term_total_ = zeros(n_eps_target,1); %<-- total number of terms in svd-expansion, including all l1,l2,l3,m1,m2,m3, as well as tau. ;
 %%%%%%%%;
 for nl=1:n_l;
 l_val = nl-1; tmp_l2 = l_val;
 tmp_ij_ = find(svd_l_==l_val);
 for nt=1:length(tmp_ij_); nx = tmp_ij_(nt);
 %%%%%%%%;
 n_m = 1+2*l_val;
 tmp_E = n_m * svd_d_c^3 * svd_r_c^3 * ( (4*pi)^2 * (svd_s_(nx))^2 );
 for neps_target=1:n_eps_target;
 eps_target = eps_target_(neps_target);
 if (svd_s_(nx)>eps_target); 
 ES3_(neps_target) = ES3_(neps_target) + tmp_E; 
 n_term_total_(neps_target) = n_term_total_(neps_target) + n_term_(1+l_val) ;
 end;%if (svd_s_(nx)>eps_target); 
 end;%for neps_target=1:n_eps_target;
 end;%for nt=1:length(tmp_ij_);
 end;%for nl=1:n_l;
 D_max = 2*svd_d_m;
 ES3_ = (4/3)*pi*R_max^3 * (4/3)*pi*D_max^3 - ES3_;
 %%%%%%%%;
 %plot(1:n_eps_target,log10(ES3_),'k.-');
 %%%%%%%%;
 %%%%%%%%%%%%%%%%;
 % Now calculate relative error as a function of the (approximate) number of terms. ;
 %%%%%%%%%%%%%%%%;
 tmp_A = (4/3)*pi*R_max^3 * (4/3)*pi*D_max^3;
 ES4_ = ES3_ ./ tmp_A;
 plot(log10(n_term_total_/n_term_base),log10(ES4_),'go-'); %plot(1:n_eps_target,log10(ES4_),'k.-');
 xlabel('log10(#_{\eta})'); ylabel('log10(E)'); title('Error vs #_{\eta} for #_{W}=1.5');
 %%%%%%%%%%%%%%%%;
 % Now compare to 2d version: taken from helper_plot_E2vsF2_0.m ;
 %%%%%%%%%%%%%%%%;
 fname_base = sprintf('E2vsF2_N%.2d',round(10*N_pixel));
 fname_mat = sprintf('/data/rangan/dir_cryoem/dir_rangan_playpen/dir_svd/%s.mat',fname_base); fcheck(fname_mat);
 load(fname_mat,'n_svd_l_','E2_rel_','n_node_','F2_rel_','N_pixel');
 %%%%%%%%;
 E2_p0=0; E2_p1=0; % linear regression. ;
 tmp_x_ = n_svd_l_;
 tmp_y_ = log10(E2_rel_);
 tmp_A_ = [dot(tmp_x_,tmp_x_) , sum(tmp_x_) ; sum(tmp_x_) , length(tmp_x_)] \ [dot(tmp_x_,tmp_y_) ; sum(tmp_y_)];
 E2_p1 = tmp_A_(1); E2_p0 = tmp_A_(2);
 F2_p0=0; F2_p1=0; % linear regression. ;
 tmp_x_ = log10(1+pi*(n_node_-1).^2);
 tmp_y_ = log10(F2_rel_);
 tmp_A_ = [dot(tmp_x_,tmp_x_) , sum(tmp_x_) ; sum(tmp_x_) , length(tmp_x_)] \ [dot(tmp_x_,tmp_y_) ; sum(tmp_y_)];
 F2_p1 = tmp_A_(1); F2_p0 = tmp_A_(2);
 %%%%%%%%;
 l10E2_ = -(0:0.25:8);
 E2_nterms_ = zeros(length(l10E2_),1);
 for ne=1:length(l10E2_);
 l10E2 = l10E2_(ne);
 E2_nterms_(ne) = max(1,ceil((l10E2 - E2_p0)/E2_p1));
 end;%for ne=1:length(l10E2_);
 %%%%%%%%;
 l10F2_ = -(0:0.25:8);
 F2_nterms_ = zeros(length(l10F2_),1);
 for ne=1:length(l10F2_);
 l10F2 = l10F2_(ne);
 F2_nterms_(ne) = max(1,ceil(10.^((l10F2 - F2_p0)/F2_p1)));
 end;%for ne=1:length(l10F2_);
 %%%%%%%%%%%%%%%%;
 % now plot comparison with 3d-case. ;
 %%%%%%%%%%%%%%%%;
 E3_p0=0; E3_p1=0; % linear regression. ;
 tmp_x_ = (n_term_total_/n_term_base).^(0.5);
 tmp_y_ = log10(ES4_);
 tmp_A_ = [dot(tmp_x_,tmp_x_) , sum(tmp_x_) ; sum(tmp_x_) , length(tmp_x_)] \ [dot(tmp_x_,tmp_y_) ; sum(tmp_y_)];
 E3_p1 = tmp_A_(1); E3_p0 = tmp_A_(2);
 l10E3_ = -(0:0.25:8);
 E3_nterms_ = zeros(length(l10E3_),1);
 for ne=1:length(l10E3_);
 l10E3 = l10E3_(ne);
 E3_nterms_(ne) = max(1,ceil((l10E3 - E3_p0)/E3_p1))^2;
 end;%for ne=1:length(l10E3_);
 %%%%%%%%;
 tmp_gamma = 17/9;
 figure(1);clf; hold on;
 plot(log10(n_tsvd_total_),log10(ES4_),'ro-',log10([21,29,32,64]),log10([0.3123,0.1765,0.1445,0.0172]),'ko');
 plot(log10(E2_nterms_),l10E2_,'g.-',log10(n_svd_l_),log10(E2_rel_),'go');
 plot(log10(E3_nterms_),l10E3_,'g.-',log10(n_term_total_/n_term_base),log10(ES4_),'go');
 plot(log10(E2_nterms_)*tmp_gamma,l10E2_,'m.-',log10(n_svd_l_)*tmp_gamma,log10(E2_rel_),'mo');
 plot(log10(E2_nterms_)*1.5,l10E2_,'b.-',log10(n_svd_l_)*1.5,log10(E2_rel_),'bo');
 hold off;
   


disp('returning');return;

end;%if (nargin<3);
%}

verbose=2;
ni = 4;
if (nargin<ni); l_max = 24; end; ni = ni+1;
if (nargin<ni); a_K = 32; end; ni = ni+1;
if (nargin<ni); b_K = 32; end; ni = ni+1;
if (verbose>1); 
disp(sprintf(' %% [entering gen_j3svd_5c] N_pixel %0.2f l_max %d, a_K %d, b_K %d, eps_target %0.6f',N_pixel,l_max,a_K,b_K,eps_target)); 
end;%if (verbose>1);

%%%%%%%%;
R_target = K_max;
z_target = N_pixel*pi*sqrt(2);
D_target = z_target/(2*pi*R_target);
%%%%%%%%;
r_max = 2*pi*R_target;
d_max = D_target;
a_m = r_max/2; a_r = a_m;
b_m = d_max/2; b_r = b_m;
%%%%%%%%;
%[a_jx,a_jw] = jacpts(a_K,0,1); a_jw=transpose(a_jw);
[a_jx,a_jw] = jacpts(a_K,0,2); a_jw=transpose(a_jw);
a_Jv_ = cell(1+a_K,1+a_K); a_Jx = zeros(a_K,a_K);
for nkA=0:a_K;
%aj = jacpoly(nkA,0,1)*sqrt(nkA+1)/sqrt(2);
aj = jacpoly(nkA,0,2)*sqrt(2*nkA+3)/sqrt(8);
if (nkA<a_K); a_Jx(1+nkA,:) = aj(a_jx); end;
a_Jv_{1+nkA} = aj;
end;%for nkA=1:a_K;
a_jt = a_jx*a_r + a_m;
%%%%%%%%;
%[b_jx,b_jw] = jacpts(b_K,0,1); b_jw=transpose(b_jw);
[b_jx,b_jw] = jacpts(b_K,0,2); b_jw=transpose(b_jw);
b_Jv_ = cell(1+b_K,1+b_K); b_Jx = zeros(b_K,b_K);
for nkB=0:b_K;
%bj = jacpoly(nkB,0,1)*sqrt(nkB+1)/sqrt(2);
bj = jacpoly(nkB,0,2)*sqrt(2*nkB+3)/sqrt(8);
if (nkB<b_K); b_Jx(1+nkB,:) = bj(b_jx); end;
b_Jv_{1+nkB} = bj;
end;%for nkB=1:b_K;
b_jt = b_jx*b_r + b_m;
%%%%%%%%;
[A_jt_,B_jt_] = meshgrid(a_jt,b_jt);
%%%%%%%%;

clear S_l_ S_u_ S_s_ S_v_ ;
l=0; n_S=0; continue_flag=1;
while (continue_flag);
if (l==0); l_ = [0]; else l_ = [+l]; end;
for l_tmp = l_;
F = @(a,b) besselj(l_tmp + 0.5,a.*b) .* sqrt(pi./2) ./ sqrt(a.*b);
F_jt_ = F(A_jt_,B_jt_);
F_ = zeros(b_K,a_K);
jw_ = b_jw*transpose(a_jw);
for nkA=0:a_K-1;for nkB=0:b_K-1;
J_tmp_ = transpose(b_Jx(1+nkB,:))*a_Jx(1+nkA,:);
S_tmp = F_jt_.*J_tmp_.*jw_;
F_(1+nkB,1+nkA) = sum(S_tmp(:));
end;end;%for nkA=0:a_K-1;for nkB=0:b_K-1;
n_svds = min([b_K,a_K]);
[U_,S_,V_] = svds(F_,n_svds); S_ = diag(S_); [ij_ret_] = find(S_>eps_target) ;
if ~isempty(ij_ret_);
if (verbose>1); disp(sprintf(' %% l %+.2d, found %d terms [%0.2f,..,%0.2f];',l_tmp,length(ij_ret_),S_(ij_ret_(1)),S_(ij_ret_(end)))); end;%if
for ij = 1:length(ij_ret_);
S_l_(1+n_S) = l_tmp;
S_u_(:,1+n_S) = U_(:,ij_ret_(ij));
S_s_(1,1+n_S) = S_(ij_ret_(ij),1);
S_v_(:,1+n_S) = V_(:,ij_ret_(ij));
n_S = n_S + 1;
end;%for ij = 1:length(ij_ret_);
end;%if ~isempty(ij_ret_);
end;%for l_tmp = l_;
l=l+1;
if (l>l_max); continue_flag=0; else continue_flag=1; end;
end;%while (continue_flag);
if (verbose>1); disp(sprintf(' %% total of n_S %d terms found;',n_S)); end%if;

n_svd_r = length(a_jt); svd_r_ = a_jt;
svd_r_m = a_m; svd_r_c = a_r; svd_r_w_ = a_jw; svd_r_Jv_ = a_Jv_;
n_svd_d = length(b_jt); svd_d_ = b_jt;
svd_d_m = b_m; svd_d_c = b_r; svd_d_w_ = b_jw; svd_d_Jv_ = b_Jv_;
n_svd_l = n_S;
svd_l_ = []; if (exist('S_l_','var')); svd_l_ = S_l_; end;
svd_U_d_ = []; if (exist('S_u_','var')); svd_U_d_ = S_u_; end;
svd_s_ = []; if (exist('S_s_','var')); svd_s_ = S_s_; end;
svd_V_r_ = []; if (exist('S_v_','var')); svd_V_r_ = S_v_; end;
