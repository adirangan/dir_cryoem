function [X0_,n_op,n_mult] = register_spharm_to_spharm_angle_parfor_2(verbose,n_k,k_,n_l_,a_,b_,n_beta,beta_);
% tests registration between molecule_A and molecule_B using an array of beta (fast only);
% Much slower than register_spharm_to_spharm_angle_parfor_1(verbose,n_k,k_,n_l_,a_,b_,n_beta,beta_);
% ;
% verbose = integer verbosity_level ;
% n_k = integer maximum k ;
% k_ = real array of length n_k; k_(nk) = k_value for shell nk ;
% n_l_ = integer array of length n_k; n_l_(nk) = spherical harmonic order on shell nk; n_l_(nk) corresponds to n_lm_(nk) = (n_l_(nk)+1)^2 coefficients ;
% a_ = complex array of length \sum_{nk} (n_lm_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% b_ = complex array of length \sum_{nk} (n_lm_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% a_ corresponds to molecule_a, b_ to molecule_b ;
% n_beta = integer number of beta angles ;
% beta_ = real array of beta angles ;
% n_alpha = integer number of alpha angles (optional);
% alpha_ = real array of alpha angles (optional);
% n_gamma = integer number of gamma angles (optional);
% gamma_ = real array of gamma angles (optional);
% ;
% If arrays alpha_ and gamma_ are not provided we use the standard arrays: ;
% alpha_ = linspace(0,2*pi,n_m_max+1); alpha_ = alpha_(1:end-1);
% gamma_ = linspace(0,2*pi,n_m_max+1); gamma_ = gamma_(1:end-1);
% and use the standard fft to calculate X0_.; 
% ;
% However, if n_alpha, alpha_ and n_gamma, gamma_ are provided, we use these arrays instead, ;
% and use the nufft to calculate X0_. ;
% ;
% X_ = complex array of size (n_alpha,n_gamma,n_beta);
% The default values of n_alpha and n_gamma are n_m_max. ;
% X_(nalpha,ngamma,nbeta) corresponds to the innerproduct between molecule_A and molecule_B, where ;
% the latter has been rotated by euler-angles alpha,beta,gamma. ;
% Note that alpha_ and gamma_ are arrays from 0 to 2*pi, ;
% whereas beta_ is an array from -pi to pi. ;

if nargin<1;
verbose=0;
for n_l=2.^[3:6];
n_k=1;k_=1;n_l_=[n_l];n_lm_=(n_l_+1).^2;
a_=randn(sum(n_lm_),1);b_=randn(sum(n_lm_),1);
n_beta=2*n_l_(1);beta_=linspace(-pi,+pi,n_beta+1);beta_=beta_(1:end-1);
[X0_,n_op,n_mult] = register_spharm_to_spharm_angle_parfor_2(verbose,n_k,k_,n_l_,a_,b_,n_beta,beta_);
end;%for n_l=2.^[4:7];
disp('returning');return;
end;%if nargin<1;

n_lm_ = (n_l_+1).^2; n_lm_csum_ = cumsum([0;n_lm_(:)]);
k_max = k_(end);
n_l_max = n_l_(end);
m_max_ = -n_l_max : +n_l_max;
n_m_max = length(m_max_);

if (nargin<=8);
fft_flag = 0; 
n_alpha = n_m_max;
n_gamma = n_m_max;
end;%if (nargin<=8);
if (nargin>=9 & nargin<=12); 
fft_flag = 1;
end;%if (nargin>=9 & nargin<=12); 

disp(sprintf(' %% n_l_max: %d: n_alpha %d, n_beta %d, n_gamma %d, fft_flag %d',n_l_max,n_alpha,n_beta,n_gamma,fft_flag));

X0_ = zeros(n_alpha,n_gamma,n_beta);
n_op = 0;
n_mult = 0;
%%%%%%%%;
d___ = zeros(n_m_max,n_m_max,1+n_l_max,n_beta);
t_0in = tic;
%parfor nbeta = 0:n_beta-1;
for nbeta = 0:n_beta-1;
beta = beta_(1+nbeta);
W_ = wignerd_b(n_l_max,-beta);
d__ = zeros(n_m_max,n_m_max,1+n_l_max);
for nl=0:n_l_max;
d__(1+n_l_max + [-nl:+nl],1+n_l_max + [-nl:+nl],1+nl) = W_{1+nl};
end;%for nl=0:n_l_max;
d___(:,:,:,1+nbeta) = d__;
end;%parfor nbeta = 0:n_beta-1;
t_out = toc(t_0in);
disp(sprintf(' %% d__ time: time %0.6f',t_out));
%%%%%%%%;
a___ = zeros(n_m_max,n_k,1+n_l_max); b___ = zeros(n_m_max,n_k,1+n_l_max);
t_0in = tic;
ixk=0;
for nk=0:n_k-1;
ixl=0;
for nl=0:n_l_max;
a___(1+n_l_max + [-nl:+nl],1+nk,1+nl) = a_(1+ixk+ixl+nl+-[-nl:+nl]);
b___(1+n_l_max + [-nl:+nl],1+nk,1+nl) = b_(1+ixk+ixl+nl+-[-nl:+nl]);
ixl = ixl+(2*nl+1);
end;%for nl=0:n_l_max;
assert(ixl==n_lm_(1+nk));
ixk = ixk+n_lm_(1+nk);
end;%for nk=0:n_k-1;
assert(ixk==sum(n_lm_));
ab__ = zeros(n_m_max,n_m_max,1+n_l_max);
for nl=0:n_l_max;
ab__(:,:,1+nl) = conj(squeeze(a___(:,:,1+nl)))*diag(k_.^2)*transpose(b___(:,:,1+nl));
end;%for nl=0:n_l_max;
t_out = toc(t_0in);
disp(sprintf(' %% ab__ time: time %0.6f',t_out));
%%%%%%%%;
abt__ = permute(ab__,[3,1,2]); %<-- now 1+n_l_max by n_m_max by n_m_max. ;
dt___ = permute(d___,[4,3,1,2]); %<-- now n_beta by 1+n_l_max by n_m_max by n_m_max. ;
t_0in = tic;
%parfor nbeta = 0:n_beta-1;
Ct__ = zeros(n_beta,n_m_max,n_m_max);
for nmp=0:n_m_max-1;
for nmn=0:n_m_max-1;
for nbeta = 0:n_beta-1;
Ct__(1+nbeta,1+nmn,1+nmp) = dt___(1+nbeta,:,1+nmn,1+nmp)*abt__(:,1+nmn,1+nmp);
end;%for nbeta = 0:n_beta-1;
end;%for nmn=0:n_m_max-1;
end;%for nmp=0:n_m_max-1;
C__ = permute(Ct__,[2,3,1]); %<-- now n_m_max by n_m_max by n_beta. ;
for nbeta=0:n_beta-1;
X0_(:,:,1+nbeta) = conj(recenter2(fft2(squeeze(C__(:,:,1+nbeta)))));
end;%for nbeta=0:n_beta-1;
n_op = 0;
n_mult = 0;
t_out = toc(t_0in);
disp(sprintf(' %% register time: time %0.6f',t_out));
