function a_k_Y_ = quadrature_approximation_to_cg_lsq_3(n_order,n_k_p_r,l_max_,n_w_,n_M,M_k_p__,CTF_index_,CTF_k_p__,euler_polar_a_,euler_azimu_b_,euler_gamma_z_,n_polar_a_,n_azimu_b__,legendre_evaluate_jlm____,expil__,expi__);
%%%%%%%%;
% approximates the least-squares problem to solve for a_k_Y_ using simple low-order quadrature. ;
% Associates CTF_k_p__(:,CTF_index_(1+nM)) with image M_k_p__(:,1+nM);
% ;
% Input: ;
% n_order: integer polynomial interpolation order used for conjugate-gradient interpolation operator. ;
% n_k_p_r: integer number of shells. ;
% l_max_: integer array of size n_k_p_r. l_max_(1+nk_p_r) is the order used for a_k_Y_ on shell nk_p_r. ;
% n_w_: integer array of size n_k_p_r. n_w_(1+nk_p_r) is the number of inplane_gamma_z values recorded at that ring. ;
% n_M: integer number of images. ;
% M_k_p__: complex array of size (n_w_sum,n_M). stack of images in k_p_ format. ;
% CTF_index_: integer array of size n_M. CTF_index_(1+nM) is the CTF_index used for image M_k_p__(:,1+nM). ;
%             This can be empty or set to 1, in which case the same CTF_k_p_ will be used for each image. ;
% CTF_k_p__: complex array of size(n_w_sum,n_CTF). stack of ctf-functions in k_p_ format. ;
%            If CTF_index_ is empty or set to 1, then we assume this contains only a single CTF_k_p_, ;
%            which will then be used for all images. ;
% euler_polar_a_: real array of size n_M. initial polar_a used for each image (randomized if empty). ;
% euler_azimu_b_: real array of size n_M. initial azimu_b used for each image (randomized if empty). ;
% euler_gamma_z_: real array of size n_M. initial gamma_z used for each image (randomized if empty). ;
% ;
% Output: ;
% a_k_Y_: complex array of size n_lm_sum. output functions in k_Y_ format. ;
%%%%%%%%;

n_polar_a_ = [];
n_azimu_b__ = [];
legendre_evaluate_jlm____=[];
expil__=[];
expi__=[];

n_lm_ = (1+l_max_).^2;
n_lm_max = max(n_lm_);
n_lm_sum = sum(n_lm_);
n_lm_csum_ = cumsum([0;n_lm_]);

n_w_max = max(n_w_);
n_w_sum = sum(n_w_);
n_w_csum_ = cumsum([0;n_w_]);

if isempty(CTF_k_p__); CTF_index_ = 1; CTF_k_p__ = ones(n_w_sum,1); end;

a_k_Y_ = zeros(n_lm_sum,1);
for nk_p_r=0:n_k_p_r-1;
%%%%%%%%;
l_max = l_max_(1+nk_p_r);
tmp_Y_ij_ = n_lm_csum_(1+nk_p_r) + (0:n_lm_(1+nk_p_r)-1);
n_w = n_w_(1+nk_p_r);
tmp_M_ij_ = n_w_csum_(1+nk_p_r) + (0:n_w_(1+nk_p_r)-1);
tmp_M_k_p_ = reshape(M_k_p__(1+tmp_M_ij_,:),[n_w*n_M,1]);
if (isempty(CTF_index_) | numel(CTF_index_)==1);
tmp_CTF_k_p_ = reshape(repmat(CTF_k_p__(1+tmp_M_ij_),[1,n_M]),[n_w*n_M,1]);
 else;
tmp_CTF_k_p_ = reshape(CTF_k_p__(1+tmp_M_ij_,CTF_index_(1:n_M)),[n_w*n_M,1]);
end;%if (isempty(CTF_index_) | numel(CTF_index_)==1);
[k_p_polar_a__,k_p_azimu_b__] = cg_rhs_1(n_M,n_w,euler_polar_a_,euler_azimu_b_,+euler_gamma_z_);
k_c_0__ = sin(k_p_polar_a__).*cos(k_p_azimu_b__);
k_c_1__ = sin(k_p_polar_a__).*sin(k_p_azimu_b__);
k_c_2__ = cos(k_p_polar_a__);
n_scatter = n_w*n_M;
%%%%%%%%;
% read n_polar_a and n_azimu_b_ if passed in as inputs. ;
%%%%%%%%;
if ( isempty(n_polar_a_));
n_polar_a = ceil(n_w/2); if (mod(n_polar_a,2)==0); n_polar_a = n_polar_a+1; end; %<-- ensure odd n_polar_a for simpson rule. ;
end;%if (isempty(n_polar_a_));
if (~isempty(n_polar_a_));
n_polar_a = n_polar_a_(1+nk_p_r);
if (mod(n_polar_a,2)==0); disp(sprintf(' %% Warning, n_polar_a %d should be odd',n_polar_a)); end;
end;%if (~isempty(n_polar_a_));
%%%%%%%%;
% Now generate simple quadrature grid. ;
%%%%%%%%;
polar_a_ = transpose(linspace(0,pi,n_polar_a)); 
weight_polar_a_ = sin(polar_a_)*pi/(n_polar_a-1); 
weight_polar_a_(2:2:end) = weight_polar_a_(2:2:end)*4/3; weight_polar_a_(1:2:end) = weight_polar_a_(1:2:end)*2/3; %<-- simpson rule. ;
if ( isempty(n_azimu_b__));
n_azimu_b_max = 2*n_polar_a;
n_azimu_b_ = zeros(n_polar_a,1);
for npolar_a=0:n_polar_a-1;
polar_a = polar_a_(1+npolar_a);
n_azimu_b_(1+npolar_a) = ceil(n_azimu_b_max*sin(polar_a));
end;%for npolar_a=0:n_polar_a-1;
end;%if ( isempty(n_azimu_b__));
if (~isempty(n_azimu_b__));
n_azimu_b_ = n_azimu_b__(:,1+npolar_a);
end;%if (~isempty(n_azimu_b__));
n_azimu_b_sum = sum(n_azimu_b_);
polar_a_all_ = zeros(n_azimu_b_sum,1);
azimu_b_all_ = zeros(n_azimu_b_sum,1);
weight_all_ = zeros(n_azimu_b_sum,1);
na=0;
for npolar_a=0:n_polar_a-1;
polar_a = polar_a_(1+npolar_a);
weight_polar_a = weight_polar_a_(1+npolar_a);
n_azimu_b = n_azimu_b_(1+npolar_a);
for nazimu_b=0:n_azimu_b-1;
azimu_b = 2*pi*nazimu_b/n_azimu_b;
azimu_b_all_(1+na) = azimu_b;
polar_a_all_(1+na) = polar_a;
weight_all_(1+na) = weight_polar_a*2*pi/n_azimu_b;
na=na+1;
end;%for nazimu_b=0:n_azimu_b-1;
end;%for npolar_a=0:n_polar_a-1;
assert(na==n_azimu_b_sum);
k_c_0_all_ = sin(polar_a_all_).*cos(azimu_b_all_);
k_c_1_all_ = sin(polar_a_all_).*sin(azimu_b_all_);
k_c_2_all_ = cos(polar_a_all_);
%%%%%%%%;
% Now read in legendre_evaluate_jlm___, expil_ and expi_ if passed in as inputs, ;
% otherwise evaluate spherical harmonics on simple quadrature grid. ;
%%%%%%%%;
if (~isempty(legendre_evaluate_jlm____));
legendre_evaluate_jlm___ = legendre_evaluate_jlm____{1+nk_p_r};
end;%if (~isempty(legendre_evaluate_jlm____));
if (~isempty(expil__));
expil_ = expil__{1+nk_p_r};
end;%if (~isempty(expil__));
if (~isempty(expil__));
expil_ = expil__{1+nk_p_r};
end;%if (~isempty(expil__));
if ( isempty(legendre_evaluate_jlm____));
legendre_evaluate_jlm___ = ylgndr_0(l_max,cos(polar_a_all_))/sqrt(4*pi);
end;%if ( isempty(legendre_evaluate_jlm____));
if ( isempty(expil__));
expi_ = exp(i*azimu_b_all_);
end;%if ( isempty(expil__));
if ( isempty(expil__));
expil_ = expi_.^(-l_max);
end;%if ( isempty(expil__));
%%%%%%%%;
% Now find nearest neighbors. ;
%%%%%%%%;
index_scatter_to_grid__ = sparse(knnsearch([k_c_0_all_(:),k_c_1_all_(:),k_c_2_all_(:)],[k_c_0__(:),k_c_1__(:),k_c_2__(:)]),1:n_scatter,1,n_azimu_b_sum,n_scatter);
%%%%%%%%;
% Now build the right-hand-side. ;
% The essential idea here is that, for each 'on grid' point x, ;
% there may be J points a_{0},...,a_{J-1} which correspond to it. ;
% These J points have J ctf-values c_{0},...,c_{J-1}. ;
% The x we choose represents the value of the spherical harmonic-expansion before multiplication by CTF, ;
% and can be calculated via: ;
% x = argmin_{x} \frac{1}{2} \sum_{j} (c_{j}*x - a_{j})^2. ;
% Which is minimized by: ;
% x = (\sum_{j} c_{j}a_{j}) / (\sum_{j} c_{j}^2) ;
%%%%%%%%;
rhs_ = zeros(n_azimu_b_sum,1);
for nazimu_b_sum=0:n_azimu_b_sum-1;
tmp_ij_ = find(index_scatter_to_grid__(1+nazimu_b_sum,:))-1;
if numel(tmp_ij_)>0;
rhs_(1+nazimu_b_sum) = sum(tmp_CTF_k_p_(1+tmp_ij_).*tmp_M_k_p_(1+tmp_ij_))/(1e-9 + sum(tmp_CTF_k_p_(1+tmp_ij_).^2)); %<-- bound the denominator. ;
end%if numel(tmp_ij_)>0;
end;%for nazimu_b_sum=0:n_azimu_b_sum-1;
%%%%%%%%;
% Now conduct quadrature. ;
%%%%%%%%;
tmp_a_k_Y_ = zeros(n_lm_(1+nk_p_r),1);
na=0;
for l_val=0:l_max;
expim_ = expil_.*(expi_.^(l_max-l_val));
for m_val=-l_val:+l_val;
tmp_a_k_Y_(1+na) = sum(weight_all_(:).*rhs_(:).*conj(legendre_evaluate_jlm___(:,1+l_val,1+abs(m_val)).*expim_(:)));
expim_ = expim_.*expi_;
na=na+1;
end;%for m_val=-l_val:+l_val;
end;%for l_val=0:l_max;
assert(na==n_lm_(1+nk_p_r));
a_k_Y_(1+tmp_Y_ij_) = tmp_a_k_Y_;
%%%%%%%%;
end;%for nk_p_r=0:n_k_p_r-1;

