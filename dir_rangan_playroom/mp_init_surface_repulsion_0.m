function [dP0__,dP2_l2_min] = mp_init_surface_repulsion_0(n_M,P0__,n_neighbor);
% pushes apart n_M points on the surface of the sphere, each defined by P0__(1+nM,:). ;
% ;
% Inputs: ;
% n_M: integer number of points. ;
% P0__: real array of size at least n_M*3. ;
%       Will be interpreted as (n_M,3). ;
%       Values of points in x_c coordinates on the surface of the sphere. ;
%       These will eventually be normalized to lie on the sphere (if they are not already). ;
% n_neighbor: integer number of nearest neighbors to consider (default 1). ;
% ;
% Output: ;
% dP0__: real array of size size(P0__) (e.g., n_M*3 or (n_M,3)). ;
%        Velocity vector for each point. ;
%        This will incorporate both the surface velocity (tangential to the surface), ;
%        as well as term pushing P0__ back onto the surface of the sphere (normal to the surface). ;
% dP2_l2_min: real minimum distance between nearest neighbors (after projection onto sphere). ;
%             Useful for choosing explicit timestep. ;
% ;

if nargin<1;
n_M = 1024; rng(0);
P0__ = randn(n_M,3);
%P0__ = P0__./repmat(sqrt(sum(P0__.^2,2)),[1,3]); %<-- normalize. ;
n_neighbor = 1;
%%%%%%%%;
dP0__ = mp_init_surface_repulsion_0(n_M,P0__,n_neighbor);
c_ = colormap_beach(n_M);
figure(1);clf;
subplot(1,2,1);
hold on;
scatter3(P0__(:,1+0),P0__(:,1+1),P0__(:,1+2),15,c_,'filled');
P1__ = P0__ + 0.05*dP0__;
scatter3(P1__(:,1+0),P1__(:,1+1),P1__(:,1+2), 5,c_,'filled');
l = line(transpose([P0__(:,1+0),P1__(:,1+0)]),transpose([P0__(:,1+1),P1__(:,1+1)]),transpose([P0__(:,1+2),P1__(:,1+2)]));
set(l,'Color','k');
axis square; axis vis3d;
%%%%%%%%;
P1__ = mp_init_surface_repulsion_wrap_0(P0__,n_neighbor);
subplot(1,2,2);
hold on;
scatter3(P1__(:,1+0),P1__(:,1+1),P1__(:,1+2),15,c_,'filled');
axis square; axis vis3d;
%%%%%%%%;
figbig;
end;%if nargin<1;

if (nargin<3); n_neighbor = []; end;
if isempty(n_neighbor); n_neighbor = 1; end; %<-- assume triangular tiling. ;

P1__ = reshape(P0__(1:n_M*3),[n_M,3]); %<-- in case P0__ is unrolled. ;
P1_l2_ = sqrt(sum(P1__.^2,2));
P2__ = P1__./repmat(P1_l2_,[1,3]); %<-- normalize P1__ to lie on surface of sphere. ;
dP1_r__ = P2__ - P1__ ; %<-- normal velocity pointing back towards the surface of the sphere. ;

dP2_avg = sqrt(4*pi^2 / n_M); %<-- average distance between uniformly spaced points on the sphere. ;
tmp_index__ = knnsearch(P2__,P2__,'K',1+n_neighbor) - 1;
tmp_row__ = repmat([0:n_M-1],[n_neighbor,1]);
tmp_col__ = transpose(tmp_index__(:,2:end));
S__ = sparse(1+tmp_row__(:),1+tmp_col__(:),1,n_M,n_M);
dP2__ = P2__ - S__*P2__/n_neighbor; %<-- direction pointing away from mean of n_neighbor nearest neighbors. ;
dP2_l2_ = sqrt(sum(dP2__.^2,2)); %<-- length of dP_. ;
dP2_l2_min = min(dP2_l2_);
dP2_n__ = dP2__./repmat(dP2_l2_,[1,3]); %<-- direction of dP2__. ;
dP2_s_ = exp(-dP2_l2_.^2/(2*dP2_avg^2)); %<-- scaling factor for gaussian repulsion. ;
dP2_t__ = dP2_n__.*repmat(dP2_s_,[1,3]); %<-- tangential velocity on surface of the sphere. ;
dP1_t__ = dP2_t__.*repmat(P1_l2_,[1,3]); %<-- scaled to original P1__. ;
dP1__ = dP1_r__ + dP1_t__ ;
dP0__ = reshape(dP1__,size(P0__));
