function output_ = legendre_evaluate_equator_0(l_val_,m_val_,flag_normalize);
% evaluates associated legendre function P_{l}^{m}(cos(pi/2)). ;
if (nargin<2);
disp(sprintf(' %% sum_{m_val=-l_val}^{m_val=+l_val} P(l_val,m_val,normalized)(0)^2 * 4*pi / (1+2*l_val) '));
for l_val=0:10;
disp(sprintf(' %% l_val %d: sum %0.16f',l_val,sum((legendre_evaluate_equator_0(l_val,-l_val:+l_val,1)).^2)*4*pi/(1+2*l_val)));
end;%for l_val=0:10;
disp('returning');return;
end;%if (nargin<2);

if ((nargin<3) | isempty(flag_normalize)); flag_normalize=1; end;
m_val_ = abs(m_val_);
n_val = max(numel(l_val_),numel(m_val_));
if numel(l_val_)==1; l_val_ = repmat(l_val_,size(m_val_)); end; 
if numel(m_val_)==1; m_val_ = repmat(m_val_,size(l_val_)); end; 
assert(numel(m_val_)==n_val);
output_ = zeros(size(l_val_));
l_val_ = l_val_(:);
m_val_ = m_val_(:);
sgn_0_ = (-1).^m_val_;
ldenominator_ = gammaln(l_val_-m_val_+1);
[lnumerator_,sgn_1_] = ldk(l_val_,m_val_);
output_ = sgn_0_.*sgn_1_.*exp(+ lnumerator_ - ldenominator_);
if flag_normalize; 
tmp_a1_ = ((1+2*l_val_)/(4*pi));
tmp_a2_ = exp(lfactorial(l_val_-abs(m_val_)) - lfactorial(l_val_+abs(m_val_)));
tmp_a3_ = sqrt(tmp_a1_.*tmp_a2_);
output_ = output_.*tmp_a3_;
end;%if flag_normalize; 
output_(find(mod(l_val_+m_val_,2)==1))=0;
output_(find(l_val_==0)) = output_(find(l_val_==0))/2;

function [output_,sgn_] = ldk(l_,m_);
assert(sum(m_>l_)==0);
output_ = zeros(size(l_));
sgn_ = ones(size(l_));
tmp_ij_ = find(mod(l_+m_,2)==1);
output_(tmp_ij_) = -Inf;
tmp_ij_ = find(mod(l_+m_,2)==0);
ub_ = m_(tmp_ij_) + l_(tmp_ij_) - 1;
lb_ = m_(tmp_ij_) - l_(tmp_ij_) + 1;
nl_ = (-lb_+1)/2;
tmp_os_ = find(lb_>0);
output_(tmp_ij_(tmp_os_)) = ldoublefactorial(ub_(tmp_os_));
tmp_ts_ = find(lb_<0);
output_(tmp_ij_(tmp_ts_)) = ldoublefactorial(ub_(tmp_ts_)) + ldoublefactorial(-lb_(tmp_ts_));
sgn_(tmp_ij_(tmp_ts_)) = (-1).^floor(nl_(tmp_ts_));
