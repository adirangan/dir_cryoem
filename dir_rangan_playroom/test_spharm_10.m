function test_spharm_10(n_k,k_,n_l_,a_,b_);
% tests registration between molecule_A and molecule_B using an array of beta (fast only);
% finds maximum value and rotates accordingly, producing X1_ ;
% Note that the maximum value within X0_ should be the angle_=[0,0,0] value of X1_ ;
% iterates this procedure until the orientation of b_ converges ;
%
% when no inputs are passed we import two spherical harmonic representations (generated by kspacegrid_to_model): ;
% molecule_A: modsph_A_ori = spiral ;
% molecule_B: modsph_B_ori = spiral with twisted tail ;
% ;
% n_k = integer maximum k ;
% k_ = real array of length n_k; k_(nk) = k_value for shell nk ;
% n_l_ = integer array of length n_k; n_l_(nk) = spherical harmonic order on shell nk; n_l_(nk) corresponds to n_lm_(nk) = (n_l_(nk)+1)^2 coefficients ;
% a_ = complex array of length \sum_{nk} (n_lm_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% b_ = complex array of length \sum_{nk} (n_lm_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% a_ corresponds to molecule_a, b_ to molecule_b ;
% ;
% test with: ;
%{
  [X0_,X1_] = test_spharm_10();
  %}

verbose=1;

if nargin<5;
xnodesr_ = MDA_read_r8('./dir_mdaT/xnodesr_.mda');
isph_start_ = MDA_read_i4('./dir_mdaT/isph_start_.mda');
nterms_sph_ = MDA_read_i4('./dir_mdaT/nterms_sph_.mda');
modsph_A_ori_ = MDA_read_c16('./dir_mdaT/modsph_A_ori_.mda');
modsph_B_ori_ = MDA_read_c16('./dir_mdaT/modsph_B_ori_.mda');
n_k = length(isph_start_);
k_ = xnodesr_;
n_l_ = nterms_sph_;
n_lm_ = (n_l_+1).^2;
a_ = modsph_A_ori_;
b_ = modsph_B_ori_;
end;%if nargin<4;

% generating innerproduct array over beta_;

n_beta = 34;
beta_ = linspace(-pi,pi,n_beta+1); beta_ = beta_(1:end-1); n_beta = length(beta_);

n_lm_ = (n_l_+1).^2;
k_max = k_(end);
n_l_max = n_l_(end);
m_max_ = -n_l_max : +n_l_max;
n_m_max = length(m_max_);
alpha_ = linspace(0,2*pi,n_m_max+1); alpha_ = alpha_(1:end-1);
gamma_ = linspace(0,2*pi,n_m_max+1); gamma_ = gamma_(1:end-1);
[b_] = rotate_spharm_to_spharm_0(verbose,n_k,k_,n_l_,a_,[+alpha_(2),+beta_(3),+gamma_(4)]);
tmp_x_aa = register_spharm_to_spharm_0(verbose,n_k,k_,n_l_,a_,a_);
tmp_x_ab = register_spharm_to_spharm_0(verbose,n_k,k_,n_l_,a_,rotate_spharm_to_spharm_0(verbose,n_k,k_,n_l_,b_,[-gamma_(4),-beta_(3),-alpha_(2)]));
disp(sprintf(' %% tmp_x_aa %0.16f --> tmp_x_ab %0.16f',tmp_x_aa,tmp_x_ab));

angle_pre_ = zeros(1,3);
iteration_max = 32; iteration=0; continue_flag=1; tmp_x_pre = 0;

while (continue_flag);

tic;
[c_] = rotate_spharm_to_spharm_0(verbose,n_k,k_,n_l_,b_,angle_pre_);
[X0_] = register_spharm_to_spharm_angle_0(verbose,n_k,k_,n_l_,a_,c_,n_beta,beta_);
t_0 = toc; 

[max_pos_v,max_ij] = max(real(X0_(:))); max_ij = max_ij-1;
max_ = zeros(1,3);
max_(1) = mod(max_ij,size(X0_,1));
max_ij = max_ij - max_(1); max_ij = max_ij / size(X0_,1) ;
max_(2) = mod(max_ij,size(X0_,2));
max_ij = max_ij - max_(2); max_ij = max_ij / size(X0_,2);
max_(3) = max_ij;
angle_pos_(1) = 2*pi*max_(1)/size(X0_,1);
angle_pos_(3) = 2*pi*max_(2)/size(X0_,2);
angle_pos_(2) = beta_(1+max_(3));
max_pos_ = 1+max_;
assert(real(X0_(max_pos_(1),max_pos_(2),max_pos_(3)))==max_pos_v);

[d_] = rotate_spharm_to_spharm_0(verbose,n_k,k_,n_l_,c_,angle_pos_);

tmp_x_pos = register_spharm_to_spharm_0(verbose,n_k,k_,n_l_,a_,d_);

angle_tmp_ = R_to_euler(euler_to_R(angle_pos_)*euler_to_R(angle_pre_));

if (verbose>0); disp(sprintf(' %% iteration %d/%d; angle_pre_ [%0.2f,%0.2f,%0.2f] o angle_pos_ [%0.2f,%0.2f,%0.2f] = angle_tmp_ [%0.2f,%0.2f,%0.2f]: time %0.2f; max_pos_v %0.16f - tmp_x_pos %0.16f = %0.16f',iteration,iteration_max,angle_pre_,angle_pos_,angle_tmp_,t_0,real(max_pos_v),real(tmp_x_pos),real(max_pos_v-tmp_x_pos))); end;
angle_pre_ = angle_tmp_;

continue_flag = ((iteration<iteration_max) & (norm(tmp_x_pre-tmp_x_pos)>1e-6));
iteration = iteration+1; tmp_x_pre = tmp_x_pos;

end;%while;
