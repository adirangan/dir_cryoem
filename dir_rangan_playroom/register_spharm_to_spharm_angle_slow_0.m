function [X_slow_] = register_spharm_to_spharm_angle_slow_0(verbose,n_k,k_,n_l_,a_,b_,n_beta,beta_);
% tests registration between molecule_A and molecule_B using an array of beta (slow only);
% ;
% verbose = integer verbosity_level ;
% n_k = integer maximum k ;
% k_ = real array of length n_k; k_(nk) = k_value for shell nk ;
% n_l_ = integer array of length n_k; n_l_(nk) = spherical harmonic order on shell nk; n_l_(nk) corresponds to n_lm_(nk) = (n_l_(nk)+1)^2 coefficients ;
% a_ = complex array of length \sum_{nk} (n_lm_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% b_ = complex array of length \sum_{nk} (n_lm_(nk)+1)^2 ; coefficients are ordered in a row, with m varying quickly and l varying slowly ;
% a_ corresponds to molecule_a, b_ to molecule_b ;
% n_beta = integer number of beta angles ;
% beta_ = real array of beta angles ;
% ;
% X_ = complex array of size (n_m_max,n_m_max,n_m_max) ;
% X_(nalpha,ngamma,nbeta) corresponds to the innerproduct between molecule_A and molecule_B, where ;
% the latter has been rotated by euler-angles alpha,beta,gamma. ;
% Note that alpha_ and gamma_ are arrays from 0 to 2*pi, ;
% whereas beta_ is an array from -pi to pi. ;

n_lm_ = (n_l_+1).^2;
k_max = k_(end);
n_l_max = n_l_(end);
m_max_ = -n_l_max : +n_l_max;
n_m_max = length(m_max_);

X_slow_ = zeros(n_m_max,n_m_max,n_beta);

for nbeta = n_beta;
beta = beta_(nbeta);
k_max = k_(end);
n_l_max = n_l_(end);
W_ = wignerd_b(n_l_max,-beta);
m_max_ = -n_l_max : +n_l_max;
n_m_max = length(m_max_);
alpha_ = linspace(0,2*pi,n_m_max+1); alpha_ = alpha_(1:end-1);
gamma_ = linspace(0,2*pi,n_m_max+1); gamma_ = gamma_(1:end-1);
X_slow_ = zeros(n_m_max,n_m_max);
for nalpha = 1:n_m_max;
alpha = alpha_(nalpha);
for ngamma = 1:n_m_max;
gamma = gamma_(ngamma);
if (verbose>1); disp(sprintf(' %% rotating molecule by: [%0.2f %0.2f %0.2f]',+alpha,+beta,+gamma)); end;
if (verbose>1); disp(sprintf(' %% rotating coordinate_frame by: [%0.2f %0.2f %0.2f]',-gamma,-beta,-alpha)); end;
X_tmp=0;
for nk = 1:n_k;
k_val = nk;
n_l = n_l_(nk); n_lm = n_lm_(nk); ix_base = sum(n_lm_(1:nk-1));
a_k_ = a_(ix_base + (1:n_lm)); b_k_ = b_(ix_base + (1:n_lm));
for nl = 0:n_l;
m_ = [-nl:+nl];
W_alpha = diag(exp(+i*m_*-gamma));
W_gamma = diag(exp(+i*m_*-alpha));
a_tmp = a_k_(1+nl*(nl+1) + (-nl:+nl));
a_tmp = reshape(a_tmp,2*nl+1,1);
b_tmp = b_k_(1+nl*(nl+1) + (-nl:+nl));
b_tmp = reshape(b_tmp,2*nl+1,1);
X_tmp = X_tmp + k_val^2 * (ctranspose(a_tmp)*W_gamma*W_{1+nl}*W_alpha*b_tmp);
end;%for nl = 0:n_l;
end;%for nk = 1:n_k;
X_slow_(nalpha,ngamma,nbeta) = X_tmp;
end;%for ngamma = 1:n_m_max;
end;%for nalpha = 1:n_m_max;
end;%for nbeta = n_beta;
