function ...
a_UCTF_UX_Y_ync__ = ...
qbp_pm_0( ...
 quad_k_eq_d ...
,pm_n_k_p_r ...
,pm_k_p_r_ ...
,pm_l_max_ ...
,pm_n_w_ ...
,n_M ...
,UX_M_k_p_wnM__ ...
,n_CTF_rank ...
,VSCTF_Mc__ ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_delta_x_ ...
,image_delta_y_ ...
,image_I_value_...
);
%%%%%%%%;
% Applies quadrature-based back-propagation to solve for a_UX_Y_. ;
% Associates CTF_k_p_r__(:,1+CTF_index_(1+nM)) with image M_k_p__(:,1+nM);
% ;
% Input: ;
% quad_k_eq_d: real equatorial distance used for determining quadrature nodes on sphere (radius assumed to be 1). ;
% pm_n_UX_rank = pm_n_k_p_r: integer number of principal-volume shells retained. ;
% (unused) pm_k_p_r_: real array of size pm_n_k_p_r. k-values for each principal-volume shell (assumed to be all ones). ;
% pm_l_max_: integer array of size pm_n_k_p_r. pm_l_max_(1+pm_nk_p_r) is the order used for a_UCTF_UX_Y_ync__ on principal-volume-shell pm_nk_p_r. ;
% pm_n_w_: integer array of size pm_n_k_p_r. pm_n_w_(1+pm_nk_p_r) is the number of inplane_gamma_z values recorded at that principal-image-ring. ;
% n_M: integer number of images. ;
% UX_M_k_p_wnM__: complex array of size (pm_n_w_sum,n_M). stack of principal-images in k_p_ format. ;
% We assume that each column of UX_M_k_p_wnM__ corresponds to a single principal-image, which is itself a stack of principal-image-rings. ;
% n_CTF_rank: integer number of CTF ranks to consider. ;
% (implicit) UCTF_kc__: real array of size (n_k_p_r,n_CTF_rank). ;
% VSCTF_Mc__: real array of size (n_M,n_CTF_rank). ;
% We assume that the full (isotropic) CTF-function CTF_k_p_r__, given by: ;
% (implicit) CTF_k_p_r__: real array of size (n_k_p_r,n_M). ;
% can be approximated via: ;
% CTF_k_p_r__ = UCTF_kc__*transpose(VSCTF_Mc__);
% which is a low-rank approximation with n_CTF_rank terms. ;
% If n_CTF_rank<=0 or VSCTF_Mc__ is empty, we assume that: ;
% n_CTF_rank=1; UCTF_kc__ = ones(pm_n_k_p_r,1); VSCTF_Mc__ = ones(n_M,1);
% euler_polar_a_: real array of size n_M. polar_a used for each image ;
% euler_azimu_b_: real array of size n_M. azimu_b used for each image ;
% euler_gamma_z_: real array of size n_M. gamma_z used for each image ;
% (unused) image_delta_x_: real array of size n_M. delta_x used for each image ;
% (unused) image_delta_y_: real array of size n_M. delta_y used for each image ;
% image_I_value_: real array of size n_M. I_value used for each image ;
% ;
% Output: ;
% a_UCTF_UX_Y_ync__: complex array of size (pm_n_lm_sum,n_UCTF_rank). output functions in k_Y_ format. ;
% This output function should approximately satisfy the least-square problem: ;
% \sum_{nCTF_rank=0}^{n_CTF_rank-1} S * [ \tau_{1+nM} * VSCTF_Mc__(1+nM,1+nCTF_rank) ] * a_UCTF_UX_Y_ync___(:,1+pm_nUX_rank,1+nCTF_rank) = [ UX_M_k_p_wnM___(:,1+pm_nUX_rank,1+nM) ] \forall nM \in [0,\ldots,n_M-1] and \forall pm_nUX_rank \in [0,pm_n_UX_rank-1]. ;
% where : ;
% \tau_{1+nM} corresponds to rotation by the viewing-angle associated with image nM, and ;
% S is the template-operator (i.e., equatorial-evaluation), and ;
% UX_M_k_p_wnM___(:,1+pm_nUX_rank,1+nM) = UX_M_k_p_wnM__(1+pm_n_w_csum_(1+pm_nUX_rank) + (0:pm_n_w_(1+pm_nUX_rank)-1),1+nM), and ;
% a_UCTF_UX_Y_ync___(:,1+pm_nUX_rank,1+nCTF_rank) = \sum_{nk_p_r=0}^{n_k_p_r} UCTF_(1+nk_p_r,1+nCTF_rank) * UX_(1+nk_p_r,1+pm_nUX_rank) * a_UX_Y__(:,1+nk_p_r). ;
% ;
% Rather than using least-squares to solve this problem, we instead generate a quadrature-grid on the sphere, ;
% map each data-point to its closest quadrature-gridpoint, and then numerically integrate to recover a_UCTF_UX_Y_ync__. ;
% We solve for the dominant CTF-modes of a first, then use an approximate residual to solve for the second (and subsequent) CTF-modes. ;
% This approximate residual is obtained simply by evaluating a_ at the quadrature-grid, and comparing the result to the aggregated data-points. ;
%%%%%%%%;

if (nargin<1);
disp(sprintf(' %% [testing qbp_pm_0]'));
n_CTF_rank = 1;
pm_n_UX_rank = 3;
pm_l_max = 32; pm_l_max_ = pm_l_max*ones(pm_n_UX_rank,1);
pm_n_lm = (1+pm_l_max)^2; pm_n_lm_ = pm_n_lm*ones(pm_n_UX_rank,1); pm_n_lm_sum = sum(pm_n_lm_);
pm_n_w = 160*2; pm_n_w_ = pm_n_w*ones(pm_n_UX_rank,1);
pm_k_p_r_ = ones(pm_n_UX_rank,1); pm_k_p_r_max = 1; pm_weight_k_p_r_ = ones(pm_n_UX_rank,1);
quad_k_eq_d = 1/(2*pi)/2;
%%%%%%%%;
rng(1);
a_true_k_Y_ = crandn(pm_n_lm_sum,1);
[ ...
 S_k_p_wnS__ ...
,pm_n_w_ ...
,~ ...
,~ ...
,n_S ...
,viewing_azimu_b_all_ ...
,viewing_polar_a_all_ ...
,viewing_weight_all_ ...
] = ...
get_template_1( ...
 0 ...
,pm_n_UX_rank ...
,pm_k_p_r_ ...
,pm_k_p_r_max ...
,pm_weight_k_p_r_ ...
,pm_l_max_ ...
,a_true_k_Y_ ...
,quad_k_eq_d ...
,-1 ...
,pm_n_w_ ...
);
%%%%%%%%;
CTF_S_ = 0.5 + 0.5*rand(n_S,1);
S_k_p_wnS__ = S_k_p_wnS__*diag(CTF_S_);
%%%%%%%%;
tmp_t = tic();
a_0qbp_k_Y_ = ...
qbp_pm_0( ...
 quad_k_eq_d ...
,pm_n_UX_rank ...
,pm_k_p_r_ ...
,pm_l_max_ ...
,pm_n_w_ ...
,n_S ...
,S_k_p_wnS__ ...
,1 ...
,CTF_S_ ...
,viewing_polar_a_all_ ...
,viewing_azimu_b_all_ ...
,zeros(n_S,1) ...
,zeros(n_S,1) ...
,zeros(n_S,1) ...
,ones(n_S,1)...
);
tmp_t = toc(tmp_t); disp(sprintf(' %% pm_l_max %d, n_S: %d, quad_k_eq_d %0.3f, qbp_pm_0: %0.3fs',pm_l_max,n_S,quad_k_eq_d,tmp_t));
%%%%%%%%;
figure(1);clf;set(gcf,'Position',1+[0,0,1024,768]);
subplot(1,2,1);plot(real(a_true_k_Y_),real(a_0qbp_k_Y_),'.',[-2,+2],[-2,+2],'k-'); xlabel('true');ylabel('0qbp');title('real');axis(2*[-1,1,-1,1]);axis square;
subplot(1,2,2);plot(imag(a_true_k_Y_),imag(a_0qbp_k_Y_),'.',[-2,+2],[-2,+2],'k-'); xlabel('true');ylabel('0qbp');title('imag');axis(2*[-1,1,-1,1]);axis square;
%%%%%%%%;
disp(sprintf(' %% corr(a_true_k_Y_,a_0qbp_k_Y_): %0.16f',corr(a_true_k_Y_,a_0qbp_k_Y_)));
disp(sprintf(' %% a_true_k_Y_ vs a_0qbp_k_Y_: %0.16f',fnorm(a_true_k_Y_ - a_0qbp_k_Y_)/fnorm(a_true_k_Y_)));
%%%%%%%%;
disp('returning');return;
end;%if (nargin<1);

if (isempty(image_I_value_)); image_I_value_ = ones(n_M,1); end;

pm_n_UX_rank = pm_n_k_p_r;
pm_l_max_ = pm_l_max_(1:pm_n_UX_rank);
pm_n_lm_ = (1+pm_l_max_).^2;
pm_n_lm_max = max(pm_n_lm_);
pm_n_lm_sum = sum(pm_n_lm_);
pm_n_lm_csum_ = cumsum([0;pm_n_lm_]);

pm_n_w_max = max(pm_n_w_(1:pm_n_k_p_r));
pm_n_w_sum = sum(pm_n_w_(1:pm_n_k_p_r));
pm_n_w_csum_ = cumsum([0;pm_n_w_(1:pm_n_k_p_r)]);

if (n_CTF_rank<=0); n_CTF_rank = 1; VSCTF_Mc__ = ones(n_M,1); end;
if (isempty(VSCTF_Mc__)); n_CTF_rank = 1; VSCTF_Mc__ = ones(n_M,1); end;

[ ...
 quad_n_all ...
,quad_azimu_b_all_ ...
,quad_polar_a_all_ ...
,quad_weight_all_ ...
,quad_k_c_0_all_ ...
,quad_k_c_1_all_ ...
,quad_k_c_2_all_ ...
,~ ...
,~ ...
,~ ...
] = ...
sample_shell_5( ...
 1.0 ...
,quad_k_eq_d ...
,'L' ...
) ;
quad_k_c_qd__ = [ quad_k_c_0_all_ , quad_k_c_1_all_ , quad_k_c_2_all_ ];

flag_uniqe_pm_n = 0;
if (numel(unique(pm_l_max_))==1 & numel(unique(pm_n_lm_))==1 & numel(unique(pm_n_w_))==1);
flag_unique_pm_n = 1;
pm_l_max = pm_l_max_(1+0);
Ylm__ = get_Ylm__(1+pm_l_max,0:pm_l_max,quad_n_all,quad_azimu_b_all_,quad_polar_a_all_);
pm_n_lm = pm_n_lm_(1+0);
Ylm_yq__ = zeros(pm_n_lm,quad_n_all);
nml=0;
for l_val=0:pm_l_max;
for m_val=-l_val:+l_val;
Ylm_yq__(1+nml,:) = Ylm__{1+l_val}(1+l_val+m_val,:);
nml=nml+1;
end;%for m_val=-l_val:+l_val;
end;%for l_val=0:pm_l_max;
Ylm_w_yq__ = Ylm_yq__ * sparse(1:quad_n_all,1:quad_n_all,quad_weight_all_,quad_n_all,quad_n_all);
pm_n_w = pm_n_w_(1+0);
[ ...
 data_k_p_polar_a__ ...
,data_k_p_azimu_b__ ...
,data_k_c_0__ ...
,data_k_c_1__ ...
,data_k_c_2__ ...
] = ...
cg_rhs_1( ...
 n_M ...
,pm_n_w ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,+euler_gamma_z_ ...
);
data_k_c_wMd__ = [ data_k_c_0__(:) , data_k_c_1__(:) , data_k_c_2__(:) ];
index_quad_from_data_ = knnsearch(quad_k_c_qd__,data_k_c_wMd__,'K',1); index_quad_from_data_ = index_quad_from_data_ - 1;
quad_from_data_qwM__ = sparse(1+index_quad_from_data_,1:pm_n_w*n_M,1,quad_n_all,pm_n_w*n_M);
n_quad_from_data_q_ = quad_from_data_qwM__*ones(pm_n_w*n_M,1); %<-- number of data-points per quadrature-point. ;
data_from_quad_wMq__ = transpose(quad_from_data_qwM__)*sparse(1:quad_n_all,1:quad_n_all,1./max(1,n_quad_from_data_q_),quad_n_all,quad_n_all);
VSCTF_wMc__ = reshape(repmat(reshape(VSCTF_Mc__,[1,n_M,n_CTF_rank]),[pm_n_w,1,1]),[pm_n_w*n_M,n_CTF_rank]);
VSCTF2_qc__ = quad_from_data_qwM__*abs(VSCTF_wMc__).^2;
end;%if (numel(unique(pm_l_max_))==1 & numel(unique(pm_n_lm_))==1 & numel(unique(pm_n_w_))==1);

if (~flag_unique_pm_n);
disp(sprintf(' %% Warning, consider setting all values of pm_l_max, pm_n_lm and pm_n_w to be the same in cg_lsq_pm_1.'));
end;%if (~flag_unique_pm_n);

a_UCTF_UX_Y_ync__ = zeros(pm_n_lm_sum,n_CTF_rank);
for pm_nk_p_r=0:pm_n_k_p_r-1;
if (~flag_unique_pm_n);
error('Error: non-unique values of pm_l_max, pm_n_lm or pm_n_w in qbp_pm_0');
end;%if (~flag_unique_pm_n);
index_Y_ = pm_n_lm_csum_(1+pm_nk_p_r) + (0:pm_n_lm-1);
index_pm_nw = pm_n_w_csum_(1+pm_nk_p_r) + (0:pm_n_w-1);
UX_M_I_wM__ = UX_M_k_p_wnM__(1+index_pm_nw,:)*sparse(1:n_M,1:n_M,image_I_value_,n_M,n_M);
for nCTF_rank=0:n_CTF_rank-1;
UX_M_I_VSCTF_wM__ = UX_M_I_wM__*sparse(1:n_M,1:n_M,VSCTF_Mc__(:,1+nCTF_rank),n_M,n_M);
quad_from_data_UX_M_I_VSCTF_normalized_q_ = (quad_from_data_qwM__ * UX_M_I_VSCTF_wM__(:))./max(1e-12,VSCTF2_qc__(:,1+nCTF_rank));
a_UCTF_UX_Y_ync__(1+index_Y_,1+nCTF_rank) = conj(Ylm_w_yq__)*quad_from_data_UX_M_I_VSCTF_normalized_q_;
UX_M_I_wM__ = UX_M_I_wM__ - reshape(data_from_quad_wMq__*(transpose(Ylm_yq__)*a_UCTF_UX_Y_ync__(1+index_Y_,1+nCTF_rank)),[pm_n_w,n_M])*sparse(1:n_M,1:n_M,VSCTF_Mc__(:,1+nCTF_rank),n_M,n_M); %<-- replace with approximate residual. ;
end;%for nCTF_rank=0:n_CTF_rank-1;
end;%for pm_nk_p_r=0:pm_n_k_p_r-1;
  

  
