function [QLS] = prepare_quadrature_approximation_to_cg_lsq_3(n_k_p_r,l_max_,n_w_);
%%%%%%%%;
% approximates the least-squares problem to solve for a_k_Y_ using simple low-order quadrature. ;
% Associates CTF_k_p__(:,CTF_index_(1+nM)) with image M_k_p__(:,1+nM);
% ;
% Input: ;
% n_k_p_r: integer number of shells. ;
% l_max_: integer array of size n_k_p_r. l_max_(1+nk_p_r) is the order used for a_k_Y_ on shell nk_p_r. ;
% n_w_: integer array of size n_k_p_r. n_w_(1+nk_p_r) is the number of inplane_gamma_z values recorded at that ring. ;
% ;
% Output: ;
% structure 'QLS' with the following fields:
% n_polar_a_: cell array of length n_k_p_r. n_polar_a_{1+nk_p_r} is the number of polar_a on shell nk_p_r. ;
% n_azimu_b__: cell array of length n_k_p_r. n_azimu_b__{1+nk_p_r}(1+npolar_a) lists the number of azimu_b for shell nk_p_r and polar_a_(1+npolar_a). ;
% n_grid_: cell array of length n_k_p_r. n_grid_{1+nk_p_r} = n_azimu_b_sum = sum(n_azimu_b__{1+nk_p_r}). ;
% polar_a_grid__: cell array of length n_k_p_r. polar_a_grid__{1+nk_p_r}(1+ngrid) = polar_a for point on shell nk_p_r. ;
% azimu_b_grid__: cell array of length n_k_p_r. azimu_b_grid__{1+nk_p_r}(1+ngrid) = azimu_b for point on shell nk_p_r. ;
% k_c_0_grid__: cell array of length n_k_p_r. k_c_0_grid__{1+nk_p_r}(1+ngrid) = k_c_0 for point on shell nk_p_r. ;
% k_c_1_grid__: cell array of length n_k_p_r. k_c_1_grid__{1+nk_p_r}(1+ngrid) = k_c_1 for point on shell nk_p_r. ;
% k_c_2_grid__: cell array of length n_k_p_r. k_c_2_grid__{1+nk_p_r}(1+ngrid) = k_c_2 for point on shell nk_p_r. ;
% weight_grid__: cell array of length n_k_p_r. weight_grid__{1+nk_p_r}(1+ngrid) = weight for point on shell nk_p_r. ;
% legendre_evaluate_jlm____: cell array of length n_k_p_r. legendre_evaluate_jlm____{1+nk_p_r}(1+ngrid,1+l_val,1+abs(m_val)) = normalized associated legendre polynomial of order l and degree m evaluated at cos(polar_a_grid__{1+nk_p_r}(1+ngrid)). ;
% expil__: cell array of length n_k_p_r. expil__{1+nk_p_r}(1+ngrid) = exp(+i*azimu_b_grid__{1+nk_p_r}(1+ngrid)*(-l_max_(1+nk_p_r))). ;
% expi__: cell array of length n_k_p_r. expi__{1+nk_p_r}(1+ngrid) = exp(+i*azimu_b_grid__{1+nk_p_r}(1+ngrid)). ;
%%%%%%%%;

QLS = struct('type','QLS');
QLS.n_polar_a_ = cell(n_k_p_r,1);
QLS.n_azimu_b__ = cell(n_k_p_r,1);
QLS.polar_a_grid__ = cell(n_k_p_r,1);
QLS.azimu_b_grid__ = cell(n_k_p_r,1);
QLS.k_c_0_grid__ = cell(n_k_p_r,1);
QLS.k_c_1_grid__ = cell(n_k_p_r,1);
QLS.k_c_2_grid__ = cell(n_k_p_r,1);
QLS.weight_grid__ = cell(n_k_p_r,1);
QLS.legendre_evaluate_jlm____ = cell(n_k_p_r,1);
QLS.expil__ = cell(n_k_p_r,1);
QLS.expi__ = cell(n_k_p_r,1);

n_lm_ = (1+l_max_).^2;
n_lm_max = max(n_lm_);
n_lm_sum = sum(n_lm_);
n_lm_csum_ = cumsum([0;n_lm_]);

n_w_max = max(n_w_);
n_w_sum = sum(n_w_);
n_w_csum_ = cumsum([0;n_w_]);

for nk_p_r=0:n_k_p_r-1;
%%%%%%%%;
l_max = l_max_(1+nk_p_r);
tmp_Y_ij_ = n_lm_csum_(1+nk_p_r) + (0:n_lm_(1+nk_p_r)-1);
n_w = n_w_(1+nk_p_r);
tmp_M_ij_ = n_w_csum_(1+nk_p_r) + (0:n_w_(1+nk_p_r)-1);
%%%%%%%%;
% determine n_polar_a and n_azimu_b_ based on n_w. ;
%%%%%%%%;
n_polar_a = ceil(n_w/2); if (mod(n_polar_a,2)==0); n_polar_a = n_polar_a+1; end; %<-- ensure odd n_polar_a for simpson rule. ;
polar_a_ = transpose(linspace(0,pi,n_polar_a)); 
weight_polar_a_ = sin(polar_a_)*pi/(n_polar_a-1); 
weight_polar_a_(2:2:end) = weight_polar_a_(2:2:end)*4/3; weight_polar_a_(1:2:end) = weight_polar_a_(1:2:end)*2/3; %<-- simpson rule. ;
n_azimu_b_max = 2*n_polar_a;
n_azimu_b_ = zeros(n_polar_a,1);
for npolar_a=0:n_polar_a-1;
polar_a = polar_a_(1+npolar_a);
n_azimu_b_(1+npolar_a) = ceil(n_azimu_b_max*sin(polar_a));
end;%for npolar_a=0:n_polar_a-1;
n_azimu_b_sum = sum(n_azimu_b_);
polar_a_grid_ = zeros(n_azimu_b_sum,1);
azimu_b_grid_ = zeros(n_azimu_b_sum,1);
weight_grid_ = zeros(n_azimu_b_sum,1);
na=0;
for npolar_a=0:n_polar_a-1;
polar_a = polar_a_(1+npolar_a);
weight_polar_a = weight_polar_a_(1+npolar_a);
n_azimu_b = n_azimu_b_(1+npolar_a);
for nazimu_b=0:n_azimu_b-1;
azimu_b = 2*pi*nazimu_b/n_azimu_b;
azimu_b_grid_(1+na) = azimu_b;
polar_a_grid_(1+na) = polar_a;
weight_grid_(1+na) = weight_polar_a*2*pi/n_azimu_b;
na=na+1;
end;%for nazimu_b=0:n_azimu_b-1;
end;%for npolar_a=0:n_polar_a-1;
assert(na==n_azimu_b_sum);
k_c_0_grid_ = sin(polar_a_grid_).*cos(azimu_b_grid_);
k_c_1_grid_ = sin(polar_a_grid_).*sin(azimu_b_grid_);
k_c_2_grid_ = cos(polar_a_grid_);
%%%%%%%%;
% Now evaluate spherical harmonics on simple quadrature grid. ;
%%%%%%%%;
legendre_evaluate_jlm___ = ylgndr_0(l_max,cos(polar_a_grid_))/sqrt(4*pi);
expi_ = exp(i*azimu_b_grid_);
expil_ = expi_.^(-l_max);
%%%%%%%%;
% Now fill in structure. ;
%%%%%%%%;
QLS.n_polar_a_{1+nk_p_r} = n_polar_a;
QLS.n_azimu_b__{1+nk_p_r} = n_azimu_b_;
QLS.n_grid_{1+nk_p_r} = n_azimu_b_sum;
QLS.polar_a_grid__{1+nk_p_r} = polar_a_grid_;
QLS.azimu_b_grid__{1+nk_p_r} = azimu_b_grid_;
QLS.k_c_0_grid__{1+nk_p_r} = k_c_0_grid_;
QLS.k_c_1_grid__{1+nk_p_r} = k_c_1_grid_;
QLS.k_c_2_grid__{1+nk_p_r} = k_c_2_grid_;
QLS.weight_grid__{1+nk_p_r} = weight_grid_;
QLS.legendre_evaluate_jlm____{1+nk_p_r} = legendre_evaluate_jlm___;
QLS.expil__{1+nk_p_r} = expil_;
QLS.expi__{1+nk_p_r} = expi_;
%%%%%%%%;
end;%for nk_p_r=0:n_k_p_r-1;

