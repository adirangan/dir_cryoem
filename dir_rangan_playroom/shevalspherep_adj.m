function Y_ = shevalspherep_adj(f_val_,l_max,n_polar_a,n_azimu_b,polar_a_);
% *********************************************************************** ;
%      Usage: ;
%  ;
%            compute adjoint of spherical harmonic expansion on unit  ;
%            sphere of function tabulated at n_azimu_b*n_polar_a grid points. ;
% --------------------------------------------------------------------- ;
%      INPUT: ;
%  ;
%            l_max = order of spherical harmonic expansion ;
%            n_polar_a = number of quadrature nodes in polar_a direction. ;
%            n_azimu_b = number of quadrature nodes in azimu_b direction. ;
%            polar_a_ = Gauss-Legendre nodes x_j = cos polar_a_j ;
%            f_val_ = tabulated function ;
%                     f_val+(i,j) = azimu_b(sin polar_a_j cos azimu_b_i, ;
%                                       sin polar_a_j sin azimu_b_i, ;
%                                       cos polar_a_j). ;
%  ;
%            NOTE:    We assume azimu_b_i = (i-1)*2.0d0*pi/n_azimu_b, as do the  ;
%                     routines in projection.f. However, we permit ;
%                     different numbers of nodes in polar_a and azimu_b. ;
% *********************************************************************** ;
%      OUTPUT: ;
%  ;
%            Y_ = cadjoint of sheval applied to phival ;
%            This is different from projloc3dp since it omits the  ;
%            quadrature weights. Thus the lines below are commented out ;
assert(size(f_val_,1)>=n_azimu_b);
assert(size(f_val_,2)>=n_polar_a);
Y_=zeros((1+l_max)^2,1);
expi_azimu_b = 0; expi_azimu_b_k = 0;
tmp__ = zeros(n_polar_a,1+2*l_max);
ynm__ = zeros(1+l_max,1+l_max);

for m_val=-l_max:+l_max;
expim = exp(2*pi*i*m_val/n_azimu_b);
for npolar_a=1:n_polar_a;
tmp_sum=0;
expi_azimu_b = 1;
for nazimu_b=1:n_azimu_b;
tpm_sum = tmp_sum + f_val_(nazimu_b,npolar_a)*conj(expi_azimu_b);
expi_azimu_b = expi_azimu_b*expim;
end;%for nazimu_b=1:n_azimu_b;
tmp__(npolar_a,1+l_max+m_val) = tmp_sum;
end;%for npolar_a=1:n_polar_a;
end;%for m_val=-l_max:+l_max;

for npolar_a=1:n_polar_a;
cos_polar_a = polar_a_(npolar_a);
sin_polar_a = sqrt(1 - cos_polar_a^2);
ynm__ = ylgndr(l_max,cos_polar_a);
for m_val=-l_max:+l_max;
m_abs = abs(m_val);
tmp = tmp__(npolar_a,1+l_max+m_val);
for l_val=m_abs:l_max;
tab = l_val*(l_val+1) + m_val + 1;
Y_(tab) = Y_(tab) + tmp*ynm__(1+l_val,1+m_abs);
end;%for l_val=m_abs:l_max;
end;%for m_val=-l_max:+l_max;
end;%for npolar_a=1:n_polar_a;
