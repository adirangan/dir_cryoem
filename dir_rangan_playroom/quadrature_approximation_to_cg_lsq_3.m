function a_k_Y_ = quadrature_approximation_to_cg_lsq_3(n_k_p_r,l_max_,n_w_,n_M,M_k_p__,CTF_index_,CTF_k_p__,euler_polar_a_,euler_azimu_b_,euler_gamma_z_,QLS);
%%%%%%%%;
% approximates the least-squares problem to solve for a_k_Y_ using simple low-order quadrature. ;
% Associates CTF_k_p__(:,1+CTF_index_(1+nM)) with image M_k_p__(:,1+nM);
% ;
% Input: ;
% n_k_p_r: integer number of shells. ;
% l_max_: integer array of size n_k_p_r. l_max_(1+nk_p_r) is the order used for a_k_Y_ on shell nk_p_r. ;
% n_w_: integer array of size n_k_p_r. n_w_(1+nk_p_r) is the number of inplane_gamma_z values recorded at that ring. ;
% n_M: integer number of images. ;
% M_k_p__: complex array of size (n_w_sum,n_M). stack of images in k_p_ format. ;
% CTF_index_: integer array of size n_M. CTF_index_(1+nM) is the (0-based) CTF_index used for image M_k_p__(:,1+nM). ;
%             This can be empty or set to 1, in which case the same CTF_k_p_ will be used for each image. ;
% CTF_k_p__: real array of size(n_w_sum,n_CTF). stack of ctf-functions in k_p_ format. ;
%            If CTF_index_ is empty or set to 1, then we assume this contains only a single CTF_k_p_, ;
%            which will then be used for all images. ;
%            Note that we assume the CTF_k_p_ is real. ;
% euler_polar_a_: real array of size n_M. initial polar_a used for each image (randomized if empty). ;
% euler_azimu_b_: real array of size n_M. initial azimu_b used for each image (randomized if empty). ;
% euler_gamma_z_: real array of size n_M. initial gamma_z used for each image (randomized if empty). ;
% QLS: a structure prepared with 'prepare_quadrature_approximation_to_cg_lsq_3.m'. ;
% ;
% Output: ;
% a_k_Y_: complex array of size n_lm_sum. output functions in k_Y_ format. ;
%%%%%%%%;

n_polar_a_ = [];
n_azimu_b__ = [];
legendre_evaluate_jlm____=[];
expil__=[];
expi__=[];

n_lm_ = (1+l_max_).^2;
n_lm_max = max(n_lm_);
n_lm_sum = sum(n_lm_);
n_lm_csum_ = cumsum([0;n_lm_]);

n_w_max = max(n_w_);
n_w_sum = sum(n_w_);
n_w_csum_ = cumsum([0;n_w_]);

if isempty(CTF_k_p__); CTF_index_ = 1; CTF_k_p__ = ones(n_w_sum,1); end;

a_k_Y_ = zeros(n_lm_sum,1);
for nk_p_r=0:n_k_p_r-1;
%%%%%%%%;
l_max = l_max_(1+nk_p_r);
tmp_Y_ij_ = n_lm_csum_(1+nk_p_r) + (0:n_lm_(1+nk_p_r)-1);
n_w = n_w_(1+nk_p_r);
tmp_M_ij_ = n_w_csum_(1+nk_p_r) + (0:n_w_(1+nk_p_r)-1);
tmp_M_k_p_ = reshape(M_k_p__(1+tmp_M_ij_,:),[n_w*n_M,1]);
if (isempty(CTF_index_) | numel(CTF_index_)==1);
tmp_CTF_k_p_ = real(reshape(repmat(CTF_k_p__(1+tmp_M_ij_),[1,n_M]),[n_w*n_M,1]));
 else;
tmp_CTF_k_p_ = real(reshape(CTF_k_p__(1+tmp_M_ij_,1+CTF_index_(1:n_M)),[n_w*n_M,1]));
end;%if (isempty(CTF_index_) | numel(CTF_index_)==1);
[k_p_polar_a_scat__,k_p_azimu_b_scat__] = cg_rhs_1(n_M,n_w,euler_polar_a_,euler_azimu_b_,+euler_gamma_z_);
k_c_0_scat__ = sin(k_p_polar_a_scat__).*cos(k_p_azimu_b_scat__);
k_c_1_scat__ = sin(k_p_polar_a_scat__).*sin(k_p_azimu_b_scat__);
k_c_2_scat__ = cos(k_p_polar_a_scat__);
n_scat = n_w*n_M;
%%%%%%%%;
% Now find nearest neighbors. ;
%%%%%%%%;
n_grid = QLS.n_grid_{1+nk_p_r};
%index_scat_to_grid__ = sparse(knnsearch([QLS.k_c_0_grid__{1+nk_p_r}(:),QLS.k_c_1_grid__{1+nk_p_r}(:),QLS.k_c_2_grid__{1+nk_p_r}(:)],[k_c_0_scat__(:),k_c_1_scat__(:),k_c_2_scat__(:)]),1:n_scat,1,n_grid,n_scat); %<-- slow to access. ;
index_grid_to_scat__ = sparse(1:n_scat,knnsearch([QLS.k_c_0_grid__{1+nk_p_r}(:),QLS.k_c_1_grid__{1+nk_p_r}(:),QLS.k_c_2_grid__{1+nk_p_r}(:)],[k_c_0_scat__(:),k_c_1_scat__(:),k_c_2_scat__(:)]),1,n_scat,n_grid); %<-- fast to access. ;
%%%%%%%%;
% Now build the right-hand-side. ;
% The essential idea here is that, for each 'on grid' point x, ;
% there may be J scattered points a_{0},...,a_{J-1} which correspond to it. ;
% These J points have J ctf-values c_{0},...,c_{J-1}. ;
% The x we choose represents the value of the spherical harmonic-expansion before multiplication by CTF, ;
% and can be calculated via: ;
% x = argmin_{x} \frac{1}{2} \sum_{j} (c_{j}*x - a_{j})^2. ; %<-- here we assume that x, a_{j} and c_{j} are all real. ;
% Which is minimized by: ;
% x = (\sum_{j} c_{j}a_{j}) / (\sum_{j} c_{j}^2) ;
%%%%%%%%;
rhs_ = zeros(n_grid,1);
for ngrid=0:n_grid-1;
%tmp_ij_ = find(index_scat_to_grid__(1+ngrid,:))-1; %<-- much slower. ;
tmp_ij_ = find(index_grid_to_scat__(:,1+ngrid))-1; %<-- much faster. ;
if numel(tmp_ij_)>0;
rhs_(1+ngrid) = sum(tmp_CTF_k_p_(1+tmp_ij_).*tmp_M_k_p_(1+tmp_ij_))/(1e-9 + sum(tmp_CTF_k_p_(1+tmp_ij_).^2)); %<-- bound the denominator. ;
end%if numel(tmp_ij_)>0;
end;%for ngrid=0:n_grid-1;
%%%%%%%%;
% Now conduct quadrature. ;
%%%%%%%%;
tmp_a_k_Y_ = zeros(n_lm_(1+nk_p_r),1);
na=0;
for l_val=0:l_max;
expim_ = QLS.expil__{1+nk_p_r}.*(QLS.expi__{1+nk_p_r}.^(l_max-l_val));
for m_val=-l_val:+l_val;
tmp_a_k_Y_(1+na) = sum(QLS.weight_grid__{1+nk_p_r}(:).*rhs_(:).*conj(QLS.legendre_evaluate_jlm____{1+nk_p_r}(:,1+l_val,1+abs(m_val)).*expim_(:)));
expim_ = expim_.*QLS.expi__{1+nk_p_r}; %<-- at this point expim_(1+ngrid) should be exp(+i*azimu_b_grid_(1+ngrid)*m_val). ;
na=na+1;
end;%for m_val=-l_val:+l_val;
end;%for l_val=0:l_max;
assert(na==n_lm_(1+nk_p_r));
a_k_Y_(1+tmp_Y_ij_) = tmp_a_k_Y_;
%%%%%%%%;
end;%for nk_p_r=0:n_k_p_r-1;

