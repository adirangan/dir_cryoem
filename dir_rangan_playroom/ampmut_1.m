function ...
[X_best_ ...
,a_CTF_UX_Y_0lsq__ ...
,euler_polar_a__ ...
,euler_azimu_b__ ...
,euler_gamma_z__ ...
,image_delta_x__ ...
,image_delta_y__ ...
,image_I_value__ ...
,image_X_value__ ...
,image_S_index__ ...
] = ...
ampmut_1( ...
 rseed ...
,n_iteration ...
,n_iteration_register ...
,viewing_k_eq_d ...
,n_order ...
,n_k_p_r ...
,k_p_r_ ...
,k_p_r_max ...
,weight_3d_k_p_r_ ...
,weight_2d_k_p_r_ ...
,delta_r_max ...
,delta_r_upb ...
,svd_eps ...
,n_delta_v_requested ...
,FTK ...
,n_w_ ...
,pm_n_UX_rank ...
,UX__ ...
,X_weight_r_ ...
,n_M ...
,M_k_p__ ...
,n_CTF_rank ...
,CTF_index_ ...
,CTF_k_p_r__ ...
,l_max_ ...
,a_CTF_UX_Y_true_ ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_delta_x_ ...
,image_delta_y_ ...
,image_I_value_ ...
,flag_MS_vs_SM ...
,f_rand ...
,order_limit_MS ...
);
%%%%%%%%;
% simple alternating minimization using principal modes. ;
% displacements drawn from disc of radius delta_r_max. ;
% updates displacements (i.e., updates translations) each iteration. ;
% uses a low-rank approximation of the ctf-function for each image. ;
% ;
% Input: ;
% rseed: integer random seed. ;
% n_iteration: integer number of iterations for alternating minimization. ;
% n_iteration_register: integer number of iterations to wait before registering result against a_k_Y_true_. ;
% viewing_k_eq_d: real equatorial distance for building viewing angles (i.e., each viewing angle is associated with a principal-template). ;
% n_order: integer polynomial interpolation order used for conjugate-gradient interpolation operator. ;
% n_k_p_r: integer number of shells. ;
% k_p_r_: real array of size n_k_p_r. k_p_r for each shell. ;
% k_p_r_max: real maximum radius (of sphere) to be integrated. ;
% weight_3d_k_p_r_: real array of size n_k_p_r. radial quadrature weighting for sphere. ;
% weight_2d_k_p_r_: real array of size n_k_p_r. radial quadrature weighting for disk. ;
% delta_r_max: real number maximum displacement used for FTK. ;
% delta_r_upb: real number maximum displacement used to bound accumulated translation. ;
% svd_eps: real number FTK svd error. ;
% n_delta_v_requested: integer number of displacements requested (actual number of displacements will be stored in FTK.n_delta_v). ;
% FTK: structure produced by ampmh_FTK_1.m ;
% n_w_: integer array of size n_k_p_r. n_w_max = max(n_w_) is the number of inplane_gamma_z values recorded at that ring. ;
% pm_n_UX_rank: integer number of principal-modes used in UX__. ;
% UX__: real array of size (n_w_max,pm_n_UX_rank). principal-mode right-singular-vectors. ;
% X_weight_r_: real array of size n_w_max. variance scaling (weight) for different principle-image rings. ;
% n_M: integer number of images. ;
% M_k_p__: complex array of size (n_w_sum,n_M). stack of images in k_p_ format. ;
% n_CTF_rank: integer number of ranks to use in CTF_k_p_r__ approximation. ;
% CTF_index_: integer array of size n_M. CTF_index_(1+nM) is the CTF_index used for image M_k_p__(:,1+nM). ;
% CTF_k_p_r__: complex array of size(n_k_p_r,n_CTF). stack of ctf-functions in k_p_r_ format. ;
% l_max_: integer array of size n_k_p_r. l_max_(1+nk_p_r) is the order used for a_CTF_UX_Y_0lsq_ for each principal mode. ;
% a_CTF_UX_Y_true_: complex array of size pm_n_lm_sum = sum((1+l_max_).^2). The 'ground-truth' to which a_CTF_UX_Y_0lsq_ is compared. ;
% euler_polar_a_: real array of size n_M. initial polar_a used for each image (randomized if empty). ;
% euler_azimu_b_: real array of size n_M. initial azimu_b used for each image (randomized if empty). ;
% euler_gamma_z_: real array of size n_M. initial gamma_z used for each image (randomized if empty). ;
% image_delta_x_: real array of size n_M. initial delta_x used for each image (zero if empty). ;
% image_delta_y_: real array of size n_M. initial delta_y used for each image (zero if empty). ;
% image_I_value_: real array of size n_M. initial I_value used for each image (one if empty). ;
% flag_MS_vs_SM: integer 0 or 1. ;
%                if set to 1 will enforce uniform distribution of viewing angles. ;
%                if set to 0 will match templates to images. ;
%                default 1. ;
% f_rand: real number. fraction of best templates to select from when matching templates to images. ;
%         default 0.15. ;
% order_limit_MS: integer greater or equal to 0. This is the order to which the MS-phase 0lsq is limited during the first half of the iterations. ;
%         default -1. (i.e., not used). ;
% ;
% Output: ;
% X_best_: real array of size n_iteration. correlation with a_k_Y_true_ at every n_iteration_register iterations. ;
% a_CTF_UX_Y_0lsq__: complex array of size (pm_n_lm_sum,n_iteration). stack of output functions in k_Y_ format. ;
% euler_polar_a__: real array of size (n_M,n_iteration). list of polar_a used for each image at each iteration. ;
% euler_azimu_b__: real array of size (n_M,n_iteration). list of azimu_b used for each image at each iteration. ;
% euler_gamma_z__: real array of size (n_M,n_iteration). list of gamma_z used for each image at each iteration. ;
% image_delta_x__: real array of size (n_M,n_iteration). list of delta_x used for each image at each iteration. ;
% image_delta_y__: real array of size (n_M,n_iteration). list of delta_y used for each image at each iteration. ;
% image_I_value__: real array of size (n_M,n_iteration). list of I_value (i.e., image intensity) used for each image at each iteration. ;
% image_X_value__: real array of size (n_M,n_iteration). list of X_S (i.e., template-image correlation) used for each image at each iteration. ;
% image_S_index__: real array of size (n_M,n_iteration). list of S_index (i.e., template index) used for each image at each iteration. ;
%%%%%%%%;

verbose=2;
if nargin<33; flag_MS_vs_SM = []; end;
if nargin<34; f_rand = []; end;
if nargin<35; order_limit_MS = []; end;
if isempty(flag_MS_vs_SM); flag_MS_vs_SM=1; end;
if isempty(f_rand); f_rand = 0.15; end;
if isempty(order_limit_MS); order_limit_MS = -1; end;
if flag_MS_vs_SM==1; str_MS_vs_SM = 'MS'; end;
if flag_MS_vs_SM==0; str_MS_vs_SM = 'SM'; end;

rng(rseed);

l_max_max = max(l_max_);
n_lm_ = (1+l_max_).^2;
n_lm_sum = sum(n_lm_);
n_lm_csum_ = cumsum([0;n_lm_]);
n_w_max = max(n_w_);
n_w_sum = sum(n_w_);
n_w_csum_ = cumsum([0;n_w_]);

pm_n_order = n_order;
pm_n_k_p_r = pm_n_UX_rank;
pm_k_p_r_ = ones(pm_n_k_p_r,1);
pm_k_p_r_max = 1;
pm_n_w_ = n_w_max*ones(pm_n_k_p_r,1);
pm_n_w_max = n_w_max;
pm_n_w_sum = sum(pm_n_w_);
pm_n_w_csum_ = cumsum([0;pm_n_w_]);
pm_l_max_ = l_max_max*ones(pm_n_k_p_r,1);
pm_n_lm_ = (1+pm_l_max_).^2; pm_n_lm_sum = sum(pm_n_lm_);
pm_weight_k_p_r_ = ones(pm_n_k_p_r,1);
pm_weight_2d_k_p_r_ = ones(pm_n_k_p_r,1);

Y_lm_cut_ = ones(pm_n_lm_sum,1);
if (order_limit_MS>-1);
Y_l_val_ = zeros(pm_n_lm_sum,1);
Y_m_val_ = zeros(pm_n_lm_sum,1);
na=0;
for pm_nk_p_r=0:pm_n_k_p_r-1;
l_max = pm_l_max_(1+pm_nk_p_r);
for l_val=0:l_max;
for m_val=-l_val:+l_val;
Y_l_val_(1+na) = l_val;
Y_m_val_(1+na) = m_val;
na=na+1;
end;%for m_val=-l_val:+l_val;
end;%for l_val=0:l_max;
end;%for pm_nk_p_r=0:pm_n_k_p_r-1;
%Y_lm_cut_ = Y_l_val_+abs(Y_m_val_)<=Y_lm_cut_threshold;
Y_lm_cut_ = Y_l_val_+0*abs(Y_m_val_)<=order_limit_MS;
end;%if (order_limit_MS>-1);

if isempty(FTK);
tmp_t = tic();
FTK = ampmh_FTK_1(n_k_p_r,k_p_r_,k_p_r_max,delta_r_max,svd_eps,n_delta_v_requested);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% FTK: %0.3fs',tmp_t)); end;
end;%if isempty(FTK);

if (n_CTF_rank<=0 | isempty(CTF_index_));
n_CTF_rank = 1;
USCTF_kc__ = ones(n_k_p_r,1); SCTF_C__ = 1; VCTF_Mc__ = ones(n_M,1);
else;
[UCTF_kc__,SCTF_c__,VCTF_Mc__] = svds(CTF_k_p_r__(:,1+CTF_index_(1:n_M)),n_CTF_rank);
end;%if (n_CTF_rank<=0 | isempty(CTF_index_));
VSCTF_Mc__ = VCTF_Mc__*SCTF_c__;

X_best_ = zeros(n_iteration,1);
if (nargout>1);
euler_polar_a__ = zeros(n_M,n_iteration);
euler_azimu_b__ = zeros(n_M,n_iteration);
euler_gamma_z__ = zeros(n_M,n_iteration);
image_delta_x__ = zeros(n_M,n_iteration);
image_delta_y__ = zeros(n_M,n_iteration);
image_I_value__ = zeros(n_M,n_iteration);
image_X_value__ = zeros(n_M,n_iteration);
image_S_index__ = zeros(n_M,n_iteration);
a_CTF_UX_Y_0lsq__ = zeros(pm_n_lm_sum,n_iteration);
end;%if (nargout>1);
%%%%%%%%;
% initialize current euler-angles randomly. ;
%%%%%%%%;
if isempty(euler_polar_a_); euler_polar_a_ = 1*pi*rand(n_M,1); end;
if isempty(euler_azimu_b_); euler_azimu_b_ = 2*pi*rand(n_M,1); end;
if isempty(euler_gamma_z_); euler_gamma_z_ = 2*pi*rand(n_M,1); end;
if isempty(image_delta_x_); image_delta_x_ = zeros(n_M,1); end;
if isempty(image_delta_y_); image_delta_y_ = zeros(n_M,1); end;
image_delta_x_upd_ = zeros(n_M,1);
image_delta_y_upd_ = zeros(n_M,1);
if isempty(image_I_value_); image_I_value_ = ones(n_M,1); end;
for niteration=0:n_iteration-1;
%%%%%%%%;
% Construct M_k_q__ while taking into account the translations. ;
%%%%%%%%;
tmp_t = tic();
M_k_q__ = zeros(n_w_sum,n_M);
for nM=0:n_M-1;
M_k_p_ = ...
transf_p_to_p( ...
 n_k_p_r ...
,k_p_r_ ...
,n_w_ ...
,n_w_sum ...
,M_k_p__(:,1+nM) ...
,+image_delta_x_(1+nM) ...
,+image_delta_y_(1+nM) ...
);
M_k_q__(:,1+nM) = ...
interp_p_to_q( ...
 n_k_p_r ...
,n_w_ ...
,n_w_sum ...
,M_k_p_ ...
);
end;%for nM=0:n_M-1;
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% M_k_q__: %0.3fs',tmp_t)); end;
%%%%%%%%;
% Now form svd_VUXM_lwnM____ using these translated images. ;
%%%%%%%%;
tmp_t = tic();
svd_VUXM_lwnM____ = tpmh_VUXM_lwnM____0(FTK,n_k_p_r,n_w_,n_M,M_k_q__,pm_n_UX_rank,UX__,X_weight_r_);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% svd_VUXM_lwnM____: %0.3fs',tmp_t)); end;
%%%%%%%%;
% Now calculate norms of the translated images. ;
%%%%%%%%;
tmp_t = tic();
UX_M_l2_dM__ = ampmh_UX_M_l2_dM__1(FTK,n_w_,n_M,pm_n_UX_rank,svd_VUXM_lwnM____);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% UX_M_l2_dM__: %0.3fs',tmp_t)); end;
%%%%%%%%;
% Now, form principal-images (using the zero-displacement). ;
%%%%%%%%;
tmp_t = tic();
[UX_M_k_q_wnM___,UX_M_k_p_wnM___] = ampmh_UX_M_k_p_wnM___0(FTK,n_w_,pm_n_UX_rank,n_M,svd_VUXM_lwnM____,zeros(n_M,1),zeros(n_M,1));
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% UX_M_k_q_wnM___: %0.6fs',tmp_t)); end;
%%%%%%%%;
% use current euler-angles and displacements to solve for current model. ;
%%%%%%%%;
tmp_t = tic();
a_UCTF_UX_Y_0lsq_ync__ = ...
cg_lsq_pm_0( ...
 pm_n_order ...
,pm_n_k_p_r ...
,pm_k_p_r_ ...
,pm_l_max_ ...
,pm_n_w_ ...
,n_M ...
,reshape(UX_M_k_p_wnM___,[n_w_max*pm_n_k_p_r,n_M]) ...
,n_CTF_rank ...
,VSCTF_Mc__ ...
,euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,[] ...
,[] ...
,image_I_value_ ...
);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% cg_lsq_pm_0 for a_UCTF_UX_Y_0lsq_ync__: %0.3fs',tmp_t)); end;
%%%%%%%%;
% Now normalize a_CTF_UX_Y_0lsq_. ;
% This step is necessary to prevent the intensity from diverging over successive iterations. ;
%%%%%%%%;
a_UCTF_UX_Y_0lsq_ync__ = spharm__normalize_1(pm_n_k_p_r,pm_k_p_r_,pm_weight_k_p_r_,pm_l_max_,a_UCTF_UX_Y_0lsq_ync__);
%%%%%%%%;
% use a_UCTF_UX_Y_0lsq_ync__ as well VSCTF_Mc__ to approximate the image-averaged a_CTF_UX_Y_0lsq_. ;
%%%%%%%%;
a_CTF_UX_Y_0lsq_ = spharm_normalize_1(pm_n_k_p_r,pm_k_p_r_,pm_weight_k_p_r_,pm_l_max_,mean(a_UCTF_UX_Y_0lsq_ync__*transpose(VSCTF_Mc__),2));
%%%%%%%%;
% Now store image-parameters. ;
% Be sure to update the translations using the previous step. ;
%%%%%%%%;
if (nargout>1);
a_CTF_UX_Y_0lsq__(:,1+niteration) = a_CTF_UX_Y_0lsq_;
euler_polar_a__(:,1+niteration) = euler_polar_a_;
euler_azimu_b__(:,1+niteration) = euler_azimu_b_;
euler_gamma_z__(:,1+niteration) = euler_gamma_z_;
image_delta_x__(:,1+niteration) = image_delta_x_;
image_delta_y__(:,1+niteration) = image_delta_y_;
image_I_value__(:,1+niteration) = image_I_value_;
end;%if (nargout>1);
%%%%%%%%;
if (mod(niteration,n_iteration_register)==n_iteration_register-1);
%%%%%%%%;
% Compare current model to a_CTF_UX_Y_true_. ;
%%%%%%%%;
tmp_t = tic();
[X_best_orig,~,~,~,~,~,~] = register_spharm_to_spharm_wigner_0(pm_n_k_p_r,pm_k_p_r_,pm_k_p_r_max,pm_weight_k_p_r_,0,pm_l_max_,a_CTF_UX_Y_true_,a_CTF_UX_Y_0lsq_);
[X_best_flip,~,~,~,~,~,~] = register_spharm_to_spharm_wigner_0(pm_n_k_p_r,pm_k_p_r_,pm_k_p_r_max,pm_weight_k_p_r_,0,pm_l_max_,a_CTF_UX_Y_true_,flipY(pm_n_k_p_r,pm_l_max_,a_CTF_UX_Y_0lsq_));
X_best = max(real(X_best_orig),real(X_best_flip));
X_best_(1+niteration) = X_best;
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% register_spharm_to_spharm_wigner_0: %0.3fs',tmp_t)); end;
if (verbose>-1); disp(sprintf(' %% %s (%d): a_CTF_UX_Y_true_ vs a_CTF_UX_Y_lsq0_: correlation %+0.6f',str_MS_vs_SM,niteration,X_best)); end;
end;%if (mod(niteration,n_iteration_register)==n_iteration_register-1);
%%%%%%%%;
% if flag_MS_vs_SM & order_limit_MS>-1 & niteration<n_iteration/2, then bandlimit a_UCTF_UX_Y_0lsq_ync__. ;
%%%%%%%%;
if ( (flag_MS_vs_SM==1) & (order_limit_MS>-1) & (niteration<n_iteration/2) );
a_UCTF_UX_Y_0lsq_ync__ = a_UCTF_UX_Y_0lsq_ync__.*repmat(Y_lm_cut_,[1,n_CTF_rank]);
end;%if ( (flag_MS_vs_SM==1) & (order_limit_MS>-1) & (niteration<n_iteration/2) );
%%%%%%%%;
% Groups images by micrograph. ;
% Calculates principal-templates associated with each micrograph. ;
% Takes svd of principal-templates. ;
% Batches images into batches of size n_M_per_Mbatch. ;
% Batches templates into batches of size n_S_per_Sbatch. ;
% Only stores the optimal translation for each image. ;
%%%%%%%%;
tmp_t = tic();
n_M_per_Mbatch = 24;
n_S_per_Sbatch = 24;
[ ...
 n_S ...
,viewing_polar_a_all_ ...
,viewing_azimu_b_all_ ...
,X_wSM___ ...
,delta_j_wSM___ ...
,I_value_wSM___ ...
] = ...
ampmh_X_wSM___5( ...
 FTK ...
,viewing_k_eq_d ...
,n_w_max ...
,l_max_max ...
,pm_n_UX_rank ...
,a_UCTF_UX_Y_0lsq_ync__ ...
,CTF_index_ ...
,n_CTF_rank ...
,VSCTF_Mc__ ...
,n_S_per_Sbatch ...
,n_M ...
,n_M_per_Mbatch ...
,svd_VUXM_lwnM____ ...
,UX_M_l2_dM__ ...
);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% X_wsM___: %0.3fs',tmp_t)); end;
%%%%%%%%;
% Use current correlations to udate current euler-angles. ;
%%%%%%%%;
if flag_MS_vs_SM==1; %<-- assign images to templates, ensuring a uniform distribution of viewing angles. ;
tmp_t = tic();
[ ...
 euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_delta_x_upd_ ...
,image_delta_y_upd_ ...
,image_I_value_ ...
,image_X_value_ ...
,image_S_index_ ...
] = ...
ampmh_MS_1( ...
 n_w_ ...
,n_S ...
,viewing_polar_a_all_ ...
,viewing_azimu_b_all_ ...
,n_M ...
,X_wSM___ ...
,FTK.delta_x_(1+delta_j_wSM___) ...
,FTK.delta_y_(1+delta_j_wSM___) ...
,I_value_wSM___ ...
);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% MS: update euler_polar_a_ euler_azimu_b_ euler_gamma_z_ : %0.3fs',tmp_t)); end;
end;%if flag_MS_vs_SM==1; %<-- assign images to templates, ensuring a uniform distribution of viewing angles. ;
if flag_MS_vs_SM==0; %<-- assign templates to images (uses leslie f_rand). ;
tmp_t = tic();
[ ...
 euler_polar_a_ ...
,euler_azimu_b_ ...
,euler_gamma_z_ ...
,image_delta_x_upd_ ...
,image_delta_y_upd_ ...
,image_I_value_ ...
,image_X_value_ ...
,image_S_index_ ...
] = ...
ampmh_SM_1( ...
 f_rand ...
,n_w_ ...
,n_S ...
,viewing_polar_a_all_ ...
,viewing_azimu_b_all_ ...
,n_M ...
,X_wSM___ ...
,FTK.delta_x_(1+delta_j_wSM___) ...
,FTK.delta_y_(1+delta_j_wSM___) ...
,I_value_wSM___ ...
);
tmp_t = toc(tmp_t); if (verbose>1); disp(sprintf(' %% SM: update euler_polar_a_ euler_azimu_b_ euler_gamma_z_ : %0.3fs',tmp_t)); end;
end;%if flag_MS_vs_SM==0; %<-- assign templates to images (uses leslie f_rand). ;
%%%%%%%%;
% update translations. ;
%%%%%%%%;
image_delta_x_ = image_delta_x_ + image_delta_x_upd_;
image_delta_y_ = image_delta_y_ + image_delta_y_upd_;
image_delta_r_ = sqrt(image_delta_x_.^2 + image_delta_y_.^2);
tmp_index_ = efind(image_delta_r_>delta_r_upb);
if (numel(tmp_index_)>0);
image_delta_x_(1+tmp_index_) = image_delta_x_(1+tmp_index_)*delta_r_upb./image_delta_r_(1+tmp_index_);
image_delta_y_(1+tmp_index_) = image_delta_y_(1+tmp_index_)*delta_r_upb./image_delta_r_(1+tmp_index_);
end;%if (numel(tmp_index_)>0);
%%%%%%%%;
if (nargout>1);
if niteration<n_iteration-1;
image_X_value__(:,1+niteration+1) = image_X_value_;
image_S_index__(:,1+niteration+1) = image_S_index_;
end;%if niteration<n_iteration-1;
end;%if (nargout>1);

%%%%%%%%;
% Now return to beginning of loop. ;
%%%%%%%%;
end;%for niteration=0:n_iteration-1;

